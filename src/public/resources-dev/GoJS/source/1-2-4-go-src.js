/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
 * GoJS v1.2.4 JavaScript Library for HTML Canvas Diagrams
 * Northwoods Software, http://www.nwoods.com/
 * GoJS and Northwoods Software are registered trademarks of Northwoods Software Corporation.
 * Copyright (C) 1998-2013 by Northwoods Software Corporation.  All Rights Reserved.
 * THIS SOFTWARE IS LICENSED.  THE LICENSE AGREEMENT IS AT: http://www.gojs.net/1.2.4/doc/license.html.
 */

// Public members stem from this. Anything not atop this is private.
var go = {};
var canSupport = document.createElement('canvas').getContext !== undefined;
if (!canSupport) {
  var msg = 'The HTML Canvas element is not supported in this browser,' +
            'or this browser is in Compatibility mode.';
  if (window.console) window.console.log(msg)
  throw new Error(msg);
}

if (!Object.prototype['__defineGetter__'] && !Object['defineProperty']) {
  throw new Error('GoJS requires a newer version of JavaScript');
}

// Firefox 3.x and Opera 10.x do not support some simple-to-emulate HTML5 functions.

// emulate ES5 getter/setter API using legacy APIs
if (Object.prototype['__defineGetter__'] && !Object['defineProperty']) {
  Object['defineProperty'] = function(obj, prop, desc) {
    if (desc['get']) obj.__defineGetter__(prop, desc.get);
    if (desc['set']) obj.__defineSetter__(prop, desc.set);
  };
}

if (Object.prototype['__lookupGetter__'] && !Object['getOwnPropertyDescriptor']) {
  Object['getOwnPropertyDescriptor'] = function(obj, prop) {
    return { 'get' : obj['__lookupGetter__'](prop),
             'set' : obj['__lookupSetter__'](prop) };
  };
}

// Opera 11.x needs Object.getPrototypeOf
if (!Object['getPrototypeOf']) {
  Object['getPrototypeOf'] = function(obj) {
    return obj.__proto__;
  };
}

// Opera 11.x needs Object.freeze/isFrozen
// not the same as permanently immutable, nor as freeze/isFrozen in this library
if (!Object['isFrozen']) {
  Object['isFrozen'] = function(obj) {
    return (obj._isConstant === true);
  };
}

if (!Object['freeze']) {
  Object['freeze'] = function(obj) {
    obj._isConstant = true;
  };
}

if (!Array['isArray']) {
  Array['isArray'] = function(obj) {
    return (Object.prototype.toString.call(obj) === '[object Array]');
  };
}

if (!Function.prototype.bind) {
  Function.prototype.bind = function (that) {
    var fSlice = Array.prototype.slice,
        aArgs = fSlice.call(arguments, 1),
        fToBind = this,
        /** @constructor */
        dummyclass = function () {},
        boundfunc = function () {
          return fToBind.apply(that, aArgs.concat(fSlice.call(arguments)));
        };
    dummyclass.prototype = this.prototype;
    boundfunc.prototype = new dummyclass();
    return boundfunc;
  };
}

(function() {
    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
        window.cancelAnimationFrame =
          window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];
    }

    if (!window.requestAnimationFrame)
        window.requestAnimationFrame = function(callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(8, 16 - (currTime - lastTime));
            var id = window.setTimeout(function() { callback(currTime + timeToCall); },
              timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };

    if (!window.cancelAnimationFrame)
        window.cancelAnimationFrame = function(id) {
            clearTimeout(id);
        };
}());
/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
 * This file defines the Debug static class. It is not included in builds, but an extern is
 */


/**
 * Static Debug object containing convenience functions. This code is for
 * debugging only and is not supported.
 */
var Debug = {
  /**
  * Determines whether or not default debug information is displayed
  */
  boundsInfoEnabled: false,
  drawLocationsEnabled: false,
  drawClipEnabled: false,
  drawLinkpointsEnabled: false,
  drawingRectsEnabled: false,
  nodeInspector: false,  // when you click on a canvas it will return a list of all objects at that location
  handleMessages: false, // tells you whether an event was handled or not
  traceError: false, // throws an error in addition to trace statements

  /**
  * This should produce some sort of logging message, if possible.
  * But because this is part of Debug, the call should not exist in "release" mode.
  * @ignore
  * @param {string} msg
  */
  trace: function(msg) {
    if (window && window.console) {
      window.console.log(msg);
    }
  },

  /**
  * Determines whether or calls to assert produce error messages and alerts.
  */
  assertions: false,

  /**
  * When debugging is enabled, this will log the message and
  * produce an alert dialog if the PRED argument is false.
  * Otherwise this does nothing.
  * @ignore
  * @param {boolean} pred If true, everything's OK; otherwise call Util.debug.
  * @param {string} msg
  */
  assert: function(pred, msg) {
    if (!pred && Debug.assertions) {
      if (window) {
        Debug.trace(msg);
        window.alert(msg);
      }
      throw new Error(msg);
    }
  },

  /**
  * For convenience one can set the default diagram that the Debug object acts
  * upon. Otherwise, the diagram will have to be given as an argument for each
  * function of Debug.
  */
  defaultDiagram: null,

  /**
  * Draws the actual bounds for all objects in yellow
  * Actual bounds are relative to a parent, so they are drawn using all transforms
  * in the drawing chain except the object's own.
  *
  * Needs the first argument to work. Second argument should be left blank
  * and is used by its recursive nature
  * @ignore
  * @param {Diagram|undefined=} diagram
  * @param {List|undefined=} objectList
  */
  drawAllActual: function(diagram, objectList) {
    if (diagram === undefined/*notpresent*/) diagram = Debug.defaultDiagram;
    if (objectList === undefined/*notpresent*/) objectList = diagram.findLayer('')._parts;

    var len = objectList.length;
    var tempDrawCtx = diagram._canvas.getContext('2d');
    tempDrawCtx.fillStyle = 'rgba(255,255,0,.3)';

    for (var i = 0; i < len; i++) {
      var elt = objectList.elt(i);
      var bl = elt.actualBounds;

      if (elt._elements !== null) {
        Debug.drawAllActual(diagram, elt._elements);
      } else {

        var exceptlast = elt._allTransforms.copy();
        exceptlast.multiplyInverted(elt._transform);

        tempDrawCtx.save();
        tempDrawCtx.transform(exceptlast.m11, exceptlast.m12, exceptlast.m21, exceptlast.m22, exceptlast.dx, exceptlast.dy);
        tempDrawCtx.fillRect(bl.x, bl.y, bl.width, bl.height);
        tempDrawCtx.restore();
      }
    }
  },

  /**
  * @ignore
  * @param {Diagram|undefined=} diagram
  * @param {List|undefined=} objectList
  */
  drawAllNatural: function(diagram, objectList) {
    if (!diagram) diagram = Debug.defaultDiagram;
    if (!objectList) objectList = diagram.findLayer('')._parts;

    var tempDrawCtx = diagram._canvas.getContext('2d');
    var len = objectList.length;
    tempDrawCtx.fillStyle = 'rgba(0,0,255,.3)';

    for (var i = 0; i < len; i++) {
      var elt = objectList.elt(i);
      var bl = elt.naturalBounds;

      var t = elt._allTransforms;

      if (elt._elements !== null) {
        Debug.drawAllNatural(diagram, elt._elements);
      } else {
        tempDrawCtx.save();
        tempDrawCtx.transform(t.m11, t.m12, t.m21, t.m22, t.dx, t.dy);
        tempDrawCtx.fillRect(bl.x,bl.y, bl.width, bl.height);
        tempDrawCtx.restore();
      }
    }
  },

  // draw all measuredBounds in diagram coordinates
  drawAllMeasuredInDiagram: function(diagram, objectList) {
    if (!diagram) diagram = Debug.defaultDiagram;
    if (!objectList) objectList = diagram.findLayer('')._parts;

    var tempDrawCtx = diagram._canvas.getContext('2d');
    var len = objectList.length;
    tempDrawCtx.fillStyle = 'rgba(0,0,255,.3)';

    for (var i = 0; i < len; i++) {
      var elt = objectList.elt(i);
      var bl = elt.measuredBounds;

      var t = elt._allTransforms;

      if (elt._elements !== null) {
        Debug.drawAllMeasuredInDiagram(diagram, elt._elements);
      } else {
        tempDrawCtx.save();
        tempDrawCtx.transform(t.m11, t.m12, t.m21, t.m22, t.dx, t.dy);
        tempDrawCtx.fillRect(bl.x || 0, bl.y || 0, bl.width, bl.height);
        tempDrawCtx.restore();
      }
    }
  },

  drawAll: function() {
    Debug.drawAllNatural();
    Debug.drawAllActual();
  },

  drawDocumentBounds: function(diagram) {
    if (!diagram) diagram = Debug.defaultDiagram;
    var r = diagram.documentBounds;
    var tempDrawCtx = diagram._canvas.getContext('2d');
    tempDrawCtx.strokeStyle = 'rgba(0,255,0,.9)';
    tempDrawCtx.strokeRect(r.x, r.y, r.width, r.height);
  },

  drawBoundsInfo: function(diagram, ctx) {
    ctx.fillStyle = 'red';
    ctx.fillRect(0, 0, 8, 8);
    ctx.lineWidth = 8;
    ctx.strokeStyle = 'rgba(255,255,0,.6)';
    var bb = diagram.viewportBounds;
    ctx.strokeRect(bb.x, bb.y, bb.width, bb.height);
    ctx.fillStyle = 'rgba(0,255,0,.2)';
    ctx.fillRect(diagram.documentBounds.x, diagram.documentBounds.y, diagram.documentBounds.width, diagram.documentBounds.height);
  },

  drawBoundsInfoActual: function(context, obj) {
    context.lineWidth = 2; context.strokeStyle = 'rgba(255,0,0,.5)';
    context.strokeRect(obj._actualBounds.x, obj._actualBounds.y, obj._actualBounds.width, obj._actualBounds.height);
    if (obj.stroke !== undefined) context.strokeStyle = obj.stroke;
    if (obj._strokeWidth !== undefined) { context.lineWidth = obj._strokeWidth; }

    // Table grid:
    if (obj.panel !== null && obj.panel.type === Panel.Table) {
      context.lineWidth = 1; context.strokeStyle = 'rgba(10,200,10,.6)';
      /*
      if (obj._layoutHeight !== 0) {
        context.beginPath();
        context.moveTo(-10000, obj._layoutY);
        context.lineTo(10000, obj._layoutY);
        context.stroke();
      }
      if (obj._layoutWidth !== 0) {
        context.beginPath();
        context.moveTo(obj._layoutX, -10000);
        context.lineTo(obj._layoutX, 10000);
        context.stroke();
      }
      */
      if (obj.stroke !== undefined) context.strokeStyle = obj.stroke;
      if (obj._strokeWidth !== undefined) { context.lineWidth = obj._strokeWidth; }
    }
  },

  drawBoundsInfoNatural: function(context, obj) {
    context.lineWidth = 1; context.strokeStyle = 'rgba(0,0,255,.5)';
    context.strokeRect(obj.naturalBounds.x, obj.naturalBounds.y, obj.naturalBounds.width, obj.naturalBounds.height);
    if (obj.stroke !== undefined) context.strokeStyle = obj.stroke;
    if (obj._strokeWidth !== undefined) { context.lineWidth = obj._strokeWidth; }
  },

  // Green locations, red positions
  drawBoundsInfoLocations: function(context, diagram, t) {
    // find Locations on nodes in each layer
    context.setTransform(t.m11, t.m12, t.m21, t.m22, t.dx, t.dy);
    var l = diagram._layers.length;
    for (var i = 0; i < l; i++) {
      var layer = diagram._layers.elt(i);
      var ll = layer._parts.length;
      for (var j = 0; j < ll; j++) {
        var obj = layer._parts.elt(j);
        if (obj.location !== undefined && obj.location !== null) {
          if (obj.location.isReal()) {
            var x = obj.location.x;
            var y = obj.location.y;
            context.beginPath();
            context.strokeStyle = 'limegreen';
            context.lineWidth = 2;
            context.moveTo(x, y + 6);
            context.lineTo(x, y);
            context.lineTo(x + 6, y);
            context.moveTo(x, y);
            context.lineTo(x + 10, y + 20);
            context.stroke();
          }

          x = obj.position.x;
          y = obj.position.y;
          context.beginPath();
          context.strokeStyle = 'red';
          context.lineWidth = 2;
          context.moveTo(x, y + 6);
          context.lineTo(x, y);
          context.lineTo(x + 6, y);
          context.moveTo(x, y);
          context.lineTo(x + 20, y + 10);
          context.stroke();
        }
      }
    }
    context.setTransform(1,0,0,1,0,0);
  },

  // Green locations, red positions
  drawRects: function(rects, ctx, diagram) {
    var l = rects.length;
    ctx.fillStyle = 'rgba(255,0,0,.1)';
    for (var i = 0; i < l; i++) {
      var rect = diagram.transformRectDocToView(rects[i]);
      ctx.fillRect(rect[0], rect[1], rect[2], rect[3]);
    }
  },

  drawClip: function(context, cx, cy, cwidth, cheight) {
    context.fillStyle = 'rgba(0,255,0,.2)';
    context.fillRect(cx, cy, cwidth, cheight);
  },

  drawLinkpoints: function(context, diagram, link) {
    context.save();

    var t = diagram._transform;
    t.reset();
    if (diagram._scale !== 1) { t.scale(diagram._scale); }
    var pos = diagram._position;
    if (pos.x !== 0 || pos.y !== 0) {
      t.translate(-pos.x, -pos.y);
    }
    context.setTransform(t.m11, t.m12, t.m21, t.m22, t.dx, t.dy);


    var pts = link._points._arr;
    var l = pts.length;
    for (var i = 0; i < l; i++) {
      var p = pts[i];
      context.beginPath();
      context.moveTo(p.x-4, p.y);
      context.lineTo(p.x+4, p.y);
      context.moveTo(p.x, p.y-4);
      context.lineTo(p.x, p.y+4);
      context.lineWidth = 2;
      context.strokeStyle = 'rgba(255,0,0,.9)';
      context.stroke();
    }
    context.restore();
  },

  diagramInfo: function(diagram) {
    if (!diagram) diagram = Debug.defaultDiagram;
    var itr = diagram.layers;
    while (itr.next()) {
      Debug.trace(itr.value.toString());
    }
  },

  // Happens on click to see where
  pointLoc: function(e, diagram) {
    var mouse = diagram._getMouse(e);
    var n = diagram._lastInput;
    n.viewPoint = diagram.transformDocToView(mouse);
    n.documentPoint = mouse;
    return diagram._maybeHandled(n, e);
  },

  paintPoint: function(n, diagram) {
    if (diagram.findObjectAt(n.documentPoint)){//.count > 0) {
      diagram._ctx.fillStyle = 'lime'
      diagram._ctx.__cachedFillStyle = 'lime';
      diagram._ctx.fillRect(n.viewPoint.x, n.viewPoint.y, 1*diagram.scale, 1*diagram.scale);
    }
  },

  /**
  * @ignore
  * Painting grid of occupied positions
  * @param {Diagram} diagram
  */
  paintPositionArray: function(diagram) {
    var pa = diagram.getPositions(false, null, null);
    if (pa.invalid) return;
    var ctx = diagram._ctx;
    for (var i = 0; i <= pa._upperBoundX; i++) {
      for (var j = 0; j <= pa._upperBoundY; j++) {
        var val = pa._array[i][j];
        if (val === PositionArray.OCCUPIED) continue;
        var x = i*pa._cellX + pa._minX;
        var y = j*pa._cellY + pa._minY;
        if (val !== 0) {
          ctx.fillStyle = 'rgba(255, 0, 0, .2)';
          ctx.fillRect(x, y, pa._cellX, pa._cellY);
        }
        if (val >= PositionArray.MAX) continue;
        var lastdigit = val % 10;
        ctx.fillStyle = 'blue';
        ctx.fillText(lastdigit.toString(), x, y+pa._cellY);
      }
    }
  },

  dumpReferences: function(obj) {
    if (obj instanceof Diagram) {
      var lit = obj.layers;
      while (lit.next()) {
        var lay = lit.value;
        Util.trace(lay.toString());
        var pit = lay.parts;
        while (pit.next()) {
          Debug.dumpReferences(pit.value);
        }
      }
    } else if (obj instanceof Part) {
      Util.trace('References for ' + obj);
      if (obj.layer) Util.trace('  ' + obj.layer.toString() + ' LayerName: "' + obj.layerName + '"');
      if (obj.selectionObject !== obj) Util.trace('  SelectionObject: ' + obj.selectionObject.toString() + ' SelectionObjectName: "' + obj.selectionObjectName + '"');
      if (obj.locationObject !== obj) Util.trace('  LocationObject: ' + obj.locationObject.toString() + ' LocationObjectName: "' + obj.locationObjectName + '"');
      if (obj._adornments) {
        var ads = '';
        var it = obj._adornments.iterator;
        while (it.next()) {
          ads += it.key + ' ';
        }
        Util.trace('  Adornments: ' + ads);
      }
      if (obj.containingGroup) Util.trace('  ContainingGroup: ' + obj.containingGroup.toString());
      if (obj instanceof Node) {
        if (obj._ports) {
          var ports = '';
          var it = obj._ports.iterator;
          while (it.next()) {
            ports += it.value.portId + ':' + it.value.toString() + ', ';
          }
        }
        if (obj.linksConnected.count > 0) {
          var links = '';
          var it = obj.linksConnected;
          while (it.next()) {
            links += it.value.toString() + ', ';
          }
          Util.trace('  Links: ' + links);
        }
        if (obj.labeledLink) Util.trace('  LabeledLink: ' + obj.labeledLink.toString());
        if (obj instanceof Group) {
          Util.trace('  Placeholder: ' + obj.placeholder);
          var mems = '';
          var it = obj.memberParts;
          while (it.next()) {
            mems += it.value.toString() + ', ';
          }
          Util.trace('  Members: ' + mems);
          mems = '';
          it = obj._nestedGroups.iterator;
          while (it.next()) {
            mems += it.value.toString() + ', ';
          }
          Util.trace('  NestedGroups: ' + mems);
          Util.trace('  Layout: ' + obj.layout);
        }
      } else if (obj instanceof Link) {
        Util.trace('  Path: ' + obj.path);
        Util.trace('  From: ' + obj.fromNode + ' ' + obj.fromPort + ' "' + obj.fromPortId + '"');
        Util.trace('  To: ' + obj.toNode + ' ' + obj.toPort + ' "' + obj.toPortId + '"');
        var labs = '';
        var it = obj.labelNodes;
        while (it.next()) {
          labs += it.value.toString() + ', ';
        }
        Util.trace('  LabelNodes: ' + labs);
      }
    }
  },

  dumpVisualTree: function(obj) {
    if (obj instanceof Diagram) {
      var lit = obj.layers;
      while (lit.next()) {
        var lay = lit.value;
        Util.trace(lay.toString());
        var pit = lay.parts;
        while (pit.next()) {
          Debug.dumpVisualTree(pit.value);
        }
      }
    } else if (obj instanceof Part) {
      var permits = ' ';
      if (obj.copyable) permits += 'c';
      if (obj.deletable) permits += 'd';
      if (obj.groupable) permits += 'g';
      if (obj.movable) permits += 'm';
      if (obj.reshapable) permits += 'h';
      if (obj.resizable) permits += 'z';
      if (obj.rotatable) permits += 'o';
      if (obj.selectable) permits += 's';
      if (obj.textEditable) permits += 't';
      if (obj.selectionAdorned) permits += 'A';
      if (obj.isInDocumentBounds) permits += 'B';
      if (obj.isLayoutPositioned) permits += 'L';
      if (obj.isSelected) permits += 'S';
      if (obj.isShadowed) permits += 'H';
      Debug._dumpVisualTree1(obj, 1, permits);
    }
  },

  _dumpVisualTree1: function(obj, indent, prefix) {
    var line = '';
    for (var i = 0; i < indent; i++) line += '  ';

    line += obj.toString();
    if (prefix) line += prefix;

    var props = ' ';
    if (obj.visible) props += 'v'; else props += '~';
    if (obj.pickable) props += 'p';
    if (obj.isPanelMain) props += 'm';
    if (obj.isActionable) props += 'a';
    line += props;

    line += ' ' + obj.actualBounds.toString();
    if (obj.desiredSize.isReal()) line += ' d:' + obj.desiredSize.toString();
    if (obj.naturalBounds.isReal()) line += ' n:' + obj.naturalBounds.toString();
    if (obj.scale !== 1) line += ' s:' + obj.scale;
    if (obj.angle !== 0) line += ' a:' + obj.angle;

    if (obj.background !== null) line += ' b:' + obj.background.toString();
    if (obj.areaBackground !== null) line += ' a:' + obj.background.toString();

    if (obj instanceof Panel) {
      line += ' elts:' + obj._elements.count;
      if (obj.topIndex !== 0) line += ' top:' + obj.topIndex;
      if (obj.leftIndex !== 0) line += ' left:' + obj.leftIndex;
      if (obj.itemArray !== null) line += ' itemArray#:' + obj.itemArray.length;
      if (obj.itemCategory) line += ' cat:' + obj.itemCategory;
      if (obj.data !== null) line += ' data:' + obj.data;
    }

    Util.trace(line);

    if (obj instanceof Panel) {
      var it = obj.elements;
      while (it.next()) {
        Debug._dumpVisualTree1(it.value, indent + 1, '');
      }
    }
  }

}; // end debug

go['Debug'] = Debug;

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
* This file defines the static Util class for
* internal error checking functions and other handy functions and constants.
*/

/** @ignore */
var Util = {
  EmptyArray: Object.freeze([]),

  /**
  * A record of the font height of each font that has been used so far
  */
  /** @ignore */
  fontHeightMap: {},
  /** @ignore */
  fontHeightMapCount: 0,
  /** @ignore */
  imageSourceMap: {},

// The textBlock class has a single private static canvas used solely for measuring text
  /** @ignore */
  sharedTempCtx: document.createElement('canvas').getContext('2d'),
  /** @ignore */
  sharedTempFont: '',

  // for making sure pictures get loaded
  /** @ignore */
  unloadedImages: [],
  /** @ignore */
  pictureInterval: null,
  /** @ignore */
  diagramsTraversed: [],

  // Used to modify some rules
  /** @ignore */
  supportsTouch: ('ontouchstart' in window),
  /** @ignore */
  supportsGestures: ('ongesturestart' in window),

  // Used to create the context menu and associated CSS in the DOM only once
  /** @ignore @type {boolean} */
  defaultContextMenuSetup: false,
  /** @ignore @type {Element} */
  cmDark: null,
  /** @ignore @type {Element} */
  cmLight: null,

  // this is the internal static clipboard variable
  /** @ignore @type {Iterable} */
  clipboardParts: null,
  /** @ignore @type {string} */
  clipboardFormat: '',

  // Debugging and Error Checking
  /** @ignore @type {boolean} */
  warnedAboutNoGroupTemplate: false,
  /** @ignore @type {boolean} */
  warnedAboutNoNodeTemplate: false,
  /** @ignore @type {boolean} */
  warnedAboutNoLinkTemplate: false,
  /** @ignore @type {boolean} */
  warnedAboutNoItemTemplate: false,
  /** @ignore @type {Panel} */
  defaultItemTemplate: null,
  /** @ignore @type {boolean} */
  warnedAboutModifyingGraphObject: false,
  /** @ignore @type {boolean} */
  warnedAboutDisplacingDifferentClass: false,
  /** @ignore @type {boolean} */
  warnedAboutMakeImageSize: false,

  /**
  * @ignore
  * @param {string} msg
  */
  throwError: function(msg) {
    if (Debug && Debug.assertions) alert(msg);
    throw new Error(msg);
  },

  /**
  * @ignore
  * @param {Object} obj an object that might no longer be modifiable.
  * @param {*=} val the attempted new value for the property.
  */
  checkFrozen: function(obj, val) {
    if (obj._isFrozen) {
      var s = 'The object is frozen, so its properties cannot be set: ' + obj.toString();
      if (val !== undefined/*notpresent*/) s += '  to value: ' + val;
      Util.throwError(s);
    }
  },

  /**
  * @ignore
  * @param {*} val
  * @param {Function} type a class.
  * @param {(string|Function)=} name "Class.property" or "Class.method:parameter" or a class function
  * @param {string=} member property name or method name
  */
  checkClass: function(val, type, name, member) {
    if (!(val instanceof type)) {
      var msg = Util.getTypeName(name);
      if (member !== undefined/*notpresent*/) msg += '.' + member;
      Util.throwTypeError(val, type, msg);
    }
  },

  /**
  * @ignore
  * @param {*} val
  * @param {string} type a primitive type: 'number', 'string', 'boolean'.
  * @param {string|Function=} name "Class.property" or "Class.method:parameter" or a class function
  * @param {string=} member property name or method name
  */
  checkPrimitive: function(val, type, name, member) {
    if (typeof val !== type) {
      var msg = Util.getTypeName(name);
      if (member !== undefined/*notpresent*/) msg += '.' + member;
      Util.throwTypeError(val, type, msg);
    }
  },

  /**
  * @ignore
  * @param {number} val
  * @param {string|function()=} name "Class.property" or "Class.method:parameter" or a class function
  * @param {string=} member property name or method name
  */
  checkRealNumber: function(val, name, member) {
    if (!isFinite(val)) {
      var msg = Util.getTypeName(name);
      if (member !== undefined/*notpresent*/) msg += '.' + member;
      Util.throwError(msg + ' must be a real number and not NaN or Infinity: ' + val);
    }
  },

  /**
  * @ignore
  * @param {*} val
  * @param {function()} type a class.
  * @param {string|function()=} name "Class.property" or "Class.method:parameter" or a class function
  * @param {string=} member property name or method name
  */
  checkEnumValue: function(val, type, name, member) {
    if (!(val instanceof EnumValue) || val.classType !== type) {
      var msg = Util.getTypeName(name);
      if (member !== undefined/*notpresent*/) msg += '.' + member;
      Util.throwTypeError(val, 'a constant of class ' + Util.getClassName(type), msg);
    }
  },

  /**
  * @ignore
  * @param {*} val
  * @param {string|Function} type a human-readable string description of the types that VAL isn't, or a class function.
  * @param {string|Function=} name "Class.property" or "Class.method:parameter" or a class function
  * @param {string=} member property name or method name
  */
  throwTypeError: function(val, type, name, member) {
    var typestr = Util.getTypeName(type);
    var msg = Util.getTypeName(name);
    if (member !== undefined/*notpresent*/) msg += '.' + member;
    Util.throwError(msg + ' value is not an instance of ' + typestr + ': ' + val);
  },

  /**
  * @ignore
  * @param {*} val
  * @param {string} range a human-readable description of the value range that VAL isn't in.
  * @param {string|function()=} name "Class.property" or "Class.method:parameter" or a class function
  * @param {string=} member property name or method name
  */
  throwRangeError: function(val, range, name, member) {
    var msg = Util.getTypeName(name);
    if (member !== undefined/*notpresent*/) msg += '.' + member;
    Util.throwError(msg + ' is not in the range ' + range + ': ' + val);
  },

  /**
  * @ignore
  * This should always produce some sort of logging message, if possible.
  * @param {string} msg
  */
  trace: function(msg) {
    if (window && window.console) {
      window.console.log(msg);
    }
    if (Debug && Debug.traceError) {
      //alert(msg);
      Util.throwError(msg);
    }
  },

  /**
  * @ignore
  * We should never use x instanceof Object, to avoid cross-frame metadata problems.
  */
  isObject: function(val) {
    return (typeof val === 'object' && val !== null);
  },

  // Handling array-like objects

  /**
  * @ignore
  * We should never use x instanceof Array, to avoid cross-frame metadata problems.
  * This is more general than Array.isArray, because it handles XML NodeList and HTML Collection.
  */
  isArray: function(val) {
    return (Array.isArray(val) || val instanceof NodeList || val instanceof HTMLCollection);
  },

  /**
  * @ignore
  */
  checkArray: function(val, classfunc, prop) {
    if (!Util.isArray(val)) {
      Util.throwTypeError(val, 'Array or NodeList or HTMLCollection', classfunc, prop);
    }
  },

  /**
  * @ignore
  * @return {number}
  */
  arrayLength: function(arr) {
    return arr.length;
  },

  /**
  * @ignore
  */
  arrayElt: function(arr, idx) {
    return arr[idx];
  },

  /**
  * @ignore
  */
  arraySetElt: function(arr, idx, val) {
    if (Array.isArray(arr)) {
      arr[idx] = val;
    } else {
      Util.throwError('Cannot replace an object in an HTMLCollection or NodeList at ' + idx);
    }
  },

  /**
  * @ignore
  * @return {number}
  */
  arrayIndexOf: function(arr, obj) {
    if (Array.isArray(arr)) {
      return arr.indexOf(obj);
    } else {
      var len = arr.length;
      for (var i = 0; i < len; i++) {
        if (arr[i] === obj) return i;
      }
      return -1;
    }
  },

  /**
  * @ignore
  */
  arrayInsertAt: function(arr, idx, obj) {
    if (Array.isArray(arr)) {
      if (idx >= arr.length) {  // add to end
        arr.push(obj);
      } else {
        arr.splice(idx, 0, obj);
      }
    } else {
      Util.throwError('Cannot insert an object into an HTMLCollection or NodeList: ' + obj + ' at ' + idx);
    }
  },

  /**
  * @ignore
  */
  arrayRemoveAt: function(arr, idx) {
    if (Array.isArray(arr)) {
      if (idx >= arr.length) {  // remove from end
        arr.pop();
      } else {
        arr.splice(idx, 1);
      }
    } else {
      Util.throwError('Cannot remove an object from an HTMLCollection or NodeList at ' + idx);
    }
  },


  // Support for caching commonly used classes
  //
  // To allocate a temporary Point, call the static method Util.tempPoint().
  // That Point must never be accessible to any programmer using GoJS,
  // except via a debugger or other unsupported invasive technique.
  // You must promptly free that Point so that it can be used again: Util.freePoint(p).
  //
  // NYI:
  // Checking that all results of tempPoint() are actually free'd.
  // Checking that each free'd Point is only free'd once before it is allocated again by tempPoint().
  // Checking that any temporary Point is not in use at any time while in the _CachedPoints collection.
  // Checking that there aren't "too many" Points saved in the _CachedPoints collection.
  // Maybe automatically freeing all temporary Points, say at the end of a transaction.

  /** @ignore */
  _CachedPoints: [],
  /**
  * @ignore
  * @return {Point}
  */
  tempPoint: function() {
    var arr = Util._CachedPoints;
    var temp = arr.pop();
    if (temp === undefined) return new Point();
    return temp;
  },
  /**
  * @ignore
  * @param {number} x
  * @param {number} y
  * @return {Point}
  */
  tempPointAt: function(x, y) {
    var arr = Util._CachedPoints;
    var temp = arr.pop();
    if (temp === undefined) return new Point(x, y);
    temp.x = x;
    temp.y = y;
    return temp;
  },
  /**
  * @ignore
  * @param {Point} temp
  */
  freePoint: function(temp) {
    Util._CachedPoints.push(temp);
  },

  /** @ignore */
  _CachedSizes: [],
  /**
  * @ignore
  * @return {Size}
  */
  tempSize: function() {
    var arr = Util._CachedSizes;
    var temp = arr.pop();
    if (temp === undefined) return new Size();
    return temp;
  },
  /**
  * @ignore
  * @param {Size} temp
  */
  freeSize: function(temp) {
    Util._CachedSizes.push(temp);
  },

  /** @ignore */
  _CachedRects: [],
  /**
  * @ignore
  * @return {Rect}
  */
  tempRect: function() {
    var arr = Util._CachedRects;
    var temp = arr.pop();
    if (temp === undefined) return new Rect();
    return temp;
  },
  /**
  * @ignore
  * @param {number} x
  * @param {number} y
  * @param {number} w
  * @param {number} h
  * @return {Rect}
  */
  tempRectAt: function(x, y, w, h) {
    var arr = Util._CachedRects;
    var temp = arr.pop();
    if (temp === undefined) return new Rect(x, y, w, h);
    temp.x = x;
    temp.y = y;
    temp.width = w;
    temp.height = h;
    return temp;
  },
  /**
  * @ignore
  * @param {Rect} temp
  */
  freeRect: function(temp) {
    Util._CachedRects.push(temp);
  },

  // don't bother with:
  //  _CachedMargins
  //  _CachedSpots

  /** @ignore */
  _CachedTransforms: [],
  /**
  * @ignore
  * @return {Transform}
  */
  tempTransform: function() {
    var arr = Util._CachedTransforms;
    var temp = arr.pop();
    if (temp === undefined) return new Transform();
    return temp;
  },
  /**
  * @ignore
  * @param {Transform} temp
  */
  freeTransform: function(temp) {
    Util._CachedTransforms.push(temp);
  },

  /** @ignore */
  _CachedStreamGeometryContext: null,
  /**
  * @ignore
  * @return {StreamGeometryContext}
  */
  tempStreamGeometryContext: function() {
    var sgc = Util._CachedStreamGeometryContext;
    if (sgc !== null) {
      Util._CachedStreamGeometryContext = null;
      return sgc;
    } else {
      return new StreamGeometryContext();
    }
  },
  /**
  * @ignore
  * @param {StreamGeometryContext} temp
  */
  freeStreamGeometryContext: function(temp) {
    temp.reset();  // release old references
    Util._CachedStreamGeometryContext = temp;
  },

  _CachedArrays: [],
  /**
  * @ignore
  * @return {Array}
  */
  tempArray: function() {
    var temp = Util._CachedArrays.pop();
    if (temp === undefined) return [];
    return temp;
  },

  /**
  * @ignore
  * @param {Array} a
  */
  freeArray: function(a) {
    a.length = 0;  // clear any references to objects
    Util._CachedArrays.push(a);
  },


  // Support for defining classes

  /** @ignore */
  /** @type {number} */
  _ObjectCounter: 1,  // used by various objects for identity of reference

  /**
  * @ignore
  * Set the unique hash ID for an object.
  * This should be called at the beginning of each constructor that does not inherit from another class.
  */
  uniqueHash: function(obj) {
    //if (Debug) {
    //  // not writable or configurable or enumerable
    //  Object.defineProperty(obj, '__gohashid', { value: Util._ObjectCounter++ });
    //} else {
      obj['__gohashid'] = Util._ObjectCounter++;
    //}
  },

  /**
  * @ignore
  * Get the unique hash ID for an object, making it if necessary.
  */
  hashIdUnique: function(obj) {
    var id = obj['__gohashid'];
    if (id === undefined) {
      id = Util._ObjectCounter++;
      obj['__gohashid'] = id;
    }
    return id;
  },

  /**
  * @ignore
  * Get the unique hash ID for an object; may return undefined.
  */
  hashId: function(obj) {
    return obj['__gohashid'];
  },

  /**
  * @ignore
  */
  exportProperty: function(object, publicName, symbol) {
    if (publicName === 'name') return;
    if (publicName === 'length') return;
    object[publicName] = symbol;
  },

  /**
  * @ignore
  * Call this in order to publicize a class.
  * @param {string} classname
  * @param {Function} classfunc
  */
  publish: function(classname, classfunc) {
    classfunc._className = classname;  // annotate the function with its name
    go[classname] = classfunc;
  },

  /**
  * @ignore
  * One must call this right after defining a subclass's constructor function.
  */
  inherit: function(subclass, baseclass) {
    /**
    * @ignore
    * @constructor
    */
    function subproto() { }
    subproto.prototype = baseclass.prototype;
    subclass.prototype = new subproto();
    subclass.prototype.constructor = subclass;
  },

  /**
  * @ignore
  * @param {Function} classfunc
  * @param {Object} propobj an object in the format {propertyName: 'propertyName'}
  * @param {function()} getter
  * @param {function(*)} setter
  * @param {Object=} extra
  */
  defineProperty: function(classfunc, propobj, getter, setter, extra) {
    Util.checkPrimitive(classfunc, 'function', 'Util.defineProperty:classfunc');
    Util.checkPrimitive(propobj, 'object', 'Util.defineProperty:propobj');
    Util.checkPrimitive(getter, 'function', 'Util.defineProperty:getter');
    Util.checkPrimitive(setter, 'function', 'Util.defineProperty:setter');
    for (var i in propobj) {
      var propname = propobj[i];  // published name, a string; might be null
      var desc = {
        'get': getter,
        'set': setter
      };
      if (extra !== undefined/*notpresent*/) {
        for (var k in extra) desc[k] = extra[k];
      }

      Object.defineProperty(classfunc.prototype, i, desc);
      var propdesc = Object.getOwnPropertyDescriptor(classfunc.prototype, i);
      if (propname && propdesc) {
        Object.defineProperty(classfunc.prototype, propname, propdesc);
      }
      break;
    }
  },

  /**
  * @ignore
  * @param {Function} classfunc
  * @param {Object} propobj an object in the format {propertyName: 'propertyName'}
  * @param {function()} getter
  * @param {Object=} extra
  */
  defineReadOnlyProperty: function(classfunc, propobj, getter, extra) {
    Util.checkPrimitive(classfunc, 'function', 'Util.defineReadOnlyProperty:classfunc');
    Util.checkPrimitive(propobj, 'object', 'Util.defineReadOnlyProperty:propobj');
    Util.checkPrimitive(getter, 'function', 'Util.defineReadOnlyProperty:getter');
    for (var i in propobj) {
      var propname = propobj[i];  // published name, a string; might be null
      var desc = {
        'get': getter,
        'set': function(val) {
          Util.throwError('The property "' + propname + '" is read-only and cannot be set to ' + val);
        }
      };
      if (extra !== undefined/*notpresent*/) {
        for (var k in extra) desc[k] = extra[k];
      }
      Object.defineProperty(classfunc.prototype, i, desc);
      var propdesc = Object.getOwnPropertyDescriptor(classfunc.prototype, i);
      if (propname && propdesc) {
        Object.defineProperty(classfunc.prototype, propname, propdesc);
      }
      break;
    }
  },

  /**
  * @ignore
  * Call this to keep checkExtraneousProperties from complaining about property names.
  * @param {Function} classfunc
  * @param {Object} propnames an object in the format {propertyName : true, propName2 : true}
  */
  defineDataProperties: function(classfunc, propnames) {
    for (var i in propnames) {
      propnames[i] = true;
    }
    classfunc.prototype._ownProperties = propnames;
  },

  /**
  * @ignore
  * @return {string|function()} a type description or constructor
  */
  getTypeName: function(type) {
    if (type === undefined) return '';
    if (typeof type === 'string') return type;
    if (typeof type === 'function') return Util.getClassName(type);
    if (type === null) return '*';
    return '';
  },

  /**
  * @ignore
  * @param {function()|Object} x
  * @return {string}
  */
  getClassName: function(x) {
    if (typeof x === 'function') {
      if (x._className) return x._className;
      if (x.name) return x.name;
      // see if the function is named by writing to a string and using
      var str = x.toString();
      var paren = str.indexOf('(');
      var name = str.substring(9, paren).trim();
      if (name) {
        x._className = name;  // remember it to avoid future calls to toString()
        return name;
      }
    } else if (typeof x === 'object' && x.constructor) {
      return Util.getClassName(x.constructor);
    }
    return typeof x;
  },


  // Support for EnumValues

  /**
  * @ignore
  * @param {function()} classfunc
  * @param {string} name
  * @param {number} num
  * @return {EnumValue}
  */
  defineEnumValue: function(classfunc, name, num) {
    Util.checkPrimitive(classfunc, 'function', 'Util.defineEnumValue:classfunc');
    Util.checkPrimitive(name, 'string', 'Util.defineEnumValue:name');
    Util.checkPrimitive(num, 'number', 'Util.defineEnumValue:num');

    var v = new EnumValue(classfunc, name, num);
    Object.freeze(v);
    classfunc[name] = v;

    var enums = classfunc._EnumValues;
    if (!enums) {
      enums = new Map('string', EnumValue);
      classfunc._EnumValues = enums;
    }
    enums.add(name, v);

    return v;
  },

  /**
  * @ignore
  * @param {function()} classfunc
  * @param {string} name
  * @return {EnumValue}
  */
  findEnumValueForName: function(classfunc, name) {
    if (!name) return null;  // if NAME is undefined, null, or an empty string
    Util.checkPrimitive(classfunc, 'function', 'Util.findEnumValueForName:classfunc');
    Util.checkPrimitive(name, 'string', 'Util.findEnumValueForName:name');
    var enums = classfunc._EnumValues;
    if (!enums) return null;
    return enums.getValue(name);
  },


  /**
  * @ignore
  * @param {Object} obj
  * @param {string=} a
  * @param {string=} b
  * @param {string=} c
  * @return {Object}
  */
  copyExcluding: function(obj, a, b, c) {
    var copy = {};
    for (var p in obj) {
      var skip = false;
      for (var i = 1; i < arguments.length; i++) {
        if (arguments[i] === p) {
          skip = true;
          break;
        }
      }
      if (skip) continue;
      copy[p] = obj[p];
    }
    return copy;
  },


  /**
  * @ignore
  * @param {string|function(Object):*} prop
  */
  safePropertyValue: function(obj, prop) {
    if (!obj || !prop) return null;
    var v = undefined;
    try {
      if (typeof prop === 'function') {
        v = prop(obj);
      } else if (typeof obj.getAttribute === 'function') {
        // handle XML DOM Element
        v = obj.getAttribute(prop);
        if (v === null) v = undefined;
      } else {
        v = obj[prop];
      }
    } catch (ex) {
      if (Debug) Util.trace('property get error: ' + ex.toString());
    }
    return v;
  },

  /**
  * @ignore
  * @param {string|function(Object,*)} prop
  */
  safePropertySet: function(obj, prop, val) {
    if (!obj || !prop) return;
    try {
      if (typeof prop === 'function') {
        prop(obj, val);
      } else if (typeof obj.setAttribute === 'function') {
        // handle XML DOM Element
        obj.setAttribute(prop, val);
      } else {
        obj[prop] = val;
      }
    } catch (ex) {
      if (Debug) Util.trace('property set error: ' + ex.toString());
    }
  },

  /**
  * @ignore
  * @param {Object} obj
  * @param {Object} props
  * @return {Object}
  */
  setCheckedProperties: function(obj, props) {
    Util.checkPrimitive(obj, 'object', 'Setting properties requires Objects as arguments');
    Util.checkPrimitive(props, 'object', 'Setting properties requires Objects as arguments');
    var oldDebug = Debug;
    if (!oldDebug) Debug = Util;
    // now actually set all of the properties, with some error checking
    // and special cases for modifying existing objects
    var inpanel = obj instanceof Panel;
    var indiagram = obj instanceof Diagram;
    for (var prop in props) {
      var target = obj;
      var property = prop;
      if (inpanel || indiagram) {
        var dotindex = prop.indexOf('.');
        if (dotindex > 0) {
          var objname = prop.substring(0, dotindex);
          if (inpanel) {
            target = obj.findObject(objname);
          } else {
            target = obj[objname];
            if (!target) {
              target = obj.toolManager[objname];
            }
          }
          if (target) {
            property = prop.substr(dotindex + 1);
          } else {
            Util.throwError('Unable to find object named: ' + objname + ' in ' + obj.toString() +
                            ' when trying to set property: ' + prop);
          }
        }
      }
      if (property[0] !== '_' && !Util.hasDefinedProperty(target, property)) {
        if (indiagram && Util.hasDefinedProperty(obj.toolManager, property)) {
          target = obj.toolManager;
        } else {
          Util.throwError('Trying to set undefined property "' + property + '" on object: ' + target.toString());
        }
      }
      var val = props[prop];
      target[property] = val;
      // record _propnames as properties to be copied by GraphObject.cloneProtected
      if (property[0] === '_') {
        var pnames = target._copyProperties;
        if (!pnames) {
          pnames = [];
          target._copyProperties = pnames;
        }
        pnames.push(property);
      }
    }
    Debug = oldDebug;
    return obj;
  },

  /**
  * @ignore
  * @param {string} pname
  */
  hasDefinedProperty: function(obj, pname) {
    var proto = Object.getPrototypeOf(obj);
    while (proto && proto !== Function) {
      if (proto.hasOwnProperty(pname)) return true;
      var props = proto._ownProperties;
      if (props && props[pname]) return true;
      proto = Object.getPrototypeOf(proto);
    }
    return false;
  },

  /** @ignore */
  checkExtraneousProperties: function(where, obj) {
    if (!Util.isObject(obj)) return '';
    if (obj instanceof Element) return '';
    if (obj instanceof CanvasRenderingContext2D) return '';
    var msg = '';
    for (var x in obj) {
      if (typeof x !== 'string') {
        if (msg === '') msg = obj + '\n';
        msg += '  ' + x + ' is not a string property\n';
        continue;
      }
      if (x.charAt(0) === '_') continue;
      if (x.length <= 2) continue;
      var v = Util.safePropertyValue(obj, x);
      if (v === null) continue;
      if (typeof v === 'function') continue;
      if (Util.hasDefinedProperty(obj, x)) continue;
      if (msg === '') msg = obj + '\n';
      msg += '  unknown property "' + x + '" has value: ' + v + ' at ' + where + '\n';
    }
    return msg;
  },

  /** @ignore */
  checkAll: function(where, obj) {
    if (!obj) return;
    if (typeof obj === 'number' || typeof obj === 'string' || typeof obj === 'boolean' || typeof obj === 'function') return;
    //Util.trace((where ? (where + ': ') : '') + obj);
    if (Util.hashId(obj) !== undefined) {
      if (Util._seen.contains(obj)) return;
      Util._seen.add(obj);
      Util._messages.add(Util.checkExtraneousProperties(where, obj));
      if (obj instanceof List || obj instanceof Set || obj instanceof Map) {
        for (var it = obj.iterator; it.next(); ) Util.checkAll(where + '[' + it.key + ']', it.value);
      } else {
        for (var x in obj) {
          var v = Util.safePropertyValue(obj, x);
          if (v === undefined || v === null || !Util.isObject(v)) continue;
          //?? if (x.length < 3) continue;  // assume minified names are 1 or 2 chars
          if (x === '_ownProperties') continue;
          if (obj instanceof TextBlock) {
            if (x === '_lines') continue;
          } else if (obj instanceof Panel) {
            if (x === 'data' || x === '_data') continue;
            if (x === 'itemArray' || x === '_itemArray') continue;
          } else if (obj instanceof Diagram) {
          } else if (obj instanceof CommandHandler) {
            if (x === 'archetypeGroupData' || x === '_archetypeGroupData') continue;
          } else if (obj instanceof LinkingTool) {
            if (x === 'archetypeLinkData' || x === '_archetypeLinkData') continue;
            if (x === 'archetypeLabelNodeData' || x === '_archetypeLabelNodeData') continue;
          } else if (obj instanceof ClickCreatingTool) {
            if (x === 'archetypeNodeData' || x === '_archetypeNodeData') continue;
          } else if (obj instanceof Model) {
            if (x === 'nodeDataArray' || x === '_nodeDataArray') continue;
            if (x === 'linkDataArray' || x === '_linkDataArray' || x === '_linkDataSet') continue;
            if (x === '_mapKeyNodeData' || x === '_delayedNodeReferences') continue;
          }
          Util.checkAll(where + '.' + x, v);
        }
      }
    } else if (Array.isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
        Util.checkAll(where + '[' + i + ']', obj[i]);
      }
    } else {
      Util._messages.add(Util.checkExtraneousProperties(where, obj));
    }
  },

  /**
  * @ignore
  * Call this on an object such as a Diagram to find all undeclared properties on it and its objects.
  */
  check: function(obj) {
    if (Util._seen === undefined) {
      Util._seen = new Set();
    } else {
      Util._seen.clear();
    }
    Util._messages = new StringBuilder();
    Util.checkAll('', obj);
    var str = Util._messages.toString()
    Util._messages = null;
    return str;
  },


  /**
  * @ignore
  */
  rc4Encrypt: function(pt) {
    var s = [];
    for (var i = 0; i < 256; i++) {
      s[i] = i;
    }
    var j = 0;
    var x;
    for (i = 0; i < 256; i++) {
      j = (j + s[i] + 119) % 256;
      x = s[i];
      s[i] = s[j];
      s[j] = x;
    }
    i = 0;
    j = 0;
    var ct = '';
    for (var y = 0; y < pt.length; y++) {
      i = (i + 1) % 256;
      j = (j + s[i]) % 256;
      x = s[i];
      s[i] = s[j];
      s[j] = x;
      ct += String.fromCharCode(pt.charCodeAt(y) ^ s[(s[i] + s[j]) % 256]);
    }
    return ct;
  },

  /**
  * @ignore
  */
  hexDecode: function(data) {
    var b16_digits = '0123456789abcdef';
    var b16_map = [];
    for (var i = 0; i < 256; i++) {
      b16_map[b16_digits.charAt(i >> 4) + b16_digits.charAt(i & 15)] = String.fromCharCode(i);
    }

    if (data.length % 2) data = '0' + data;

    var result = [];
    var j = 0;
    for (var i = 0; i < data.length; i += 2) {
      result[j++] = b16_map[data.substr(i, 2)];
    }

    var k = result.join('');
    if (k === '') return '0';
    return k;
  },

  /**
  * @ignore
  */
  decrypt: function(str) {
    return Util.rc4Encrypt(Util.hexDecode(str));
  },

  /**
  * @ignore
  */
  wmq: null,
  /**
  * @ignore
  */
  ady: '6ea013a7f62555874c86',
  /**
  * @ignore
  */
  color1: '@COLOR1',
  /**
  * @ignore
  */
  color2: '@COLOR2'
};        // end Util static object

/** @ignore */
Util.wmq = (function() {
  var nc = document.createElement('canvas');
  var nctx = nc.getContext('2d')
  nctx[Util.decrypt('7ca11abfd022028846')] = Util.decrypt('398c3597c01238');
  var draw = '7ca11abfd7330390';
  var draw2 = ['',
  '',
  '',
  ''];
  var x = 10, y = 0;
  for (var i = 1; i < 5; i++){
    nctx[Util.decrypt(draw)](Util.decrypt(draw2[i-1]), x, (i*15)+y);
  }
  //x++;y--;
  nctx[Util.decrypt('7ca11abfd022028846')] = Util.decrypt('39f046ebb36e4b');
  for (var i = 1; i < 5; i++){
    nctx[Util.decrypt(draw)](Util.decrypt(draw2[i-1]), x, (i*15)+y);
  }
  return nc;
})();


/**
* @ignore
* @constructor
* @class
*/
function EnumValue(classfunc, name, val) {
  Util.uniqueHash(this);
  this._class = classfunc;
  /** @type {string} */
  this._name = name;
  /** @type {number} */
  this._value = val;
}

/**
* @ignore
* @this {EnumValue}
* @return {string}
*/
EnumValue.prototype.toString = function() {
  return Util.getClassName(this._class) + '.' + this._name;
};

/**
* @ignore
* @name EnumValue#classType
* @function.
* @return {function()}
*/
/** @type {function()} */
EnumValue.prototype.classType;
Util.defineReadOnlyProperty(EnumValue, {classType : 'classType'},
  /** @this {EnumValue} */
  function() { return this._class; }
);

/**
* @ignore
* @name EnumValue#name
* @function.
* @return {string}
*/
/** @type {string} */
EnumValue.prototype.name;
Util.defineReadOnlyProperty(EnumValue, {name : 'name'},
  /** @this {EnumValue} */
  function() { return this._name; }
);

/**
* @ignore
* @name EnumValue#name
* @function.
* @return {number}
*/
/** @type {number} */
EnumValue.prototype.value;
Util.defineReadOnlyProperty(EnumValue, {value : 'value'},
  /** @this {EnumValue} */
  function() { return this._value; }
);


/**
* @ignore
* @constructor
* @class
*/
function StringBuilder() {
  this._buffer = [];
  this._indentation = 0;
  this._tabString = '  ';  // two spaces per indent
}

/**
* @ignore
* @this {StringBuilder}
* @return {string}
*/
StringBuilder.prototype.toString = function() {
  return this._buffer.join('');
};

/**
* @ignore
* @this {StringBuilder}
* @param {string} str
*/
StringBuilder.prototype.add = function(str) {
  if (str) this._buffer.push(str);
};

/**
* @ignore
* @this {StringBuilder}
*/
StringBuilder.prototype.increaseIndent = function() {
  this._indentation++;
};

/**
* @ignore
* @this {StringBuilder}
*/
StringBuilder.prototype.decreaseIndent = function() {
  this._indentation--;
  if (this._indentation < 0) this._indentation = 0;
};

/**
* @ignore
* Starts a new line and adds spaces according to the current indentation
* @this {StringBuilder}
*/
StringBuilder.prototype.indent = function() {
  var str = '\n';
  for (var i = this._indentation; i > 0; i--) str += this._tabString;
  this._buffer.push(str);
};

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
* This file defines List, Set, and Map classes,
* the Iterable interface,
* their internal ...Iterator classes,
* the internal KeyValuePair class used by Map and Set, and
* the internal MapKeySet class for treating a Map as a Set of keys.
*/


////////////////
// Interfaces //
////////////////

/**
* This is an interface and thus does not have a constructor.
* @interface
* @category Collection
* @class
* This interface is implemented by the {@link List}, {@link Set}, and {@link Map}
* classes; it provides the {@link #iterator} read-only property that returns an {@link Iterator}.
* <p/>
* Typical usage is:
* <pre>
* var it = anIterableCollection.iterator;
* while (it.next()) {
*   var item = it.value;
* }
* </pre>
*/
function Iterable() { }

/**
* Gets an {@link Iterator} that can iterate over the items in the collection.
* <p/>
* Typical usage is:
* <pre>
*  var it = anIterableCollection.iterator;
*  while (it.next()) {
*    var item = it.value;
*  }
* </pre>
* @name Iterable#iterator
* @function.
* @return {Iterator}
*/

/** @type {Iterator} */
Iterable.prototype.iterator;


/**
* This is an interface and thus does not have a constructor.
* @interface
* @extends Iterable
* @category Collection
* @class
* This interface defines properties and methods for iterating over a collection;
* it provides the {@link #next} predicate and the {@link #value} read-only property.
* Some Iterators also provide <code>key</code> property values along with each <code>value</code>.
* <p/>
* Typical usage is:
* <pre>
*  var it = anIterableCollection.iterator;
*  while (it.next()) {
*    var item = it.value;
*  }
* </pre>
* <p/>
* Many iterators will signal an error if {@link #next} is called
* after the underlying collection has been modified.
* <p/>
* To avoid confusion when dealing with {@link Iterable}s,
* iterators implement the {@link Iterable#iterator} property
* by just returning themselves.
*/
function Iterator() { }

/**
* Returns itself, which is convenient for code that expects an {@link Iterable}
* instead of an {@link Iterator}.
* @name Iterator#iterator
* @function.
* @return {Iterator}
*/
/** @type {Iterator} */
Iterator.prototype.iterator;

/**
* Call this method to advance the iterator to the next item in the collection.
* This should be called before accessing any {@link #value}.
* @this {Iterator}
* @return {boolean} whether another item is available; when true the value of {@link #value} will be that item.
*/
Iterator.prototype.next = function() {};
/**
* Return the first item in the collection, or null if there is none.
* @this {Iterator}
* @return {*}
* @since 1.1
*/
Iterator.prototype.first = function() {};
/**
* Start this iterator all over again.
* @this {Iterator}
*/
Iterator.prototype.reset = function() {};
Iterator.prototype._dispose = function() {};


/**
 * Gets the current item in the collection, assuming {@link #next} has just returned true.
 * @name Iterator#value
 * @function.
 */
//Iterator.prototype.value;

/**
 * Gets the current index to the item in the collection, assuming {@link #next} has just returned true.
 * @name Iterator#key
 * @function.
 */
//Iterator.prototype.key;

/**
 * Gets the total number of items in the iterated collection.
 * @name Iterator#count
 * @function.
 * @return {number}
 */
/** @type {number} */
Iterator.prototype.count;




///////////////////////
// Special Iterators //
///////////////////////

/**
* @ignore
* @constructor
* @implements {Iterator}
* @category Collection
*/
function EmptyIterator() { }

/**
* @ignore
* Returns itself, which is convenient for code that expects an {@link Iterable}
* instead of an {@link Iterator}.
* @name EmptyIterator#iterator
* @function.
* @return {EmptyIterator} this.
*/
/** @type {Iterator} */
EmptyIterator.prototype.iterator;
Util.defineReadOnlyProperty(EmptyIterator, {iterator: 'iterator'},
  /** @this {EmptyIterator} */
  function() { return this; }
);

EmptyIterator.prototype['reset'] =
/**
* @ignore
* @this {EmptyIterator}
*/
EmptyIterator.prototype.reset = function() { };

EmptyIterator.prototype['next'] =
/**
* @ignore
* @this {EmptyIterator}
* @return {boolean}
*/
EmptyIterator.prototype.next = function() { return false; };

EmptyIterator.prototype['first'] =
/**
* @ignore
* @this {EmptyIterator}
* @return {*}
*/
EmptyIterator.prototype.first = function() { return null; };

/**
* @ignore
* @name EmptyIterator#count
* @function.
* @return {number}
*/
/** @type {number} */
EmptyIterator.prototype.count;
Util.defineReadOnlyProperty(EmptyIterator, {count: 'count'},
  /** @this {EmptyIterator} */
  function() { return 0; }
);

/**
* @ignore
* @this {EmptyIterator}
*/
EmptyIterator.prototype._dispose = function() { };

/**
 * @ignore
 */
/** @type {number} */
EmptyIterator.prototype.key;

/**
 * @ignore
 */
/** @type {*} */
EmptyIterator.prototype.value;

/**
* @ignore
* @this {EmptyIterator}
* @return {string}
*/
EmptyIterator.prototype.toString = function() { return 'EmptyIterator'; };


/** @ignore */
Util.EmptyIterator = new EmptyIterator();


/**
* @ignore
* @constructor
* @implements {Iterator}
* @category Collection
*/
function SingletonIterator(val) {
  this.key = -1;
  this.value = val;
}

Util.defineDataProperties(SingletonIterator, { key: true, value: true });

/**
 * @ignore
 * Gets the only index in the collection, zero.
 * @name SingletonIterator#key
 * @function.
 * @return {number} if {@link #next} returned true, this is the iterator's only index, zero.
 */
/** @type {number} */
SingletonIterator.prototype.key;

/**
 * @ignore
 * Gets the only item in the collection.
 * @name SingletonIterator#value
 * @function.
 */
/** @type {*} */
SingletonIterator.prototype.value;

/**
 * @ignore
 * Returns itself, which is convenient for code that expects an {@link Iterable}
 * instead of an {@link Iterator}.
 * @name SingletonIterator#iterator
 * @function.
 * @return {SingletonIterator} this.
 */
/** @type {Iterator} */
SingletonIterator.prototype.iterator;
Util.defineReadOnlyProperty(SingletonIterator, {iterator: 'iterator'},
  /** @this {SingletonIterator} */
  function() { return this; }
);

SingletonIterator.prototype['reset'] =
/**
* @ignore
* @this {SingletonIterator}
*/
SingletonIterator.prototype.reset = function() { this.key = -1; };

SingletonIterator.prototype['next'] =
/**
* @ignore
* @this {SingletonIterator}
* @return {boolean}
*/
SingletonIterator.prototype.next = function() {
  if (this.key === -1) {
    this.key = 0;  // like a ListIterator?
    return true;
  } else {
    return false;
  }
};

SingletonIterator.prototype['first'] =
/**
* @ignore
* @this {SingletonIterator}
* @return {*}
*/
SingletonIterator.prototype.first = function() {
  this.key = 0;
  return this.value;
};

/**
* @ignore
* @name SingletonIterator#count
* @function.
* @return {number}
*/
/** @type {number} */
SingletonIterator.prototype.count;
Util.defineReadOnlyProperty(SingletonIterator, {count: 'count'},
  /** @this {SingletonIterator} */
  function() { return 1; }
);

/**
* @ignore
* @this {SingletonIterator}
*/
SingletonIterator.prototype._dispose = function() { this.value = null; };

/**
* @ignore
* @this {SingletonIterator}
* @return {string}
*/
SingletonIterator.prototype.toString = function() { return 'SingletonIterator(' + this.value + ')'; };


//////////
// List //
//////////

/**
* @ignore
* @constructor
* @implements {Iterator}
* @category Collection
* @class
*/
function ListIterator(l) {
  /** @type {List} */
  this._list = l;
  /** @type {function(*):boolean | null} */
  this._predicate = null;
  this.reset();
}

Util.defineDataProperties(ListIterator, { key: true, value: true });

/**
 * @ignore
 * Gets the current index into the list.
 * @name ListIterator#key
 * @function.
 * @return {number} if {@link #next} returned true, this is the iterator's current index.
 */
/** @type {number} */
ListIterator.prototype.key;

/**
 * @ignore
 * Gets the current item in the list.
 * @name ListIterator#value
 * @function.
 */
/** @type {*} */
ListIterator.prototype.value;

/**
 * @ignore
 * Returns itself, which is convenient for code that expects an {@link Iterable}
 * instead of an {@link Iterator}.
 * @name ListIterator#iterator
 * @function.
 * @return {ListIterator} this.
 */
/** @type {Iterator} */
ListIterator.prototype.iterator;
Util.defineReadOnlyProperty(ListIterator, {iterator: 'iterator'},
  /** @this {ListIterator} */
  function() { return this; }
);

/**
* @ignore
* Only used for filtering forward iterations.
*/
/** @type {function(*):boolean | null} */
ListIterator.prototype.predicate;
Util.exportProperty(ListIterator, 'predicate', ListIterator.prototype.predicate);
Util.defineProperty(ListIterator, {predicate: 'predicate'},
  /** @this {ListIterator} */
  function() { return this._predicate; },
  /** @this {ListIterator} */
  function(val) { this._predicate = val; }
);

ListIterator.prototype['reset'] =
/**
* @ignore
* @this {ListIterator}
*/
ListIterator.prototype.reset = function() {
  var l = this._list;
  l._iterator = null;  // protect against recursion or multiple use
  /** @type {number} */
  this._state = l._changed;
  /** @type {number} */
  this._index = -1;
};

ListIterator.prototype['next'] =
/**
* @ignore
* @this {ListIterator}
* @return {boolean}
*/
ListIterator.prototype.next = function() {
  var l = this._list;
  if (l._changed !== this._state) {
    Util.throwError('the List has been modified during iteration');
  }
  var arr = l._arr;
  var len = arr.length;
  var idx = ++this._index;

  var pred = this._predicate;
  if (pred !== null) {
    while (idx < len) {  // try to find value that satisfies predicate
      var val = arr[idx];
      if (pred(val)) {
        this._index = idx;
        this.key = idx;
        this.value = val;
        return true;
      }
      idx++;
    }
  } else {  // no predicate, use all values
    if (idx < len) {
      this.key = idx;
      this.value = arr[idx];
      return true;
    }
    this._dispose();  // only dispose when there's no predicate
  }
  return false;
};

ListIterator.prototype['first'] =
/**
* @ignore
* @this {ListIterator}
* @return {*}
*/
ListIterator.prototype.first = function() {
  var l = this._list;
  this._state = l._changed;
  this._index = 0;
  var arr = l._arr;
  var len = arr.length;
  var pred = this._predicate;
  if (pred !== null) {
    var idx = 0;
    while (idx < len) {  // try to find value that satisfies predicate
      var val = arr[idx];
      if (pred(val)) {
        this._index = idx;
        this.key = idx;
        this.value = val;
        return val;
      }
      idx++;
    }
    return null;
  } else if (len > 0) {
    var val = arr[0];
    this.key = 0;
    this.value = val;
    return val;
  } else {
    return null;
  }
};

/**
* @ignore
* @name ListIterator#count
* @function.
* @return {number}
*/
/** @type {number} */
ListIterator.prototype.count;
Util.defineReadOnlyProperty(ListIterator, {count: 'count'},
  /** @this {ListIterator} */
  function() {
    var pred = this._predicate;
    if (pred !== null) {
      // if there's a predicate, need to test each item to see if it counts
      var count = 0;
      var arr = this._list._arr;
      var len = arr.length;
      for (var i = 0; i < len; i++) {
        if (pred(arr[i])) count++;
      }
      return count;
    } else {
      return this._list._arr.length;
    }
  }
);

/**
* @ignore
* @this {ListIterator}
*/
ListIterator.prototype._dispose = function() {
  this.key = -1;  // release any references
  this.value = null;
  this._state = -1;  // disallow continued use by next()
  this._predicate = null;
  this._list._iterator = this;  // return iterator for re-use
};

/**
* @ignore
* @this {ListIterator}
* @return {string}
*/
ListIterator.prototype.toString = function() {
  return 'ListIterator@' + this._index + '/' + this._list.count;
};


/**
* @ignore
* @constructor
* @implements {Iterator}
* @category Collection
* @class
*/
function ListIteratorBackwards(l) {
  /** @type {List} */
  this._list = l;
  this.reset();
}

Util.defineDataProperties(ListIteratorBackwards, { key: true, value: true });

/**
 * @ignore
 * Gets the current index into the list.
 * @name ListIteratorBackwards#key
 * @function.
 * @return {number} if {@link #next} returned true, this is the iterator's current index.
 */
/** @type {number} */
ListIteratorBackwards.prototype.key;

/**
 * @ignore
 * Gets the current item in the list.
 * @name ListIteratorBackwards#value
 * @function.
 * @return {*} if {@link #next} returned true, this is the iterator's current item in the list.
 */
/** @type {*} */
ListIteratorBackwards.prototype.value;

/**
 * @ignore
 * Returns itself, which is convenient for code that expects an {@link Iterable}
 * instead of an {@link Iterator}.
 * @name ListIteratorBackwards#iterator
 * @function.
 * @return {ListIteratorBackwards} this.
 */
/** @type {Iterator} */
ListIteratorBackwards.prototype.iterator;
Util.defineReadOnlyProperty(ListIteratorBackwards, {iterator: 'iterator'},
  /** @this {ListIteratorBackwards} */
  function() { return this; }
);

ListIteratorBackwards.prototype['reset'] =
/**
* @ignore
* @this {ListIteratorBackwards}
*/
ListIteratorBackwards.prototype.reset = function() {
  var l = this._list;
  l._iteratorBackwards = null;  // protect against recursion or multiple use
  /** @type {number} */
  this._state = l._changed;
  /** @type {number} */
  this._index = l._arr.length;
};

ListIteratorBackwards.prototype['next'] =
/**
* @ignore
* @this {ListIteratorBackwards}
* @return {boolean}
*/
ListIteratorBackwards.prototype.next = function() {
  var l = this._list;
  if (l._changed !== this._state) {
    Util.throwError('the List has been modified during iteration');
  }
  var idx = --this._index;
  if (idx >= 0) {
    this.key = idx;
    this.value = l._arr[idx];
    return true;
  } else {
    this._dispose();
    return false;
  }
};

ListIteratorBackwards.prototype['first'] =
/**
* @ignore
* @this {ListIteratorBackwards}
* @return {*}
*/
ListIteratorBackwards.prototype.first = function() {
  var l = this._list;
  this._state = l._changed;
  var arr = l._arr;
  var idx = arr.length - 1;
  this._index = idx;
  if (idx >= 0) {
    var val = arr[idx];
    this.key = idx;
    this.value = val;
    return val;
  } else {
    return null;
  }
};

/**
* @ignore
* @name ListIteratorBackwards#count
* @function.
* @return {number}
*/
/** @type {number} */
ListIteratorBackwards.prototype.count;
Util.defineReadOnlyProperty(ListIteratorBackwards, {count: 'count'},
  /** @this {ListIteratorBackwards} */
  function() { return this._list._arr.length; }
);

/**
* @ignore
* @this {ListIteratorBackwards}
*/
ListIteratorBackwards.prototype._dispose = function() {
  this.key = -1;  // release any references
  this.value = null;
  this._state = -1;  // disallow continued use by next()
  this._list._iteratorBackwards = this;  // return iterator for re-use
};

/**
* @ignore
* @this {ListIteratorBackwards}
* @return {string}
*/
ListIteratorBackwards.prototype.toString = function() {
  return 'ListIteratorBackwards(' + this._index + '/' + this._list.count + ')';
};


/**
 * There are three possible constructors:
 * List(),
 * List(string) where string is a primitive type ('number', 'string', 'boolean', or 'function'), or
 * List(func) where func is a class function/constructor, such as {@link GraphObject}.
 * <p/>
 * Typical usage would be something like:
 * <pre>
 *   var list = new go.List(go.GraphObject);  // keep a list of GraphObjects
 * </pre>
 * @constructor
 * @implements {Iterable}
 * @param {function(...)|string|null=} type Optional class type (constructor) or a string
 * describing a primitive type.
 * 'string', 'number', 'boolean', and 'function' are accepted primitive types.
 * @category Collection
 * @class
 * An ordered iterable collection.
 * It optionally enforces the type of elements that may be added to the List.
 * <p/>
 * An example usage:
 * <pre>
 *   var list = new go.List(go.Point);  // make a list of Points
 *   list.add(new go.Point(0, 0));
 *   list.add(new go.Point(20, 10));
 *   list.add(new go.Point(10, 20));
 *   // now list.length === 3
 *   // and list.elt(1) instanceof go.Point
 * </pre>
 * <p/>
 * You can iterate over the items in a List:
 * <pre>
 *   var it = aList.iterator;
 *   while (it.next()) {
 *     window.console.log("#" + it.key + " is " + it.value);
 *   }
 * </pre>
 * The key will range from zero to {@link #count}-1.
 */
function List(type) {
  Util.uniqueHash(this);
  /** @type {boolean} */
  this._isFrozen = false;

  // Three possible constructors:
  // List()
  // List(string) where string is a primitive type
  // List(func) where func is a class function/constructor

  this._arr = [];
  /** @type {number} */
  this._changed = 0;
  /** @type {ListIterator} */
  this._iterator = null;
  /** @type {ListIteratorBackwards} */
  this._iteratorBackwards = null;

  if (type === undefined/*notpresent*/ || type === null) { // if no type specified
    /** @type {string|function()|null} */
    this._type = null;
  } else if (typeof type === 'string') { // if a primitive type
    if (type === 'object' || type === 'string' || type === 'number' || type === 'boolean' || type === 'function') {
      this._type = type;
    } else {
      Util.throwRangeError(type, 'the string \'object\', \'number\', \'string\', \'boolean\', or \'function\'', 'List constructor: type');
    }
  } else if (typeof type === 'function') { // if an object
    if (type === Object) {
      this._type = 'object';
    } else if (type === String) {
      this._type = 'string';
    } else if (type === Number) {
      this._type = 'number';
    } else if (type === Boolean) {
      this._type = 'boolean';
    } else if (type === Function) {
      this._type = 'function';
    } else {
      this._type = type;
    }
  } else {
    Util.throwRangeError(type, 'null, a primitive type name, or a class type', 'List constructor: type');
  }
}

Util.publish('List', List);

/**
* @ignore
* @this {List}
*/
List.prototype._checkCollectionType = function(val) {
  if (this._type === null) return;
  if (typeof this._type === 'string') {
    if (typeof val !== this._type || val === null) {
      Util.throwTypeError(val, this._type);
    }
  } else {
    if (!(val instanceof this._type)) {
      Util.throwTypeError(val, this._type);
    }
  }
};

/**
* @ignore
* @this {List}
*/
List.prototype._modify = function() {
  var c = this._changed;
  c++;
  if (c > 999999999) c = 0;
  this._changed = c;
};

List.prototype['freeze'] =
/**
* @ignore
* Make this List 'frozen' or immutable.
* Future attempts to change its state, for example by adding or replacing an element,
* may result in an exception.
* @this {List}
* @return {List}
*/
List.prototype.freeze = function() {
  this._isFrozen = true;
  return this;
};

List.prototype['thaw'] =
/**
* @ignore
* Make this object 'thawed' or mutable.
* @this {List}
* @return {List}
*/
List.prototype.thaw = function() {
  this._isFrozen = false;
  return this;
};

/**
* @ignore
* @this {List}
* @return {string}
*/
List.prototype.toString = function() {
  return 'List(' + Util.getTypeName(this._type) + ')#' + Util.hashId(this);
};

List.prototype['add'] =
/**
* Adds a given value to the end of the List.
* @this {List}
*/
List.prototype.add = function(val) {
  if (val === null) return;
  if (Debug) this._checkCollectionType(val);
  Util.checkFrozen(this, val);
  var arr = this._arr;
  arr.push(val);
  this._modify();
};

List.prototype['addAll'] =
/**
* Adds all of the values of a collection to the end of this List.
* @this {List}
* @param {Iterable|Array} coll the collection of items to add.
* @return {List} this List.
*/
List.prototype.addAll = function(coll) {
  if (coll === null) return this;
  Util.checkFrozen(this);
  var arr = this._arr;
  if (Util.isArray(coll)) {
    var len = Util.arrayLength(coll);
    for (var i = 0; i < len; i++) {
      var val = Util.arrayElt(coll, i);
      if (Debug) this._checkCollectionType(val);
      arr.push(val);
    }
  } else {
    var it = coll.iterator;
    while (it.next()) {
      var val = it.value;
      if (Debug) this._checkCollectionType(val);
      arr.push(val);
    }
  }
  this._modify();
  return this;
};

List.prototype['clear'] =
/**
* Clears the List.
* This sets the {@link #count} to zero.
* @this {List}
*/
List.prototype.clear = function() {
  Util.checkFrozen(this);
  this._arr.length = 0;
  this._modify();
};

List.prototype['contains'] =
/**
* Returns whether the given value is in this List.
* @this {List}
* @param {*} val The value to check.
* @return {boolean} Whether or not the value is contained within the List.
*/
List.prototype.contains = function(val) {
  if (val === null) return false;
  if (Debug) this._checkCollectionType(val);
  var arr = this._arr;
  return arr.indexOf(val) !== -1;
};

List.prototype['indexOf'] =
/**
* Returns the index of the given value if it is in this List.
* @this {List}
* @param {*} val The value to check.
* @return {number} returns -1 if the value is not in this list.
*/
List.prototype.indexOf = function(val) {
  if (val === null) return -1;
  if (Debug) this._checkCollectionType(val);
  var arr = this._arr;
  return arr.indexOf(val);
};

List.prototype['elt'] =
/**
* Returns the element at the given index.
* @this {List}
* @param {number} i The index of the element to return.
* @return {?} the value at the given index.
*/
List.prototype.elt = function(i) {
  if (Debug) Util.checkRealNumber(i, List, 'elt:i');
  var arr = this._arr;
  if (i < 0 || i >= arr.length) Util.throwRangeError(i, '0 <= i < length', List, 'elt:i');
  return arr[i];
};

List.prototype['setElt'] =
/**
* Set the element at the given index to a given value.
* @this {List}
* @param {number} i The index of the element to set.
* @param {*} val The value to set at the index.
*/
List.prototype.setElt = function(i, val) {
  if (Debug) {
    this._checkCollectionType(val);
    Util.checkRealNumber(i, List, 'setElt:i');
  }
  var arr = this._arr;
  if (i < 0 || i >= arr.length) Util.throwRangeError(i, '0 <= i < length', List, 'setElt:i');
  Util.checkFrozen(this, i);
  arr[i] = val;
};

List.prototype['first'] =
/**
* Returns the first item in the collection, or null if there is none.
* @this {List}
* @return {?} This returns null if there are no items in the collection.
*/
List.prototype.first = function() {
  var arr = this._arr;
  if (arr.length === 0) return null;
  return arr[0];
};

List.prototype['insertAt'] =
/**
* Insert a value before the index i.
* @this {List}
* @param {number} i The index to insert before.
* @param {*} val The value to insert.
*/
List.prototype.insertAt = function(i, val) {
  if (Debug) {
    this._checkCollectionType(val);
    Util.checkRealNumber(i, List, 'insertAt:i');
  }
  if (i < 0) Util.throwRangeError(i, '>= 0', List, 'insertAt:i');
  Util.checkFrozen(this, i);
  var arr = this._arr;
  if (i >= arr.length) { //special case, add to end
    arr.push(val);
  } else {
    arr.splice(i, 0, val);
  }
  this._modify();
  return true;
};


List.prototype['remove'] =
/**
* Removes a given value (if found) from the List.
* @this {List}
* @param {*} val The value to remove.
* @return {boolean} true if the value was found and removed, false otherwise.
*/
List.prototype.remove = function(val) {
  if (val === null) return false;
  if (Debug) this._checkCollectionType(val);
  Util.checkFrozen(this, val);
  var arr = this._arr;
  var idx = arr.indexOf(val);
  if (idx === -1) return false;
  //optimization for last element (8x faster)
  if (idx === arr.length - 1) {
    arr.pop();
  } else {
    arr.splice(idx, 1);
  }
  this._modify();
  return true;
};

List.prototype['removeAt'] =
/**
* Removes a value at a given index from the List.
* @this {List}
* @param {number} i The index to remove.
*/
List.prototype.removeAt = function(i) {
  if (Debug) Util.checkRealNumber(i, List, 'removeAt:i');
  var arr = this._arr;
  if (i < 0 || i >= arr.length) Util.throwRangeError(i, '0 <= i < length', List, 'removeAt:i');
  Util.checkFrozen(this, i);
  //optimization for last element (8x faster)
  if (i === arr.length - 1) {
    arr.pop();
  } else {
    arr.splice(i, 1);
  }
  this._modify();
};

List.prototype['removeRange'] =
/**
* Removes a range of values from the List.
* @this {List}
* @param {number} to The starting index of the range to remove, inclusive.
* @param {number} from The ending index of the range to remove, inclusive.
*/
List.prototype.removeRange = function(from, to) {
  if (Debug) {
    Util.checkRealNumber(from, List, 'removeRange:from');
    Util.checkRealNumber(to, List, 'removeRange:to');
  }
  var arr = this._arr;
  if (from < 0 || from >= arr.length) Util.throwRangeError(from, '0 <= from < length', List, 'elt:from');
  if (to < 0 || to >= arr.length) Util.throwRangeError(to, '0 <= to < length', List, 'elt:to');
  Util.checkFrozen(this, from);

  var rest = arr.slice((to || from) + 1 || arr.length);
  arr.length = from < 0 ? arr.length + from : from;
  arr.push.apply(arr, rest);
  this._modify();
};

/**
* Makes a shallow copy of this List.
* The values are not copied,
* so if they are objects they may continue to be shared with the original List.
* @expose
* @this {List}
* @return {List} The new list.
*/
List.prototype.copy = function() {
  var newlist = new List(this._type);
  var arr = this._arr;
  var l = this.count;
  for (var i = 0; i < l; i++) {
    newlist.add(arr[i]);
  }
  return newlist;
};

List.prototype['toArray'] =
/**
* Produces a JavaScript Array from the contents of this List.
* @this {List}
* @return {Array} A copy of the List in Array form.
*/
List.prototype.toArray = function() {
  var arr = this._arr;
  var l = this.count;
  var newarr = new Array(l);
  for (var i = 0; i < l; i++) {
    newarr[i] = arr[i];
  }
  return newarr;
};

List.prototype['toSet'] =
/**
* Converts the List to a {@link Set}.
* The count of the resulting Set may be less than the count of this List
* if any duplicates were removed.
* @this {List}
* @return {Set} A copy of the contents of this List,
* but with duplicates removed and ordering lost.
*/
List.prototype.toSet = function() {
  var newset = new Set(this._type);
  var arr = this._arr;
  var l = this.count;
  for (var i = 0; i < l; i++) {
    newset.add(arr[i]);
  }
  return newset;
};

List.prototype['sort'] =
/**
* Sort the List according to a comparison function.
* @this {List}
* @param {function(*,*):number} sortfunc  This function is passed two items in the list.
* It should return zero if they are equal,
* less than zero if the first value should come before the second value,
* or greater than zero if the first value should come after the second value.
* @return {List} this modified List.
*/
List.prototype.sort = function(sortfunc) {
  if (Debug) Util.checkPrimitive(sortfunc, 'function', List, 'sort:sortfunc');
  Util.checkFrozen(this);
  this._arr.sort(sortfunc);
  this._modify();
  return this;
};

List.prototype['sortRange'] =
/**
* @ignore
* Sorts a range of consecutive elements in this List based on the given comparison function.
* @this {List}
* @param {function(*,*):number} sortfunc  This function is passed two elements in the list.
* It should return zero if they are equal,
* less than zero if the first value should come before the second value,
* or greater than zero if the first value should come after the second value.
* @param {number=} from The optional index at which to start the sort, including that element;
* default to zero, the first element of the list.
* @param {number=} to The optional index at which to end the sort, excluding that element;
* defaults to the end of the list.
* @return {List} this modified List.
*/
List.prototype.sortRange = function(sortfunc, from, to) {
  var arr = this._arr;
  var len = arr.length;
  if (from === undefined/*notpresent*/) from = 0;
  if (to === undefined/*notpresent*/) to = len;
  if (Debug) {
    Util.checkPrimitive(sortfunc, 'function', List, 'sortRange:sortfunc');
    Util.checkRealNumber(from, List, 'sortRange:from');
    Util.checkRealNumber(to, List, 'sortRange:to');
  }
  Util.checkFrozen(this);

  var num = to - from;
  if (num <= 1) return this;

  // FROM can't be at or beyond the last item, because NUM >= 2
  if (from < 0 || from >= len - 1) Util.throwRangeError(from, '0 <= from < length', List, 'sortRange:from');

  if (num === 2) {  // handle special case of just two items in the range
    var first = arr[from];
    var second = arr[from + 1];
    if (sortfunc(first, second) > 0) {
      arr[from] = second;
      arr[from + 1] = first;
      this._modify();
    }
    return this;
  }

  // now NUM >= 3
  if (from === 0) {
    if (to >= len) {  // sort the whole array
      arr.sort(sortfunc);
    } else {  // not the end of the array
      var temp = arr.slice(0, to);
      temp.sort(sortfunc);
      for (var i = 0; i < to; i++) arr[i] = temp[i];
    }
  } else {
    if (to >= len) { // not the beginning of the array, but all the rest
      var temp = arr.slice(from);
      temp.sort(sortfunc);
      for (var i = from; i < len; i++) arr[i] = temp[i - from];
    } else {  // neither beginning nor the end of the array
      var temp = arr.slice(from, to);
      temp.sort(sortfunc);
      for (var i = from; i < to; i++) arr[i] = temp[i - from];
    }
  }

  this._modify();
  return this;
};

List.prototype['reverse'] =
/**
* Reverse the order of items in this List.
* @this {List}
* @return {List} this modified List.
*/
List.prototype.reverse = function() {
  Util.checkFrozen(this);
  this._arr.reverse();
  this._modify();
  return this;
};

/**
 * Gets the length of the List.
 * @name List#count
 * @function.
 * @return {number} the List's length.
 */
/** @type {number} */
List.prototype.count;
Util.defineReadOnlyProperty(List, {count: 'count'},
  /** @this {List} */
  function() { return this._arr.length; }
);

/**
 * Gets the length of the List, a synonym for the {@link #count} property.
 * @name List#length
 * @function.
 * @return {number} the List's length.
 */
/** @type {number} */
List.prototype.length;
Util.defineReadOnlyProperty(List, {length: 'length'},
  /** @this {List} */
  function() { return this._arr.length; }
);

/**
* Gets an object that you can use for iterating over the List.
* The key will be an integer from zero to the count-1.
* The value will be the item at that index in the list.
* Typical usage:
* <pre>
*   var it = aList.iterator;
*   while (it.next()) {
*     . . . "index: " + it.key + " value: " + it.value . . .
*   }
* </pre>
* @name List#iterator
* @function.
* @return {Iterator}
*/
/** @type {Iterator} */
List.prototype.iterator;
Util.defineReadOnlyProperty(List, {iterator: 'iterator'},
  /** @this {List} */
  function() {
    if (this._arr.length <= 0) return Util.EmptyIterator;
    var it = this._iterator;
    if (it !== null) {  // reuse a single instance of an iterator, assuming single-threaded
      it.reset();
      return it;
    }
    return new ListIterator(this);
  }
);

/**
* Gets an object that you can use for iterating over the List in backwards order.
* The key will be an integer from count-1 to zero.
* The value will be the item at that index in the list.
* The list is not modified by traversing in reverse order.
* Typical usage:
* <pre>
*   var it = aList.iteratorBackwards;
*   while (it.next()) {
*     . . . 'key: ' + it.key + ' value: ' + it.value . . .
*   }
* </pre>
* @name List#iteratorBackwards
* @function.
* @return {Iterator}
*/
/** @type {Iterator} */
List.prototype.iteratorBackwards;
Util.defineReadOnlyProperty(List, {iteratorBackwards: 'iteratorBackwards'},
  /** @this {List} */
  function() {
    if (this._arr.length <= 0) return Util.EmptyIterator;
    var it = this._iteratorBackwards;
    if (it !== null) {  // reuse a single instance of an iterator, assuming single-threaded
      it.reset();
      return it;
    }
    return new ListIteratorBackwards(this);
  }
);


/////////
// Set //
/////////

/**
* @ignore
* @constructor
* @implements {Iterator}
* @category Collection
* @class
*/
function SetIterator(s) {
  /** @type {Set} */
  this._set = s;
  this.reset();
}

Util.defineDataProperties(SetIterator, { key: true, value: true });

/**
 * @ignore
 * Gets the current key used by a value in the set.
 * @name SetIterator#key
 * @function.
 * @return {*} if {@link #next} returned true, this is the iterator's current key in the Set.
 */
/** @type {*} */
SetIterator.prototype.key;

/**
 * @ignore
 * Gets the current item in the set.
 * @name SetIterator#value
 * @function.
 * @return {*} if {@link #next} returned true, this is the iterator's current item in the Set.
 */
/** @type {*} */
SetIterator.prototype.value;

/**
 * @ignore
 * Returns itself, which is convenient for code that expects an {@link Iterable}
 * instead of an {@link Iterator}.
 * @name SetIterator#iterator
 * @function.
 * @return {SetIterator} this.
 */
/** @type {Iterator} */
SetIterator.prototype.iterator;
Util.defineReadOnlyProperty(SetIterator, {iterator: 'iterator'},
  /** @this {SetIterator} */
  function() { return this; }
);

SetIterator.prototype['reset'] =
/**
* @ignore
* @this {SetIterator}
*/
SetIterator.prototype.reset = function() {
  var s = this._set;
  s._iterator = null;  // protect against recursion or multiple use
  /** @type {number} */
  this._state = s._changed;
  /** @type {KeyValuePair} */
  this._kvp = null;
};

SetIterator.prototype['next'] =
/**
* @ignore
* @this {SetIterator}
* @return {boolean}
*/
SetIterator.prototype.next = function() {
  var s = this._set;
  if (s._changed !== this._state) {
    Util.throwError('the Set has been modified during iteration');
  }
  var kvp = this._kvp;
  if (kvp === null) {
    kvp = s._first;
  } else {
    kvp = kvp._next;
  }
  if (kvp !== null) {
    this._kvp = kvp;
    this.value = kvp.value;
    this.key = kvp.key;
    return true;
  }
  this._dispose();
  return false;
};

SetIterator.prototype['first'] =
/**
* @ignore
* @this {SetIterator}
* @return {*}
*/
SetIterator.prototype.first = function() {
  var s = this._set;
  this._state = s._changed;
  var kvp = s._first;
  if (kvp !== null) {
    this._kvp = kvp;
    var val = kvp.value;
    this.key = kvp.key;
    this.value = val;
    return val;
  } else {
    return null;
  }
};

/**
* @ignore
* @name SetIterator#count
* @function.
* @return {number}
*/
/** @type {number} */
SetIterator.prototype.count;
Util.defineReadOnlyProperty(SetIterator, {count: 'count'},
  /** @this {SetIterator} */
  function() { return this._set._count; }
);

/**
* @ignore
* @this {SetIterator}
*/
SetIterator.prototype._dispose = function() {
  this.value = null;  // release any references
  this._state = -1;  // disallow continued use by next()
  this._set._iterator = this;  // return iterator for re-use
};

/**
* @ignore
* @this {SetIterator}
* @return {string}
*/
SetIterator.prototype.toString = function() {
  if (this._kvp !== null)
    return 'SetIterator@' + this._kvp.value;
  else
    return 'SetIterator';
};


/**
 * There are three possible constructors:
 * Set(),
 * Set(string) where string is a primitive type ('number' or 'string'), or
 * Set(func) where func is a class function/constructor, such as {@link GraphObject}.
 * @constructor
 * @implements {Iterable}
 * @param {function(...)|string|null=} type Optional class type (constructor) or a string
 * describing a primitive type, either 'string' or 'number'.
 * @category Collection
 * @class
 * An unordered iterable collection that cannot contain two instances of the same kind of value.
 * It optionally enforces the type of elements that may be added to the Set.
 * <p/>
 * An example usage:
 * <pre>
 *   var set = new go.Set("string");  // make a set of strings
 *   set.add("orange");
 *   set.add("apple");
 *   set.add("orange");
 *   // now set.count === 2
 *   // and set.contains("orange") === true
 *   // and set.contains("banana") === false
 * </pre>
 * <p/>
 * You can iterate over the items in a Set:
 * <pre>
 *   var it = aSet.iterator;
 *   while (it.next()) {
 *     . . . it.value . . .
 *   }
 * </pre>
 */
function Set(type) {
  Util.uniqueHash(this);
  /** @type {boolean} */
  this._isFrozen = false;
  if (type === undefined/*notpresent*/ || type === null) { // if no type specified
    /** @type {string|function()|null} */
    this._type = null;
  } else if (typeof type === 'string') { // if a primitive type
    if (type === 'object' || type === 'string' || type === 'number') {
      this._type = type;
    } else {
      Util.throwRangeError(type, 'the string \'object\', \'number\' or \'string\'', 'Set constructor: type');
    }
  } else if (typeof type === 'function') { // if an object
    if (type === Object) {
      this._type = 'object';
    } else if (type === String) {
      this._type = 'string';
    } else if (type === Number) {
      this._type = 'number';
    } else {
      this._type = type;
    }
  } else {
    Util.throwRangeError(type, 'null, a primitive type name, or a class type', 'Set constructor: type');
  }

  this._dict = {};
  /** @type {number} */
  this._count = 0;
  /** @type {SetIterator} */
  this._iterator = null;
  /** @type {number} */
  this._changed = 0;
  /** @type {KeyValuePair} */
  this._first = null;
  /** @type {KeyValuePair} */
  this._last = null;
}

Util.publish('Set', Set);

/**
* @ignore
* @this {Set}
*/
Set.prototype._checkCollectionType = function(val) {
  if (this._type === null) return;
  if (typeof this._type === 'string') {
    if (typeof val !== this._type || val === null) {
      Util.throwTypeError(val, this._type);
    }
  } else {
    if (!(val instanceof this._type)) {
      Util.throwTypeError(val, this._type);
    }
  }
};

/**
* @ignore
* @this {Set}
*/
Set.prototype._modify = function() {
  var c = this._changed;
  c++;
  if (c > 999999999) c = 0;
  this._changed = c;
};

Set.prototype['freeze'] =
/**
* @ignore
* Make this Set 'frozen' or immutable.
* Future attempts to change its state, for example by adding or removing an element,
* may result in an exception.
* @this {Set}
* @return {Set}
*/
Set.prototype.freeze = function() {
  this._isFrozen = true;
  return this;
};

Set.prototype['thaw'] =
/**
* @ignore
* Make this object 'thawed' or mutable.
* @this {Set}
* @return {Set}
*/
Set.prototype.thaw = function() {
  this._isFrozen = false;
  return this;
};

/**
* @ignore
* @this {Set}
* @return {string}
*/
Set.prototype.toString = function() {
  return 'Set(' + Util.getTypeName(this._type) + ')#' + Util.hashId(this);
};

Set.prototype['add'] =
/**
* Adds a given value to the Set, if not already present.
* @this {Set}
* @param {*} val The value to add to the Set; must not be null.
* @return {boolean} true if the value was not already present in the Set; false if it was.
*/
Set.prototype.add = function(val) {
  if (val === null) return false;
  if (Debug) this._checkCollectionType(val);
  Util.checkFrozen(this, val);
  var realkey = val;
  if (Util.isObject(val)) {
    realkey = Util.hashIdUnique(val);
  }
  var kvp = this._dict[realkey];
  if (kvp === undefined/*notpresent*/) {  // not found
    this._count++;
    var newkvp = new KeyValuePair(val, val);
    this._dict[realkey] = newkvp;
    var last = this._last;
    if (last === null) {
      this._first = newkvp;
      this._last = newkvp;
    } else {
      newkvp._prev = last;
      last._next = newkvp;
      this._last = newkvp;
    }
    this._modify();
    return true;
  } else {
    return false;
  }
};

Set.prototype['addAll'] =
/**
* Adds all of the values of a collection to this Set.
* @this {Set}
* @param {Iterable|Array} coll the collection of items to add.
* @return {Set} this Set.
*/
Set.prototype.addAll = function(coll) {
  if (coll === null) return this;
  Util.checkFrozen(this);
  if (Util.isArray(coll)) {
    var len = Util.arrayLength(coll);
    for (var i = 0; i < len; i++) {
      this.add(Util.arrayElt(coll, i));
    }
  } else {
    var it = coll.iterator;
    while (it.next()) {
      this.add(it.value);
    }
  }
  return this;
};

Set.prototype['contains'] =
/**
* Returns whether the given value is in this Set.
* @this {Set}
* @param {*} val The value to check.
* @return {boolean} Whether or not the value is contained within the Set.
*/
Set.prototype.contains = function(val) {
  if (val === null) return false;
  if (Debug) this._checkCollectionType(val);
  var realkey = val;
  if (Util.isObject(val)) {
    realkey = Util.hashId(val);
    if (realkey === undefined) return false;
  }
  var kvp = this._dict[realkey];
  return (kvp !== undefined/*notpresent*/);
};

Set.prototype['containsAll'] =
/**
* Returns true if all of the values of a given collection are in this Set.
* @this {Set}
* @param {Iterable} coll the collection of items to check for.
* @return {boolean}
*/
Set.prototype.containsAll = function(coll) {
  if (coll === null) return true;
  var it = coll.iterator;
  while (it.next()) {
    if (!this.contains(it.value)) return false;
  }
  return true;
};

Set.prototype['containsAny'] =
/**
* Returns true if any of the values of a given collection are in this Set.
* @this {Set}
* @param {Iterable} coll the collection of items to check for.
* @return {boolean}
*/
Set.prototype.containsAny = function(coll) {
  if (coll === null) return true;
  var it = coll.iterator;
  while (it.next()) {
    if (this.contains(it.value)) return true;
  }
  return false;
};

Set.prototype['first'] =
/**
* Returns the first item in the collection, or null if there is none.
* @this {Set}
* @return {?} This returns null if there are no items in the collection.
*/
Set.prototype.first = function() {
  var kvp = this._first;
  if (kvp === null) return null;
  return kvp.value;
};

Set.prototype['remove'] =
/**
* Removes a value (if found) from the Set.
* @this {Set}
* @param {*} val The value to insert.
* @return {boolean} true if the value was found and removed, false otherwise.
*/
Set.prototype.remove = function(val) {
  if (val === null) return false;
  if (Debug) this._checkCollectionType(val);
  Util.checkFrozen(this, val);
  var realkey = val;
  if (Util.isObject(val)) {
    realkey = Util.hashId(val);
    if (realkey === undefined) return false;
  }
  var kvp = this._dict[realkey];
  if (kvp === undefined/*notpresent*/) {  // not found
    return false;
  } else {
    var next = kvp._next;
    var prev = kvp._prev;
    if (next !== null) next._prev = prev;
    if (prev !== null) prev._next = next;
    if (this._first === kvp) this._first = next;
    if (this._last === kvp) this._last = prev;
    delete this._dict[realkey];
    this._count--;
    this._modify();
    return true;
  }
};

Set.prototype['removeAll'] =
/**
* Removes all of the values of a collection from this Set.
* @this {Set}
* @param {Iterable} coll the collection of items to remove.
* @return {Set} this Set.
*/
Set.prototype.removeAll = function(coll) {
  if (coll === null) return this;
  Util.checkFrozen(this);
  var it = coll.iterator;
  while (it.next()) {
    this.remove(it.value);
  }
  return this;
};

Set.prototype['retainAll'] =
/**
* Removes from this Set all items that are not in the given collection.
* @this {Set}
* @param {Iterable} coll the collection of items that should be kept in this Set.
* @return {Set} this Set.
*/
Set.prototype.retainAll = function(coll) {
  if (coll === null) return this;
  if (this.count === 0) return this;
  Util.checkFrozen(this);
  var keep = new Set(this._type);
  keep.addAll(coll);
  //?? It would be more efficient to go through kvp chain,
  //   rather than rehashing values and accumulating another List.
  var remove = new List(this._type);
  var it = this.iterator;
  while (it.next()) {
    if (!keep.contains(it.value)) {
      remove.add(it.value);
    }
  }
  var rit = remove.iterator;
  while (rit.next()) {
    this.remove(rit.value);
  }
  return this;
};

Set.prototype['clear'] =
/**
* Clears the Set.
* This sets the {@link #count} to zero.
* @this {Set}
*/
Set.prototype.clear = function() {
  Util.checkFrozen(this);
  this._dict = {};
  this._count = 0;
  this._first = null;
  this._last = null;
  this._modify();
};

/**
* Makes a shallow copy of this Set.
* The values are not copied,
* so if they are objects they may continue to be shared with the original Set.
* @expose
* @this {Set}
* @return {Set} The new Set.
*/
Set.prototype.copy = function() {
  var newset = new Set(this._type);
  var dict = this._dict;
  for (var a in dict) {
    newset.add(dict[a].value);
  }
  return newset;
};

Set.prototype['toArray'] =
/**
* Produces a JavaScript Array from the contents of this Set.
* @this {Set}
* @return {Array} A copy of the Set in Array form.
*/
Set.prototype.toArray = function() {
  var newarr = new Array(this._count);
  var dict = this._dict;
  var i = 0;
  for (var a in dict) {
    newarr[i] = dict[a].value;
    i++;
  }
  return newarr;
};

Set.prototype['toList'] =
/**
* Converts the Set to a {@link List}.
* Because there is no ordering within a Set,
* the values in the List may be in any order.
* @this {Set}
* @return {List} A copy of the contents of this Set in List form.
*/
Set.prototype.toList = function() {
  var newlist = new List(this._type);
  var dict = this._dict;
  for (var a in dict) {
    newlist.add(dict[a]);
  }
  return newlist;
};

/**
 * Gets the number of elements in the Set.
 * @name Set#count
 * @function.
 * @return {number}
 */
/** @type {number} */
Set.prototype.count;
Util.defineReadOnlyProperty(Set, {count: 'count'},
  /** @this {Set} */
  function() { return this._count; }
);

/**
* Gets an object that you can use for iterating over the Set.
* The value will be a member of the Set.
* Typical usage:
* <pre>
*   var it = aSet.iterator;
*   while (it.next()) {
*     . . . " value: " + it.value . . .
*   }
* </pre>
* @name Set#iterator
* @function.
* @return {Iterator}
*/
/** @type {Iterator} */
Set.prototype.iterator;
Util.defineReadOnlyProperty(Set, {iterator: 'iterator'},
  /** @this {Set} */
  function() {
    if (this._count <= 0) return Util.EmptyIterator;
    var it = this._iterator;
    if (it !== null) {  // reuse a single instance of an iterator, assuming single-threaded
      it.reset();
      return it;
    }
    return new SetIterator(this);
  }
);


///////////////
// MapKeySet //
///////////////

/**
* @ignore
* @constructor
* @implements {Iterator}
* @category Collection
* @class
*/
function MapKeySetIterator(m) {
  /** @type {Map} */
  this._map = m;
  this.reset();
}

Util.defineDataProperties(MapKeySetIterator, { key: true, value: true });

/**
 * @ignore
 */
/** @type {*} */
MapKeySetIterator.prototype.key;

/**
 * @ignore
 * Gets the current key in the map.
 * @name MapKeySetIterator#value
 * @function.
 * @return {*} if {@link #next} returned true, this is the iterator's current key in the map.
 */
/** @type {*} */
MapKeySetIterator.prototype.value;

/**
 * @ignore
 * Returns itself, which is convenient for code that expects an {@link Iterable}
 * instead of an {@link Iterator}.
 * @name MapKeySetIterator#iterator
 * @function.
 * @return {MapKeySetIterator} this.
 */
/** @type {Iterator} */
MapKeySetIterator.prototype.iterator;
Util.defineReadOnlyProperty(MapKeySetIterator, {iterator: 'iterator'},
  /** @this {MapKeySetIterator} */
  function() { return this; }
);

MapKeySetIterator.prototype['reset'] =
/**
* @ignore
* @this {MapKeySetIterator}
*/
MapKeySetIterator.prototype.reset = function() {
  var m = this._map;
  /** @type {number} */
  this._state = m._changed;
  /** @type {KeyValuePair} */
  this._kvp = null;
};

MapKeySetIterator.prototype['next'] =
/**
* @ignore
* @this {MapKeySetIterator}
* @return {boolean}
*/
MapKeySetIterator.prototype.next = function() {
  var m = this._map;
  if (m._changed !== this._state) {
    Util.throwError('the Map has been modified during iteration');
  }
  var kvp = this._kvp;
  if (kvp === null) {
    kvp = m._first;
  } else {
    kvp = kvp._next;
  }
  if (kvp !== null) {
    this._kvp = kvp;
    this.value = kvp.key;
    return true;
  }
  this._dispose();
  return false;
};

MapKeySetIterator.prototype['first'] =
/**
* @ignore
* @this {MapKeySetIterator}
* @return {*}
*/
MapKeySetIterator.prototype.first = function() {
  var m = this._map;
  this._state = m._changed;
  var kvp = m._first;
  if (kvp !== null) {
    this._kvp = kvp;
    var val = kvp.value;
    this.key = kvp.key;
    this.value = val;
    return val;
  } else {
    return null;
  }
};

/**
* @ignore
* @name MapKeySetIterator#count
* @function.
* @return {number}
*/
/** @type {number} */
MapKeySetIterator.prototype.count;
Util.defineReadOnlyProperty(MapKeySetIterator, {count: 'count'},
  /** @this {MapKeySetIterator} */
  function() { return this._map._count; }
);

/**
* @ignore
* @this {MapKeySetIterator}
*/
MapKeySetIterator.prototype._dispose = function() {
  this.value = null;  // release any references
  this._state = -1;  // disallow continued use by next()
};

/**
* @ignore
* @this {MapKeySetIterator}
* @return {string}
*/
MapKeySetIterator.prototype.toString = function() {
  if (this._kvp !== null)
    return 'MapKeySetIterator@' + this._kvp.value;
  else
    return 'MapKeySetIterator';
};


/**
* @ignore
* @constructor
* @extends Set
* @category Collection
*/
function MapKeySet(map) {
  Util.uniqueHash(this);
  /*@type {Map} */
  this._map = map;
}

Util.inherit(MapKeySet, Set);

/**
* @ignore
* A MapKeySet is read-only, so the concept of freezing and thawing is not applicable.
* @this {MapKeySet}
* @return {MapKeySet}
*/
MapKeySet.prototype.freeze = function() { return this; };

/**
* @ignore
* A MapKeySet is read-only, so the concept of freezing and thawing is not applicable.
* @this {MapKeySet}
* @return {MapKeySet}
*/
MapKeySet.prototype.thaw = function() { return this; };

/**
* @ignore
* @this {MapKeySet}
* @return {string}
* @override
*/
MapKeySet.prototype.toString = function() {
  return 'MapKeySet(' + this._map.toString() + ')';
};

MapKeySet.prototype['add'] =
/**
* @ignore
* A MapKeySet is read-only.
* @this {MapKeySet}
*/
MapKeySet.prototype.add = function(val) {
  Util.throwError('This Set is read-only: ' + this.toString());
  return false;
};

MapKeySet.prototype['contains'] =
/**
* @ignore
* Returns whether the given value is in this MapKeySet.
* @this {MapKeySet}
* @param {*} val The value to check.
* @return {boolean} Whether or not the value is contained within the MapKeySet.
*/
MapKeySet.prototype.contains = function(val) {
  return this._map.contains(val);
};

MapKeySet.prototype['remove'] =
/**
* @ignore
* A MapKeySet is read-only.
* @this {MapKeySet}
*/
MapKeySet.prototype.remove = function(key) {
  Util.throwError('This Set is read-only: ' + this.toString());
  return false;
};

MapKeySet.prototype['clear'] =
/**
* @ignore
* A MapKeySet is read-only.
* @this {MapKeySet}
*/
MapKeySet.prototype.clear = function() {
  Util.throwError('This Set is read-only: ' + this.toString());
};

/**
* @ignore
* This just creates another MapKeySet for the same {@link Map}.
* @this {MapKeySet}
*/
MapKeySet.prototype.copy = function() {
  return new MapKeySet(this._map);
};

MapKeySet.prototype['toSet'] =
/**
* @ignore
* Makes a shallow copy of this Set.
* The values are not copied,
* so if they are objects they may continue to be shared with the original MapKeySet.
* @this {MapKeySet}
* @return {Set} The new Set.
*/
MapKeySet.prototype.toSet = function() {
  var newset = new Set(this._map._type);
  var dict = this._map._dict;
  for (var a in dict) {
    newset.add(dict[a].key);
  }
  return newset;
};

MapKeySet.prototype['toArray'] =
/**
* @ignore
* Produces a JavaScript Array from the contents of this Set.
* @this {MapKeySet}
* @return {Array} A copy of the Set in Array form.
*/
MapKeySet.prototype.toArray = function() {
  var dict = this._map._dict;
  var newarr = new Array(this._map._count);
  var i = 0;
  for (var a in dict) {
    newarr[i] = (dict[a].key);
    i++;
  }
  return newarr;
};

MapKeySet.prototype['toList'] =
/**
* @ignore
* Converts the MapKeySet to a {@link List}.
* @this {MapKeySet}
* @return {List} A copy of the contents of this Set in List form.
*/
MapKeySet.prototype.toList = function() {
  var newlist = new List(this._type);
  var dict = this._map._dict;
  for (var a in dict) {
    newlist.add(dict[a].key);
  }
  return newlist;
};

/**
 * @ignore
 * Gets the number of elements in the MapKeySet.
 * @name MapKeySet#count
 * @function.
 * @return {number}
 */
/** @type {number} */
MapKeySet.prototype.count;
Util.defineReadOnlyProperty(MapKeySet, {count: 'count'},
  /** @this {MapKeySet} */
  function() { return this._map._count; }
);


/**
* @ignore
* Gets an object that you can use for iterating over the MapKeySet.
* The value will be a member of the MapKeySet.
* Typical usage:
* <pre>
*   var it = aSet.iterator;
*   while (it.next()) {
*     . . . " value: " + it.value . . .
*   }
* </pre>
* @name MapKeySet#iterator
* @function.
* @return {Iterator}
*/
///** @type {Iterator} */
//MapKeySet.prototype.iterator;  //?? commented out due to error upon load
Util.defineReadOnlyProperty(MapKeySet, {iterator: 'iterator'},
  /** @this {MapKeySet} */
  function() {
    if (this._map._count <= 0) return Util.EmptyIterator;
    return new MapKeySetIterator(this._map);
  }
);


//////////////////
// KeyValuePair //
//////////////////

/**
* @ignore
* @constructor
* @category Collection
* @class
*/
function KeyValuePair(k, v) {
  this.key = k;
  this.value = v;
  /** @type {KeyValuePair} */
  this._next = null;
  /** @type {KeyValuePair} */
  this._prev = null;
}

Util.defineDataProperties(KeyValuePair, { key: true, value: true });

/**
* @ignore
* @this {KeyValuePair}
* @return {string}
*/
KeyValuePair.prototype.toString = function() {
  return '{' + this.key + ':' + this.value + '}';
};

/**
 * @ignore
 * Gets a key for a value in a {@link Map}.
 * @name KeyValuePair#key
 * @function.
 * @return {*} the key uniquely identifying a {@link #value} in a {@link Map}.
 */
/** @type {*} */
KeyValuePair.prototype.key;

/**
 * @ignore
 * Gets a value in a {@link Map}.
 * @name KeyValuePair#value
 * @function.
 * @return {*} a value in a {@link Map} corresponding to a {@link #key}.
 */
/** @type {*} */
KeyValuePair.prototype.value;



/////////
// Map //
/////////

/**
* @ignore
* @constructor
* @implements {Iterator}
* @category Collection
* @class
*/
function MapIterator(m) {
  /** @type {Map} */
  this._map = m;
  this.reset();
}

Util.defineDataProperties(MapIterator, { key: true, value: true });

/**
 * @ignore
 * Gets the current key for a value in the map.
 * @name MapIterator#key
 * @function.
 * @return {*} if {@link #next} returned true, this is the iterator's current key in the map.
 */
/** @type {*} */
MapIterator.prototype.key;

/**
 * @ignore
 * Gets the current item in the map.
 * @name MapIterator#value
 * @function.
 * @return {*} if {@link #next} returned true, this is the iterator's current value in the map.
 */
/** @type {*} */
MapIterator.prototype.value;

/**
 * @ignore
 * Returns itself, which is convenient for code that expects an {@link Iterable}
 * instead of an {@link Iterator}.
 * @name MapIterator#iterator
 * @function.
 * @return {MapIterator} this.
 */
/** @type {Iterator} */
MapIterator.prototype.iterator;
Util.defineReadOnlyProperty(MapIterator, {iterator: 'iterator'},
  /** @this {MapIterator} */
  function() { return this; }
);

MapIterator.prototype['reset'] =
/**
* @ignore
* @this {MapIterator}
*/
MapIterator.prototype.reset = function() {
  var m = this._map;
  m._iterator = null;  // protect against recursion or multiple use
  /** @type {number} */
  this._state = m._changed;
  /** @type {KeyValuePair} */
  this._kvp = null;
};

MapIterator.prototype['next'] =
/**
* @ignore
* @this {MapIterator}
* @return {boolean}
*/
MapIterator.prototype.next = function() {
  var m = this._map;
  if (m._changed !== this._state) {
    Util.throwError('the Map has been modified during iteration');
  }
  var kvp = this._kvp;
  if (kvp === null) {
    kvp = m._first;
  } else {
    kvp = kvp._next;
  }
  if (kvp !== null) {
    this._kvp = kvp;
    this.key = kvp.key;
    this.value = kvp.value;
    return true;
  }
  this._dispose();
  return false;
};

MapIterator.prototype['first'] =
/**
* @ignore
* @this {MapIterator}
* @return {*}
*/
MapIterator.prototype.first = function() {
  var m = this._map;
  this._state = m._changed;
  var kvp = m._first;
  if (kvp !== null) {
    this._kvp = kvp;
    var key = kvp.key;
    this.key = key;
    this.value = kvp.value;
    return key;
  } else {
    return null;
  }
};

/**
* @ignore
* @name MapIterator#count
* @function.
* @return {number}
*/
/** @type {number} */
MapIterator.prototype.count;
Util.defineReadOnlyProperty(MapIterator, {count: 'count'},
  /** @this {MapIterator} */
  function() { return this._map._count; }
);

/**
* @ignore
* @this {MapIterator}
*/
MapIterator.prototype._dispose = function() {
  this.key = null;  // release any references
  this.value = null;
  this._state = -1;  // disallow continued use by next()
  this._map._iterator = this;  // return iterator for re-use
};

/**
* @ignore
* @this {MapIterator}
* @return {string}
*/
MapIterator.prototype.toString = function() {
  if (this._kvp !== null)
    return 'MapIterator@' + this._kvp;
  else
    return 'MapIterator';
};


/**
 * The two optional arguments to the constructor describe the types of keys
 * and the types of values that this Map may hold.
 * If the argument is null, it does not check the type.
 * If the argument is a string, it must be one of: 'number' or 'string' for the key type,
 * or 'number', 'string', 'boolean', or 'function' for the value type.
 * Otherwise the argument must be a class function/constructor, such as {@link GraphObject}.
 * <p/>
 * For example, the expression:
 * <pre>  new go.Map("string", go.Point)</pre>
 * produces a Map that has keys that must be strings and whose associated values
 * must be {@link Point}s.
 * @constructor
 * @implements {Iterable}
 * @param {function(...)|string|null=} keytype Optional class type (constructor) or a string, for the key
 * describing the primitive key type.
 * @param {function(...)|string|null=} valtype Optional class type (constructor) or a string, for the value
 * describing the primitive value type.
 * @category Collection
 * @class
 * An unordered iterable collection of key/value pairs that cannot contain two instances of the
 * same key.
 * It optionally enforces the type of the key and the type of the associated value.
 * <p/>
 * To create a Map:
 * <pre>
 *   var map = new go.Map("string", "number");
 *   map.add("one", 1);
 *   map.add("two", 2);
 *   map.add("three", 3);
 *   // now map.count === 3
 *   // and map.getValue("two") === 2
 *   // and map.contains("zero") === false
 * </pre>
 * <p/>
 * You can iterate over the key/value pairs in a Map:
 * <pre>
 *   var it = aMap.iterator;
 *   while (it.next()) {
 *     window.console.log(it.key + ": " + it.value);
 *   }
 * </pre>
 * But note that there is no guaranteed ordering amongst the key/value pairs.
 * <p/>
 * Call {@link #toKeySet} to get a read-only {@link Set} that holds all of the keys of a Map.
 * Iterating over that Set will produce values that are the keys in the Map.
 */
function Map(keytype, valtype) {
  Util.uniqueHash(this);
  /** @type {boolean} */
  this._isFrozen = false;
  if (keytype === undefined/*notpresent*/ || keytype === null) { // if no type specified
    /** @type {string|function()|null} */
    this._keytype = null;
  } else if (typeof keytype === 'string') { // if a primitive type
    if (keytype === 'object' || keytype === 'string' || keytype === 'number') {
      this._keytype = keytype;
    } else {
      Util.throwRangeError(keytype, 'the string \'object\', \'number\' or \'string\'', 'Map constructor: keytype');
    }
  } else if (typeof keytype === 'function') { // if an object
    if (keytype === Object) {
      this._keytype = 'object';
    } else if (keytype === String) {
      this._keytype = 'string';
    } else if (keytype === Number) {
      this._keytype = 'number';
    } else {
      this._keytype = keytype;
    }
  } else {
    Util.throwRangeError(keytype, 'null, a primitive type name, or a class type', 'Map constructor: keytype');
  }

  if (valtype === undefined/*notpresent*/ || valtype === null) { // if no type specified
    /** @type {string|function()|null} */
    this._valtype = null;
  } else if (typeof valtype === 'string') { // if a primitive type
    if (valtype === 'object' || valtype === 'string' || valtype === 'boolean' || valtype === 'number' || valtype === 'function') {
      this._valtype = valtype;
    } else {
      Util.throwRangeError(valtype, 'the string \'object\', \'number\', \'string\', \'boolean\', or \'function\'', 'Map constructor: valtype');
    }
  } else if (typeof valtype === 'function') { // if an object
    if (valtype === Object) {
      this._valtype = 'object';
    } else if (valtype === String) {
      this._valtype = 'string';
    } else if (valtype === Number) {
      this._valtype = 'number';
    } else if (valtype === Boolean) {
      this._valtype = 'boolean';
    } else if (valtype === Function) {
      this._valtype = 'function';
    } else {
      this._valtype = valtype;
    }
  } else {
    Util.throwRangeError(valtype, 'null, a primitive type name, or a class type', 'Map constructor: valtype');
  }

  this._dict = {};
  /** @type {number} */
  this._count = 0;
  /** @type {MapIterator} */
  this._iterator = null;
  /** @type {number} */
  this._changed = 0;
  /** @type {KeyValuePair} */
  this._first = null;
  /** @type {KeyValuePair} */
  this._last = null;
}

Util.publish('Map', Map);

/**
* @ignore
* @this {Map}
*/
Map.prototype._checkCollectionKeyType = function(key) {
  if (this._keytype === null) return;
  if (typeof this._keytype === 'string') {
    if (typeof key !== this._keytype || key === null) {
      Util.throwTypeError(key, this._keytype);
    }
  } else {
    if (!(key instanceof this._keytype)) {
      Util.throwTypeError(key, this._keytype);
    }
  }
};

/**
* @ignore
* @this {Map}
*/
Map.prototype._checkCollectionValType = function(val) {
  if (this._valtype === null) return;
  if (typeof this._valtype === 'string') {
    if (typeof val !== this._valtype || val === null) {
      Util.throwTypeError(val, this._valtype);
    }
  } else {
    if (!(val instanceof this._valtype)) {
      Util.throwTypeError(val, this._valtype);
    }
  }
};

/**
* @ignore
* @this {Map}
*/
Map.prototype._modify = function() {
  var c = this._changed;
  c++;
  if (c > 999999999) c = 0;
  this._changed = c;
};

Map.prototype['freeze'] =
/**
* @ignore
* Make this Map 'frozen' or immutable.
* Future attempts to change its state,
* for example by adding a key/value pair or modifying the value of an existing key,
* may result in an exception.
* @this {Map}
* @return {Map}
*/
Map.prototype.freeze = function() {
  this._isFrozen = true;
  return this;
};

Map.prototype['thaw'] =
/**
* @ignore
* Make this object 'thawed' or mutable.
* @this {Map}
* @return {Map}
*/
Map.prototype.thaw = function() {
  this._isFrozen = false;
  return this;
};

/**
* @ignore
* @this {Map}
* @return {string}
*/
Map.prototype.toString = function() {
  return 'Map(' + Util.getTypeName(this._keytype) + ',' + Util.getTypeName(this._valtype) + ')#' + Util.hashId(this);
};

Map.prototype['add'] =
/**
* Adds a key-value association to the Map, or replaces the value associated with the key
* if the key was already present in the map.
* @this {Map}
* @param {*} key The key or index for storing the value in the Map.
* @param {*} val The value to add to the Map, associated with the key.
* @return {boolean} true if the key was not already present in the Map; false if it was.
*/
Map.prototype.add = function(key, val) {
  if (Debug) {
    this._checkCollectionKeyType(key);
    this._checkCollectionValType(val);
  }
  Util.checkFrozen(this, key);
  var realkey = key;
  if (Util.isObject(key)) {
    realkey = Util.hashIdUnique(key);
  }
  var kvp = this._dict[realkey];
  if (kvp === undefined/*notpresent*/) {  // not found
    this._count++;
    var newkvp = new KeyValuePair(key, val);
    this._dict[realkey] = newkvp;
    var last = this._last;
    if (last === null) {
      this._first = newkvp;
      this._last = newkvp;
    } else {
      newkvp._prev = last;
      last._next = newkvp;
      this._last = newkvp;
    }
    this._modify();
    return true;
  } else {
    //?? don't _modify() when replacing value for existing key
    kvp.value = val;
    return false;
  }
};

Map.prototype['addAll'] =
/**
* Adds all of the key-value pairs of another Map to this Map.
* If a key is already present in this Map,
* its value is replaced with the corresponding value from the given map.
* @this {Map}
* @param {Map} map the collection of keys/values to add.
* @return {Map} this map.
*/
Map.prototype.addAll = function(map) {
  if (map === null) return this;
  if (Debug) Util.checkClass(map, Map, Map, 'addAll:map');
  var it = map.iterator;
  while (it.next()) {
    this.add(it.key, it.value);
  }
  return this;
};

Map.prototype['contains'] =
/**
* Returns whether the given key is in this Map.
* @this {Map}
* @param {*} key The key to look up in the Map.
* @return {boolean} Whether or not the key is contained within the Map.
*/
Map.prototype.contains = function(key) {
  if (Debug) this._checkCollectionKeyType(key);
  var realkey = key;
  if (Util.isObject(key)) {
    realkey = Util.hashId(key);
    if (realkey === undefined) return false;
  }
  var kvp = this._dict[realkey];
  return (kvp !== undefined/*notpresent*/);
};

Map.prototype['getValue'] =
/**
 * Returns the value associated with a key.
 * @this {Map}
 * @param {*} key The key to look up in the Map.
 * @return {?} The value associated with the given key, or null if not present in the Map.
 */
Map.prototype.getValue = function(key) {
  if (Debug) this._checkCollectionKeyType(key);
  var realkey = key;
  if (Util.isObject(key)) {
    realkey = Util.hashId(key);
    if (realkey === undefined) return null;
  }
  var kvp = this._dict[realkey];
  if (kvp === undefined/*notpresent*/) return null;
  return kvp.value;
};

Map.prototype['remove'] =
/**
* Removes a key (if found) from the Map.
* @this {Map}
* @param {*} key The key to insert.
* @return {boolean} true if the key was found and removed, false otherwise.
*/
Map.prototype.remove = function(key) {
  if (key === null) return false;
  if (Debug) this._checkCollectionKeyType(key);
  Util.checkFrozen(this, key);
  var realkey = key;
  if (Util.isObject(key)) {
    realkey = Util.hashId(key);
    if (realkey === undefined) return false;
  }
  var kvp = this._dict[realkey];
  if (kvp === undefined/*notpresent*/) {  // not found
    return false;
  } else {
    var next = kvp._next;
    var prev = kvp._prev;
    if (next !== null) next._prev = prev;
    if (prev !== null) prev._next = next;
    if (this._first === kvp) this._first = next;
    if (this._last === kvp) this._last = prev;
    delete this._dict[realkey];
    this._count--;
    this._modify();
    return true;
  }
};

Map.prototype['clear'] =
/**
* Clears the Map, removing all key-value associations.
* This sets the {@link #count} to zero.
* @this {Map}
*/
Map.prototype.clear = function() {
  Util.checkFrozen(this);
  this._dict = {};
  this._count = 0;
  this._first = null;
  this._last = null;
  this._modify();
};

/**
* Makes a shallow copy of this Map.
* The keys and their values are not copied,
* so if they are objects they may continue to be shared with the original Map.
* @expose
* @this {Map}
* @return {Map} The new Map.
*/
Map.prototype.copy = function() {
  var newmap = new Map(this._keytype, this._valtype);
  var dict = this._dict;
  for (var rk in dict) {
    var kvp = dict[rk];
    newmap.add(kvp.key, kvp.value);
  }
  return newmap;
};

Map.prototype['toArray'] =
/**
* Produces a JavaScript Array of key/value pair objects from the contents of this Map.
* @this {Map}
* @return {Array} A copy of the Map in Array form,
* each element being an Object with 'key' and 'value' properties.
*/
Map.prototype.toArray = function() {
  var dict = this._dict;
  var newarr = new Array(this._count);
  var i = 0;
  for (var rk in dict) {
    var kvp = dict[rk];
    newarr[i] = (new KeyValuePair(kvp.key, kvp.value));
    i++;
  }
  return newarr;
};

Map.prototype['toKeySet'] =
/**
* Produces a {@link Set} that provides a read-only view onto the keys of this Map.
* The collection of keys is not copied.
* @this {Map}
* @return {Set}
*/
Map.prototype.toKeySet = function() {
  return new MapKeySet(this);
};

/**
 * Gets the number of associations in the Map.
 * @name Map#count
 * @function.
 * @return {number}
 */
/** @type {number} */
Map.prototype.count;
Util.defineReadOnlyProperty(Map, {count: 'count'},
  /** @this {Map} */
  function() { return this._count; }
);

/**
* Gets an object that you can use for iterating over the Map.
* Typical usage:
* <pre>
*   var it = aMap.iterator;
*   while (it.next()) {
*     window.console.log("the key: " + it.key + " has value: " + it.value);
*   }
* </pre>
* @name Map#iterator
* @function.
* @return {Iterator}
*/
/** @type {Iterator} */
Map.prototype.iterator;
Util.defineReadOnlyProperty(Map, {iterator: 'iterator'},
  /** @this {Map} */
  function() {
    if (this.count <= 0) return Util.EmptyIterator;
    var it = this._iterator;
    if (it !== null) {  // reuse a single instance of an iterator, assuming single-threaded
      it.reset();
      return it;
    }
    return new MapIterator(this);
  }
);

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
Point
Size
Rect
Margin
Transform (internal)
*/


/**
 * The default constructor produces the Point(0,0).
 * @constructor
 * @param {number=} x The x value.
 * @param {number=} y The y value.
 * @category Geometry
 * @class
 * A Point represents an x- and y-coordinate pair in two-dimensional space.
 */
function Point(x, y) {
  if (x === undefined/*notpresent*/) {
    /** @type {number} */
    this._x = 0;
    /** @type {number} */
    this._y = 0;
  } else if (typeof x === 'number' && typeof y === 'number') {
    this._x = x;
    this._y = y;
  } else {
    Util.throwError('Invalid arguments to Point constructor');
  }
}

Util.publish('Point', Point);

/**
* @ignore
* Replace the properties of this Point with those of another Point.
* This can modify a frozen object.
* @this {Point}
* @param {Point} p the other Point from which to copy property values.
*/
Point.prototype.assign = function(p) {
  this._x = p._x;
  this._y = p._y;
};

/**
* @ignore
* Replace the properties of this Point with given values.
* This can modify a frozen object.
* @this {Point}
* @param {number} x
* @param {number} y
*/
Point.prototype._set = function(x, y) {
  this._x = x;
  this._y = y;
};

Point.prototype['setTo'] =
/**
* Modify this Point with new X and Y values.
* @this {Point}
* @param {number} x
* @param {number} y
* @return {Point} this.
*/
Point.prototype.setTo = function(x, y) {
  if (Debug) {
    Util.checkPrimitive(x, 'number', Point, 'setTo:x');
    Util.checkPrimitive(y, 'number', Point, 'setTo:y');
  }
  Util.checkFrozen(this);
  this._x = x;
  this._y = y;
  return this;
};

Point.prototype['set'] =
/**
* Modify this Point so that its X and Y values are the same as the given Point.
* @this {Point}
* @param {Point} p the given Point.
* @return {Point} this.
*/
Point.prototype.set = function(p) {
  if (Debug) Util.checkClass(p, Point, Point, 'set:p');
  Util.checkFrozen(this);
  this._x = p._x;
  this._y = p._y;
  return this;
};

/**
* Create a copy of this Point, with the same values.
* @expose
* @this {Point}
* @return {Point}
*/
Point.prototype.copy = function() {
  var copy = new Point();
  copy._x = this._x;
  copy._y = this._y;
  return copy;
};

/**
* @ignore
* Make this object 'constant' and 'frozen'.
* Future attempts to change its state may result in an exception.
* This constant object may be shared freely.
* @this {Point}
* @return {Point} this.
*/
Point.prototype.constant = function() {
  this._isFrozen = true;
  Object.freeze(this);
  return this;
};

/**
* @ignore
* If this object is 'constant', just return it.
* Otherwise make a copy of this object and freeze it ({@link #frozen}).
* @this {Point}
* @return {Point}
*/
Point.prototype.copyFrozen = function() {
  if (Object.isFrozen(this)) return this;
  return this.copy().freeze();
};

/**
* @ignore
* Make this object 'frozen' or immutable.
* Future attempts to change its state, for example by setting any of its properties,
* may result in an exception, until it is thaw()'ed.
* @this {Point}
* @return {Point} this.
*/
Point.prototype.freeze = function() {
  this._isFrozen = true;
  return this;
};

/**
* @ignore
* Make this object 'thawed' or mutable.
* @this {Point}
* @return {Point} this.
*/
Point.prototype.thaw = function() {
  if (Object.isFrozen(this)) Util.throwError('cannot thaw constant: ' + this);
  this._isFrozen = false;
  return this;
};


Point['parse'] =
/**
* This static method can be used to read in a {@link Point} from a string that was produced by {@link Point.stringify}.
* @param {string} str
* @return {Point}
*/
Point.parse = function(str) {
  if (typeof str === 'string') {
    var split = str.split(' ');
    var i = 0;
    var x = 0;
    while (split[i] === '') i++;
    var s = split[i++];
    if (s) x = parseFloat(s);
    var y = 0;
    while (split[i] === '') i++;
    s = split[i++];
    if (s) y = parseFloat(s);
    return new Point(x, y);
  } else {
    return new Point();
  }
};

Point['stringify'] =
/**
* This static method can be used to write out a {@link Point} as a string that can be read by {@link Point.parse}.
* @param {Point} val
* @return {string}
*/
Point.stringify = function(val) {
  if (val instanceof Point) {
    return val.x.toString() + ' ' + val.y.toString();
  } else {
    return val.toString();
  }
};


/**
* @ignore
* @this {Point}
* @return {string} A string containing this Point's information.
*/
Point.prototype.toString = function() {
  return 'Point(' + this.x + ',' + this.y + ')';
};

Point.prototype['equals'] =
/**
* Indicates whether the given Point is equal to this Point.
* @this {Point}
* @param {Point} p The Point to compare to the current Point.
* @return {boolean} True if the two Points have identical X and Y values,
* false otherwise.
* @see #equalTo
*/
Point.prototype.equals = function(p) {
  if (!(p instanceof Point)) return false;
  return (this._x === p.x && this._y === p.y);
};

Point.prototype['equalTo'] =
/**
* Indicates whether the given point (x, y) is equal to this Point.
* @this {Point}
* @param {number} x
* @param {number} y
* @return {boolean} True if the two Points have identical X and Y values,
* false otherwise.
* @see #equals
*/
Point.prototype.equalTo = function(x, y) {
  return (this._x === x && this._y === y);
};

/**
* @ignore
* Indicates whether the given Point is approximately equal to this Point.
* @this {Point}
* @param {Point} p The Point to compare to the current Point.
* @return {boolean} True if the two Points have near identical X and Y
* values, false otherwise.
*/
Point.prototype.equalsApprox = function(p) {
  return Geo.isApproxEqual(this._x, p.x) &&
         Geo.isApproxEqual(this._y, p.y);
};

/**
* @ignore
* Indicates whether the given Point is nearly equal to this Point.
* @this {Point}
* @param {Point} p The Point to compare to the current Point.
* @return {boolean} True if the two Points have X and Y values that
* are equal with a tolerance of 0.5, false otherwise.
*/
Point.prototype.equalsAbout = function(p) {
  return Geo.isApprox(this._x, p.x) &&
         Geo.isApprox(this._y, p.y);
};

Point.prototype['add'] =
/**
* Modify this point so that is the sum of the current Point and the
* x and y co-ordinates of the given Point.
* @this {Point}
* @param {Point} p The Point to add to this Point.
* @return {Point} this.
* @see #offset
* @see #subtract
*/
Point.prototype.add = function(p) {
  if (Debug) Util.checkClass(p, Point, Point, 'add:p');
  Util.checkFrozen(this);
  this._x += p.x;
  this._y += p.y;
  return this;
};

Point.prototype['subtract'] =
/**
* Modify this point so that is the difference of this Point and the
* x and y co-ordinates of the given Point.
* @this {Point}
* @param {Point} p The Point to subtract from the current Point.
* @return {Point} this.
* @see #offset
* @see #add
*/
Point.prototype.subtract = function(p) {
  if (Debug) Util.checkClass(p, Point, Point, 'subtract:p');
  Util.checkFrozen(this);
  this._x -= p.x;
  this._y -= p.y;
  return this;
};

Point.prototype['offset'] =
/**
* Modify this point by shifting its values with the given DX and DY offsets.
* @this {Point}
* @param {number} dx
* @param {number} dy
* @return {Point} this.
* @see #add
* @see #subtract
*/
Point.prototype.offset = function(dx, dy) {
  if (Debug) {
    Util.checkRealNumber(dx, Point, 'offset:dx');
    Util.checkRealNumber(dy, Point, 'offset:dy');
  }
  Util.checkFrozen(this);
  this._x += dx;
  this._y += dy;
  return this;
};

Point.prototype['rotate'] =
/**
* Modify this Point so that has been rotated about the origin by the given angle.
* @this {Point}
* @param {number} angle an angle in degrees.
* @return {Point} this.
*/
Point.prototype.rotate = function(angle) {
  if (Debug) Util.checkRealNumber(angle, Point, 'rotate:angle');
  Util.checkFrozen(this);
  if (angle === 0) return this;
  var px = this._x;
  var py = this._y;
  if (px === 0 && py === 0) return this;
  var rad = angle * Math.PI / 180;
  var cosine = Math.cos(rad);
  var sine = Math.sin(rad);
  this._x = cosine * px - sine * py;
  this._y = sine * px + cosine * py;
  return this;
};

Point.prototype['scale'] =
/**
* Modify this Point so that its X and Y values have been scaled by given factors along the X and Y axes.
* @this {Point}
* @param {number} sx
* @param {number} sy
* @return {Point} this.
*/
Point.prototype.scale = function(sx, sy) {
  if (Debug) {
    Util.checkRealNumber(sx, Point, 'scale:sx');
    Util.checkRealNumber(sy, Point, 'scale:sy');
  }
  this._x *= sx;
  this._y *= sy;
  return this;
};

Point.prototype['distanceSquaredPoint'] =
/**
* Returns the square of the distance from this Point to a given Point.
* @this {Point}
* @param {Point} p the other Point to measure to.
* @return {number} the square of the euclidean distance.
* @see #distanceSquared
*/
Point.prototype.distanceSquaredPoint = function(p) {
  if (Debug) Util.checkClass(p, Point, Point, 'distanceSquaredPoint:p');
  var dx = p.x - this._x;
  var dy = p.y - this._y;
  return dx * dx + dy * dy;
};

Point.prototype['distanceSquared'] =
/**
* Returns the square of the distance from this point to a given point (px, py).
* @this {Point}
* @param {number} px
* @param {number} py
* @return {number} the square of the euclidean distance.
* @see #distanceSquaredPoint
*/
Point.prototype.distanceSquared = function(px, py) {
  if (Debug) {
    Util.checkRealNumber(px, Point, 'distanceSquared:px');
    Util.checkRealNumber(py, Point, 'distanceSquared:py');
  }
  var dx = px - this._x;
  var dy = py - this._y;
  return dx * dx + dy * dy;
};

Point.prototype['normalize'] =
/**
* Modify this Point so that its X and Y values have been normalized to a unit length.
* However, if this Point is the origin (zero, zero), its length remains zero.
* @this {Point}
* @return {Point} this.
*/
Point.prototype.normalize = function() {
  Util.checkFrozen(this);
  var px = this._x;
  var py = this._y;
  var len = Math.sqrt(px * px + py * py);
  if (len > 0) {
    this._x = px / len;
    this._y = py / len;
  }
  return this;
};

Point.prototype['directionPoint'] =
/**
* Compute the angle from this Point to a given Point.
* However, if the given Point is the same as this Point, the direction is zero.
* @this {Point}
* @param {Point} p the other Point to which to measure the relative angle.
* @return {number} the angle, in degrees, of the line from this Point to the given point.
* @see #direction
*/
Point.prototype.directionPoint = function(p) {
  if (Debug) Util.checkClass(p, Point, Point, 'directionPoint:p');
  return this._angleOf(p.x - this._x, p.y - this._y);
};

Point.prototype['direction'] =
/**
* Compute the angle from this Point to a given (px,py) point.
* However, if the point is the same as this Point, the direction is zero.
* @this {Point}
* @param {number} px
* @param {number} py
* @return {number} the angle, in degrees, of the line from this Point to the given point.
* @see #directionPoint
*/
Point.prototype.direction = function(px, py) {
  if (Debug) {
    Util.checkRealNumber(px, Point, 'direction:px');
    Util.checkRealNumber(py, Point, 'direction:py');
  }
  return this._angleOf(px - this._x, py - this._y);
};

/**
* @ignore
* @this {Point}
* @param {number} x
* @param {number} y
* @return {number}
*/
Point.prototype._angleOf = function(x, y) {
  if (x === 0) {
    if (y > 0)
      return 90;
    else if (y < 0)
      return 270;
    else
      return 0;
  } else if (y === 0) {
    if (x > 0)
      return 0;
    else  // x < 0
      return 180;
  } else {
    if (isNaN(x) || isNaN(y)) return 0;
    var a = Math.atan(Math.abs(y / x)) * 180 / Math.PI;
    if (x < 0) {
      if (y < 0)
        a += 180;
      else
        a = 180 - a;
    } else if (y < 0) {
      a = 360 - a;
    }
    return a;
  }
};

Point.prototype['setRectSpot'] =
/**
* Modify this Point so that its X and Y values correspond to a particular {@link Spot}
* in a given Rect.
* <p/>
* The result is meaningless if {@link Spot#isNoSpot} is true for the given Spot.
* @this {Point}
* @param {Rect} r the Rect for which we are finding the point.
* @param {Spot} spot the Spot; {@link Spot#isSpot} must be true for this Spot.
* @return {Point} this.
* @see #setSpot
*/
Point.prototype.setRectSpot = function(r, spot) {
  if (Debug) {
    Util.checkClass(r, Rect, Point, 'setRectSpot:r');
    Util.checkClass(spot, Spot, Point, 'setRectSpot:spot');
  }
  Util.checkFrozen(this);
  this._x = r.x + spot.x * r.width + spot.offsetX;
  this._y = r.y + spot.y * r.height + spot.offsetY;
  return this;
};

Point.prototype['setSpot'] =
/**
* Modify this Point so that its X and Y values correspond to a particular {@link Spot}
* in a given rectangle.
* <p/>
* The result is meaningless if {@link Spot#isNoSpot} is true for the given Spot.
* @this {Point}
* @param {number} x The X coordinate of the Rect for which we are finding the point.
* @param {number} y The Y coordinate of the Rect for which we are finding the point.
* @param {number} w The Width of the Rect for which we are finding the point.
* @param {number} h The Height of the Rect for which we are finding the point.
* @param {Spot} spot the Spot; {@link Spot#isSpot} must be true for this Spot.
* @return {Point} this the point of the spot in the rectangle.
* @see #setRectSpot
*/
Point.prototype.setSpot = function(x, y, w, h, spot) {
  if (Debug) {
    Util.checkRealNumber(x, Point, 'setSpot:x');
    Util.checkRealNumber(y, Point, 'setSpot:y');
    Util.checkRealNumber(w, Point, 'setSpot:w');
    Util.checkRealNumber(h, Point, 'setSpot:h');
    if (w < 0 || h < 0) {
      Util.throwError('Point.setSpot:Width and height cannot be negative');
    }
    Util.checkClass(spot, Spot, Point, 'setSpot:spot');
  }
  Util.checkFrozen(this);
  this._x = x + spot.x * w + spot.offsetX;
  this._y = y + spot.y * h + spot.offsetY;
  return this;
};

/**
* @ignore
* Modify this Point so that its X and Y values have been multiplied with the given Transform.
* @this {Point}
* @param {Transform} t the given Transform.
* @return {Point} this transformed Point.
*/
Point.prototype.transform = function(t) {
  if (Debug) Util.checkClass(t, Transform, Point, 'transform:t');
  t.transformPoint(this);
  return this;
};

/**
* @ignore
* Modify this Point so that its X and Y values have been multiplied
* with the inverse of the given Transform.
* @this {Point}
* @param {Transform} t the given Transform, which is not modified.
* @return {Point} this transformed Point.
*/
Point.prototype.transformInverted = function(t) {
  if (Debug) Util.checkClass(t, Transform, Point, 'transformInverted:t');
  t.invertedTransformPoint(this);
  return this;
};


Point['distanceLineSegmentSquared'] =
/**
* This static method returns the square of the distance from the point P
* to the finite line segment from point A to point B.
* @param {number} px
* @param {number} py
* @param {number} ax
* @param {number} ay
* @param {number} bx
* @param {number} by
* @return {number} the euclidean distance.
*/
Point.distanceLineSegmentSquared = function(px, py, ax, ay, bx, by) {
  if (Debug) {
    Util.checkRealNumber(px, Point, 'distanceLineSegmentSquared:px');
    Util.checkRealNumber(py, Point, 'distanceLineSegmentSquared:py');
    Util.checkRealNumber(ax, Point, 'distanceLineSegmentSquared:ax');
    Util.checkRealNumber(ay, Point, 'distanceLineSegmentSquared:ay');
    Util.checkRealNumber(bx, Point, 'distanceLineSegmentSquared:bx');
    Util.checkRealNumber(by, Point, 'distanceLineSegmentSquared:by');
  }
  var ux = bx - ax;
  var uy = by - ay;
  var length = ux * ux + uy * uy;
  var vx = ax - px;
  var vy = ay - py;
  var dot = - vx * ux - vy * uy;
  if (dot <= 0 || dot >= length) {  // beyond the segment
    ux = bx - px;
    uy = by - py;
    return Math.min(vx * vx + vy * vy, ux * ux + uy * uy);
  } else {
    var det = ux * vy - uy * vx;
    return (det * det) / length;
  }
};


Point['distanceSquared'] =
/**
* This static method returns the square of the distance from the point P to the point Q.
* @param {number} px
* @param {number} py
* @param {number} qx
* @param {number} qy
* @return {number}
*/
Point.distanceSquared = function(px, py, qx, qy) {
  if (Debug) {
    Util.checkRealNumber(px, Point, 'distanceSquared:px');
    Util.checkRealNumber(py, Point, 'distanceSquared:py');
    Util.checkRealNumber(qx, Point, 'distanceSquared:qx');
    Util.checkRealNumber(qy, Point, 'distanceSquared:qy');
  }
  /** @type {number} */
  var dx = qx - px;
  /** @type {number} */
  var dy = qy - py;
  return dx * dx + dy * dy;
};


Point['direction'] =
/**
* This static method returns the angle in degrees of the line from point P to point Q.
* @param {number} px
* @param {number} py
* @param {number} qx
* @param {number} qy
* @return {number}
*/
Point.direction = function(px, py, qx, qy) {
  if (Debug) {
    Util.checkRealNumber(px, Point, 'direction:px');
    Util.checkRealNumber(py, Point, 'direction:py');
    Util.checkRealNumber(qx, Point, 'direction:qx');
    Util.checkRealNumber(qy, Point, 'direction:qy');
  }
  /** @type {number} */
  var x = qx - px;
  /** @type {number} */
  var y = qy - py;
  if (x === 0) {
    if (y > 0)
      return 90;
    else if (y < 0)
      return 270;
    else
      return 0;
  } else if (y === 0) {
    if (x > 0)
      return 0;
    else  // x < 0
      return 180;
  } else {
    if (isNaN(x) || isNaN(y)) return 0;
    var a = Math.atan(Math.abs(y / x)) * 180 / Math.PI;
    if (x < 0) {
      if (y < 0)
        a += 180;
      else
        a = 180 - a;
    } else if (y < 0) {
      a = 360 - a;
    }
    return a;
  }
};

/**
 * Gets or sets the x value of the Point.
 * @name Point#x
 * @function.
 * @return {number}
 */
/** @type {number} */
Point.prototype.x;
Util.exportProperty(Point, 'x', Point.prototype.x);
Util.defineProperty(Point, {x: 'x'},
  /** @this {Point} */
  function() { return this._x; },
  /** @this {Point} */
  function(val) {
    Util.checkFrozen(this, val);
    if (Debug) Util.checkPrimitive(val, 'number', Point, 'x');
    this._x = val;
  }
);

/**
 * Gets or sets the y value of the Point.
 * @name Point#y
 * @function.
 * @return {number}
 */
/** @type {number} */
Point.prototype.y;
Util.exportProperty(Point, 'y', Point.prototype.y);
Util.defineProperty(Point, {y: 'y'},
  /** @this {Point} */
  function() { return this._y; },
  /** @this {Point} */
  function(val) {
    Util.checkFrozen(this, val);
    if (Debug) Util.checkPrimitive(val, 'number', Point, 'y');
    this._y = val;
  }
);

Point.prototype['isReal'] =
/**
* True if this Point has X and Y values that are real numbers and not infinity.
* @this {Point}
* @return {boolean}
*/
Point.prototype.isReal = function() {
  return isFinite(this.x) && isFinite(this.y);
};


/**
 * The default constructor produces the Size(0,0).
 * @constructor
 * @param {number=} w The initial width (must be non-negative).
 * @param {number=} h The initial height (must be non-negative).
 * @category Geometry
 * @class
 * A Size describes a width and a height in two-dimensional coordinates.
 * The width and height must both be non-negative.
 */
function Size(w, h) {
  if (w === undefined/*notpresent*/) {
    /** @type {number} */
    this._width = 0;
    /** @type {number} */
    this._height = 0;
  } else if (typeof w === 'number' && (w >= 0 || isNaN(w)) &&
             typeof h === 'number' && (h >= 0 || isNaN(h))) {
    this._width = w;
    this._height = h;
  } else {
    Util.throwError('Invalid arguments to Size constructor');
  }
}

Util.publish('Size', Size);

/**
* @ignore
* Replace the properties of this Size with those of another Size.
* This can modify a frozen object.
* @this {Size}
* @param {Size} s the other Size from which to copy property values.
*/
Size.prototype.assign = function(s) {
  this._width = s._width;
  this._height = s._height;
};

/**
* @ignore
* Replace the properties of this Size with given values.
* This can modify a frozen object.
* @this {Size}
* @param {number} w
* @param {number} h
*/
Size.prototype._set = function(w, h) {
  this._width = w;
  this._height = h;
};

Size.prototype['setTo'] =
/**
* Modify this Size with new Width and Height values.
* @this {Size}
* @param {number} w the width.
* @param {number} h the height.
* @return {Size} this.
*/
Size.prototype.setTo = function(w, h) {
  if (Debug) {
    Util.checkPrimitive(w, 'number', Size, 'setTo:w');
    Util.checkPrimitive(h, 'number', Size, 'setTo:h');
  }
  if (w < 0) Util.throwRangeError(w, '>= 0', Size, 'setTo:w');
  if (h < 0) Util.throwRangeError(h, '>= 0', Size, 'setTo:h');
  Util.checkFrozen(this);
  this._width = w;
  this._height = h;
  return this;
};

Size.prototype['set'] =
/**
* Modify this Size so that its Width and Height values are the same as the given Size.
* @this {Size}
* @param {Size} s the given Size.
* @return {Size} this.
*/
Size.prototype.set = function(s) {
  if (Debug) Util.checkClass(s, Size, Size, 'set:s');
  Util.checkFrozen(this);
  this._width = s._width;
  this._height = s._height;
  return this;
};

/**
* Create a copy of this Size, with the same values.
* @expose
* @this {Size}
* @return {Size}
*/
Size.prototype.copy = function() {
  var copy = new Size();
  copy._width = this._width;
  copy._height = this._height;
  return copy;
};

/**
* @ignore
* Make this object 'constant' and 'frozen'.
* Future attempts to change its state may result in an exception.
* This constant object may be shared freely.
* @this {Size}
* @return {Size}
*/
Size.prototype.constant = function() {
  this._isFrozen = true;
  Object.freeze(this);
  return this;
};

/**
* @ignore
* If this object is 'constant', just return it.
* Otherwise make a copy of this object and freeze it ({@link #frozen}).
* @this {Size}
* @return {Size}
*/
Size.prototype.copyFrozen = function() {
  if (Object.isFrozen(this)) return this;
  return this.copy().freeze();
};

/**
* @ignore
* Make this object 'frozen' or immutable.
* Future attempts to change its state, for example by setting any of its properties,
* may result in an exception, until it is thaw()'ed.
* @this {Size}
* @return {Size}
*/
Size.prototype.freeze = function() {
  this._isFrozen = true;
  return this;
};

/**
* @ignore
* Make this object 'thawed' or mutable.
* @this {Size}
* @return {Size}
*/
Size.prototype.thaw = function() {
  if (Object.isFrozen(this)) Util.throwError('cannot thaw constant: ' + this);
  this._isFrozen = false;
  return this;
};


Size['parse'] =
/**
* This static method can be used to read in a {@link Size} from a string that was produced by {@link Size.stringify}.
* @param {string} str
* @return {Size}
*/
Size.parse = function(str) {
  if (typeof str === 'string') {
    var split = str.split(' ');
    var i = 0;
    var w = 0;
    while (split[i] === '') i++;
    var s = split[i++];
    if (s) w = parseFloat(s);
    var h = 0;
    while (split[i] === '') i++;
    s = split[i++];
    if (s) h = parseFloat(s);
    return new Size(w, h);
  } else {
    return new Size();
  }
};

Size['stringify'] =
/**
* This static method can be used to write out a {@link Size} as a string that can be read by {@link Size.parse}.
* @param {Size} val
* @return {string}
*/
Size.stringify = function(val) {
  if (val instanceof Size) {
    return val.width.toString() + ' ' + val.height.toString();
  } else {
    return val.toString();
  }
};


/**
* @ignore
* @this {Size}
* @return {string} A string containing this Size's information.
*/
Size.prototype.toString = function() {
  return 'Size(' + this.width + ',' + this.height + ')';
};

Size.prototype['equals'] =
/**
 * Indicates whether the given Size is equal to the current Size.
 * @this {Size}
 * @param {Size} s The Size to compare to the current Size.
 * @return {boolean} True if the Sizes have the same width and height,
 * false otherwise.
* @see #equalTo
 */
Size.prototype.equals = function(s) {
  if (!(s instanceof Size)) return false;
  return (this._width === s.width && this._height === s.height);
};

Size.prototype['equalTo'] =
/**
 * Indicates whether the given size is equal to this Size.
 * @this {Size}
 * @param {number} w the width.
 * @param {number} h the height.
 * @return {boolean} True if the Sizes have the same width and height,
 * false otherwise.
 * @see #equals
 */
Size.prototype.equalTo = function(w, h) {
  return (this._width === w && this._height === h);
};

/**
* @ignore
* Indicates whether the given Size is approximately equal to this Size.
* @this {Size}
* @param {Size} s The Size to compare to the current Size.
* @return {boolean} True if the two Sizes have near identical Width and Height
* values, false otherwise.
*/
Size.prototype.equalsApprox = function(s) {
  return Geo.isApproxEqual(this._width, s.width) &&
         Geo.isApproxEqual(this._height, s.height);
};

/**
* @ignore
* Indicates whether the given Size is nearly equal to this Size.
* @this {Size}
* @param {Size} s The Size to compare to the current Size.
* @return {boolean} True if the two Sizes have Width and Height values that
* are equal with a tolerance of 0.5, false otherwise.
*/
Size.prototype.equalsAbout = function(s) {
  return Geo.isApprox(this._width, s.width) &&
         Geo.isApprox(this._height, s.height);
};

/**
 * Gets or sets the width value of the Size.
 * The value must not be negative.
 * @name Size#width
 * @function.
 * @return {number}
 */
/** @type {number} */
Size.prototype.width;
Util.exportProperty(Size, 'width', Size.prototype.width);
Util.defineProperty(Size, {width: 'width'},
  /** @this {Size} */
  function() { return this._width; },
  /** @this {Size} */
  function(val) {
    Util.checkFrozen(this, val);
    if (Debug) Util.checkPrimitive(val, 'number', Size, 'width');
    if (val < 0) Util.throwRangeError(val, '>= 0', Size, 'width');
    this._width = val;
  }
);

/**
 * Gets or sets the height value of the Size.
 * The value must not be negative.
 * @name Size#height
 * @function.
 * @return {number}
 */
/** @type {number} */
Size.prototype.height;
Util.exportProperty(Size, 'height', Size.prototype.height);
Util.defineProperty(Size, {height: 'height'},
  /** @this {Size} */
  function() { return this._height; },
  /** @this {Size} */
  function(val) {
    Util.checkFrozen(this, val);
    if (Debug) Util.checkPrimitive(val, 'number', Size, 'height');
    if (val < 0) Util.throwRangeError(val, '>= 0', Size, 'height');
    this._height = val;
  }
);

Size.prototype['isReal'] =
/**
* True if this Size has Width and Height values that are real numbers and not infinity.
* @this {Size}
* @return {boolean}
*/
Size.prototype.isReal = function() {
  return isFinite(this.width) && isFinite(this.height);
};


/**
 * There are four constructors: (), (Point, Point), (Point, Size),
 * and four numbers for (x, y, width, height).
 * The default constructor (no argument) results in a Rect(0,0,0,0).
 * @constructor
 * @param {Point|number=} x Top-left Point, or x value.
 * @param {Point|Size|number=} y Bottom-right Point or Size or y value.
 * @param {number=} w Width to be used if x,y are specified
 * must be non-negative.
 * @param {number=} h Height to be used if x,y are specified;
 * must be non-negative.
 * @category Geometry
 * @class
 * A Rect describes a rectangular two-dimensional area as a top-left point (x and y values)
 * and a size (width and height values).
 */
function Rect(x, y, w, h) {
  if (x === undefined/*notpresent*/) {  // zero args
    /** @type {number} */
    this._x = 0;
    /** @type {number} */
    this._y = 0;
    /** @type {number} */
    this._width = 0;
    /** @type {number} */
    this._height = 0;
  } else {
    if (x instanceof Point) {
      if (y instanceof Point) {  // Point, Point
        this._x = Math.min(x._x, y._x);
        this._y = Math.min(x._y, y._y);
        this._width = Math.abs(x._x - y._x);
        this._height = Math.abs(x._y - y._y);
      } else if (y instanceof Size) {  // Point, Size
        this._x = x._x;
        this._y = x._y;
        this._width = y._width;
        this._height = y._height;
      } else {
        Util.throwError('Incorrect arguments supplied');
      }
    } else if (typeof x === 'number' &&
               typeof y === 'number' &&
               typeof w === 'number' && (w >= 0 || isNaN(w)) &&
               typeof h === 'number' && (h >= 0 || isNaN(h))) {  // x, y, width, height
      this._x = x;
      this._y = y;
      this._width = w;
      this._height = h;
    } else {
      Util.throwError('Invalid arguments to Rect constructor');
    }
  }
}

Util.publish('Rect', Rect);

/**
* @ignore
* Replace the properties of this Rect with those of another Rect.
* This can modify a frozen object.
* @this {Rect}
* @param {Rect} r the other Rect from which to copy property values.
*/
Rect.prototype.assign = function(r) {
  this._x = r._x;
  this._y = r._y;
  this._width = r._width;
  this._height = r._height;
};

/**
* @ignore
* Replace the properties of this Rect with given values.
* This can modify a frozen object.
* @this {Rect}
* @param {number} x
* @param {number} y
* @param {number} w
* @param {number} h
*/
Rect.prototype._set = function(x, y, w, h) {
  this._x = x;
  this._y = y;
  this._width = w;
  this._height = h;
};

/**
* @ignore
* Replace the properties of this Rect with given values.
* This can modify a frozen object.
* @this {Rect}
* @param {number} w
* @param {number} h
*/
Rect.prototype.setWidthHeight = function(w, h) {
  this._width = w;
  this._height = h;
};

Rect.prototype['setTo'] =
/**
* Modify this Rect with new X, Y, Width, and Height values.
* @this {Rect}
* @param {number} x
* @param {number} y
* @param {number} w the width.
* @param {number} h the height.
* @return {Rect} this.
*/
Rect.prototype.setTo = function(x, y, w, h) {
  if (Debug) {
    Util.checkPrimitive(x, 'number', Rect, 'setTo:x');
    Util.checkPrimitive(y, 'number', Rect, 'setTo:y');
    Util.checkPrimitive(w, 'number', Rect, 'setTo:w');
    Util.checkPrimitive(h, 'number', Rect, 'setTo:h');
  }
  if (w < 0) Util.throwRangeError(w, '>= 0', Rect, 'setTo:w');
  if (h < 0) Util.throwRangeError(h, '>= 0', Rect, 'setTo:h');
  Util.checkFrozen(this);
  this._x = x;
  this._y = y;
  this._width = w;
  this._height = h;
  return this;
};

Rect.prototype['set'] =
/**
* Modify this Rect so that its X, Y, Width, and Height values are the same as the given Rect.
* @this {Rect}
* @param {Rect} r the given Rect.
* @return {Rect} this.
*/
Rect.prototype.set = function(r) {
  if (Debug) Util.checkClass(r, Rect, Rect, 'set:r');
  Util.checkFrozen(this);
  this._x = r._x;
  this._y = r._y;
  this._width = r._width;
  this._height = r._height;
  return this;
};

Rect.prototype['setPoint'] =
/**
* Modify this Rect so that its X and Y values are the same as the given Point.
* @this {Rect}
* @param {Point} p the given Point.
* @return {Rect} this.
*/
Rect.prototype.setPoint = function(p) {
  if (Debug) Util.checkClass(p, Point, Rect, 'setPoint:p');
  Util.checkFrozen(this);
  this._x = p._x;
  this._y = p._y;
  return this;
};

Rect.prototype['setSize'] =
/**
* Modify this Rect so that its Width and Height values are the same as the given Size.
* @this {Rect}
* @param {Size} s the given Size.
* @return {Rect} this.
*/
Rect.prototype.setSize = function(s) {
  if (Debug) Util.checkClass(s, Size, Rect, 'setSize:s');
  Util.checkFrozen(this);
  this._width = s._width;
  this._height = s._height;
  return this;
};

/**
* Create a copy of this Rect, with the same values.
* @expose
* @this {Rect}
* @return {Rect}
*/
Rect.prototype.copy = function() {
  var copy = new Rect();
  copy._x = this._x;
  copy._y = this._y;
  copy._width = this._width;
  copy._height = this._height;
  return copy;
};

/**
* @ignore
* Make this object 'constant' and 'frozen'.
* Future attempts to change its state may result in an exception.
* This constant object may be shared freely.
* @this {Rect}
* @return {Rect}
*/
Rect.prototype.constant = function() {
  this._isFrozen = true;
  Object.freeze(this);
  return this;
};

/**
* @ignore
* If this object is 'constant', just return it.
* Otherwise make a copy of this object and freeze it ({@link #frozen}).
* @this {Rect}
* @return {Rect}
*/
Rect.prototype.copyFrozen = function() {
  if (Object.isFrozen(this)) return this;
  return this.copy().freeze();
};

/**
* @ignore
* Make this object 'frozen' or immutable.
* Future attempts to change its state, for example by setting any of its properties,
* may result in an exception, until it is thaw()'ed.
* @this {Rect}
* @return {Rect}
*/
Rect.prototype.freeze = function() {
  this._isFrozen = true;
  return this;
};

/**
* @ignore
* Make this object 'thawed' or mutable.
* @this {Rect}
* @return {Rect}
*/
Rect.prototype.thaw = function() {
  if (Object.isFrozen(this)) Util.throwError('cannot thaw constant: ' + this);
  this._isFrozen = false;
  return this;
};


Rect['parse'] =
/**
* This static method can be used to read in a {@link Rect} from a string that was produced by {@link Rect.stringify}.
* @param {string} str
* @return {Rect}
*/
Rect.parse = function(str) {
  if (typeof str === 'string') {
    var split = str.split(' ');
    var i = 0;
    var x = 0;
    while (split[i] === '') i++;
    var s = split[i++];
    if (s) x = parseFloat(s);
    var y = 0;
    while (split[i] === '') i++;
    s = split[i++];
    if (s) y = parseFloat(s);
    var w = 0;
    while (split[i] === '') i++;
    s = split[i++];
    if (s) w = parseFloat(s);
    var h = 0;
    while (split[i] === '') i++;
    s = split[i++];
    if (s) h = parseFloat(s);
    return new Rect(x, y, w, h);
  } else {
    return new Rect();
  }
};

Rect['stringify'] =
/**
* This static method can be used to write out a {@link Rect} as a string that can be read by {@link Rect.parse}.
* @param {Rect} val
* @return {string}
*/
Rect.stringify = function(val) {
  if (val instanceof Rect) {
    return val.x.toString() + ' ' + val.y.toString() + ' ' + val.width.toString() + ' ' + val.height.toString();
  } else {
    return val.toString();
  }
};


/**
* @ignore
* @this {Rect}
* @return {string} A string containing Rect's information.
*/
Rect.prototype.toString = function() {
  return 'Rect(' + this.x + ',' + this.y + ',' + this.width + ',' + this.height + ')';
};

Rect.prototype['equals'] =
/**
* Indicates whether the given Rect is equal to the current Rect.
* @this {Rect}
* @param {Rect} r The rectangle to compare to the current rectangle.
* @return {boolean} True if the Rects are equivalent in x, y, width,
* and height.
* @see #equalTo
*/
Rect.prototype.equals = function(r) {
  if (!(r instanceof Rect)) return false;
  return (this._x === r.x && this._y === r.y &&
          this._width === r.width && this._height === r.height);
};

Rect.prototype['equalTo'] =
/**
* Indicates whether the given Rect is equal to the current Rect.
* @this {Rect}
* @param {number} x
* @param {number} y
* @param {number} w the width.
* @param {number} h the height.
* @return {boolean} True if the Rects are equivalent in x, y, width, and height.
* @see #equals
*/
Rect.prototype.equalTo = function(x, y, w, h) {
  return (this._x === x && this._y === y &&
          this._width === w && this._height === h);
};

/**
* @ignore
* Indicates whether the given Rect is approximately equal to this Rect.
* @this {Rect}
* @param {Rect} r The Rect to compare to the current Rect.
* @return {boolean} True if the two Rects have near identical X, Y, Width,
* and Height values, false otherwise.
*/
Rect.prototype.equalsApprox = function(r) {
  return Geo.isApproxEqual(this._x, r.x) &&
         Geo.isApproxEqual(this._y, r.y) &&
         Geo.isApproxEqual(this._width, r.width) &&
         Geo.isApproxEqual(this._height, r.height);
};

/**
* @ignore
* Indicates whether the given Rect is nearly equal to this Rect.
* @this {Rect}
* @param {Rect} r The Rect to compare to the current Rect.
* @return {boolean} True if the two Rects have respective X, Y, Width,
* and Height values within 0.5, false otherwise.
*/
Rect.prototype.equalsAbout = function(r) {
  return Geo.isApprox(this._x, r.x) &&
         Geo.isApprox(this._y, r.y) &&
         Geo.isApprox(this._width, r.width) &&
         Geo.isApprox(this._height, r.height);
};

Rect.prototype['containsPoint'] =
/**
* Indicates whether this Rect contains the given Point.
* @this {Rect}
* @param {Point} p The Point to check.
* @return {boolean} True if the Point is contained within this Rect,
* false otherwise.
* @see #containsRect
* @see #contains
*/
Rect.prototype.containsPoint = function(p) {
  if (Debug) Util.checkClass(p, Point, Rect, 'containsPoint:p');
  return ((this._x <= p.x) && ((this._x + this._width) >= p.x) &&
          (this._y <= p.y) && ((this._y + this._height) >= p.y));
};

Rect.prototype['containsRect'] =
/**
* Indicates whether this Rect contains the given Rect.
* @this {Rect}
* @param {Rect} r The Rect to check.
* @return {boolean} True if the Rect is contained within this Rect,
* false otherwise.
* @see #containsPoint
* @see #contains
*/
Rect.prototype.containsRect = function(r) {
  if (Debug) Util.checkClass(r, Rect, Rect, 'containsRect:r');
  return (this._x <= r.x && r.x + r.width <= this._x + this._width &&
          this._y <= r.y && r.y + r.height <= this._y + this._height);
};

Rect.prototype['contains'] =
/**
* Indicates whether this Rect contains the given Point/Rect.
* @this {Rect}
* @param {number} x The X coordinate of the Point or Rect to include in the new bounds.
* @param {number} y The Y coordinate of the Point or Rect to include in the new bounds.
* @param {number=} w The Width of the Rect to include in the new bounds, defaults to zero.
* @param {number=} h The Height of the Rect to include in the new bounds, defaults to zero.
* @return {boolean} True if the Point/Rect is contained within this Rect,
* false otherwise.
* @see #containsRect
* @see #containsPoint
*/
Rect.prototype.contains = function(x, y, w, h) {
  if (Debug) {
    Util.checkRealNumber(x, Rect, 'contains:x');
    Util.checkRealNumber(y, Rect, 'contains:y');
    if (w === undefined/*notpresent*/) {
      w = 0;
    } else {
      Util.checkRealNumber(w, Rect, 'contains:w');
    }
    if (h === undefined/*notpresent*/) {
      h = 0;
    } else {
      Util.checkRealNumber(h, Rect, 'contains:h');
    }
    if (w < 0 || h < 0) {
      Util.throwError('Rect.contains:Width and height cannot be negative');
    }
  } else {
    if (w === undefined/*notpresent*/) w = 0;
    if (h === undefined/*notpresent*/) h = 0;
  }
  return (this._x <= x && x + w <= this._x + this._width &&
          this._y <= y && y + h <= this._y + this._height);
};

/**
* @ignore
* Modify this Rect so that its X, Y, Width, and Height values are all zero.
* @this {Rect}
*/
Rect.prototype.reset = function() {
  Util.checkFrozen(this);
  this._x = 0;
  this._y = 0;
  this._width = 0;
  this._height = 0;
};

Rect.prototype['offset'] =
/**
* Modify this Rect by shifting its values with the given DX and DY offsets.
* @this {Rect}
* @param {number} dx
* @param {number} dy
* @return {Rect} this.
*/
Rect.prototype.offset = function(dx, dy) {
  if (Debug) {
    Util.checkRealNumber(dx, Rect, 'offset:dx');
    Util.checkRealNumber(dy, Rect, 'offset:dy');
  }
  Util.checkFrozen(this);
  this._x += dx;
  this._y += dy;
  return this;
};

Rect.prototype['inflate'] =
/**
* Modify this Rect so that its width and height are changed on all four sides,
* equally on the left and right sides, and equally on the top and bottom sides.
* When the arguments are negative, this operation deflates this Rect, but not beyond zero.
* @this {Rect}
* @param {number} w The additional width on each side, left and right; may be negative.
* @param {number} h The additional height on each side, top and bottom; may be negative.
* @return {Rect} this.
* @see #grow
* @see #addMargin
* @see #subtractMargin
*/
Rect.prototype.inflate = function(w, h) {
  if (Debug) {
    Util.checkRealNumber(w, Rect, 'inflate:w');
    Util.checkRealNumber(h, Rect, 'inflate:h');
  }
  return this._grow(h, w, h, w);
};

Rect.prototype['addMargin'] =
/**
* Modify this Rect by adding the given Margin to each side of the Rect.
* @this {Rect}
* @param {Margin} m The Margin to add to the Rect.
* @return {Rect} this bigger Rect.
* @see #subtractMargin
* @see #grow
* @see #inflate
*/
Rect.prototype.addMargin = function(m) {
  if (Debug) Util.checkClass(m, Margin, Rect, 'addMargin:m');
  return this._grow(m.top, m.right, m.bottom, m.left);
};

Rect.prototype['subtractMargin'] =
/**
* Modify this Rect by subtracting the given Margin from each side of the Rect.
* @this {Rect}
* @param {Margin} m The Margin to subtract from the Rect.
* @return {Rect} this smaller Rect.
* @see #addMargin
* @see #grow
* @see #inflate
*/
Rect.prototype.subtractMargin = function(m) {
  if (Debug) Util.checkClass(m, Margin, Rect, 'subtractMargin:m');
  return this._grow(-m.top, -m.right, -m.bottom, -m.left);
};

Rect.prototype['grow'] =
/**
* Modifies this Rect by adding some distance to each side of the Rect.
* @this {Rect}
* @param {number} t the amount to move the top side upwards; may be negative.
* @param {number} r the amount to move the right side rightwards; may be negative.
* @param {number} b the amount to move the bottom side downwards; may be negative.
* @param {number} l the amount to move the left side leftwards; may be negative.
* @return {Rect} this modified Rect.
* @see #inflate
* @see #addMargin
* @see #subtractMargin
*/
Rect.prototype.grow = function(t, r, b, l) {
  if (Debug) {
    Util.checkRealNumber(t, Rect, 'grow:t');
    Util.checkRealNumber(r, Rect, 'grow:r');
    Util.checkRealNumber(b, Rect, 'grow:b');
    Util.checkRealNumber(l, Rect, 'grow:l');
  }
  return this._grow(t, r, b, l);
};

/**
* @ignore
* Modifies this Rect by adding some distance to each side of the Rect.
* @this {Rect}
* @param {number} t the amount to move the top side upwards; may be negative.
* @param {number} r the amount to move the right side rightwards; may be negative.
* @param {number} b the amount to move the bottom side downwards; may be negative.
* @param {number} l the amount to move the left side leftwards; may be negative.
* @return {Rect} this modified Rect.
*/
Rect.prototype._grow = function(t, r, b, l) {
  Util.checkFrozen(this);
  var w = this._width;
  if (r + l <= -w) {
    this._x += w / 2;
    this._width = 0;
  } else {
    this._x -= l;
    this._width += r + l;
  }
  var h = this._height;
  if (t + b <= -h) {
    this._y += h / 2;
    this._height = 0;
  } else {
    this._y -= t;
    this._height += t + b;
  }
  return this;
};

Rect.prototype['intersectRect'] =
/**
* Modify this Rect so that it is the intersection of this Rect and the given Rect.
* @this {Rect}
* @param {Rect} r Rect to intersect with.
* @return {Rect} this.
* @see #intersect
* @see #intersects
*/
Rect.prototype.intersectRect = function(r) {
  if (Debug) Util.checkClass(r, Rect, Rect, 'intersectRect:r');
  return this._intersect(r.x, r.y, r.width, r.height);
};

Rect.prototype['intersect'] =
/**
* Modify this Rect so that it is the intersection of this Rect and the rectangle
* defined by x, y, w, h.
* @this {Rect}
* @param {number} x
* @param {number} y
* @param {number} w
* @param {number} h
* @return {Rect} this.
* @see #intersectRect
* @see #intersects
*/
Rect.prototype.intersect = function(x, y, w, h) {
  if (Debug) {
    Util.checkRealNumber(x, Rect, 'intersect:x');
    Util.checkRealNumber(y, Rect, 'intersect:y');
    Util.checkRealNumber(w, Rect, 'intersect:w');
    Util.checkRealNumber(h, Rect, 'intersect:h');
    if (w < 0 || h < 0) {
      Util.throwError('Rect.intersect:Width and height cannot be negative');
    }
  }
  return this._intersect(x, y, w, h);
};

/**
* @ignore
* Modifies this Rect so that it is the intersection of this Rect and the given Rect.
* @this {Rect}
* @param {number} x
* @param {number} y
* @param {number} w
* @param {number} h
* @return {Rect}
*/
Rect.prototype._intersect = function(x, y, w, h) {
  Util.checkFrozen(this);
  //??? should this returns a special Empty value if there's no intersection
  var maxx = Math.max(this._x, x);
  var maxy = Math.max(this._y, y);
  var minr = Math.min(this._x + this._width, x + w);
  var minb = Math.min(this._y + this._height, y + h);
  this._x = maxx;
  this._y = maxy;
  this._width = Math.max(0, minr - maxx);
  this._height = Math.max(0, minb - maxy);
  return this;
};

Rect.prototype['intersectsRect'] =
/**
* Determine if a given Rect is partly or wholly inside of this Rect.
* @this {Rect}
* @param {Rect} r Rect to test intersection with.
* @return {boolean} true if there is an intersection.
* @see #intersects
* @see #intersectRect
*/
Rect.prototype.intersectsRect = function(r) {
  if (Debug) Util.checkClass(r, Rect, Rect, 'intersectsRect:r');
  return this.intersects(r.x, r.y, r.width, r.height);
};

Rect.prototype['intersects'] =
/**
* Determine if this Rect partly or wholly overlaps the rectangle
* defined by x, y, w, h.
* @this {Rect}
* @param {number} x
* @param {number} y
* @param {number} w
* @param {number} h
* @return {boolean} true if there is any overlap.
* @see #intersectsRect
* @see #intersect
*/
Rect.prototype.intersects = function(x, y, w, h) {
  if (Debug) {
    Util.checkRealNumber(x, Rect, 'intersects:x');
    Util.checkRealNumber(y, Rect, 'intersects:y');
    Util.checkRealNumber(x, Rect, 'intersects:w');
    Util.checkRealNumber(y, Rect, 'intersects:h');
    if (w < 0 || h < 0) {
      Util.throwError('Rect.intersects:Width and height cannot be negative');
    }
  }

  var tw = this._width;
  var tx = this._x;
  if (tw !== Infinity && w !== Infinity) {
    tw += tx;
    w += x;
    if (isNaN(w) || isNaN(tw) || tx > w || x > tw) return false;
  }
  var th = this._height;
  var ty = this._y;
  if (th !== Infinity && h !== Infinity) {
    th += ty;
    h += y;
    if (isNaN(h) || isNaN(th) || ty > h || y > th) return false;
  }
  return true;
};

/**
* @ignore
* Faster with added-in rect expansion
* Assumes no NaN or Infinity values
* @this {Rect}
* @param {Rect} r Rect to test intersection with.
* @param {number} expansion to expand r on all sides. Can be zero.
* @return {boolean} true if there is an intersection.
*/
Rect.prototype.intersectsRectPlus = function(r, expansion) {
  var tw = this._width;
  var rw = r.width + expansion + expansion;
  var tx = this._x;
  var rx = r.x - expansion;
  tw += tx;
  rw += rx;
  if (tx > rw || rx > tw) return false;

  var th = this._height;
  var rh = r.height + expansion + expansion;
  var ty = this._y;
  var ry = r.y - expansion;
  th += ty;
  rh += ry;
  if (ty > rh || ry > th) return false;
  return true;
};


Rect.prototype['unionPoint'] =
/**
* Modify this Rect to be exactly big enough to contain both the original Rect and the given Point.
* @this {Rect}
* @param {Point} p The Point to include in the new bounds.
* @return {Rect} this.
* @see #unionRect
* @see #union
*/
Rect.prototype.unionPoint = function(p) {
  if (Debug) Util.checkClass(p, Point, Rect, 'unionPoint:p');
  return this.unionNoCheck(p.x, p.y, 0, 0);
};

Rect.prototype['unionRect'] =
/**
* Modify this Rect to be exactly big enough to contain this Rect and the given Rect.
* @this {Rect}
* @param {Rect} r The Rect to include in the new bounds.
* @return {Rect} this.
* @see #unionPoint
* @see #union
*/
Rect.prototype.unionRect = function(r) {
  if (Debug) Util.checkClass(r, Rect, Rect, 'unionRect:r');
  return this.unionNoCheck(r._x, r._y, r._width, r._height);
};

Rect.prototype['union'] =
/**
* Modify this Rect to be exactly big enough to contain both the original Rect and the given rectangular area.
* @this {Rect}
* @param {number} x The X coordinate of the Point or Rect to include in the new bounds.
* @param {number} y The Y coordinate of the Point or Rect to include in the new bounds.
* @param {number=} w The Width of the Rect to include in the new bounds, defaults to zero.
* @param {number=} h The Height of the Rect to include in the new bounds, defaults to zero.
* @return {Rect} this.
* @see #unionRect
* @see #unionPoint
*/
Rect.prototype.union = function(x, y, w, h) {
  Util.checkFrozen(this);
  if (Debug) {
    Util.checkRealNumber(x, Rect, 'union:x');
    Util.checkRealNumber(y, Rect, 'union:y');
    if (w === undefined/*notpresent*/) {
      w = 0;
    } else {
      Util.checkRealNumber(w, Rect, 'union:w');
    }
    if (h === undefined/*notpresent*/) {
      h = 0;
    } else {
      Util.checkRealNumber(h, Rect, 'union:h');
    }
    if (w < 0 || h < 0) {
      Util.throwError('Rect.union:Width and height cannot be negative');
    }
  } else {
    if (w === undefined/*notpresent*/) w = 0;
    if (h === undefined/*notpresent*/) h = 0;
  }
  return this.unionNoCheck(x, y, w, h);
};

/**
* @ignore
* Modify this Rect to be exactly big enough to contain both the original Rect and the given rectangular area.
* @this {Rect}
* @param {number} x The X coordinate of the Point or Rect to include in the new bounds.
* @param {number} y The Y coordinate of the Point or Rect to include in the new bounds.
* @param {number} w The Width of the Rect to include in the new bounds, defaults to zero.
* @param {number} h The Height of the Rect to include in the new bounds, defaults to zero.
* @return {Rect} this.
*/
Rect.prototype.unionNoCheck = function(x, y, w, h) {
  var minx = Math.min(this._x, x);
  var miny = Math.min(this._y, y);
  var maxr = Math.max(this._x + this._width, x + w);
  var maxb = Math.max(this._y + this._height, y + h);
  this._x = minx;
  this._y = miny;
  this._width = maxr - minx;
  this._height = maxb - miny;
  return this;
};

Rect.prototype['setSpot'] =
/**
* Modify this Rect so that a given Spot is at a given (x,y) point using this Rect's size.
* Return this rectangle for which the spot is at that point, without modifying the size.
* <p/>
* The result is meaningless if {@link Spot#isNoSpot} is true.
* @this {Rect}
* @param {number} x the point where the spot should be.
* @param {number} y the point where the spot should be.
* @param {Spot} spot a Spot; {@link Spot#isSpot} must be true.
* @return {Rect} this.
*/
Rect.prototype.setSpot = function(x, y, spot) {
  if (Debug) {
    Util.checkRealNumber(x, Rect, 'setSpot:x');
    Util.checkRealNumber(y, Rect, 'setSpot:y');
    Util.checkClass(spot, Spot, Rect, 'setSpot:spot');
  }
  Util.checkFrozen(this);
  this._x = x - spot.offsetX - spot.x * this._width;
  this._y = y - spot.offsetY - spot.y * this._height;
  return this;
};

Rect['contains'] =
/**
* This static method indicates whether a Rect contains the given Point/Rect.
* @param {number} rx The X coordinate of a Rect.
* @param {number} ry The Y coordinate of a Rect.
* @param {number} rw The Width of a Rect.
* @param {number} rh The Height of a Rect.
* @param {number} x The X coordinate of the Point or Rect that might be in the bounds (RX, RY, RW, RH).
* @param {number} y The Y coordinate of the Point or Rect that might be in the bounds (RX, RY, RW, RH).
* @param {number=} w The Width of the Rect to include in the new bounds, defaults to zero.
* @param {number=} h The Height of the Rect to include in the new bounds, defaults to zero.
* @return {boolean} True if the Point/Rect is contained within this Rect,
* false otherwise.
*/
Rect.contains = function(rx, ry, rw, rh, x, y, w, h) {
  if (Debug) {
    Util.checkRealNumber(rx, Rect, 'contains:rx');
    Util.checkRealNumber(ry, Rect, 'contains:ry');
    Util.checkRealNumber(rw, Rect, 'contains:rw');
    Util.checkRealNumber(rh, Rect, 'contains:rh');
    Util.checkRealNumber(x, Rect, 'contains:x');
    Util.checkRealNumber(y, Rect, 'contains:y');
    if (w === undefined/*notpresent*/) {
      w = 0;
    } else {
      Util.checkRealNumber(w, Rect, 'contains:w');
    }
    if (h === undefined/*notpresent*/) {
      h = 0;
    } else {
      Util.checkRealNumber(h, Rect, 'contains:h');
    }
    if (rw < 0 || rh < 0 || w < 0 || h < 0) {
      Util.throwError('Rect.contains:Width and height cannot be negative');
    }
  } else {
    if (w === undefined/*notpresent*/) w = 0;
    if (h === undefined/*notpresent*/) h = 0;
  }
  return (rx <= x && x + w <= rx + rw &&
          ry <= y && y + h <= ry + rh);
};

Rect['intersects'] =
/**
* This static method indicates whether a Rect partly or wholly overlaps the given Rect.
* @param {number} rx The X coordinate of a Rect.
* @param {number} ry The Y coordinate of a Rect.
* @param {number} rw The Width of a Rect.
* @param {number} rh The Height of a Rect.
* @param {number} x The X coordinate of the Point or Rect that might overlap the bounds (RX, RY, RW, RH).
* @param {number} y The Y coordinate of the Point or Rect that might overlap the bounds (RX, RY, RW, RH).
* @param {number} w
* @param {number} h
* @return {boolean} true if there is any overlap.
*/
Rect.intersects = function(rx, ry, rw, rh, x, y, w, h) {
  if (Debug) {
    Util.checkRealNumber(rx, Rect, 'intersects:rx');
    Util.checkRealNumber(ry, Rect, 'intersects:ry');
    Util.checkRealNumber(rw, Rect, 'intersects:rw');
    Util.checkRealNumber(rh, Rect, 'intersects:rh');
    Util.checkRealNumber(x, Rect, 'intersects:x');
    Util.checkRealNumber(y, Rect, 'intersects:y');
    Util.checkRealNumber(w, Rect, 'intersects:w');
    Util.checkRealNumber(h, Rect, 'intersects:h');
    if (rw < 0 || rh < 0 || w < 0 || h < 0) {
      Util.throwError('Rect.intersects:Width and height cannot be negative');
    }
  }

  /** @type {number} */
  var tw = rw;
  /** @type {number} */
  var uw = w;
  /** @type {number} */
  var tx = rx;
  /** @type {number} */
  var ux = x;
  tw += tx;
  uw += ux;
  if (tx > uw || ux > tw) return false;

  /** @type {number} */
  var th = rh;
  /** @type {number} */
  var uh = h;
  /** @type {number} */
  var ty = ry;
  /** @type {number} */
  var uy = y;
  th += ty;
  uh += uy;
  if (ty > uh || uy > th) return false;
  return true;
};

/**
 * Gets or sets the top-left x coordinate of the Rect.
 * @name Rect#x
 * @function.
 * @return {number}
 */
/** @type {number} */
Rect.prototype.x;
Util.exportProperty(Rect, 'x', Rect.prototype.x);
Util.defineProperty(Rect, {x: 'x'},
  /** @this {Rect} */
  function() { return this._x; },
  /** @this {Rect} */
  function(val) {
    Util.checkFrozen(this, val);
    if (Debug) Util.checkPrimitive(val, 'number', Rect, 'x');
    this._x = val;
  }
);

/**
 * Gets or sets the top-left y coordinate of the Rect.
 * @name Rect#y
 * @function.
 * @return {number}
 */
/** @type {number} */
Rect.prototype.y;
Util.exportProperty(Rect, 'y', Rect.prototype.y);
Util.defineProperty(Rect, {y: 'y'},
  /** @this {Rect} */
  function() { return this._y; },
  /** @this {Rect} */
  function(val) {
    Util.checkFrozen(this, val);
    if (Debug) Util.checkPrimitive(val, 'number', Rect, 'y');
    this._y = val;
  }
);

/**
 * Gets or sets the width of the Rect.
 * The value must not be negative.
 * @name Rect#width
 * @function.
 * @return {number}
 */
/** @type {number} */
Rect.prototype.width;
Util.exportProperty(Rect, 'width', Rect.prototype.width);
Util.defineProperty(Rect, {width: 'width'},
  /** @this {Rect} */
  function() { return this._width; },
  /** @this {Rect} */
  function(val) {
    Util.checkFrozen(this, val);
    if (Debug) Util.checkPrimitive(val, 'number', Rect, 'width');
    if (val < 0) Util.throwRangeError(val, '>= 0', Rect, 'width');
    this._width = val;
  }
);

/**
 * Gets or sets the height of the Rect.
 * The value must not be negative.
 * @name Rect#height
 * @function.
 * @return {number}
 */
/** @type {number} */
Rect.prototype.height;
Util.exportProperty(Rect, 'height', Rect.prototype.height);
Util.defineProperty(Rect, {height: 'height'},
  /** @this {Rect} */
  function() { return this._height; },
  /** @this {Rect} */
  function(val) {
    Util.checkFrozen(this, val);
    if (Debug) Util.checkPrimitive(val, 'number', Rect, 'height');
    if (val < 0) Util.throwRangeError(val, '>= 0', Rect, 'height');
    this._height = val;
  }
);

/**
* Gets or sets the leftmost value of the Rect.
* This is the same as the X value.
* @name Rect#left
* @function.
* @return {number}
*/
/** @type {number} */
Rect.prototype.left;
Util.exportProperty(Rect, 'left', Rect.prototype.left);
Util.defineProperty(Rect, {left: 'left'},
  /** @this {Rect} */
  function() { return this._x; },
  /** @this {Rect} */
  function(val) {
    Util.checkFrozen(this, val);
    if (Debug) Util.checkPrimitive(val, 'number', Rect, 'left');
    this._x = val;
  }
);

/**
 * Gets or sets the topmost value of the Rect.
 * This is the same as the Y value.
 * @name Rect#top
 * @function.
 * @return {number}
 */
/** @type {number} */
Rect.prototype.top;
Util.exportProperty(Rect, 'top', Rect.prototype.top);
Util.defineProperty(Rect, {top: 'top'},
  /** @this {Rect} */
  function() { return this._y; },
  /** @this {Rect} */
  function(val) {
    Util.checkFrozen(this, val);
    if (Debug) Util.checkPrimitive(val, 'number', Rect, 'top');
    this._y = val;
  }
);

/**
 * Gets or sets the x-axis value of the right of the Rect.
 * This is equal to the sum of the x value and the width.
 * @name Rect#right
 * @function.
 * @return {number}
 */
/** @type {number} */
Rect.prototype.right;
Util.exportProperty(Rect, 'right', Rect.prototype.right);
Util.defineProperty(Rect, {right: 'right'},
  /** @this {Rect} */
  function() { return this._x + this._width; },
  /** @this {Rect} */
  function(val) {
    Util.checkFrozen(this, val);
    if (Debug) Util.checkRealNumber(val, Rect, 'right');
    this._x += (val - (this._x + this._width));
  }
);

/**
* Gets or sets the y-axis value of the bottom of the Rect.
* This is equal to the sum of the y value and the height.
* @name Rect#bottom
* @function.
* @return {number}
*/
/** @type {number} */
Rect.prototype.bottom;
Util.exportProperty(Rect, 'bottom', Rect.prototype.bottom);
Util.defineProperty(Rect, {bottom: 'bottom'},
  /** @this {Rect} */
  function() { return this._y + this._height; },
  /** @this {Rect} */
  function(val) {
    Util.checkFrozen(this, val);
    if (Debug) Util.checkRealNumber(val, Rect, 'top');
    this._y += (val - (this._y + this._height));
  }
);

/**
 * Gets or sets the x- and y-axis position of the Rect as a Point.
 * @name Rect#position
 * @function.
 * @return {Point}
 */
/** @type {Point} */
Rect.prototype.position;
Util.exportProperty(Rect, 'position', Rect.prototype.position);
Util.defineProperty(Rect, {position: 'position'},
  /** @this {Rect} */
  function() { return new Point(this._x, this._y); },
  /** @this {Rect} */
  function(val) {
    Util.checkFrozen(this, val);
    if (Debug) Util.checkClass(val, Point, Rect, 'position');
    this._x = val.x;
    this._y = val.y;
  }
);

/**
 * Gets or sets the width and height of the Rect as a Size.
 * @name Rect#size
 * @function.
 * @return {Size}
 */
/** @type {Size} */
Rect.prototype.size;
Util.exportProperty(Rect, 'size', Rect.prototype.size);
Util.defineProperty(Rect, {size: 'size'},
  /** @this {Rect} */
  function() { return new Size(this._width, this._height); },
  /** @this {Rect} */
  function(val) {
    Util.checkFrozen(this, val);
    if (Debug) Util.checkClass(val, Size, Rect, 'size');
    this._width = val.width;
    this._height = val.height;
  }
);

/**
* Gets or sets the Point at the center of this Rect.
* Setting this property just shifts the X and Y values.
* @name Rect#center
* @function.
* @return {Point}
*/
/** @type {Point} */
Rect.prototype.center;
Util.exportProperty(Rect, 'center', Rect.prototype.center);
Util.defineProperty(Rect, {center: 'center'},
  /** @this {Rect} */
  function() { return new Point(this._x + this._width / 2, this._y + this._height / 2); },
  /** @this {Rect} */
  function(val) {
    Util.checkFrozen(this, val);
    if (Debug) Util.checkClass(val, Point, Rect, 'center');
    this._x = val.x - this._width / 2;
    this._y = val.y - this._height / 2;
  }
);

/**
 * Gets or sets the horizontal center X coordinate of the Rect.
 * @name Rect#centerX
 * @function.
 * @return {number}
 */
/** @type {number} */
Rect.prototype.centerX;
Util.exportProperty(Rect, 'centerX', Rect.prototype.centerX);
Util.defineProperty(Rect, {centerX: 'centerX'},
  /** @this {Rect} */
  function() { return this._x + this._width / 2; },
  /** @this {Rect} */
  function(val) {
    Util.checkFrozen(this, val);
    if (Debug) Util.checkRealNumber(val, Rect, 'centerX');
    this._x = val - this._width / 2;
  }
);

/**
 * Gets or sets the vertical center Y coordinate of the Rect.
 * @name Rect#centerY
 * @function.
 * @return {number}
 */
/** @type {number} */
Rect.prototype.centerY;
Util.exportProperty(Rect, 'centerY', Rect.prototype.centerY);
Util.defineProperty(Rect, {centerY: 'centerY'},
  /** @this {Rect} */
  function() { return this._y + this._height / 2; },
  /** @this {Rect} */
  function(val) {
    Util.checkFrozen(this, val);
    if (Debug) Util.checkRealNumber(val, Rect, 'centerY');
    this._y = val - this._height / 2;
  }
);

Rect.prototype['isReal'] =
/**
* True if this Rect has X, Y, Width, and Height values that are real numbers and not infinity.
* @this {Rect}
* @return {boolean}
*/
Rect.prototype.isReal = function() {
  return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
};

Rect.prototype['isEmpty'] =
/**
* True if this Rect has a Width and Height of zero.
* @this {Rect}
* @return {boolean}
*/
Rect.prototype.isEmpty = function() {
  return this.width === 0 && this.height === 0;
};


/**
* If zero arguments are supplied, zero is used for all four sides.
* If one argument is supplied, that number is used for all four sides.
* If two arguments are supplied, the top and bottom sides get the first value,
* and the left and right sides get the second value.
* Otherwise there must be four arguments, in the order: top, right, bottom, left.
* @constructor
* @param {number=} t the margin for the top side;
*                    if not supplied, all sides are zero.
* @param {number=} r the margin for the right side;
*                    if not supplied, all sides have the value of the first argument.
* @param {number=} b the margin for all bottom side;
*                    if not supplied, the top and bottom get the value of the first argument,
*                    and the right and left sides get the value of the second argument.
* @param {number=} l the margin for the left side;
*                    must be supplied if the third argument was supplied.
* @category Geometry
* @class
* A Margin represents a band of space outside or inside a rectangular area,
* with possibly different values on each of the four sides.
* <p/>
* Example uses include {@link GraphObject#margin}, {@link Panel#padding}, and {@link Diagram#padding}.
*/
function Margin(t, r, b, l) {
  if (t === undefined/*notpresent*/) {  // zero args
    /** @type {number} */
    this._top = 0;
    /** @type {number} */
    this._right = 0;
    /** @type {number} */
    this._bottom = 0;
    /** @type {number} */
    this._left = 0;
  } else {
    if (r === undefined/*notpresent*/) {  // one arg
      r = t;
      b = t;
      l = t;
      this.top = t;
      this.right = r;
      this.bottom = b;
      this.left = l;
    } else if (b === undefined/*notpresent*/) {  // two args
      b = t;
      l = r;
      this.top = t;
      this.right = r;
      this.bottom = b;
      this.left = l;
    } else if (l !== undefined) { // else four args
      this.top = t;
      this.right = r;
      this.bottom = b;
      this.left = l;
    } else {
      Util.throwError('Invalid arguments to Margin constructor');
    }
  }
}

Util.publish('Margin', Margin);

/**
* @ignore
* Replace the properties of this Margin with those of another Margin.
* This can modify a frozen object.
* @this {Margin}
* @param {Margin} m the other Margin from which to copy property values.
*/
Margin.prototype.assign = function(m) {
  this._top = m._top;
  this._right = m._right;
  this._bottom = m._bottom;
  this._left = m._left;
};

Margin.prototype['setTo'] =
/**
* Modify this Margin with new Top, Right, Bottom, and Left values.
* @this {Margin}
* @param {number} t top.
* @param {number} r right.
* @param {number} b bottom.
* @param {number} l left.
* @return {Margin} this.
*/
Margin.prototype.setTo = function(t, r, b, l) {
  if (Debug) {
    Util.checkPrimitive(t, 'number', Margin, 'setTo:t');
    Util.checkPrimitive(r, 'number', Margin, 'setTo:r');
    Util.checkPrimitive(b, 'number', Margin, 'setTo:b');
    Util.checkPrimitive(l, 'number', Margin, 'setTo:l');
  }
  Util.checkFrozen(this);
  this._top = t;
  this._right = r;
  this._bottom = b;
  this._left = l;
  return this;
};

Margin.prototype['set'] =
/**
* Modify this Margin so that its Top, Right, Bottom, and Left values
* are the same as the given Margin.
* @this {Margin}
* @param {Margin} m the given Margin.
* @return {Margin} this.
*/
Margin.prototype.set = function(m) {
  if (Debug) Util.checkClass(m, Margin, Margin, 'assign:m');
  Util.checkFrozen(this);
  this._top = m._top;
  this._right = m._right;
  this._bottom = m._bottom;
  this._left = m._left;
  return this;
};

/**
* Create a copy of this Margin, with the same values.
* @expose
* @this {Margin}
* @return {Margin}
*/
Margin.prototype.copy = function() {
  var copy = new Margin();
  copy._top = this._top;
  copy._right = this._right;
  copy._bottom = this._bottom;
  copy._left = this._left;
  return copy;
};

/**
* @ignore
* Make this object 'constant' and 'frozen'.
* Future attempts to change its state may result in an exception.
* This constant object may be shared freely.
* @this {Margin}
* @return {Margin}
*/
Margin.prototype.constant = function() {
  this._isFrozen = true;
  Object.freeze(this);
  return this;
};

/**
* @ignore
* If this object is 'constant', just return it.
* Otherwise make a copy of this object and freeze it ({@link #frozen}).
* @this {Margin}
* @return {Margin}
*/
Margin.prototype.copyFrozen = function() {
  if (Object.isFrozen(this)) return this;
  return this.copy().freeze();
};

/**
* @ignore
* Make this object 'frozen' or immutable.
* Future attempts to change its state, for example by setting any of its properties,
* may result in an exception, until it is thaw()'ed.
* @this {Margin}
* @return {Margin}
*/
Margin.prototype.freeze = function() {
  this._isFrozen = true;
  return this;
};

/**
* @ignore
* Make this object 'thawed' or mutable.
* @this {Margin}
* @return {Margin}
*/
Margin.prototype.thaw = function() {
  if (Object.isFrozen(this)) Util.throwError('cannot thaw constant: ' + this);
  this._isFrozen = false;
  return this;
};


Margin['parse'] =
/**
* This static method can be used to read in a {@link Margin} from a string that was produced by {@link Margin.stringify}.
* @param {string} str
* @return {Margin}
*/
Margin.parse = function(str) {
  if (typeof str === 'string') {
    var split = str.split(' ');
    var i = 0;
    var t = 0;
    while (split[i] === '') i++;
    var s = split[i++];
    if (s) t = parseFloat(s);
    var r = 0;
    while (split[i] === '') i++;
    s = split[i++];
    if (s) r = parseFloat(s);
    var b = 0;
    while (split[i] === '') i++;
    s = split[i++];
    if (s) b = parseFloat(s);
    var l = 0;
    while (split[i] === '') i++;
    s = split[i++];
    if (s) l = parseFloat(s);
    return new Margin(t, r, b, l);
  } else {
    return new Margin();
  }
};

Margin['stringify'] =
/**
* This static method can be used to write out a {@link Margin} as a string that can be read by {@link Margin.parse}.
* @param {Margin} val
* @return {string}
*/
Margin.stringify = function(val) {
  if (val instanceof Margin) {
    return val.top.toString() + ' ' + val.right.toString() + ' ' + val.bottom.toString() + ' ' + val.left.toString();
  } else {
    return val.toString();
  }
};


/**
* @ignore
* @this {Margin}
* @return {string} A string containing this Margin's information.
*/
Margin.prototype.toString = function() {
  return 'Margin(' + this.top + ',' + this.right + ',' + this.bottom + ',' + this.left + ')';
};

Margin.prototype['equals'] =
/**
* Indicates whether the given Margin is equal to this Margin.
* @this {Margin}
* @param {Margin} m The Margin to compare to this Margin.
* @return {boolean} True if the two Margins have identical Top and Right and Bottom and Left values,
* false otherwise.
* @see #equalTo
*/
Margin.prototype.equals = function(m) {
  if (!(m instanceof Margin)) return false;
  return (this._top === m.top && this._right === m.right &&
          this._bottom === m.bottom && this._left === m.left);
};

Margin.prototype['equalTo'] =
/**
* Indicates whether the given margin is equal to this Margin.
* @this {Margin}
* @param {number} t top.
* @param {number} r right.
* @param {number} b bottom.
* @param {number} l left.
* @return {boolean} True if the two Margins have identical Top and Right and Bottom and Left values,
* false otherwise.
* @see #equals
*/
Margin.prototype.equalTo = function(t, r, b, l) {
  return (this._top === t && this._right === r &&
          this._bottom === b && this._left === l);
};

/**
* @ignore
* Indicates whether the given Margin is approximately equal to this Margin.
* @this {Margin}
* @param {Margin} m The Margin to compare to the current Margin.
* @return {boolean} True if the two Margins have near identical Top, Right,
* Bottom and Left values, false otherwise.
*/
Margin.prototype.equalsApprox = function(m) {
  return Geo.isApproxEqual(this._top, m.top) &&
         Geo.isApproxEqual(this._right, m.right) &&
         Geo.isApproxEqual(this._bottom, m.bottom) &&
         Geo.isApproxEqual(this._left, m.left);
};

/**
* @ignore
* Indicates whether the given Margin is nearly equal to this Margin.
* @this {Margin}
* @param {Margin} m The Margin to compare to the current Margin.
* @return {boolean} True if the two Margins have Top, Right,
* Bottom and Left values within 0.5, false otherwise.
*/
Margin.prototype.equalsAbout = function(m) {
  return Geo.isApprox(this._top, m.top) &&
         Geo.isApprox(this._right, m.right) &&
         Geo.isApprox(this._bottom, m.bottom) &&
         Geo.isApprox(this._left, m.left);
};

/**
* Gets or sets the top value of this margin. Default is 0.
* @name Margin#top
* @function.
* @return {number}
*/
/** @type {number} */
Margin.prototype.top;
Util.exportProperty(Margin, 'top', Margin.prototype.top);
Util.defineProperty(Margin, {top: 'top'},
  /** @this {Margin} */
  function() { return this._top; },
  /** @this {Margin} */
  function(val) {
    Util.checkFrozen(this, val);
    if (Debug) Util.checkRealNumber(val, Margin, 'top');
    this._top = val;
  }
);

/**
* Gets or sets the right value of this margin. Default is 0.
* @name Margin#right
* @function.
* @return {number}
*/
/** @type {number} */
Margin.prototype.right;
Util.exportProperty(Margin, 'right', Margin.prototype.right);
Util.defineProperty(Margin, {right: 'right'},
  /** @this {Margin} */
  function() { return this._right; },
  /** @this {Margin} */
  function(val) {
    Util.checkFrozen(this, val);
    if (Debug) Util.checkRealNumber(val, Margin, 'right');
    this._right = val;
  }
);

/**
* Gets or sets the bottom value of this margin. Default is 0.
* @name Margin#bottom
* @function.
* @return {number}
*/
/** @type {number} */
Margin.prototype.bottom;
Util.exportProperty(Margin, 'bottom', Margin.prototype.bottom);
Util.defineProperty(Margin, {bottom: 'bottom'},
  /** @this {Margin} */
  function() { return this._bottom; },
  /** @this {Margin} */
  function(val) {
    Util.checkFrozen(this, val);
    if (Debug) Util.checkRealNumber(val, Margin, 'bottom');
    this._bottom = val;
  }
);

/**
* Gets or sets the left value of this margin. Default is 0.
* @name Margin#left
* @function.
* @return {number}
*/
/** @type {number} */
Margin.prototype.left;
Util.exportProperty(Margin, 'left', Margin.prototype.left);
Util.defineProperty(Margin, {left: 'left'},
  /** @this {Margin} */
  function() { return this._left; },
  /** @this {Margin} */
  function(val) {
    Util.checkFrozen(this, val);
    if (Debug) Util.checkRealNumber(val, Margin, 'left');
    this._left = val;
  }
);

Margin.prototype['isReal'] =
/**
* True if this Margin has values that are real numbers and not infinity.
* @this {Margin}
* @return {boolean}
*/
Margin.prototype.isReal = function() {
  return isFinite(this.top) && isFinite(this.right) && isFinite(this.bottom) && isFinite(this.left);
};


/**
* @ignore
* @constructor
* @class
* The Transform class holds a transformation matrix.
*/
function Transform() {
  /** @ignore @type {number} */
  this.m11 = 1;
  /** @ignore @type {number} */
  this.m12 = 0;
  /** @ignore @type {number} */
  this.m21 = 0;
  /** @ignore @type {number} */
  this.m22 = 1;
  /** @ignore @type {number} */
  this.dx = 0;
  /** @ignore @type {number} */
  this.dy = 0;
}

Util.defineDataProperties(Transform, {
  m11: true,
  m12: true,
  m21: true,
  m22: true,
  dx: true,
  dy: true
});

Transform.prototype['set'] =
/**
* @ignore
* Replace the transformation matrix of this Transform with those of another Transform.
* @this {Transform}
* @param {Transform} t the other Transform from which to copy the transformation matrix.
* @return {Transform} this.
*/
Transform.prototype.set = function(t) {
  if (Debug) Util.checkClass(t, Transform, Transform, 'set:t');
  this.m11 = t.m11;
  this.m12 = t.m12;
  this.m21 = t.m21;
  this.m22 = t.m22;
  this.dx = t.dx;
  this.dy = t.dy;
  return this;
};

/**
* @ignore
* Create a copy of this Transform, with the same values.
* @expose
* @this {Transform}
* @return {Transform}
*/
Transform.prototype.copy = function() {
  var copy = new Transform();
  copy.m11 = this.m11;
  copy.m12 = this.m12;
  copy.m21 = this.m21;
  copy.m22 = this.m22;
  copy.dx = this.dx;
  copy.dy = this.dy;
  return copy;
};

/**
* @ignore
* @this {Transform}
* @return {string}
*/
Transform.prototype.toString = function() {
  return 'Transform(' + this.m11 + ',' + this.m12 + ',' + this.m21 +
                  ',' + this.m22 + ',' + this.dx + ',' + this.dy + ')';
};

Transform.prototype['equals'] =
/**
* @ignore
* Indicates whether the given Transform is equal to the current Transform.
* @this {Transform}
* @param {Transform} t The Transform to compare to the current Transform.
* @return {boolean} True if the two Transforms have identical matrixes,
* false otherwise.
*/
Transform.prototype.equals = function(t) {
  if (!(t instanceof Transform)) return false;
  return (this.m11 === t.m11 && this.m12 === t.m12 && this.m21 === t.m21 &&
          this.m22 === t.m22 && this.dx === t.dx && this.dy === t.dy);
};

Transform.prototype['reset'] =
/**
* @ignore
* Resets the Transform's matrix to an identity matrix.
* @this {Transform}
*/
Transform.prototype.reset = function() {
  this.m11 = 1;
  this.m12 = 0;
  this.m21 = 0;
  this.m22 = 1;
  this.dx = 0;
  this.dy = 0;
};

Transform.prototype['multiply'] =
/**
* @ignore
* Modifies this Transform to be the product of this Transform with a given one.
* @this {Transform}
* @param {Transform} matrix
* @return {Transform} this.
*/
Transform.prototype.multiply = function(matrix) {
  if (Debug) Util.checkClass(matrix, Transform, Transform, 'multiply:matrix');

  var m11 = this.m11 * matrix.m11 + this.m21 * matrix.m12;
  var m12 = this.m12 * matrix.m11 + this.m22 * matrix.m12;

  var m21 = this.m11 * matrix.m21 + this.m21 * matrix.m22;
  var m22 = this.m12 * matrix.m21 + this.m22 * matrix.m22;

  var dx = this.m11 * matrix.dx + this.m21 * matrix.dy + this.dx;
  var dy = this.m12 * matrix.dx + this.m22 * matrix.dy + this.dy;

  this.m11 = m11;
  this.m12 = m12;
  this.m21 = m21;
  this.m22 = m22;
  this.dx = dx;
  this.dy = dy;
  return this;
};

Transform.prototype['multiplyInverted'] =
/**
* @ignore
* Modifies this Transform to be the product of this Transform with the inverse of a given one.
* @this {Transform}
* @param {Transform} matrix
*/
Transform.prototype.multiplyInverted = function(matrix) {
  if (Debug) Util.checkClass(matrix, Transform, Transform, 'multiplyInverted:matrix');

  // invert
  var t = matrix;
  var d = 1 / (t.m11 * t.m22 - t.m12 * t.m21);
  var m0 = t.m22 * d;
  var m1 = -t.m12 * d;
  var m2 = -t.m21 * d;
  var m3 = t.m11 * d;
  var m4 = d * (t.m21 * t.dy - t.m22 * t.dx);
  var m5 = d * (t.m12 * t.dx - t.m11 * t.dy);

  // multiply
  var m11 = this.m11 * m0 + this.m21 * m1;
  var m12 = this.m12 * m0 + this.m22 * m1;

  var m21 = this.m11 * m2 + this.m21 * m3;
  var m22 = this.m12 * m2 + this.m22 * m3;

  var dx = this.m11 * m4 + this.m21 * m5 + this.dx;
  var dy = this.m12 * m4 + this.m22 * m5 + this.dy;

  // modify
  this.m11 = m11;
  this.m12 = m12;
  this.m21 = m21;
  this.m22 = m22;
  this.dx = dx;
  this.dy = dy;
  return this;
};

Transform.prototype['invert'] =
/**
* @ignore
* Inverts this Transform matrix, modifying the matrix.
* @this {Transform}
*/
Transform.prototype.invert = function() {
  var d = 1 / (this.m11 * this.m22 - this.m12 * this.m21);
  var m0 = this.m22 * d;
  var m1 = -this.m12 * d;
  var m2 = -this.m21 * d;
  var m3 = this.m11 * d;
  var m4 = d * (this.m21 * this.dy - this.m22 * this.dx);
  var m5 = d * (this.m12 * this.dx - this.m11 * this.dy);
  this.m11 = m0;
  this.m12 = m1;
  this.m21 = m2;
  this.m22 = m3;
  this.dx = m4;
  this.dy = m5;
};

Transform.prototype['rotate'] =
/**
* @ignore
* Rotates the Transform's matrix clockwise by a given angle.
* This modifies this Transform.
* @this {Transform}
* @param {number} angle The angle to rotate by.
* @param {number} rx The X point to rotate about.
* @param {number} ry The Y point to rotate about.
*/
Transform.prototype.rotate = function(angle, rx, ry) {
  if (Debug) {
    Util.checkRealNumber(angle, Transform, 'rotate:angle');
    Util.checkRealNumber(rx, Transform, 'rotate:rx');
    Util.checkRealNumber(ry, Transform, 'rotate:ry');
  }
  this.translate(rx, ry);
  var rad = angle * Math.PI / 180;
  //??? optimize common cases to avoid trig function calls
  var c = Math.cos(rad);
  var s = Math.sin(rad);
  var m11 = this.m11 * c + this.m21 * s;
  var m12 = this.m12 * c + this.m22 * s;
  var m21 = this.m11 * -s + this.m21 * c;
  var m22 = this.m12 * -s + this.m22 * c;
  this.m11 = m11;
  this.m12 = m12;
  this.m21 = m21;
  this.m22 = m22;
  this.translate(-rx, -ry);
};

Transform.prototype['translate'] =
/**
* @ignore
* Translates this Transform's matrix by x and y.
* This modifies this Transform.
* @this {Transform}
* @param {number} x The x-axis translation.
* @param {number} y The y-axis translation.
*/
Transform.prototype.translate = function(x, y) {
  if (Debug) {
    Util.checkRealNumber(x, Transform, 'translate:x');
    Util.checkRealNumber(y, Transform, 'translate:y');
  }
  this.dx += this.m11 * x + this.m21 * y;
  this.dy += this.m12 * x + this.m22 * y;
};

Transform.prototype['scale'] =
/**
* @ignore
* Scales this Transform's matrix by sx and sy.
* This modifies this Transform.
* @this {Transform}
* @param {number} sx A number, that may be negative,
* but probably should not be zero.
* @param {number=} sy If not supplied, defaults to the first argument.
*/
Transform.prototype.scale = function(sx, sy) {
  if (sy === undefined/*notpresent*/) sy = sx;
  if (Debug) {
    Util.checkRealNumber(sx, Transform, 'translate:sx');
    Util.checkRealNumber(sy, Transform, 'translate:sy');
  }
  this.m11 *= sx;
  this.m12 *= sx;
  this.m21 *= sy;
  this.m22 *= sy;
};

Transform.prototype['transformPoint'] =
/**
* @ignore
* Modifies the given Point with this Transform.
* @this {Transform}
* @param {Point} p The point to transform with this Transform.
* @return {Point} the point P.
*/
Transform.prototype.transformPoint = function(p) {
  if (Debug) Util.checkClass(p, Point, Transform, 'transformPoint:p');
  var x = p._x;
  var y = p._y;
  p._x = x * this.m11 + y * this.m21 + this.dx;
  p._y = x * this.m12 + y * this.m22 + this.dy;
  return p;
};

Transform.prototype['invertedTransformPoint'] =
/**
* @ignore
* Modifies the given Point with the inverse of this Transform.
* @this {Transform}
* @param {Point} p The point to transform with the inverse of this Transform.
* @return {Point} the point P.
*/
Transform.prototype.invertedTransformPoint = function(p) {
  if (Debug) Util.checkClass(p, Point, Transform, 'invertedTransformPoint:p');

  var d = 1 / (this.m11 * this.m22 - this.m12 * this.m21);
  var m0 = this.m22 * d;
  var m1 = -this.m12 * d;
  var m2 = -this.m21 * d;
  var m3 = this.m11 * d;
  var m4 = d * (this.m21 * this.dy - this.m22 * this.dx);
  var m5 = d * (this.m12 * this.dx - this.m11 * this.dy);

  var x = p._x;
  var y = p._y;
  p._x = x * m0 + y * m2 + m4;
  p._y = x * m1 + y * m3 + m5;
  return p;
};

Transform.prototype['transformRect'] =
/**
* @ignore
* Modifies a rectangle (X, Y, W, H) with the bounds of the transformed Rect in
* the transformed coordinate system.
* @this {Transform}
* @param {Rect} rect the Rect to modify with the resulting bounds.
*/
Transform.prototype.transformRect = function(rect) {
  if (Debug) Util.checkClass(rect, Rect, Transform, 'transformRect:rect');

  var x = rect._x;
  var y = rect._y;
  var r = x + rect._width;
  var b = y + rect._height;

  var m0 = this.m11;
  var m1 = this.m12;
  var m2 = this.m21;
  var m3 = this.m22;
  var m4 = this.dx;
  var m5 = this.dy;

  var ltx = x * m0 + y * m2 + m4;
  var lty = x * m1 + y * m3 + m5;

  var rtx = r * m0 + y * m2 + m4;
  var rty = r * m1 + y * m3 + m5;

  var lbx = x * m0 + b * m2 + m4;
  var lby = x * m1 + b * m3 + m5;

  var rbx = r * m0 + b * m2 + m4;
  var rby = r * m1 + b * m3 + m5;

  var minx = ltx;
  var maxx = ltx;
  var miny = lty;
  var maxy = lty;

  minx = Math.min(minx, rtx);
  maxx = Math.max(maxx, rtx);
  miny = Math.min(miny, rty);
  maxy = Math.max(maxy, rty);

  minx = Math.min(minx, lbx);
  maxx = Math.max(maxx, lbx);
  miny = Math.min(miny, lby);
  maxy = Math.max(maxy, lby);

  minx = Math.min(minx, rbx);
  maxx = Math.max(maxx, rbx);
  miny = Math.min(miny, rby);
  maxy = Math.max(maxy, rby);

  rect._x = minx;
  rect._y = miny;
  rect._width = maxx - minx;
  rect._height = maxy - miny;
};

Transform.prototype['isIdentity'] =
/**
* @ignore
* @this {Transform}
* True if this transformation is the identity transformation.
* @return {boolean}
*/
Transform.prototype.isIdentity = function() {
  return (this.m11 === 1 && this.m12 === 0 && this.m21 === 0 &&
          this.m22 === 1 && this.dx === 0 && this.dy === 0);
};

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
Spot
*/


/**
 * The default constructor produces the Spot(0, 0, 0, 0), at the top-left corner.
 * @constructor
 * @param {number=} x The x value of the Spot. Default is zero.
 * @param {number=} y The y value of the Spot. Default is zero.
 * @param {number=} offx (Optional) The absolute x offset. Default is zero.
 * @param {number=} offy (Optional) The absolute y offset. Default is zero.
 * @category Geometry
 * @class
 * A Spot represents a relative point from (0,0) to (1,1) within the bounds of
 * a rectangular area plus an absolute offset.
 */
function Spot(x, y, offx, offy) {
  if (x === undefined/*notpresent*/) {  // zero args
    /** @type {number} */
    this._x = 0;
    /** @type {number} */
    this._y = 0;
    /** @type {number} */
    this._offsetX = 0;
    /** @type {number} */
    this._offsetY = 0;
  } else {  // one or more args
    if (y === undefined/*notpresent*/) y = 0;
    if (offx === undefined/*notpresent*/) offx = 0;
    if (offy === undefined/*notpresent*/) offy = 0;
    this.x = x;
    this.y = y;
    this.offsetX = offx;
    this.offsetY = offy;
  }
}

Util.publish('Spot', Spot);


/**
* @ignore
* Replace the properties of this Spot with those of another Spot.
* This can modify a frozen object.
* @this {Spot}
* @param {Spot} s the other Spot from which to copy property values.
*/
Spot.prototype.assign = function(s) {
  this._x = s._x;
  this._y = s._y;
  this._offsetX = s._offsetX;
  this._offsetY = s._offsetY;
};

Spot.prototype['setTo'] =
/**
* Modify this Spot with new X, Y, OffsetX, and OffsetY values.
* @this {Spot}
* @param {number} x
* @param {number} y
* @param {number} offx
* @param {number} offy
* @return {Spot} this.
*/
Spot.prototype.setTo = function(x, y, offx, offy) {
  if (Debug) {
    this._checkLocation(x, 'setTo:x');
    this._checkLocation(y, 'setTo:y');
    this._checkOffset(offx, 'setTo:offx');
    this._checkOffset(offy, 'setTo:offy');
  }
  Util.checkFrozen(this);
  this._x = x;
  this._y = y;
  this._offsetX = offx;
  this._offsetY = offy;
  return this;
};

Spot.prototype['set'] =
/**
* Modify this Spot so that its X, Y, OffsetX, and OffsetY values are the same as the given Spot.
* @this {Spot}
* @param {Spot} s the given Spot.
* @return {Spot} this.
*/
Spot.prototype.set = function(s) {
  if (Debug) Util.checkClass(s, Spot, Spot, 'set:s');
  Util.checkFrozen(this);
  this._x = s._x;
  this._y = s._y;
  this._offsetX = s._offsetX;
  this._offsetY = s._offsetY;
  return this;
};

/**
* Create a copy of this Spot, with the same values.
* @expose
* @this {Spot}
* @return {Spot}
*/
Spot.prototype.copy = function() {
  var copy = new Spot();
  copy._x = this._x;
  copy._y = this._y;
  copy._offsetX = this._offsetX;
  copy._offsetY = this._offsetY;
  return copy;
};

/**
* @ignore
* Make this object 'constant' and 'frozen'.
* Future attempts to change its state may result in an exception.
* This constant object may be shared freely.
* @this {Spot}
* @return {Spot}
*/
Spot.prototype.constant = function() {
  this._isFrozen = true;
  Object.freeze(this);
  return this;
};

/**
* @ignore
* If this object is 'constant', just return it.
* Otherwise make a copy of this object and freeze it ({@link #frozen}).
* @this {Spot}
* @return {Spot}
*/
Spot.prototype.copyFrozen = function() {
  if (Object.isFrozen(this)) return this;
  return this.copy().freeze();
};

/**
* @ignore
* Make this object 'frozen' or immutable.
* Future attempts to change its state, for example by setting any of its properties,
* may result in an exception, until it is thaw()'ed.
* @this {Spot}
* @return {Spot}
*/
Spot.prototype.freeze = function() {
  this._isFrozen = true;
  return this;
};

/**
* @ignore
* Make this object 'thawed' or mutable.
* @this {Spot}
* @return {Spot}
*/
Spot.prototype.thaw = function() {
  if (Object.isFrozen(this)) Util.throwError('cannot thaw constant: ' + this);
  this._isFrozen = false;
  return this;
};

/**
* @ignore
* @param {number} cat
* @return {Spot}
*/
Spot.prototype._special = function(cat) {
  this._x = NaN;
  this._y = NaN;
  this._offsetX = cat;
  return this;
};

/**
* @ignore
* @param {number} v
* @param {string} name
*/
Spot.prototype._checkLocation = function(v, name) {
  if (isNaN(v) || v > 1 || v < 0) {
    Util.throwRangeError(v, '0 <= ' + name + ' <= 1', Spot, name);
  }
};

/**
* @ignore
* @param {number} v
* @param {string} name
*/
Spot.prototype._checkOffset = function(v, name) {
  if (isNaN(v) || (v === Infinity) || (v === -Infinity)) {
    Util.throwRangeError(v, 'real number, not NaN or Infinity', Spot, name);
  }
};


Spot['parse'] =
/**
* This static method can be used to read in a {@link Spot} from a string that was produced by {@link Spot.stringify}.
* @param {string} str
* @return {Spot}
*/
Spot.parse = function(str) {
  if (typeof str === 'string') {
    str = str.trim();
    // handle all no-spot cases
    if (str === 'None') return Util.NONE;
    if (str === 'TopLeft') return Util.TOPLEFT;
    if (str === 'Top' || str === 'TopCenter' || str === 'MiddleTop') return Util.TOPCENTER;
    if (str === 'TopRight') return Util.TOPRIGHT;
    if (str === 'Left' || str === 'LeftCenter' || str === 'MiddleLeft') return Util.MIDDLELEFT;
    if (str === 'Center') return Util.CENTER;
    if (str === 'Right' || str === 'RightCenter' || str === 'MiddleRight') return Util.MIDDLERIGHT;
    if (str === 'BottomLeft') return Util.BOTTOMLEFT;
    if (str === 'Bottom' || str === 'BottomCenter' || str === 'MiddleBottom') return Util.BOTTOMCENTER;
    if (str === 'BottomRight') return Util.BOTTOMRIGHT;
    if (str === 'TopSide') return Util.TOPSIDE;
    if (str === 'LeftSide') return Util.LEFTSIDE;
    if (str === 'RightSide') return Util.RIGHTSIDE;
    if (str === 'BottomSide') return Util.BOTTOMSIDE;
    if (str === 'TopBottomSides') return Util.TOPBOTTOMSIDES;
    if (str === 'LeftRightSides') return Util.LEFTRIGHTSIDES;
    if (str === 'TopLeftSides') return Util.TOPLEFTSIDES;
    if (str === 'TopRightSides') return Util.TOPRIGHTSIDES;
    if (str === 'BottomLeftSides') return Util.BOTTOMLEFTSIDES;
    if (str === 'BottomRightSides') return Util.BOTTOMRIGHTSIDES;
    if (str === 'NotTopSide') return Util.NOTTOPSIDE;
    if (str === 'NotLeftSide') return Util.NOTLEFTSIDE;
    if (str === 'NotRightSide') return Util.NOTRIGHTSIDE;
    if (str === 'NotBottomSide') return Util.NOTBOTTOMSIDE;
    if (str === 'AllSides') return Util.ALLSIDES;
    if (str === 'Default') return Util.DEFAULT;

    // otherwise assume isSpot is true, and it has X,Y,OffsetX,OffsetY values
    var split = str.split(' ');
    var i = 0;
    var x = 0;
    while (split[i] === '') i++;
    var s = split[i++];
    if (s) x = parseFloat(s);
    var y = 0;
    while (split[i] === '') i++;
    s = split[i++];
    if (s) y = parseFloat(s);
    var ox = 0;
    while (split[i] === '') i++;
    s = split[i++];
    if (s) ox = parseFloat(s);
    var oy = 0;
    while (split[i] === '') i++;
    s = split[i++];
    if (s) oy = parseFloat(s);
    return new Spot(x, y, ox, oy);
  } else {
    return new Spot();
  }
};

Spot['stringify'] =
/**
* This static method can be used to write out a {@link Spot} as a string that can be read by {@link Spot.parse}.
* @param {Spot} val
* @return {string}
*/
Spot.stringify = function(val) {
  if (val instanceof Spot) {
    if (val.isSpot()) {
      return val.x.toString() + ' ' + val.y.toString() + ' ' + val.offsetX.toString() + ' ' + val.offsetY.toString();
    } else {
      return val.toString();  // no-spot values
    }
  } else {
    return val.toString();
  }
};


/**
* @ignore
* @this {Spot}
* @return {string}
*/
Spot.prototype.toString = function() {
  if (this.isSpot()) {
    if (this._offsetX === 0 && this._offsetY === 0) {
      return 'Spot(' + this.x + ',' + this.y + ')';
    } else {
      return 'Spot(' + this.x + ',' + this.y + ',' + this.offsetX + ',' + this.offsetY + ')';
    }
  } else {
    // just generate no-spot values
    if (this.equals(Util.NONE)) return 'None';
    if (this.equals(Util.TOPLEFT)) return 'TopLeft';
    if (this.equals(Util.TOPCENTER)) return 'Top';
    if (this.equals(Util.TOPRIGHT)) return 'TopRight';
    if (this.equals(Util.MIDDLELEFT)) return 'Left';
    if (this.equals(Util.CENTER)) return 'Center';
    if (this.equals(Util.MIDDLERIGHT)) return 'Right';
    if (this.equals(Util.BOTTOMLEFT)) return 'BottomLeft';
    if (this.equals(Util.BOTTOMCENTER)) return 'Bottom';
    if (this.equals(Util.BOTTOMRIGHT)) return 'BottomRight';
    if (this.equals(Util.TOPSIDE)) return 'TopSide';
    if (this.equals(Util.LEFTSIDE)) return 'LeftSide';
    if (this.equals(Util.RIGHTSIDE)) return 'RightSide';
    if (this.equals(Util.BOTTOMSIDE)) return 'BottomSide';
    if (this.equals(Util.TOPBOTTOMSIDES)) return 'TopBottomSides';
    if (this.equals(Util.LEFTRIGHTSIDES)) return 'LeftRightSides';
    if (this.equals(Util.TOPLEFTSIDES)) return 'TopLeftSides';
    if (this.equals(Util.TOPRIGHTSIDES)) return 'TopRightSides';
    if (this.equals(Util.BOTTOMLEFTSIDES)) return 'BottomLeftSides';
    if (this.equals(Util.BOTTOMRIGHTSIDES)) return 'BottomRightSides';
    if (this.equals(Util.NOTTOPSIDE)) return 'NotTopSide';
    if (this.equals(Util.NOTLEFTSIDE)) return 'NotLeftSide';
    if (this.equals(Util.NOTRIGHTSIDE)) return 'NotRightSide';
    if (this.equals(Util.NOTBOTTOMSIDE)) return 'NotBottomSide';
    if (this.equals(Util.ALLSIDES)) return 'AllSides';
    if (this.equals(Util.DEFAULT)) return 'Default';
    return 'None';
  }
};

Spot.prototype['equals'] =
/**
* Two spots are equal if all four property values are the same.
* @this {Spot}
* @param {Spot} spot The Spot to compare to the current Spot.
* @return {boolean} True if the two spots are equal, false otherwise.
*/
Spot.prototype.equals = function(spot) {
  if (!(spot instanceof Spot)) return false;
  return (
  (this._x === spot.x || (isNaN(this._x) && isNaN(spot.x))) &&
  (this._y === spot.y || (isNaN(this._y) && isNaN(spot.y))) &&
  this._offsetX === spot.offsetX && this._offsetY === spot.offsetY);
};

Spot.prototype['opposite'] =
/**
* Return a new spot that is opposite this spot.
* The X and Y values will be an equal distance
* away from the center on the other side of the center.
* The OffsetX and OffsetY values are also negated.
* <p/>
* The result is meaningless if {@link #isNoSpot} is true.
* @this {Spot}
* @return {Spot}
*/
Spot.prototype.opposite = function() {
  return new Spot(0.5 - (this._x - 0.5), 0.5 - (this._y - 0.5), -this._offsetX, -this._offsetY);
};

Spot.prototype['includesSide'] =
/**
* This predicate is true if this Spot is a side that
* includes the side(s) given by the argument Spot.
* @this {Spot}
* @param {Spot} side
* @return {boolean} false if either this Spot or the argument Spot is not a "Side";
* true if the side(s) that this Spot represents are a superset or the same set of
* sides represented by the argument Spot.
*/
Spot.prototype.includesSide = function(side) {
  if (!this.isSide()) return false;
  if (!side.isSide()) return false;
  var sides = this._offsetY;
  var s = side.offsetY;
  return ((sides & s) === s);
};

/**
 * Gets or sets the x value of the Spot, a fractional value between zero and one.
 * <p/>
 * The Spot(0,0) of a rectangle is at the top-left corner.
 * This value is commonly available as {@link Spot#TopLeft}.
 * The Spot(0.5,1) would be at the middle of the bottom side.
 * That value is commonly available as {@link Spot#MiddleBottom}.
 * @name Spot#x
 * @function.
 * @return {number}
 */
/** @type {number} */
Spot.prototype.x;
Util.exportProperty(Spot, 'x', Spot.prototype.x);
Util.defineProperty(Spot, {x: 'x'},
  /** @this {Spot} */
  function() { return this._x; },
  /** @this {Spot} */
  function(val) {
    Util.checkFrozen(this, val);
    if (Debug) this._checkLocation(val, 'x');
    this._x = val;
  }
);

/**
 * Gets or sets the y value of the Spot, a fractional value between zero and one.
 * <p/>
 * The Spot(0,1) of a rectangle is at the bottom-left corner.
 * This value is commonly available as {@link Spot#BottomLeft}.
 * The Spot(1,0.5) would be at the middle of the right side.
 * That value is commonly available as {@link Spot#MiddleRight}.
 * @name Spot#y
 * @function.
 * @return {number}
 */
/** @type {number} */
Spot.prototype.y;
Util.exportProperty(Spot, 'y', Spot.prototype.y);
Util.defineProperty(Spot, {y: 'y'},
  /** @this {Spot} */
  function() { return this._y; },
  /** @this {Spot} */
  function(val) {
    Util.checkFrozen(this, val);
    if (Debug) this._checkLocation(val, 'y');
    this._y = val;
  }
);

/**
 * Gets or sets the offsetX value of the Spot.
 * The value may be negative.
 * If this represents a side value instead of a specific spot, this value is meaningless.
 * <p/>
 * A Spot(0,0,5,5) of a large rectangle is near the top-left corner, inside the rectangle.
 * A Spot(1,1,5,5) would be near the bottom-right corner, outside the rectangle.
 * A Spot(1,1,-5,-5) would also be near the bottom-right corner, but inside the rectangle.
 * @name Spot#offsetX
 * @function.
 * @return {number}
 */
/** @type {number} */
Spot.prototype.offsetX;
Util.exportProperty(Spot, 'offsetX', Spot.prototype.offsetX);
Util.defineProperty(Spot, {offsetX: 'offsetX'},
  /** @this {Spot} */
  function() { return this._offsetX; },
  /** @this {Spot} */
  function(val) {
    Util.checkFrozen(this, val);
    if (Debug) this._checkOffset(val, 'offsetX');
    this._offsetX = val;
  }
);

/**
 * Gets or sets the offsetY value of the Spot.
 * The value may be negative.
 * If this represents a side value instead of a specific spot, this value is meaningless.
 * <p/>
 * A Spot(0,0,5,5) of a large rectangle is near the top-left corner, inside the rectangle.
 * A Spot(1,1,5,5) would be near the bottom-right corner, outside the rectangle.
 * A Spot(1,1,-5,-5) would also be near the bottom-right corner, but inside the rectangle.
 * @name Spot#offsetY
 * @function.
 * @return {number}
 */
/** @type {number} */
Spot.prototype.offsetY;
Util.exportProperty(Spot, 'offsetY', Spot.prototype.offsetY);
Util.defineProperty(Spot, {offsetY: 'offsetY'},
  /** @this {Spot} */
  function() { return this._offsetY; },
  /** @this {Spot} */
  function(val) {
    Util.checkFrozen(this, val);
    if (Debug) this._checkOffset(val, 'offsetY');
    this._offsetY = val;
  }
);

/**
* True if this is a specific spot, not a side nor {@link Spot#None}.
* @this {Spot}
* @return {boolean}
*/
Spot.prototype.isSpot = function() {  // represents a spot, not None nor a side
  return !isNaN(this.x) && !isNaN(this.y);
};

/**
* True if this is an unspecific special spot, such as {@link Spot#None}
* or one of the sides.
* @this {Spot}
* @return {boolean}
*/
Spot.prototype.isNoSpot = function() {  // could be === None or could be a side
  return isNaN(this.x) || isNaN(this.y);
};

/**
* True if this is a special spot referring to one (or more) of the sides.
* This is false if the spot is {@link Spot#None}.
* @this {Spot}
* @return {boolean}
*/
Spot.prototype.isSide = function() {
  return this.isNoSpot() && this.offsetX === 1 && this.offsetY !== 0;
};

/**
* True if this is a special spot referring to the default spot.
* @this {Spot}
* @return {boolean}
*/
Spot.prototype.isDefault = function() {
  return isNaN(this.x) && isNaN(this.y) && this.offsetX === -1 && this.offsetY === 0;
};


Util.MTop = 1;
Util.MLeft = 2;
Util.MRight = 4;
Util.MBottom = 8;

Util.NONE = new Spot(0, 0, 0, 0)._special(0).constant();
Util.DEFAULT = new Spot(0, 0, -1, 0)._special(-1).constant();
Util.TOPLEFT = new Spot(0.0, 0.0, 0, 0).constant();
Util.TOPCENTER = new Spot(0.5, 0.0, 0, 0).constant();
Util.TOPRIGHT = new Spot(1.0, 0.0, 0, 0).constant();
Util.MIDDLELEFT = new Spot(0.0, 0.5, 0, 0).constant();
Util.CENTER = new Spot(0.5, 0.5, 0, 0).constant();
Util.MIDDLERIGHT = new Spot(1.0, 0.5, 0, 0).constant();
Util.BOTTOMLEFT = new Spot(0.0, 1.0, 0, 0).constant();
Util.BOTTOMCENTER = new Spot(0.5, 1.0, 0, 0).constant();
Util.BOTTOMRIGHT = new Spot(1.0, 1.0, 0, 0).constant();

// Sides:
Util.TOPSIDE = new Spot(0, 0, 1, Util.MTop)._special(1).constant();
Util.LEFTSIDE = new Spot(0, 0, 1, Util.MLeft)._special(1).constant();
Util.RIGHTSIDE = new Spot(0, 0, 1, Util.MRight)._special(1).constant();
Util.BOTTOMSIDE = new Spot(0, 0, 1, Util.MBottom)._special(1).constant();
Util.TOPBOTTOMSIDES = new Spot(0, 0, 1, Util.MTop | Util.MBottom)._special(1).constant();
Util.LEFTRIGHTSIDES = new Spot(0, 0, 1, Util.MLeft | Util.MRight)._special(1).constant();
Util.TOPLEFTSIDES = new Spot(0, 0, 1, Util.MTop | Util.MLeft)._special(1).constant();
Util.TOPRIGHTSIDES = new Spot(0, 0, 1, Util.MTop | Util.MRight)._special(1).constant();
Util.BOTTOMLEFTSIDES = new Spot(0, 0, 1, Util.MBottom | Util.MLeft)._special(1).constant();
Util.BOTTOMRIGHTSIDES = new Spot(0, 0, 1, Util.MBottom | Util.MRight)._special(1).constant();
Util.NOTTOPSIDE = new Spot(0, 0, 1, Util.MLeft | Util.MRight | Util.MBottom)._special(1).constant();
Util.NOTLEFTSIDE = new Spot(0, 0, 1, Util.MTop | Util.MRight | Util.MBottom)._special(1).constant();
Util.NOTRIGHTSIDE = new Spot(0, 0, 1, Util.MTop | Util.MLeft | Util.MBottom)._special(1).constant();
Util.NOTBOTTOMSIDE = new Spot(0, 0, 1, Util.MTop | Util.MLeft | Util.MRight)._special(1).constant();
Util.ALLSIDES = new Spot(0, 0, 1, Util.MTop | Util.MLeft | Util.MRight | Util.MBottom)._special(1).constant();

/**
 * Use this Spot value to indicate no particular spot --
 * code looking for a particular point on an element will need to do their
 * own calculations to determine the desired point depending on the
 * circumstances.
 * @name Spot#None
 * @constant
 * @static
 * @return {Spot}
 */
Spot['None'] = Spot.None = Util.NONE;

/**
 * Use this value to indicate that the real spot value is inherited from elsewhere.
 * @name Spot#Default
 * @constant
 * @static
 * @return {Spot}
 */
Spot['Default'] = Spot.Default = Util.DEFAULT;


// Specific spots:

/**
 * The specific point at the top-left corner of the bounding rectangle.
 * @name Spot#TopLeft
 * @constant
 * @static
 * @return {Spot}
 */
Spot['TopLeft'] = Spot.TopLeft = Util.TOPLEFT;

/**
 * The specific point at the center of the top side of the bounding rectangle.
 * @name Spot#TopCenter
 * @constant
 * @static
 * @return {Spot}
 */
Spot['TopCenter'] = Spot.TopCenter = Util.TOPCENTER;

/**
 * The specific point at the top-right corner of the bounding rectangle.
 * @name Spot#TopRight
 * @constant
 * @static
 * @return {Spot}
 */
Spot['TopRight'] = Spot.TopRight = Util.TOPRIGHT;


/**
 * The specific point at the middle of the left side of bounding rectangle.
 * @name Spot#LeftCenter
 * @constant
 * @static
 * @return {Spot}
 */
Spot['LeftCenter'] = Spot.LeftCenter = Util.MIDDLELEFT;

/**
 * The specific point at the very center of the bounding rectangle.
 * @name Spot#Center
 * @constant
 * @static
 * @return {Spot}
 */
Spot['Center'] = Spot.Center = Util.CENTER;

/**
 * The specific point at the middle of the right side of bounding rectangle.
 * @name Spot#RightCenter
 * @constant
 * @static
 * @return {Spot}
 */
Spot['RightCenter'] = Spot.RightCenter = Util.MIDDLERIGHT;


/**
 * The specific point at the bottom-left corner of the bounding rectangle.
 * @name Spot#BottomLeft
 * @constant
 * @static
 * @return {Spot}
 */
Spot['BottomLeft'] = Spot.BottomLeft = Util.BOTTOMLEFT;

/**
 * The specific point at the middle of the bottom side of bounding rectangle.
 * @name Spot#BottomCenter
 * @constant
 * @static
 * @return {Spot}
 */
Spot['BottomCenter'] = Spot.BottomCenter = Util.BOTTOMCENTER;

/**
 * The specific point at the bottom-right corner of the bounding rectangle.
 * @name Spot#BottomRight
 * @constant
 * @static
 * @return {Spot}
 */
Spot['BottomRight'] = Spot.BottomRight = Util.BOTTOMRIGHT;


/**
 * A synonym for {@link Spot#TopCenter}.
 * @name Spot#MiddleTop
 * @constant
 * @static
 * @return {Spot}
 */
Spot['MiddleTop'] = Spot.MiddleTop = Util.TOPCENTER;

/**
 * A synonym for {@link Spot#LeftCenter}.
 * @name Spot#MiddleLeft
 * @constant
 * @static
 * @return {Spot}
 */
Spot['MiddleLeft'] = Spot.MiddleLeft = Util.MIDDLELEFT;

/**
 * A synonym for {@link Spot#RightCenter}.
 * @name Spot#MiddleRight
 * @constant
 * @static
 * @return {Spot}
 */
Spot['MiddleRight'] = Spot.MiddleRight = Util.MIDDLERIGHT;

/**
 * A synonym for {@link Spot#BottomCenter}.
 * @name Spot#MiddleBottom
 * @constant
 * @static
 * @return {Spot}
 */
Spot['MiddleBottom'] = Spot.MiddleBottom = Util.BOTTOMCENTER;


/**
 * A synonym for {@link Spot#TopCenter}.
 * @name Spot#Top
 * @constant
 * @static
 * @return {Spot}
 */
Spot['Top'] = Spot.Top = Util.TOPCENTER;

/**
 * A synonym for {@link Spot#LeftCenter}.
 * @name Spot#Left
 * @constant
 * @static
 * @return {Spot}
 */
Spot['Left'] = Spot.Left = Util.MIDDLELEFT;

/**
 * A synonym for {@link Spot#RightCenter}.
 * @name Spot#Right
 * @constant
 * @static
 * @return {Spot}
 */
Spot['Right'] = Spot.Right = Util.MIDDLERIGHT;

/**
 * A synonym for {@link Spot#BottomCenter}.
 * @name Spot#Bottom
 * @constant
 * @static
 * @return {Spot}
 */
Spot['Bottom'] = Spot.Bottom = Util.BOTTOMCENTER;


// Sides:

/**
 * The set of points at the top side of the bounding rectangle.
 * @name Spot#TopSide
 * @constant
 * @static
 * @return {Spot}
 */
Spot['TopSide'] = Spot.TopSide = Util.TOPSIDE;

/**
 * The set of points at the left side of the bounding rectangle.
 * @name Spot#LeftSide
 * @constant
 * @static
 * @return {Spot}
 */
Spot['LeftSide'] = Spot.LeftSide = Util.LEFTSIDE;

/**
 * The set of points at the right side of the bounding rectangle.
 * @name Spot#RightSide
 * @constant
 * @static
 * @return {Spot}
 */
Spot['RightSide'] = Spot.RightSide = Util.RIGHTSIDE;

/**
 * The set of points at the bottom side of the bounding rectangle.
 * @name Spot#BottomSide
 * @constant
 * @static
 * @return {Spot}
 */
Spot['BottomSide'] = Spot.BottomSide = Util.BOTTOMSIDE;

/**
 * The set of points at the top or bottom sides of the bounding rectangle.
 * @name Spot#TopBottomSides
 * @constant
 * @static
 * @return {Spot}
 */
Spot['TopBottomSides'] = Spot.TopBottomSides = Util.TOPBOTTOMSIDES;

/**
 * The set of points at the left or right sides of the bounding rectangle.
 * @name Spot#LeftRightSides
 * @constant
 * @static
 * @return {Spot}
 */
Spot['LeftRightSides'] = Spot.LeftRightSides = Util.LEFTRIGHTSIDES;

/**
 * The set of points at the top or left sides of the bounding rectangle.
 * @name Spot#TopLeftSides
 * @constant
 * @static
 * @return {Spot}
 */
Spot['TopLeftSides'] = Spot.TopLeftSides = Util.TOPLEFTSIDES;

/**
 * The set of points at the top or right sides of the bounding rectangle.
 * @name Spot#TopRightSides
 * @constant
 * @static
 * @return {Spot}
 */
Spot['TopRightSides'] = Spot.TopRightSides = Util.TOPRIGHTSIDES;

/**
 * The set of points at the left or bottom sides of the bounding rectangle.
 * @name Spot#BottomLeftSides
 * @constant
 * @static
 * @return {Spot}
 */
Spot['BottomLeftSides'] = Spot.BottomLeftSides = Util.BOTTOMLEFTSIDES;

/**
 * The set of points at the right or bottom sides of the bounding rectangle.
 * @name Spot#BottomRightSides
 * @constant
 * @static
 * @return {Spot}
 */
Spot['BottomRightSides'] = Spot.BottomRightSides = Util.BOTTOMRIGHTSIDES;

/**
 * The set of points on all sides of the bounding rectangle except top side.
 * @name Spot#NotTopSide
 * @constant
 * @static
 * @return {Spot}
 */
Spot['NotTopSide'] = Spot.NotTopSide = Util.NOTTOPSIDE;

/**
 * The set of points on all sides of the bounding rectangle except left side.
 * @name Spot#NotLeftSide
 * @constant
 * @static
 * @return {Spot}
 */
Spot['NotLeftSide'] = Spot.NotLeftSide = Util.NOTLEFTSIDE;

/**
 * The set of points on all sides of the bounding rectangle except right side.
 * @name Spot#NotRightSide
 * @constant
 * @static
 * @return {Spot}
 */
Spot['NotRightSide'] = Spot.NotRightSide = Util.NOTRIGHTSIDE;

/**
 * The set of points on all sides of bounding rectangle except bottom side.
 * @name Spot#NotBottomSide
 * @constant
 * @static
 * @return {Spot}
 */
Spot['NotBottomSide'] = Spot.NotBottomSide = Util.NOTBOTTOMSIDE;

/**
 * The set of points on all sides of the bounding rectangle.
 * @name Spot#AllSides
 * @constant
 * @static
 * @return {Spot}
 */
Spot['AllSides'] = Spot.AllSides = Util.ALLSIDES;

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
* This file defines the Geo static class
*/

/**
* Static Geo object for convenience functions
*/
var Geo = {
  // constant used to approximate a symmetrical arc using a cubic Bezier curve
  KAPPA: 4 * ((Math.sqrt(2) - 1) / 3),

  Origin: new Point(0, 0).constant(),

  ZeroRect: new Rect(0, 0, 0, 0).constant(),
  ZeroMargin: new Margin(0, 0, 0, 0).constant(),
  TwoMargin: new Margin(2, 2, 2, 2).constant(),

  UnlimitedSize: new Size(Infinity, Infinity).constant(),

  InfiniteTopLeft: new Point(-Infinity, -Infinity).constant(),
  InfiniteBottomRight: new Point(Infinity, Infinity).constant(),

  ZeroSize: new Size(0, 0).constant(),
  OneSize: new Size(1, 1).constant(),
  SixSize: new Size(6, 6).constant(),
  EightSize: new Size(8, 8).constant(),

  NoPoint: new Point(NaN, NaN).constant(),

  /**
  * @ignore
  * @type {Array.<number>}
  */
  Sqrts: null,

  /**
  * @ignore
  * Geo.sqrt is just used by Layouts, where use of Math.sqrt is too slow and the precision of the result is not so important
  * Use Math.sqrt instead when needing good precision.
  * @param {number} n
  * @return {number}
  */
  sqrt: function(n) {
    if (n <= 0) return 0;
    var a = Geo.Sqrts;
    if (a === null) {
      a = [];
      for (var i = 0; i <= 2000; i++) {
        a[i] = Math.sqrt(i);
      }
      Geo.Sqrts = a;
    }
    if (n < 1) {
      var x = 1 / n;
      if (x <= 2000) {
        return 1 / (a[x | 0]);
      } else {
        return Math.sqrt(n);
      }
    } else {
      if (n <= 2000) {
        return a[n | 0];
      } else {
        return Math.sqrt(n);
      }
    }
  },

  /**
  * @ignore
  * True if the difference between X and Y is less than 0.5.
  * @param {number} x
  * @param {number} y
  * @return {boolean}
  */
  isApprox: function(x, y) {
    var d = x - y;
    return d < 0.5 && d > -0.5;
  },

  /**
  * @ignore
  * True if the difference between X and Y is less than 0.00000005.
  * @param {number} x
  * @param {number} y
  * @return {boolean}
  */
  isApproxEqual: function(x, y) {
    var d = x - y;
    return d < 0.00000005 && d > -0.00000005;
  },

  /**
  * @ignore
  * See if P is near the line [A,B].
  * @param {number} ax
  * @param {number} ay
  * @param {number} bx
  * @param {number} by
  * @param {number} fuzz A double describing the resolution, with a minimum of 0.000001.
  * @param {number} px
  * @param {number} py
  * @return {boolean}
  */
  lineContainsPoint: function(ax, ay, bx, by, fuzz, px, py) {
    if (fuzz <= 0) fuzz = 0.000001;
    var maxx, minx, maxy, miny;
    if (ax < bx) {
      minx = ax;
      maxx = bx;
    } else {
      minx = bx;
      maxx = ax;
    }
    if (ay < by) {
      miny = ay;
      maxy = by;
    } else {
      miny = by;
      maxy = ay;
    }

    // do simple vertical and horizontal cases first,
    // without fuzz beyond the endpoints

    // ??? the added fuzz here fixes mitering errors on corners.
    // but the older version is being used because we do not want fuzz on endpoints.
    // in the future we should distinguish between endpoint line segments and non-enpoint segments.
    /*
    if (ax === bx) {
      return (miny - fuzz <= py && py <= maxy + fuzz &&
              ax - fuzz <= px && px <= ax + fuzz);
    }
    if (ay === by) {
      return (minx - fuzz <= px && px <= maxx + fuzz &&
              ay - fuzz <= py && py <= ay + fuzz);
    }*/

    // do simple vertical and horizontal cases first,
    // without fuzz beyond the endpoints
    if (ax === bx) return (miny <= py && py <= maxy &&
    ax - fuzz <= px && px <= ax + fuzz);
    if (ay === by) return (minx <= px && px <= maxx &&
    ay - fuzz <= py && py <= ay + fuzz);

    // if we're in the x-range, including fuzz,
    var xrange_high = maxx + fuzz;
    var xrange_low = minx - fuzz;
    if ((xrange_low <= px) && (px <= xrange_high)) {

      // and if we're in the y-range
      var yrange_high = maxy + fuzz;
      var yrange_low = miny - fuzz;
      if ((yrange_low <= py) && (py <= yrange_high)) {

        // see if we should compute the X coordinate or Y coordinate
        if (xrange_high - xrange_low > yrange_high - yrange_low) {
          if (ax - bx > fuzz || bx - ax > fuzz) {
            var slope = (by - ay) / (bx - ax);
            var guessY = (slope * (px - ax) + ay);

            if ((guessY - fuzz <= py) && (py <= guessY + fuzz)) {
              return true;
            }
          } else {
            return true;
          }
        } else {
          if (ay - by > fuzz || by - ay > fuzz) {
            var slope = (bx - ax) / (by - ay);
            var guessX = (slope * (py - ay) + ax);

            if ((guessX - fuzz <= px) && (px <= guessX + fuzz)) {
              return true;
            }
          } else {
            return true;
          }
        }
      }
    }
    return false;
  }, //end lineContainsPoint

  /**
  * @ignore
  * @param {number} sx
  * @param {number} sy
  * @param {number} c1x
  * @param {number} c1y
  * @param {number} c2x
  * @param {number} c2y
  * @param {number} ex
  * @param {number} ey
  * @param {number} epsilon
  * @param {number} px
  * @param {number} py
  * @param {number} thickness
  * @return {boolean}
  */
  bezierContainsPoint: function(sx, sy, c1x, c1y, c2x, c2y, ex, ey, epsilon, px, py, thickness) {
    if (!Geo.lineContainsPoint(sx, sy, ex, ey, thickness, c1x, c1y) ||
        !Geo.lineContainsPoint(sx, sy, ex, ey, thickness, c2x, c2y)) {
      var a1x = (sx + c1x) / 2;
      var a1y = (sy + c1y) / 2;
      var a2x = (c1x + c2x) / 2;
      var a2y = (c1y + c2y) / 2;
      var a3x = (c2x + ex) / 2;
      var a3y = (c2y + ey) / 2;

      var vx = (a1x + a2x) / 2;
      var vy = (a1y + a2y) / 2;
      var wx = (a2x + a3x) / 2;
      var wy = (a2y + a3y) / 2;
      var mx = (vx + wx) / 2;
      var my = (vy + wy) / 2;
      return Geo.bezierContainsPoint(sx, sy, a1x, a1y, vx, vy, mx, my, epsilon, px, py, thickness) ||
             Geo.bezierContainsPoint(mx, my, wx, wy, a3x, a3y, ex, ey, epsilon, px, py, thickness);
    } else {
      return Geo.lineContainsPoint(sx, sy, ex, ey, thickness, px, py);
    }
  },

  /**
  * @ignore
  * @param {number} sx
  * @param {number} sy
  * @param {number} c1x
  * @param {number} c1y
  * @param {number} c2x
  * @param {number} c2y
  * @param {number} ex
  * @param {number} ey
  * @param {Point} midp  Modified to hold the result.
  * @return {Point}
  */
  bezierMidPoint: function(sx, sy, c1x, c1y, c2x, c2y, ex, ey, midp) {
    var m1x = (sx + c1x) / 2;
    var m1y = (sy + c1y) / 2;
    var m2x = (c1x + c2x) / 2;
    var m2y = (c1y + c2y) / 2;
    var m3x = (c2x + ex) / 2;
    var m3y = (c2y + ey) / 2;

    var vx = (m1x + m2x) / 2;
    var vy = (m1y + m2y) / 2;
    var wx = (m2x + m3x) / 2;
    var wy = (m2y + m3y) / 2;

    midp.x = (vx + wx) / 2;
    midp.y = (vy + wy) / 2;
    return midp;
  },

  /**
  * @ignore
  * @param {number} sx
  * @param {number} sy
  * @param {number} c1x
  * @param {number} c1y
  * @param {number} c2x
  * @param {number} c2y
  * @param {number} ex
  * @param {number} ey
  * @return {number}
  */
  bezierMidAngle: function(sx, sy, c1x, c1y, c2x, c2y, ex, ey) {
    var m1x = (sx + c1x) / 2;
    var m1y = (sy + c1y) / 2;
    var m2x = (c1x + c2x) / 2;
    var m2y = (c1y + c2y) / 2;
    var m3x = (c2x + ex) / 2;
    var m3y = (c2y + ey) / 2;

    var vx = (m1x + m2x) / 2;
    var vy = (m1y + m2y) / 2;
    var wx = (m2x + m3x) / 2;
    var wy = (m2y + m3y) / 2;

    return Point.direction(vx, vy, wx, wy);
  },

  // ??? epsilon is usually 0.1 but is slow. Values have been bumped to 0.5 temporarily
  /**
  * @ignore
  * @param {number} sx
  * @param {number} sy
  * @param {number} c1x
  * @param {number} c1y
  * @param {number} c2x
  * @param {number} c2y
  * @param {number} ex
  * @param {number} ey
  * @param {number} epsilon
  * @param {Rect} result a Rect that is modified to hold the union of the points on the line.
  * @return {Rect}
  */
  bezierBounds: function(sx, sy, c1x, c1y, c2x, c2y, ex, ey, epsilon, result) {
    if (!Geo.lineContainsPoint(sx, sy, ex, ey, epsilon, c1x, c1y) ||
        !Geo.lineContainsPoint(sx, sy, ex, ey, epsilon, c2x, c2y)) {
      var a1x = (sx + c1x) / 2;
      var a1y = (sy + c1y) / 2;
      var a2x = (c1x + c2x) / 2;
      var a2y = (c1y + c2y) / 2;
      var a3x = (c2x + ex) / 2;
      var a3y = (c2y + ey) / 2;

      var vx = (a1x + a2x) / 2;
      var vy = (a1y + a2y) / 2;
      var wx = (a2x + a3x) / 2;
      var wy = (a2y + a3y) / 2;
      var mx = (vx + wx) / 2;
      var my = (vy + wy) / 2;

      Geo.bezierBounds(sx, sy, a1x, a1y, vx, vy, mx, my, epsilon, result);
      Geo.bezierBounds(mx, my, wx, wy, a3x, a3y, ex, ey, epsilon, result);
    } else {
      result.unionNoCheck(sx, sy, 0, 0);
      result.unionNoCheck(ex, ey, 0, 0);
    }
    return result;
  },

  // return a bunch of line segments describing the bezier curve
  /**
  * @ignore
  * @param {number} sx
  * @param {number} sy
  * @param {number} c1x
  * @param {number} c1y
  * @param {number} c2x
  * @param {number} c2y
  * @param {number} ex
  * @param {number} ey
  * @param {number} epsilon
  * @param {Array} result an Array that holds line segments roughly describing the bezier.
  * @return {Array}
  */
  bezierLines: function(sx, sy, c1x, c1y, c2x, c2y, ex, ey, epsilon, result) {
    if (!Geo.lineContainsPoint(sx, sy, ex, ey, epsilon, c1x, c1y) ||
        !Geo.lineContainsPoint(sx, sy, ex, ey, epsilon, c2x, c2y)) {
      var a1x = (sx + c1x) / 2;
      var a1y = (sy + c1y) / 2;
      var a2x = (c1x + c2x) / 2;
      var a2y = (c1y + c2y) / 2;
      var a3x = (c2x + ex) / 2;
      var a3y = (c2y + ey) / 2;

      var vx = (a1x + a2x) / 2;
      var vy = (a1y + a2y) / 2;
      var wx = (a2x + a3x) / 2;
      var wy = (a2y + a3y) / 2;
      var mx = (vx + wx) / 2;
      var my = (vy + wy) / 2;

      Geo.bezierLines(sx, sy, a1x, a1y, vx, vy, mx, my, epsilon, result);
      Geo.bezierLines(mx, my, wx, wy, a3x, a3y, ex, ey, epsilon, result);
    } else {
      if (result.length === 0) result.push([sx, sy]);
      result.push([ex, ey]);
    }
    return result;
  },

  /**
  * @ignore
  * @param {number} sx
  * @param {number} sy
  * @param {number} cx
  * @param {number} cy
  * @param {number} ex
  * @param {number} ey
  * @param {number} epsilon
  * @param {number} px
  * @param {number} py
  * @return {boolean}
  */
  quadraticBezierContainsPoint: function(sx, sy, cx, cy, ex, ey, epsilon, px, py, thickness) {
    if (!Geo.lineContainsPoint(sx, sy, ex, ey, thickness, cx, cy)) {
      var a1x = (sx + cx) / 2;
      var a1y = (sy + cy) / 2;
      var a2x = (cx + ex) / 2;
      var a2y = (cy + ey) / 2;

      var mx = (a1x + a2x) / 2;
      var my = (a1y + a2y) / 2;

      return Geo.quadraticBezierContainsPoint(sx, sy, a1x, a1y, mx, my, epsilon, px, py, thickness) ||
             Geo.quadraticBezierContainsPoint(mx, my, a2x, a2y, ex, ey, epsilon, px, py, thickness);
    } else {
      return Geo.lineContainsPoint(sx, sy, ex, ey, thickness, px, py);
    }
  },

  /**
  * @ignore
  * @param {number} sx
  * @param {number} sy
  * @param {number} cx
  * @param {number} cy
  * @param {number} ex
  * @param {number} ey
  * @param {Point} midp  Modified to hold the result.
  * @return {Point}
  */
  quadraticBezierMidPoint: function(sx, sy, cx, cy, ex, ey, midp) {
    var m1x = (sx + cx) / 2;
    var m1y = (sy + cy) / 2;
    var m2x = (cx + ex) / 2;
    var m2y = (cy + ey) / 2;

    midp.x = (m1x + m2x) / 2;
    midp.y = (m1y + m2y) / 2;
    return midp;
  },

  /**
  * @ignore
  * @param {number} sx
  * @param {number} sy
  * @param {number} cx
  * @param {number} cy
  * @param {number} ex
  * @param {number} ey
  * @param {number} epsilon
  * @param {Rect} result a Rect that is modified to hold the union of the points on the line.
  * @return {Rect}
  */
  quadraticBezierBounds: function(sx, sy, cx, cy, ex, ey, epsilon, result) {
    if (!Geo.lineContainsPoint(sx, sy, ex, ey, epsilon, cx, cy)) {
      var a1x = (sx + cx) / 2;
      var a1y = (sy + cy) / 2;
      var a2x = (cx + ex) / 2;
      var a2y = (cy + ey) / 2;

      var mx = (a1x + a2x) / 2;
      var my = (a1y + a2y) / 2;

      Geo.quadraticBezierBounds(sx, sy, a1x, a1y, mx, my, epsilon, result);
      Geo.quadraticBezierBounds(mx, my, a2x, a2y, ex, ey, epsilon, result);
    } else {
      result.unionNoCheck(sx, sy, 0, 0);
      result.unionNoCheck(ex, ey, 0, 0);
    }
    return result;
  },

  // return a bunch of line segments describing the bezier curve
  /**
  * @ignore
  * @param {number} sx
  * @param {number} sy
  * @param {number} cx
  * @param {number} cy
  * @param {number} ex
  * @param {number} ey
  * @param {number} epsilon
  * @param {Array} result an Array that holds line segments roughly describing the bezier.
  * @return {Array}
  */
  quadraticBezierLines: function(sx, sy, cx, cy, ex, ey, epsilon, result) {
    if (!Geo.lineContainsPoint(sx, sy, ex, ey, epsilon, cx, cy)) {
      var a1x = (sx + cx) / 2;
      var a1y = (sy + cy) / 2;
      var a2x = (cx + ex) / 2;
      var a2y = (cy + ey) / 2;

      var mx = (a1x + a2x) / 2;
      var my = (a1y + a2y) / 2;

      Geo.quadraticBezierLines(sx, sy, a1x, a1y, mx, my, epsilon, result);
      Geo.quadraticBezierLines(mx, my, a2x, a2y, ex, ey, epsilon, result);
    } else {
      if (result.length === 0) result.push([sx, sy]);
      result.push([ex, ey]);
    }
    return result;
  },

  /**
  * @ignore
  * @param {number} sx
  * @param {number} sy
  * @param {number} c1x
  * @param {number} c1y
  * @param {number} c2x
  * @param {number} c2y
  * @param {number} ex
  * @param {number} ey
  * @param {number} p1x
  * @param {number} p1y
  * @param {number} p2x
  * @param {number} p2y
  * @param {number} epsilon
  * @param {Point} R a Point that is modified to hold the union of the points on the line.
  * @return {boolean}
  */
  bezierNearestIntersectionOnLine: function(sx, sy, c1x, c1y, c2x, c2y, ex, ey, p1x, p1y, p2x, p2y, epsilon, R) {
    if (epsilon <= 0) epsilon = .000001;
    if (!Geo.lineContainsPoint(sx, sy, ex, ey, epsilon, c1x, c1y) ||
        !Geo.lineContainsPoint(sx, sy, ex, ey, epsilon, c2x, c2y)) {
      var a1x = (sx + c1x) / 2;
      var a1y = (sy + c1y) / 2;
      var a2x = (c1x + c2x) / 2;
      var a2y = (c1y + c2y) / 2;
      var a3x = (c2x + ex) / 2;
      var a3y = (c2y + ey) / 2;
      var vx = (a1x + a2x) / 2;
      var vy = (a1y + a2y) / 2;
      var wx = (a2x + a3x) / 2;
      var wy = (a2y + a3y) / 2;
      var mx = (vx + wx) / 2;
      var my = (vy + wy) / 2;

      var dist = (p2x - p1x) * (p2x - p1x) + (p2y - p1y) * (p2y - p1y);
      var fnd = false;

      if (Geo.bezierNearestIntersectionOnLine(sx, sy, a1x, a1y, vx, vy, mx, my, p1x, p1y, p2x, p2y, epsilon, R)) {
        var tempdist = (R.x - p1x) * (R.x - p1x) + (R.y - p1y) * (R.y - p1y);
        if (tempdist < dist) {
          dist = tempdist;
          fnd = true;
        }
      }
      var Rx = R.x;
      var Ry = R.y;
      if (Geo.bezierNearestIntersectionOnLine(mx, my, wx, wy, a3x, a3y, ex, ey, p1x, p1y, p2x, p2y, epsilon, R)) {
        var tempdist = (R.x - p1x) * (R.x - p1x) + (R.y - p1y) * (R.y - p1y);
        if (tempdist < dist) {
          dist = tempdist;
          fnd = true;
        }
        else {
          R.x = Rx; R.y = Ry;
        }
      }
      return fnd;
    } else {

      var d = (sx - ex) * (p1y - p2y) - (sy - ey) * (p1x - p2x);
      if (!d) { return false; }
      var xint = ((sx * ey - sy * ex) * (p1x - p2x) - (sx - ex) * (p1x * p2y - p1y * p2x)) / d;
      var yint = ((sx * ey - sy * ex) * (p1y - p2y) - (sy - ey) * (p1x * p2y - p1y * p2x)) / d;

      if ((p1x > p2x ? p1x - p2x : p2x - p1x) < (p1y > p2y ? p1y - p2y : p2y - p1y)) {
        var min, max;
        if (sy < ey) { min = sy, max = ey; } else { min = ey; max = sy; }
        if (yint < min || yint > max) { return false; }
      }
      else {
        var min, max;
        if (sx < ex) { min = sx, max = ex; } else { min = ex; max = sx; }
        if (xint < min || xint > max) { return false; }
      }
      R.x = xint; R.y = yint;
      return true;
    }
  },

  /**
  * @ignore
  * @param {number} sx
  * @param {number} sy
  * @param {number} c1x
  * @param {number} c1y
  * @param {number} c2x
  * @param {number} c2y
  * @param {number} ex
  * @param {number} ey
  * @param {number} p1x
  * @param {number} p1y
  * @param {number} p2x
  * @param {number} p2y
  * @param {number} epsilon
  * @return {number}
  */
  bezierWinding: function(sx, sy, c1x, c1y, c2x, c2y, ex, ey, p1x, p1y, p2x, p2y, epsilon) {
    var res = 0;
    if (epsilon <= 0) epsilon = .000001;
    if (!Geo.lineContainsPoint(sx, sy, ex, ey, epsilon, c1x, c1y) ||
        !Geo.lineContainsPoint(sx, sy, ex, ey, epsilon, c2x, c2y)) {

      var a1x = (sx + c1x) / 2;
      var a1y = (sy + c1y) / 2;
      var a2x = (c1x + c2x) / 2;
      var a2y = (c1y + c2y) / 2;
      var a3x = (c2x + ex) / 2;
      var a3y = (c2y + ey) / 2;
      var vx = (a1x + a2x) / 2;
      var vy = (a1y + a2y) / 2;
      var wx = (a2x + a3x) / 2;
      var wy = (a2y + a3y) / 2;
      var mx = (vx + wx) / 2;
      var my = (vy + wy) / 2;

      res += Geo.bezierWinding(sx, sy, a1x, a1y, vx, vy, mx, my, p1x, p1y, p2x, p2y, epsilon);
      res += Geo.bezierWinding(mx, my, wx, wy, a3x, a3y, ex, ey, p1x, p1y, p2x, p2y, epsilon);
    } else {

      var d = (sx - ex) * (p1y - p2y) - (sy - ey) * (p1x - p2x);
      if (!d) { return res; }
      var xint = ((sx * ey - sy * ex) * (p1x - p2x) - (sx - ex) * (p1x * p2y - p1y * p2x)) / d;
      var yint = ((sx * ey - sy * ex) * (p1y - p2y) - (sy - ey) * (p1x * p2y - p1y * p2x)) / d;

      if (xint >= p2x) { return res; } // has to be on correct side

      if ((p1x > p2x ? p1x - p2x : p2x - p1x) < (p1y > p2y ? p1y - p2y : p2y - p1y)) {
        var min, max;
        if (sy < ey) { min = sy, max = ey; } else { min = ey; max = sy; }
        if (yint < min || yint > max) { return res; }
      }
      else {
        var min, max;
        if (sx < ex) { min = sx, max = ex; } else { min = ex; max = sx; }
        if (xint < min || xint > max) { return res; }
      }

      if (d > 0) { res++; }
      else if (d < 0) { res--; }
    }
    return res;
  },

  /**
  * @ignore
  * Return a point on a straight line segment that is closest to a given point.
  * @param {number} Ax One end of the line.
  * @param {number} Ay
  * @param {number} Bx The other end of the line.
  * @param {number} By
  * @param {number} Px The point to be closest to.
  * @param {number} Py
  * @param {Point} result Modified to be a point that is on the finite length straight line segment from A-B.
  * @return {boolean} true if the point P is on on a perpendicular line to the line segment;
  *    false if the point P is beyond either end of the line segment.
  *    When this returns false, the RESULT will be either A or B.
  */
  nearestPointOnLine: function(Ax, Ay, Bx, By, Px, Py, result) {
    // A and B are the endpoints of this segment
    // P is the point we want to get closest to

    // handle vertical and horizontal lines specially
    if (Geo.isApproxEqual(Ax, Bx)) { // was ==
      var min, max;
      if (Ay < By) {
        min = Ay;
        max = By;
      } else {
        min = By;
        max = Ay;
      }
      var newp = Py;
      if (newp < min) {
        result.x = Ax;
        result.y = min;
        return false;
      }
      if (newp > max) {
        result.x = Ax;
        result.y = max;
        return false;
      }
      result.x = Ax;
      result.y = newp;
      return true;
    } else if (Geo.isApproxEqual(Ay, By)) {
      var min, max;
      if (Ax < Bx) {
        min = Ax;
        max = Bx;
      } else {
        min = Bx;
        max = Ax;
      }
      var newp = Px;
      if (newp < min) {
        result.x = min;
        result.y = Ay;
        return false;
      }
      if (newp > max) {
        result.x = max;
        result.y = Ay;
        return false;
      }
      result.x = newp;
      result.y = Ay;
      return true;
    } else {
      // ought to take sqrt to get real length, but don't bother...
      var L = (Bx - Ax) * (Bx - Ax) + (By - Ay) * (By - Ay);
      // ought to be dividing By L^2, but didn't bother to sqrt!
      var Q = ((Ax - Px) * (Ax - Bx) + (Ay - Py) * (Ay - By)) / L;

      if (Q < -0.000005) {
        result.x = Ax;
        result.y = Ay;
        return false;
      } else if (Q > 1.000005) {
        result.x = Bx;
        result.y = By;
        return false;
      } else {
        // OK to use point on line between A and B
        var x = Ax + Q * (Bx - Ax);
        var y = Ay + Q * (By - Ay);
        result.x = x;
        result.y = y;
        return true;
      }
    }
  },

  /**
  * @ignore
  * Find the intersection point of the finite line segment A-B and the
  * infinite line P-Q
  * that is closest to point P.
  * result is out variable fixed
  * @param {number} Ax
  * @param {number} Ay
  * @param {number} Bx
  * @param {number} By
  * @param {number} Px
  * @param {number} Py
  * @param {number} Qx
  * @param {number} Qy
  * @param {Point} result
  * @return {boolean}
  */
  nearestIntersectionOnLine: function(Ax, Ay, Bx, By, Px, Py, Qx, Qy, result) {
    if (Geo.isApprox(Ax, Bx) && Geo.isApprox(Ay, By)) {
      result.x = Ax;
      result.y = Ay;
      return false;
    }

    if (Geo.isApproxEqual(Px, Qx)) {  // P-Q line is vertical
      if (Geo.isApproxEqual(Ax, Bx)) {  // parallel vertical lines: just return closest point
        Geo.nearestPointOnLine(Ax, Ay, Bx, By, Px, Py, result);
        return false;
      }
      else {  // line segment A-B is not vertical, but P-Q is
        var M = (By - Ay) / (Bx - Ax);
        var y = M * (Px - Ax) + Ay;
        return Geo.nearestPointOnLine(Ax, Ay, Bx, By, Px, y, result);
      }
    }
    else {
      var S = (Qy - Py) / (Qx - Px);
      if (Geo.isApproxEqual(Ax, Bx)) {  // line segment A-B is vertical, but P-Q is not
        var y = S * (Ax - Px) + Py;
        var min, max;
        if (Ay < By) { min = Ay; max = By; }
        else { min = By; max = Ay; }
        if (y < min) {
          result.x = Ax;
          result.y = min;
          return false;
        }
        if (y > max) {
          result.x = Ax;
          result.y = max;
          return false;
        }
        result.x = Ax;
        result.y = y;
        return true;
      }
      else {  // neither line is vertical
        var M = (By - Ay) / (Bx - Ax);
        if (Geo.isApproxEqual(S, M)) {  // parallel lines--easiest to just return closest point
          Geo.nearestPointOnLine(Ax, Ay, Bx, By, Px, Py, result);
          return false;
        } else {
          var x = (M * Ax - S * Px + Py - Ay) / (M - S);
          if (Geo.isApproxEqual(M, 0)) {  // line segment A-B is horizontal
            var min, max;
            if (Ax < Bx) { min = Ax; max = Bx; }
            else { min = Bx; max = Ax; }
            if (x < min) {
              result.x = min;
              result.y = Ay;
              return false;
            }
            if (x > max) {
              result.x = max;
              result.y = Ay;
              return false;
            }
            result.x = x;
            result.y = Ay;
            return true;
          }
          else {
            var y = M * (x - Ax) + Ay;
            return Geo.nearestPointOnLine(Ax, Ay, Bx, By, x, y, result);
          }
        }
      }
    }
  },

  /**
  * @ignore
  * Returns true if line(line1, line2) intersects with line
  * segment(seg1, seg2) and sets [intersection] to the point
  * @param {Point} line1
  * @param {Point} line2
  * @param {Point} seg1
  * @param {Point} seg2
  * @param {Point} intersection modified to hold result.
  * @return {boolean}
  */
  lineIntersectsWithSegment: function(line1, line2, seg1, seg2, intersection) {
    return Geo.nearestIntersectionOnLine(seg1.x, seg1.y, seg2.x, seg2.y, line1.x, line1.y, line2.x, line2.y, intersection)
  },

  /**
  * @ignore
  * Returns the closest intersection between the infinite line L1-L2
  * and the ellipse in the rectangle S-E, and accounting for a strokeWidth SW.
  * @param {number} l1x
  * @param {number} l1y
  * @param {number} l2x
  * @param {number} l2y
  * @param {number} sx
  * @param {number} sy
  * @param {number} ex
  * @param {number} ey
  * @param {Point} result
  * @param {number} sw
  * @return {Point}
  */
  getNearestLineEllipseIntersection: function(l1x, l1y, l2x, l2y, sx, sy, ex, ey, result, sw) {
    var dist2 = Infinity;
    /** @ignore */
    function dist(x1, y1) {
      var d = (x1 - l1x) * (x1 - l1x) + (y1 - l1y) * (y1 - l1y);
      if (d < dist2) { dist2 = d; result.x = x1; result.y = y1; }
    }

    dist(result.x, result.y);

    // Now, check for the actual intersections
    var rectL, rectR, rectT, rectB;
    if (sx < ex) { rectL = sx; rectR = ex; } else { rectL = ex; rectR = sx; }
    if (sy < ey) { rectT = sx; rectB = ex; } else { rectT = ex; rectB = sx; }
    var rectW = rectR - rectL; var rectH = rectB - rectT;
    var ax = rectW / 2 + sw;
    var by = rectH / 2 + sw;
    var centerX = (sx + ex) / 2;
    var centerY = (sy + ey) / 2; // center assuming 2ax*2bx is the size
    // No space is occupied if radii are 0
    if (ax === 0 || by === 0) return result;
    if ((l2x > l1x ? l2x - l1x : l1x - l2x) < 0.5) { // If it's a vertical line
      var disc = 1 - (l2x - centerX) * (l2x - centerX) / (ax * ax);
      if (disc < 0) return result;
      var disc2 = Math.sqrt(disc);
      var y1 = by * disc2 + centerY;
      var y2 = -by * disc2 + centerY;
      dist(l2x, y1);
      dist(l2x, y2);
    }
    else // Else we need to quadratic formula
    {
      var slope = (l2y - l1y) / (l2x - l1x);
      var a = 1 / (ax * ax) + (slope * slope) / (by * by);
      var b = 2 * slope * (l1y - slope * l1x) /
        (by * by) - 2 * slope * centerY /
        (by * by) - 2 * centerX / (ax * ax);
      var c = 2 * slope * l1x * centerY /
        (by * by) - 2 * l1y * centerY / (by * by) +
        centerY * centerY / (by * by) + centerX *
        centerX / (ax * ax) - 1 + (l1y - slope * l1x) *
        (l1y - slope * l1x) / (by * by);

      // Quadratic Formula to find intersections:
      var discriminant = b * b - 4 * a * c;
      if (discriminant < 0)
        return result; // No intersections
      var disc2 = Math.sqrt(discriminant);
      var intX1 = (-b + disc2) / (2 * a);
      dist(intX1, slope * intX1 - slope * l1x + l1y);
      var intX2 = (-b - disc2) / (2 * a);
      dist(intX2, slope * intX2 - slope * l1x + l1y);
    }
    return result;
  },

  // uses no points except the result point
  /**
  * @ignore
  * Find the closest point of a rectangle to a given point that is on a line from that point.
  * @param {number} l
  * @param {number} r
  * @param {number} t
  * @param {number} b
  * @param {number} Cx
  * @param {number} Cy
  * @param {number} Dx
  * @param {number} Dy
  * @param {Point} result
  * @return {boolean} true if the infinite line does intersect with the rectangle; false otherwise.
  */
  getNearestIntersectionPoint: function(l, t, r, b, Cx, Cy, Dx, Dy, result) {
    var closestdist = 10e20;
    var closestx = l;
    var closesty = t;
    if (Geo.nearestIntersectionOnLine(l, t, l, b, Cx, Cy, Dx, Dy, result)) {
      // calculate the (non-square-rooted) distance from C to result
      var dist = (result.x - Cx) * (result.x - Cx) + (result.y - Cy) * (result.y - Cy);
      if (dist < closestdist) {
        closestdist = dist;
        closestx = result.x;
        closesty = result.y;
      }
    }

    if (Geo.nearestIntersectionOnLine(r, t, r, b, Cx, Cy, Dx, Dy, result)) {
      var dist = (result.x - Cx) * (result.x - Cx) + (result.y - Cy) * (result.y - Cy);
      if (dist < closestdist) {
        closestdist = dist;
        closestx = result.x;
        closesty = result.y;
      }
    }

    if (Geo.nearestIntersectionOnLine(l, t, r, t, Cx, Cy, Dx, Dy, result)) {
      var dist = (result.x - Cx) * (result.x - Cx) + (result.y - Cy) * (result.y - Cy);
      if (dist < closestdist) {
        closestdist = dist;
        closestx = result.x;
        closesty = result.y;
      }
    }

    if (Geo.nearestIntersectionOnLine(l, b, r, b, Cx, Cy, Dx, Dy, result)) {
      var dist = (result.x - Cx) * (result.x - Cx) + (result.y - Cy) * (result.y - Cy);
      if (dist < closestdist) {
        closestdist = dist;
        closestx = result.x;
        closesty = result.y;
      }
    }

    result.x = closestx;
    result.y = closesty;
    return (closestdist < 10e20);
  },

  /**
  * @ignore
  * @param {Rect} rect
  * @param {Point} p1
  * @param {Point} p2
  * @return {boolean}
  */
  intersectsLineSegment: function(rect, p1, p2) {
    var p1x = p1.x, p1y = p1.y, p2x = p2.x, p2y = p2.y;
    var l = rect.left, r = rect.right, t = rect.top, b = rect.bottom;
    if (p1x === p2x) {
      var min, max;
      if (p1y < p2y) { min = p1y; max = p2y; } else { min = p2y; max = p1y; }
      return (l <= p1x && p1x <= r && min <= b && max >= t);
    }
    if (p1y === p2y) {
      var min, max;
      if (p1x < p2x) { min = p1x; max = p2x; } else { min = p2x; max = p1x; }
      return (t <= p1y && p1y <= b && min <= r && max >= l);
    }
    if (rect.containsPoint(p1))
      return true;
    if (rect.containsPoint(p2))
      return true;
    if (Geo.intersectingLineSegments(l, t, r, t, p1x, p1y, p2x, p2y))
      return true;
    if (Geo.intersectingLineSegments(r, t, r, b, p1x, p1y, p2x, p2y))
      return true;
    if (Geo.intersectingLineSegments(r, b, l, b, p1x, p1y, p2x, p2y))
      return true;
    if (Geo.intersectingLineSegments(l, b, l, t, p1x, p1y, p2x, p2y))
      return true;
    return false;
  },

  /**
  * @ignore
  * This predicate returns true if two finite straight line segments intersect.
  * @param {number} a1x
  * @param {number} a1y
  * @param {number} a2x
  * @param {number} a2y
  * @param {number} b1x
  * @param {number} b1y
  * @param {number} b2x
  * @param {number} b2y
  * @return {boolean}
  */
  intersectingLineSegments: function(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
    return ((Geo.comparePointWithLine(a1x, a1y, a2x, a2y, b1x, b1y) * Geo.comparePointWithLine(a1x, a1y, a2x, a2y, b2x, b2y) <= 0) &&
            (Geo.comparePointWithLine(b1x, b1y, b2x, b2y, a1x, a1y) * Geo.comparePointWithLine(b1x, b1y, b2x, b2y, a2x, a2y) <= 0));
  },

  /**
  * @ignore
  * @param {number} a1x
  * @param {number} a1y
  * @param {number} a2x
  * @param {number} a2y
  * @param {number} p1x
  * @param {number} p1y
  * @return {number}  -1, 0, or 1.
  */
  comparePointWithLine: function(a1x, a1y, a2x, a2y, p1x, p1y) {
    var x2 = a2x - a1x;
    var y2 = a2y - a1y;
    var px = p1x - a1x;
    var py = p1y - a1y;
    var ccw = px * y2 - py * x2;
    if (ccw === 0) {
      ccw = px * x2 + py * y2;
      if (ccw > 0) {
        px -= x2;
        py -= y2;
        ccw = px * x2 + py * y2;
        if (ccw < 0) ccw = 0;
      }
    }
    return (ccw < 0) ? -1 : ((ccw > 0) ? 1 : 0);
  },

  /**
  * @ignore
  * @param {number} a
  * @return {number}
  */
  normalizeAngle: function(a) {
    if (a < 0) a += 360;
    if (a >= 360) a -= 360;
    return a;
  },

/*
  returns an array that represents the bezier curves needed to draw or hit-test an arc
  */
  createArc: function(x, y, radius, startAngle, endAngle, anglesInRadians) {

    var pi = Math.PI;
    if (!anglesInRadians) {
      // convert these to radians
      startAngle = startAngle * (pi / 180);
      endAngle = endAngle * (pi / 180);
    }

    var sign = (startAngle < endAngle) ? 1 : -1;
    var epsilon = 0.00001;
    var twoPI = pi * 2 + epsilon;

    // Compute the sequence of arc curves, up to PI/2 at a time.  Total arc angle
    // is less than 2PI.
    var curves = [];
    var piOverTwo = pi / 2.0;


    var a1 = startAngle;
    var totalAngle = Math.min(twoPI, Math.abs(endAngle - startAngle));
    while (totalAngle > epsilon) {
        var a2 = a1 + sign * Math.min(totalAngle, piOverTwo);
        curves.push(Geo.createSmallArc(radius, a1, a2, x, y));
        totalAngle -= Math.abs(a2 - a1);
        a1 = a2;
    }

    return curves;
  },

  /*
   *  Cubic bezier approximation of a circular arc centered at the origin,
   *  from (radians) a1 to a2, where a2-a1 < pi/2.  The arc's radius is r.
   *
  */
  createSmallArc: function(r, a1, a2, x, y) {
    // Compute all four points for an arc that subtends the same total angle
    // but is centered on the X-axis

    var a = (a2 - a1) / 2.0; //

    var tx4 = r * Math.cos(a);
    var ty4 = r * Math.sin(a);
    var tx1 = tx4;
    var ty1 = -ty4;

    var k = 0.5522847498;
    var f = k * Math.tan(a);

    var tx2 = tx1 + f * ty4;
    var ty2 = ty1 + f * tx4;
    var tx3 = tx2;
    var ty3 = -ty2;

    // Find the arc points actual locations by computing x1,y1 and x4,y4
    // and rotating the control points by a + a1

    var ar = a + a1;
    var cos_ar = Math.cos(ar);
    var sin_ar = Math.sin(ar);
    return {
      x1: x + r * Math.cos(a1),
      y1: y + r * Math.sin(a1),
      x2: x + tx2 * cos_ar - ty2 * sin_ar,
      y2: y + tx2 * sin_ar + ty2 * cos_ar,
      x3: x + tx3 * cos_ar - ty3 * sin_ar,
      y3: y + tx3 * sin_ar + ty3 * cos_ar,
      x4: x + r * Math.cos(a2),
      y4: y + r * Math.sin(a2)
    };
  },


  /**
  * @ignore
  * This static method finds the nearest point on an infinite grid given the grids origin
  * and the size of the cells.
  * @param {number} x The X point to look near.
  * @param {number} y The Y point to look near.
  * @param {number} originX The X-coordinate of the origin of the grid.
  * @param {number} originY The Y-coordinate of the origin of the grid.
  * @param {number} cellwidth The width of the grid cell.
  * @param {number} cellheight The height of the grid cell.
  * @param {Point} result a Point that is modified and returned
  * @return {Point} The nearest grid point.
  */
  findNearestInfiniteGridPoint: function(x, y, originX, originY, cellwidth, cellheight, result) {
    // the grid space looks like the figure below.
    //  +               +
    //   A(ax, ay)
    //
    //        *(x,y)
    //  +               +

    var gridW = cellwidth;
    var gridH = cellheight;

    var ax = (Math.floor((x - originX) / gridW)) * gridW + originX;
    var ay = (Math.floor((y - originY) / gridH)) * gridH + originY;

    var bestx = ax;
    if ((ax + gridW - x) < gridW / 2)
      bestx = ax + gridW;
    var besty = ay;
    if ((ay + gridH - y) < gridH / 2)
      besty = ay + gridH;

    result._set(bestx, besty);
    return result;
  },

  /**
  * @ignore
  * Compute the greatest common divisor of two positive integers
  * @param {number} x
  * @param {number} y
  * @return {number}
  */
  gcd: function(x, y) {
    var a = Math.max(x, y);
    var b = Math.min(x, y);
    var c = 1;
    var result = 1;
    do {
      c = a % b;
      result = b;
      a = b;
      b = c;
    } while (c > 0);
    return result;
  },

  // The ellipse is (x0/e0)^2 + (x1/e1)^2 = 1.  The query point is (y0,y1).
  // The function returns the distance from the query point to the ellipse.
  distancePointEllipse: function(e0, e1, p0, p1) { // e[2], p[2], x[2]
      // Determine reflections for p to the first quadrant.
      var reflect0 = (p0 < 0);
      var reflect1 = (p1 < 0);
      var i, j;

      // Determine the axis order for decreasing extents.
      var permute0, permute1;
      if (e0 < e1) {
          permute0 = 1; permute1 = 0;
      } else {
          permute0 = 0; permute1 = 1;
      }

      // Might have been an issue with original implementation ???
      var invpermute0 = permute0;
      var invpermute1 = permute1;

      var locE0, locE1;
      var locY0, locY1;
      j = permute0;
      locE0 = j === 0 ? e0 : e1;
      locY0 = j === 0 ? p0 : p1;
      if (j === 0 ? reflect0 : reflect1) {
          locY0 = -locY0;
      }
      j = permute1;
      locE1 = j === 0 ? e0 : e1;
      locY1 = j === 0 ? p0 : p1;
      if (j === 0 ? reflect0 : reflect1) {
          locY1 = -locY1;
      }

      var distance = Geo.distancePointEllipseHelper(locE0, locE1, locY0, locY1, 0, 0);
      return distance;
  },

  // The ellipse is (x0/e0)^2 + (x1/e1)^2 = 1 with e0 >= e1.  The query point is
  // (y0,y1) with y0 >= 0 and y1 >= 0.  The function returns the distance from
  // the query point to the ellipse.  It also computes the ellipse point (x0,x1)
  // in the first quadrant that is closest to (y0,y1).
  distancePointEllipseHelper: function(e0, e1, y0, y1, x0, x1) { // e[2], y[2], x[2]
      var distance;
      if (y1 > 0) {
          if (y0 > 0) {
              // Bisect to compute the root of F(t) for t >= -e1*e1.
              var esqr0 = e0 * e0;
              var esqr1 = e1 * e1;
              var ey0 = e0 * y0
              var ey1 = e1 * y1;
              var t0 = -esqr1 + ey1;
              var t1 = -esqr1 + Math.sqrt(ey0 * ey0 + ey1 * ey1);
              var t = t0;
              var imax = 9999999999; // ???
              for (var i = 0; i < imax; ++i) {
                  t = (0.5) * (t0 + t1);
                  if (t === t0 || t === t1) {
                      break;
                  }

                  var r0 = ey0 / (t + esqr0);
                  var r1 = ey1 / (t + esqr1);
                  var f = r0 * r0 + r1 * r1 - 1;
                  if (f > 0) {
                      t0 = t;
                  } else if (f < 0) {
                      t1 = t;
                  } else {
                      break;
                  }
              }

              x0 = esqr0 * y0 / (t + esqr0);
              x1 = esqr1 * y1 / (t + esqr1);
              var d0 = x0 - y0;
              var d1 = x1 - y1;
              distance = Math.sqrt(d0 * d0 + d1 * d1);
          } else { // y0 == 0
              x0 = 0;
              x1 = e1;
              distance = Math.abs(y1 - e1);
          }
      } else { // y1 == 0
          var denom0 = e0 * e0 - e1 * e1;
          var e0y0 = e0 * y0;
          if (e0y0 < denom0) {
              // y0 is inside the subinterval.
              var x0de0 = e0y0 / denom0;
              var x0de0sqr = x0de0 * x0de0;
              x0 = e0 * x0de0;
              x1 = e1 * Math.sqrt(Math.abs(1 - x0de0sqr));
              var d0 = x0 - y0;
              distance = Math.sqrt(d0 * d0 + x1 * x1);
          } else {
              // y0 is outside the subinterval.  The closest ellipse point has
              // x1 == 0 and is on the domain-boundary interval (x0/e0)^2 = 1.
              x0 = e0;
              x1 = 0;
              distance = Math.abs(y0 - e0);
          }
      }
      return distance;
  }

}; // end Geo static object

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
Geometry
PathFigure
PathSegment
*/


/**
* Construct an empty Geometry.
* The geometry type must be one of the following values:
* {@link Geometry#Line}, {@link Geometry#Ellipse}, {@link Geometry#Rectangle}, {@link Geometry#Path}.
* @constructor
* @param {EnumValue=} type If not supplied, the default Geometry type is {@link Geometry#Path}.
* @category Geometry
* @class
* The Geometry class is used to define the "shape" of a {@link Shape}.
* A Geometry can be simple straight lines, rectangles, or ellipses.
* A Geometry can also be an arbitrarily complex path, consisting of a list of {@link PathFigure}s.
* <p/>
* A Geometry must not be modified once it has been used by a {@link Shape}.
* However, a Geometry may be shared by multiple Shapes.
*/
function Geometry(type) {
  if (arguments.length > 1) {
    Util.throwError('Geometry constructor can take at most one optional argument, the Geometry type.');
  }
  Util.uniqueHash(this);
  if (type === undefined/*notpresent*/) {
    type = Geometry.Path;
  } else {
    if (Debug) Util.checkEnumValue(type, Geometry, Geometry, 'constructor:type');
  }
  /** @type {EnumValue} */
  this._type = type;

  // for Line, Rectangle, Ellipse:
  /** @type {number} */
  this._startX = 0;
  /** @type {number} */
  this._startY = 0;
  /** @type {number} */
  this._endX = 0;
  /** @type {number} */
  this._endY = 0;
  // for Path:
  /** @type {List} */
  this._figures = new List(PathFigure);
  /** @type {number} */
  this._figuresChanged = this._figures._changed;

  /** @type {Rect} */
  this._computedBounds = new Rect().freeze();
  /** @type {boolean} */
  this._invalidBounds = true;

  /** @type {Spot} */
  this._spot1 = Spot.TopLeft;
  /** @type {Spot} */
  this._spot2 = Spot.BottomRight;

  // When a geometry is created it is helpful (but not necessary)
  // to save the input width and height in order to avoid recomputing it
  /** @type {number} */
  this._inputWidth = NaN;
  /** @type {number} */
  this._inputHeight = NaN;

  /** @type {Size} */
  this._minSize = Geo.ZeroSize; //??? used in computeBounds, set in figures.js, but is it necessary?

  // For some figures this is Uniform
  /** @type {EnumValue} */
  this._defaultStretch = GraphObject.Fill;
}

Util.publish('Geometry', Geometry);


/**
* Create a copy of this Geometry, with the same values and figures.
* @expose
* @this {Geometry}
* @return {Geometry}
*/
Geometry.prototype.copy = function() {
  var copy = new Geometry();
  copy._type = this._type;
  copy._startX = this._startX;
  copy._startY = this._startY;
  copy._endX = this._endX;
  copy._endY = this._endY;
  var oldfigs = this._figures;
  var numfigs = oldfigs.length;
  var newfigs = copy._figures;
  for (var i = 0; i < numfigs; i++) {
    var oldfig = oldfigs._arr[i];
    var newfig = oldfig.copy();
    newfigs.add(newfig);
  }
  copy._figuresChanged = this._figuresChanged;
  copy._computedBounds.assign(this._computedBounds);
  copy._invalidBounds = this._invalidBounds;
  copy._spot1 = this._spot1.copyFrozen();
  copy._spot2 = this._spot2.copyFrozen();
  copy._inputWidth = this._inputWidth;
  copy._inputHeight = this._inputHeight;
  copy._minSize = this._minSize.copyFrozen();
  copy._defaultStretch = this._defaultStretch;
  return copy;
};


/**
* For drawing a simple straight line;
* a value for {@link Geometry#type}.
* The line goes from the point
* ({@link #startX}, {@link #startY}) to the point ({@link #endX}, {@link #endY}).
* @name Geometry#Line
* @constant
* @static
* @return {EnumValue}
*/
Geometry['Line'] = Geometry.Line = Util.defineEnumValue(Geometry, 'Line', 0);

/**
* For drawing a rectangle;
* a value for {@link Geometry#type}.
* The rectangle goes from the point
* ({@link #startX}, {@link #startY}) to the point ({@link #endX}, {@link #endY}).
* @name Geometry#Rectangle
* @constant
* @static
* @return {EnumValue}
*/
Geometry['Rectangle'] = Geometry.Rectangle = Util.defineEnumValue(Geometry, 'Rectangle', 1);

/**
* For drawing an ellipse fitting within a rectangle;
* a value for {@link Geometry#type}.
* The ellipse fits within the rectangle that goes from the point
* ({@link #startX}, {@link #startY}) to the point ({@link #endX}, {@link #endY}).
* @name Geometry#Ellipse
* @constant
* @static
* @return {EnumValue}
*/
Geometry['Ellipse'] = Geometry.Ellipse = Util.defineEnumValue(Geometry, 'Ellipse', 2);

/**
* For drawing a complex path made of a list of {@link PathFigure}s;
* a value for {@link Geometry#type}.
* @name Geometry#Path
* @constant
* @static
* @return {EnumValue}
*/
Geometry['Path'] = Geometry.Path = Util.defineEnumValue(Geometry, 'Path', 3);


/**
* @ignore
* Make this object 'constant' and 'frozen'.
* Future attempts to change its state may result in an exception.
* This constant object may be shared freely.
* @this {Geometry}
* @return {Geometry}
*/
Geometry.prototype.constant = function() {
  this.freeze();
  Object.freeze(this);
  return this;
};

/**
* @ignore
* Make this object 'frozen' or immutable.
* Future attempts to change its state, for example by setting any of its properties,
* may result in an exception, until it is thaw()'ed.
* @this {Geometry}
* @return {Geometry}
*/
Geometry.prototype.freeze = function() {
  /** @type {boolean} */
  this._isFrozen = true;
  var figs = this.figures;
  figs.freeze();
  var numfigs = figs.length;
  for (var i = 0; i < numfigs; i++) {
    var fig = figs._arr[i];
    fig.freeze();
  }
  return this;
};

/**
* @ignore
* Make this object 'thawed' or mutable.
* Caution: this object might be shared, which would mean that any changes
* to this object would need to update all users of this object.
* @this {Geometry}
* @return {Geometry}
*/
Geometry.prototype.thaw = function() {
  if (Object.isFrozen(this)) Util.throwError('cannot thaw constant: ' + this);
  this._isFrozen = false;
  var figs = this.figures;
  figs.thaw();
  var numfigs = figs.length;
  for (var i = 0; i < numfigs; i++) {
    var fig = figs._arr[i];
    fig.thaw();
  }
  return this;
};

Geometry.prototype['equalsApprox'] =
/**
* @ignore
* @this {Geometry}
* @param {Geometry} g
* @return {boolean}
*/
Geometry.prototype.equalsApprox = function(g) {
  if (!(g instanceof Geometry)) return false;
  if (this.type !== g.type) {
    if (this.type === Geometry.Line && g.type === Geometry.Path) {
      return this.equalsApproxLine(g);
    } else if (g.type === Geometry.Line && this.type === Geometry.Path) {
      return g.equalsApproxLine(this);
    }
    return false;
  }
  if (this.type === Geometry.Path) {
    var figs1 = this.figures;
    var figs2 = g.figures;
    var numfigs = figs1.length;
    if (numfigs !== figs2.length) return false;
    for (var i = 0; i < numfigs; i++) {
      var fig1 = figs1._arr[i];
      var fig2 = figs2._arr[i];
      if (!fig1.equalsApprox(fig2)) return false;
    }
    return true;
  } else {
    // don't bother with spot1, spot2, minSize
    return Geo.isApprox(this.startX, g.startX) &&
           Geo.isApprox(this.startY, g.startY) &&
           Geo.isApprox(this.endX, g.endX) &&
           Geo.isApprox(this.endY, g.endY);
  }
};

/**
* @ignore
* @this {Geometry}
* @param {Geometry} g
* @return {boolean}
*/
Geometry.prototype.equalsApproxLine = function(g) {
  if (this.type !== Geometry.Line) return false;
  if (g.type !== Geometry.Path) return false;
  if (g.figures.count === 1) {
    var fig = g.figures.elt(0);
    if (fig.segments.count === 1 &&
        Geo.isApprox(this.startX, fig.startX) &&
        Geo.isApprox(this.startY, fig.startY)) {
      var seg = fig.segments.elt(0);
      if (seg.type === PathSegment.Line &&
          Geo.isApprox(this.endX, seg.endX) &&
          Geo.isApprox(this.endY, seg.endY)) {
        return true;
      }
    }
  }
  return false;
};

Geometry['stringify'] =
/**
* <p>
* This static method can be used to write out a {@link Geometry} as a string
* that can be read by {@link Geometry.parse}.
* <p>
* The string produced by this method is a superset of the SVG path
* string rules that contains some additional GoJS-specific tokens.
* See the <a href="../../intro/pictures.html">Introduction page on Geometry Parsing</a> for more details.
* @param {Geometry} val
* @return {string}
* @since 1.1
*/
Geometry.stringify = function(val) {
  return val.toString();
};

/**
* @ignore
* @this {Geometry}
* @param {number=} precision Optional: the amount of decimal places to round numbers to for debugging purposes,
* leaves number unchanged by default.
* @return {string}
*/
Geometry.prototype.toString = function(precision) {
  switch (this.type) {
    case Geometry.Line:
      if (precision === undefined) {
        return 'M' + this.startX.toString() + ' ' + this.startY.toString() +
               'L' + this.endX.toString() + ' ' + this.endY.toString();
      } else {
        return 'M' + this.startX.toFixed(precision) + ' ' + this.startY.toFixed(precision) +
               'L' + this.endX.toFixed(precision) + ' ' + this.endY.toFixed(precision);
      }
    case Geometry.Rectangle:
      var r = new Rect(this.startX, this.startY, 0, 0);
      r.union(this.endX, this.endY, 0, 0);
      if (precision === undefined) {
        return 'M' + r.x.toString() + ' ' + r.y.toString() +
             'H' + r.right.toString() +
             'V' + r.bottom.toString() +
             'H' + r.left.toString() +
             'z';
      } else {
        return 'M' + r.x.toFixed(precision) + ' ' + r.y.toFixed(precision) +
             'H' + r.right.toFixed(precision) +
             'V' + r.bottom.toFixed(precision) +
             'H' + r.left.toFixed(precision) +
             'z';
      }
    case Geometry.Ellipse:
      var r = new Rect(this.startX, this.startY, 0, 0);
      r.union(this.endX, this.endY, 0, 0);
      if (precision === undefined) {
        var p1 = r.left.toString() + ' ' + (r.y + r.height / 2).toString();
        var p2 = r.right.toString() + ' ' + (r.y + r.height / 2).toString();
        return 'M' + p1 +
           'A' + (r.width / 2).toString() + ' ' + (r.height / 2).toString() + ' 0 0 1 ' + p2 +
           'A' + (r.width / 2).toString() + ' ' + (r.height / 2).toString() + ' 0 0 1 ' + p1;
      } else {
        var p1 = r.left.toFixed(precision) + ' ' + (r.y + r.height / 2).toFixed(precision);
        var p2 = r.right.toFixed(precision) + ' ' + (r.y + r.height / 2).toFixed(precision);
        return 'M' + p1 +
           'A' + (r.width / 2).toFixed(precision) + ' ' + (r.height / 2).toFixed(precision) + ' 0 0 1 ' + p2 +
           'A' + (r.width / 2).toFixed(precision) + ' ' + (r.height / 2).toFixed(precision) + ' 0 0 1 ' + p1;
      }
    case Geometry.Path:
      var str = '';
      var figs = this.figures;
      var numfigs = figs.length;
      for (var i = 0; i < numfigs; i++) {
        var fig = figs._arr[i];
        if (i > 0) str += ' x ';
        if (fig.isFilled) str += 'F ';
        str += fig.toString(precision);
      }
      return str;
    default:
      return this.type.toString();
  } // end type switch
};

Geometry['fillPath'] =
/**
* Given a SVG or GoJS path string, returns a congruent path string with each pathfigure filled.
* For instance, "M0 0 L22 22 L33 0" would become "F M0 0 L22 22 L33 0".
* @param {string} str
* @return {string}
* @since 1.1
*/
Geometry.fillPath = function(str) {
  if (typeof str !== 'string') Util.throwTypeError(str, 'string', Geometry, 'fillPath:str');
  // split string by any x commands
  var paths = str.split(/[Xx]/);
  var l = paths.length;
  var r = '';
  for (var i = 0; i < l; i++) {
    var p = paths[i];
    if (p.match(/[Ff]/) !== null) {
      if (i === 0) {
        r += p;
      } else {
        r += 'X' + ((p[0] === ' ') ? '' : ' ') + p;
      }
      continue;
    }
    r += (i === 0 ? '' : 'X ') + 'F' + ((p[0] === ' ') ? '' : ' ') + p;
  }
  return r;
};

Geometry['parse'] =
/**
* Produce a {@link Geometry} from a string that uses an SVG-like compact path geometry syntax.
* The syntax accepts all SVG Path Syntax (<a href="http://www.w3.org/TR/SVG/paths.html" target="_blank">W3 page</a>),
* as well as three GoJS-specific tokens.
* Specifically, the following tokens are allowed:
* <ul>
* <li><code>M (x,y)+ </code> - Move commands
* <li><code>L (x,y)+, H (x)+, V (y)+</code> Lines commands, including horizontal and vertical lines
* <li><code>C (x1 y1 x2 y2 x y)+, S (x2 y2 x y)+</code> Cubic bezier curves
* <li><code>Q (x1 y1 x y)+, T (x y)+</code> Quadratic bezier curves
* <li><code>A (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</code> Arcs (following SVG arc conventions)
* <li><code>Z</code> Denotes that the previous subpath is closed
* </ul>
* Additionally there are some tokens specific to GoJS:
* <ul>
* <li><code>B (startAngle, sweepAngle, centerX, centerY, radius)+</code> Arcs following GoJS canvas arc conventions
* <li><code>X</code> Used before M-commands to denote separate PathFigures instead of a subpath
* <li><code>F</code> Denotes whether the current PathFigure is filled (true if F is present)
* </ul>
* See the <a href="../../intro/geometry.html">Introduction page on Geometry Parsing</a> for more details.
* @param {string} str
* @param {boolean=} filled whether figures should be filled.
* If true, all PathFigures in the string will be filled regardless of the presence
* of an "F" command or not.
* If false, all PathFigures will determine their own filled state by the presence of an "F" command or not.
* Default is false.
* @return {Geometry}
*/
Geometry.parse = function(str, filled) {
  if (filled === undefined/*notpresent*/) filled = false;
  if (typeof str !== 'string') Util.throwTypeError(str, 'string', Geometry, 'parse:str');
  // ??? check floating points
  str = str.replace(/,/gm, ' '); // get rid of all commas
  str = str.replace(/([UuBbMmZzLlHhVvCcSsQqTtAaFf])([UuBbMmZzLlHhVvCcSsQqTtAaFf])/gm, '$1 $2'); // separate commands from commands
  str = str.replace(/([UuBbMmZzLlHhVvCcSsQqTtAaFf])([UuBbMmZzLlHhVvCcSsQqTtAaFf])/gm, '$1 $2'); // separate commands from commands
  str = str.replace(/([UuBbMmZzLlHhVvCcSsQqTtAaFf])([^\s])/gm, '$1 $2'); // separate commands from points
  str = str.replace(/([^\s])([UuBbMmZzLlHhVvCcSsQqTtAaFf])/gm, '$1 $2'); // separate commands from points
  str = str.replace(/([0-9])([+\-])/gm, '$1 $2'); // separate digits when no comma
  str = str.replace(/(\.[0-9]*)(\.)/gm, '$1 $2'); // separate digits when no comma
  str = str.replace(/([Aa](\s+[0-9]+){3})\s+([01])\s*([01])/gm, '$1 $3 $4 '); // shorthand elliptical arc path syntax
  str = str.replace(/[\s\r\t\n]+/gm, ' '); // compress spaces
  str = str.replace(/^\s+|\s+$/g, ''); // trim

  var tokens = str.split(' ');

  var i = -1;
  var command = '';
  var previousCommand = '';
  var start = new Point(0, 0);
  var control = new Point(0, 0);
  var current = new Point(0, 0);

  // things done often:
  // returns true if the next item is a command
  /** @ignore */
  function isCommandOrEnd() {
    if (i >= length - 1) return true;
    return tokens[i + 1].match(/[A-Za-z]/) !== null;
  }

  /** @ignore */
  function getToken() {
    i++;
    return tokens[i];
  }

  /** @ignore */
  function getPoint() {
    var p = new Point(parseFloat(getToken()), parseFloat(getToken()));
    // make it absolute
    if (command === command.toLowerCase()) {
      p.x = current.x + p.x;
      p.y = current.y + p.y;
    }
    return p;
  }

  /** @ignore */
  function getAsCurrentPoint() {
    current = getPoint();
    return current;
  }

  /** @ignore */
  function getAsControlPoint() {
    control = getPoint();
    return control;
  }

  /** @ignore */
  function getArc() {
    // 5-7 arguments
    // startAngle, sweepAngle, centerX, centerY, radiusX, radiusY)
    var args = [
      parseFloat(getToken()),
      parseFloat(getToken()),
      parseFloat(getToken()),
      parseFloat(getToken()),
      parseFloat(getToken())];
    if (!isCommandOrEnd()) {
      args.push(parseFloat(getToken()));
      if (!isCommandOrEnd()) args.push(parseFloat(getToken()));
    }
    // make it absolute
    if (command === command.toLowerCase()) {
      args[2] += current.x; // centerX
      args[3] += current.y; // centerY
    }
    return args;
  }

  /** @ignore */
  function getReflectedControlPoint() {
    if (previousCommand.toLowerCase() !== 'c' && previousCommand.toLowerCase() !== 's') {
      return current;
    }
    // reflect point
    return new Point(2 * current.x - control.x, 2 * current.y - control.y);
  }

  var length = tokens.length;
  var ctx = Util.tempStreamGeometryContext();
  var p;
  var fCommand = false;
  var uCommand = false;
  var newfig = true;
  while (!(i >= length - 1)) {
    previousCommand = command;
    command = getToken();
    if (command === '') continue;

    switch (command.toUpperCase()) {
      case 'X':
        newfig = true;
        fCommand = false;
        uCommand = false;
        break;
      case 'M':
        p = getAsCurrentPoint();
        if (ctx._fig === null || newfig === true) {
          // uCommand means no shadow, so !uCommand for isShadowed
          ctx.beginFigure(p.x, p.y, fCommand, false, !uCommand);
          newfig = false;
        } else {
          ctx.moveTo(p.x, p.y);
        }
        // multiple M params mean subsequent line segments:
        start = current;
        while (!isCommandOrEnd()) {
          p = getAsCurrentPoint();
          ctx.lineTo(p.x, p.y);
        }
        break;
      case 'L':
        while (!isCommandOrEnd()) {
          var c = current;
          p = getAsCurrentPoint();
          ctx.lineTo(p.x, p.y);
        }
        break;
      case 'H':
        while (!isCommandOrEnd()) {
          var newP = new Point((command === command.toLowerCase() ? current.x : 0) + parseFloat(getToken()), current.y);
          current = newP;
          ctx.lineTo(current.x, current.y);
        }
        break;
      case 'V':
        while (!isCommandOrEnd()) {
          var newP = new Point(current.x, (command === command.toLowerCase() ? current.y : 0) + parseFloat(getToken()));
          current = newP;
          ctx.lineTo(current.x, current.y);
        }
        break;
      case 'C':
        while (!isCommandOrEnd()) {
          var curr = current;
          var p1 = getPoint();
          var cntrl = getAsControlPoint();
          var cp = getAsCurrentPoint();
          ctx.bezierTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
        }
        break;
      case 'S':
        while (!isCommandOrEnd()) {
          var curr = current;
          var p1 = getReflectedControlPoint();
          var cntrl = getAsControlPoint();
          var cp = getAsCurrentPoint();
          ctx.bezierTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
        }
        break;
      case 'Q':
        while (!isCommandOrEnd()) {
          var curr = current;
          var cntrl = getAsControlPoint();
          var cp = getAsCurrentPoint();
          ctx.quadraticBezierTo(cntrl.x, cntrl.y, cp.x, cp.y);
        }
        break;
      case 'T':
        while (!isCommandOrEnd()) {
          var curr = current;
          var cntrl = getReflectedControlPoint();
          control = cntrl;
          var cp = getAsCurrentPoint();
          ctx.quadraticBezierTo(cntrl.x, cntrl.y, cp.x, cp.y);
        }
        break;
      case 'B':
        while (!isCommandOrEnd()) {
          // 5 or 7 arguments
          // startAngle, sweepAngle, centerX, centerY, radiusX, radiusY)
          var args = getArc();
          ctx.arcTo(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        break;
      case 'A': // elliptical arc
        while (!isCommandOrEnd()) {
          var curr = current; // aka last point
          // rx, ry is scalar, not a literal point
          var rx = Math.abs(parseFloat(getToken()));
          var ry = Math.abs(parseFloat(getToken()));
          var xAxisRotation = parseFloat(getToken());
          var largeArcFlag = !!parseFloat(getToken());
          var sweepFlag = !!parseFloat(getToken());
          var cp = getAsCurrentPoint();

          ctx.svgArcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, cp.x, cp.y);
        }
        break;
      case 'Z':
        /* original*/
        //ctx.closePath();
        //current = start;

        // !original: closes path
        var fig = ctx.geo.figures._arr[ctx.geo.figures.length - 1];
        ctx.closeLast();
        current = start;
        break;
      case 'F':
        var nextToken = null;
        var j = 1;
        while (tokens[i + j]) {
          if (tokens[i + j].match(/[Uu]/) !== null) { j++; continue; }
          if (tokens[i + j].match(/[A-Za-z]/) === null) { j++; continue; }
          nextToken = tokens[i + j];
          break;
        }
        if (nextToken.match(/[Mm]/)) {
          fCommand = true;
        } else {
          ctx.fillLast();
        }
        break;
      case 'U':
        var nextToken = null;
        var j = 1;
        while (tokens[i + j]) {
          if (tokens[i + j].match(/[Ff]/) !== null) { j++; continue; }
          if (tokens[i + j].match(/[A-Za-z]/) === null) { j++; continue; }
          nextToken = tokens[i + j];
          break;
        }
        if (nextToken.match(/[Mm]/)) {
          uCommand = true;
        } else {
          ctx.setShadow(false);
        }

        break;
      default:
        // the 1 and 2 of F1/F2 currently fall here
        //Util.throwError('Unknown geometry command: ' + command);
        break;
    }
  } // end switch

  var geo = ctx.geo;
  Util.freeStreamGeometryContext(ctx);
  if (filled) {
    var it = geo.figures.iterator;
    while (it.next()) {
      it.value.isFilled = true;
    }
  }
  return geo;
};

// For use with curves made from B-arcs, which need to be normalized pre-transform
/**
* @ignore
* @this {Geometry}
*/
Geometry.transformCurves = function(curves, tt) {
  var l = curves.length;
  var p = Util.tempPoint();
  var initx = 0;
  var inity = 0;

  for (var i = 0; i < l; i++) {
    var c = curves[i];
    if (i === 0) {
      initx = c.x1;
      inity = c.y1;
    }

    c.x1 -= initx;
    c.y1 -= inity;
    c.x2 -= initx;
    c.y2 -= inity;
    c.x3 -= initx;
    c.y3 -= inity;
    c.x4 -= initx;
    c.y4 -= inity;
  }

  for (var i = 0; i < l; i++) {
    var c = curves[i];
    p.x = c.x1;
    p.y = c.y1;
    tt.transformPoint(p);
    c.x1 = p.x + initx;
    c.y1 = p.y + inity;

    p.x = c.x2;
    p.y = c.y2;
    tt.transformPoint(p);
    c.x2 = p.x + initx;
    c.y2 = p.y + inity;

    p.x = c.x3;
    p.y = c.y3;
    tt.transformPoint(p);
    c.x3 = p.x + initx;
    c.y3 = p.y + inity;

    p.x = c.x4;
    p.y = c.y4;
    tt.transformPoint(p);
    c.x4 = p.x + initx;
    c.y4 = p.y + inity;
  }
  Util.freePoint(p);
};

// For use with curves made from A-arcs, which do not need to be normalized pre-transform
/**
* @ignore
* @this {Geometry}
*/
Geometry.transformCurves2 = function(curves, tt) {
  var l = curves.length;
  var p = Util.tempPoint();
  for (var i = 0; i < l; i++) {
    var c = curves[i];
    p.x = c.x1;
    p.y = c.y1;
    tt.transformPoint(p);
    c.x1 = p.x;
    c.y1 = p.y;

    p.x = c.x2;
    p.y = c.y2;
    tt.transformPoint(p);
    c.x2 = p.x;
    c.y2 = p.y;

    p.x = c.x3;
    p.y = c.y3;
    tt.transformPoint(p);
    c.x3 = p.x;
    c.y3 = p.y;

    p.x = c.x4;
    p.y = c.y4;
    tt.transformPoint(p);
    c.x4 = p.x;
    c.y4 = p.y;
  }
  Util.freePoint(p);
};

/**
* @ignore
* @this {Geometry}
* @return {boolean}
*/
Geometry.prototype.isInvalidBounds = function() {
  if (this._invalidBounds) return true;
  var figs = this.figures;
  if (this._figuresChanged !== figs._changed) return true;
  // for each PathFigure:
  var l = figs.length;
  for (var i = 0; i < l; i++) {
    var fig = figs._arr[i];
    if (fig.isInvalidBounds()) return true;
  }
  return false;
};

/**
* @ignore
* @this {Geometry}
*/
Geometry.prototype.validateBounds = function() {
  this._invalidBounds = false;

  var figs = this.figures;
  this._figuresChanged = figs._changed;
  // for each PathFigure:
  var l = figs.length;
  for (var i = 0; i < l; i++) {
    var fig = figs._arr[i];
    fig.validateBounds();
  }
};

/**
* @ignore
* @this {Geometry}
*/
Geometry.prototype.computeBounds = function() {
  var b = this._computedBounds;
  b.thaw();
  b._set(0, 0, this._minSize.width, this._minSize.height);
  this.computeBoundsInternal(b, false);
  b.unionNoCheck(0, 0, 0, 0);  // always include the origin
  b.freeze();
};

Geometry.prototype['computeBoundsWithoutOrigin'] =
/**
* Computes the Geometry's bounds without adding an origin point, and returns those bounds as a rect.
* This method does not modify the Geometry or its bounds.
* @this {Geometry}
* @return {Rect}
* @since 1.1
*/
Geometry.prototype.computeBoundsWithoutOrigin = function() {
  var b = new Rect();
  this.computeBoundsInternal(b, true);
  return b;
};

/**
* @ignore
* Modifies a given rectangle to be the bounds
* @this {Geometry}
* @param {Rect} b the rectangle to modify.
* @param {boolean} set whether or not the first point is set or unioned.
* Use true only if you don't want the existing rectangle (ie 0,0,0,0) to be included.
*/
Geometry.prototype.computeBoundsInternal = function(b, set) {
    switch (this.type) {
    case Geometry.Line:
    case Geometry.Rectangle:
    case Geometry.Ellipse:
      if (set) b._set(this._startX, this._startY, 0, 0);
      else b.unionNoCheck(this._startX, this._startY, 0, 0);
      b.unionNoCheck(this._endX, this._endY, 0, 0);
      break;
    case Geometry.Path:
      var figs = this.figures;
      // for each PathFigure:
      var numfigs = figs.length;
      for (var i = 0; i < numfigs; i++) {
        var fig = figs._arr[i];
        if (set && i === 0) b._set(fig.startX, fig.startY, 0, 0);
        else b.unionNoCheck(fig.startX, fig.startY, 0, 0);
        // for each segment of the PathFigure:
        var segments = fig.segments;
        var numsegs = segments.length;
        var lastpointX = fig.startX;
        var lastpointY = fig.startY;
        for (var j = 0; j < numsegs; j++) {
          var seg = segments._arr[j];
          switch (seg.type) {
            case PathSegment.Line:
            case PathSegment.Move:
              lastpointX = seg.endX;
              lastpointY = seg.endY;
              b.unionNoCheck(lastpointX, lastpointY, 0, 0);
              break;
            case PathSegment.Bezier:
              Geo.bezierBounds(lastpointX, lastpointY, seg.point1X, seg.point1Y,
                             seg.point2X, seg.point2Y, seg.endX, seg.endY, 0.5, b); //?? epsilon
              lastpointX = seg.endX;
              lastpointY = seg.endY;
              break;
            case PathSegment.QuadraticBezier:
              Geo.quadraticBezierBounds(lastpointX, lastpointY, seg.point1X, seg.point1Y,
                                      seg.endX, seg.endY, 0.5, b); //?? epsilon
              lastpointX = seg.endX;
              lastpointY = seg.endY;
              break;
            case PathSegment.Arc:
            case PathSegment.SvgArc:
              var curves = (seg.type === PathSegment.Arc) ? seg.buildBeziers(fig) : seg.buildSVGBeziers(fig, lastpointX, lastpointY);
              var clen = curves.length;
              var c = null;
              for (var k = 0; k < clen; k++) {
                c = curves[k];
                Geo.bezierBounds(c.x1, c.y1, c.x2, c.y2, c.x3, c.y3, c.x4, c.y4, 0.5, b);
              }
              if (c !== null) {
                lastpointX = c.x4;
                lastpointY = c.y4;
              }
              break;
            default:
              Util.throwError('Unknown Segment type: ' + seg.type);
              break;
          }
        } // end segments
      } // end figures
      break;
    default:
      Util.throwError('Unknown Geometry type: ' + this.type);
      break;
  }
};

/**
* @ignore
* Returns a copy of this Geometry that has been scaled by an x and y value
* @this {Geometry}
* @param {number} width
* @param {number} height
* @return {Geometry}
*/
Geometry.prototype.computeScaledGeometry = function(width, height) {
  var result = this.copy();
  var bounds = this.bounds;
  var x = width / bounds.width;
  var y = height / bounds.height;
  // bounds might be zero or input might be Infinity, we don't want this
  if (!isFinite(x)) x = 1;
  if (!isFinite(y)) y = 1;
  if (x === 1 && y === 1) return result;
  switch (result.type) {
    case Geometry.Line:
    case Geometry.Rectangle:
    case Geometry.Ellipse:
      result.startX *= x;
      result.startY *= y;
      result.endX *= x;
      result.endY *= y;
      break;
    case Geometry.Path:
      var figs = result.figures;
      // for each PathFigure:
      var numfigs = figs.length;
      for (var i = 0; i < numfigs; i++) {
        var fig = figs._arr[i];
        fig.startX *= x;
        fig.startY *= y;
        // for each segment of the PathFigure:
        var segments = fig.segments;
        var numsegs = segments.length;
        for (var j = 0; j < numsegs; j++) {
          var seg = segments._arr[j];
          switch (seg.type) {
            case PathSegment.Line:
            case PathSegment.Move:
              seg.endX *= x;
              seg.endY *= y;
              break;
            case PathSegment.Bezier:
              seg.point1X *= x;
              seg.point1Y *= y;
              seg.point2X *= x;
              seg.point2Y *= y;
              seg.endX *= x;
              seg.endY *= y;
              break;
            case PathSegment.QuadraticBezier:
              seg.point1X *= x;
              seg.point1Y *= y;
              seg.endX *= x;
              seg.endY *= y;
              break;
            case PathSegment.Arc:
              seg.centerX *= x;
              seg.centerY *= y;
              seg.radiusX *= x;
              if (seg.radiusY !== undefined) seg.radiusY *= y;
              break;
            case PathSegment.SvgArc:
              seg.endX *= x;
              seg.endY *= y;
              seg.radiusX *= x;
              seg.radiusY *= y;
              break;
            default:
              Util.throwError('Unknown Segment type: ' + seg.type);
              break;
          }
        } // end segment
      } // end path figures
      break;
  }
  return result;
};

Geometry.prototype['normalize'] =
/**
* Normalizes the Geometry points in place by ensuring the top-left bounds of the geometry lines up with (0, 0),
* returning the {@link Point} (x, y) amount it was shifted.
* After this method is called there will be no negative X or Y value for the Geometry's bounds,
* and no empty space at the top-left of the Geometry.
* @this {Geometry}
* @return {Point}
* @since 1.1
*/
Geometry.prototype.normalize = function() {
  Util.checkFrozen(this);
  var r = this.computeBoundsWithoutOrigin();
  this.offset(-r.x, -r.y);
  return new Point(-r.x, -r.y);
};

Geometry.prototype['offset'] =
/**
* Offsets the Geometry in place by a given (x, y) amount
* @this {Geometry}
* @param {number} x The x-axis offset factor.
* @param {number} y The y-axis offset factor.
* @since 1.1
*/
Geometry.prototype.offset = function(x, y) {
  Util.checkFrozen(this);
  if (Debug) {
    Util.checkRealNumber(x, Geometry, 'offset');
    Util.checkRealNumber(y, Geometry, 'offset');
  }
  this.transform(1, 0, 0, 1, x, y);
};

Geometry.prototype['scale'] =
/**
* Scales the Geometry in place by a given (x, y) scale factor
* @this {Geometry}
* @param {number} x The x-axis scale factor.
* @param {number} y The y-axis scale factor.
* @since 1.1
*/
Geometry.prototype.scale = function(x, y) {
  Util.checkFrozen(this);
  if (Debug) {
    Util.checkRealNumber(x, Geometry, 'scale:x');
    Util.checkRealNumber(y, Geometry, 'scale:y');
    if (x <= 0) Util.throwRangeError(x, 'scale must be greater than zero', Geometry, 'scale:x');
    if (y <= 0) Util.throwRangeError(y, 'scale must be greater than zero', Geometry, 'scale:y');
  }
  this.transform(x, 0, 0, y, 0, 0);
};

Geometry.prototype['rotate'] =
/**
* Rotates the Geometry in place by a given angle, with optional x and y values to rotate the geometry about.
* If no x and y value are giving, (0, 0) is used as the rotation point.
* @this {Geometry}
* @param {number} angle The angle to rotate by.
* @param {number=} x The optional X point to rotate the geometry about. If no point is given, this value is 0.
* @param {number=} y The optional Y point to rotate the geometry about. If no point is given, this value is 0.
* @since 1.1
*/
Geometry.prototype.rotate = function(angle, x, y) {
  Util.checkFrozen(this);
  if (x === undefined) x = 0;
  if (y === undefined) y = 0;
  if (Debug) {
    Util.checkRealNumber(angle, Geometry, 'rotate:angle');
    Util.checkRealNumber(x, Geometry, 'rotate:x');
    Util.checkRealNumber(y, Geometry, 'rotate:y');
  }
  var t = Util.tempTransform();
  t.reset();
  t.rotate(angle, x, y);
  this.transform(t.m11, t.m12, t.m21, t.m22, t.dx, t.dy);
  Util.freeTransform(t);
};

Geometry.prototype['transform'] =
/**
* @ignore
* Transforms the Geometry in place by a given transform
* @this {Geometry}
* @param {number} m11
* @param {number} m12
* @param {number} m21
* @param {number} m22
* @param {number} dx
* @param {number} dy
*/
Geometry.prototype.transform = function(m11, m12, m21, m22, dx, dy) {
  // x,y
  /* Transforming a point:
  x = x * m11 + y * m21 + dx;
  y = x * m12 + y * m22 + dy;
  */
  var x, y;
  switch (this.type) {
    case Geometry.Line:
    case Geometry.Rectangle:
    case Geometry.Ellipse:
      x = this._startX;
      y = this._startY;
      this._startX = x * m11 + y * m21 + dx;
      this._startY = x * m12 + y * m22 + dy;

      x = this._endX;
      y = this._endY;
      this._endX = x * m11 + y * m21 + dx;
      this._endY = x * m12 + y * m22 + dy;
      break;
    case Geometry.Path:
      var figs = this.figures;
      // for each PathFigure:
      var numfigs = figs.length;
      for (var i = 0; i < numfigs; i++) {
        var fig = figs._arr[i];
        x = fig.startX;
        y = fig.startY;
        fig.startX = x * m11 + y * m21 + dx;
        fig.startY = x * m12 + y * m22 + dy;
        // for each segment of the PathFigure:
        var segments = fig.segments;
        var numsegs = segments.length;
        for (var j = 0; j < numsegs; j++) {
          var seg = segments._arr[j];
          switch (seg.type) {
            case PathSegment.Line:
            case PathSegment.Move:
              x = seg.endX;
              y = seg.endY;
              seg.endX = x * m11 + y * m21 + dx;
              seg.endY = x * m12 + y * m22 + dy;
              break;
            case PathSegment.Bezier:
              x = seg.point1X;
              y = seg.point1Y;
              seg.point1X = x * m11 + y * m21 + dx;
              seg.point1Y = x * m12 + y * m22 + dy;

              x = seg.point2X;
              y = seg.point2Y;
              seg.point2X = x * m11 + y * m21 + dx;
              seg.point2Y = x * m12 + y * m22 + dy;

              x = seg.endX;
              y = seg.endY;
              seg.endX = x * m11 + y * m21 + dx;
              seg.endY = x * m12 + y * m22 + dy;
              break;
            case PathSegment.QuadraticBezier:
              x = seg.point1X;
              y = seg.point1Y;
              seg.point1X = x * m11 + y * m21 + dx;
              seg.point1Y = x * m12 + y * m22 + dy;

              x = seg.endX;
              y = seg.endY;
              seg.endX = x * m11 + y * m21 + dx;
              seg.endY = x * m12 + y * m22 + dy;
              break;
            case PathSegment.Arc:
              x = seg.centerX;
              y = seg.centerY;
              seg.centerX = x * m11 + y * m21 + dx;
              seg.centerY = x * m12 + y * m22 + dy;
              // scalar:
              seg.radiusX *= Math.sqrt((m11 * m11) + (m21 * m21));
              if (seg.radiusY !== undefined) {
                seg.radiusY *= Math.sqrt((m12 * m12) + (m22 * m22));
              }
              break;
            case PathSegment.SvgArc:
              x = seg.endX;
              y = seg.endY;
              seg.endX = x * m11 + y * m21 + dx;
              seg.endY = x * m12 + y * m22 + dy;
              // scalar:
              seg.radiusX *= Math.sqrt((m11 * m11) + (m21 * m21));
              seg.radiusY *= Math.sqrt((m12 * m12) + (m22 * m22));
              break;
            default:
              Util.throwError('Unknown Segment type: ' + seg.type);
              break;
          }
        } // end segment
      } // end path figures
      break;
  }
  this._invalidBounds = true;
};

/**
* @ignore
* @this {Geometry}
* @param {Geometry} geom  The Geometry to be modified and returned.
* @param {Transform} tt  The Transform to be applied to the points of the Rectangle.
* @return {Geometry}
*/
Geometry.prototype._turnEllipseIntoBezierPath = function(geom, tt) {
  var x1 = this._startX;
  var y1 = this._startY;
  var x2 = this._endX;
  var y2 = this._endY;

  var rx = Math.abs(x2 - x1) / 2;
  var ry = Math.abs(y2 - y1) / 2;
  var cx = Math.min(x1, x2) + rx;
  var cy = Math.min(y1, y2) + ry;

  var temp = Util.tempPoint();

  temp.x = cx;
  temp.y = cy - ry;
  tt.transformPoint(temp);
  var f = new PathFigure(temp.x, temp.y);

  var p1 = new PathSegment(PathSegment.Bezier);
  temp.x = cx + (Geo.KAPPA * rx);
  temp.y = cy - ry;
  tt.transformPoint(temp);
  p1.point1X = temp.x;
  p1.point1Y = temp.y;
  temp.x = cx + rx;
  temp.y = cy - (Geo.KAPPA * ry);
  tt.transformPoint(temp);
  p1.point2X = temp.x;
  p1.point2Y = temp.y;
  temp.x = cx + rx;
  temp.y = cy;
  tt.transformPoint(temp);
  p1.endX = temp.x;
  p1.endY = temp.y;
  f.segments.add(p1);

  var p2 = new PathSegment(PathSegment.Bezier);
  temp.x = cx + rx;
  temp.y = cy + (Geo.KAPPA * ry);
  tt.transformPoint(temp);
  p2.point1X = temp.x;
  p2.point1Y = temp.y;
  temp.x = cx + (Geo.KAPPA * rx);
  temp.y = cy + ry;
  tt.transformPoint(temp);
  p2.point2X = temp.x;
  p2.point2Y = temp.y;
  temp.x = cx;
  temp.y = cy + ry;
  tt.transformPoint(temp);
  p2.endX = temp.x;
  p2.endY = temp.y;
  f.segments.add(p2);

  var p3 = new PathSegment(PathSegment.Bezier);
  temp.x = cx - (Geo.KAPPA * rx);
  temp.y = cy + ry;
  tt.transformPoint(temp);
  p3.point1X = temp.x;
  p3.point1Y = temp.y;
  temp.x = cx - rx;
  temp.y = cy + (Geo.KAPPA * ry);
  tt.transformPoint(temp);
  p3.point2X = temp.x;
  p3.point2Y = temp.y;
  temp.x = cx - rx;
  temp.y = cy;
  tt.transformPoint(temp);
  p3.endX = temp.x;
  p3.endY = temp.y;
  f.segments.add(p3);

  var p4 = new PathSegment(PathSegment.Bezier);
  temp.x = cx - rx;
  temp.y = cy - (Geo.KAPPA * ry);
  tt.transformPoint(temp);
  p4.point1X = temp.x;
  p4.point1Y = temp.y;
  temp.x = cx - (Geo.KAPPA * rx);
  temp.y = cy - ry;
  tt.transformPoint(temp);
  p4.point2X = temp.x;
  p4.point2Y = temp.y;
  temp.x = cx;
  temp.y = cy - ry;
  tt.transformPoint(temp);
  p4.endX = temp.x;
  p4.endY = temp.y;
  f.segments.add(p4);

  Util.freePoint(temp);

  geom.type = Geometry.Path;
  geom.figures.add(f);
  return geom;
};

/**
* @ignore
* @this {Geometry}
* @param {Geometry} geom  The Geometry to be modified and returned.
* @param {Transform} tt  The Transform to be applied to the points of the Rectangle.
* @return {Geometry}
*/
Geometry.prototype._turnRectangleIntoPath = function(geom, tt) {
  var x1 = this._startX;
  var y1 = this._startY;
  var x2 = this._endX;
  var y2 = this._endY;

  var x = Math.min(x1, x2);
  var y = Math.min(y1, y2);
  var w = Math.abs(x2 - x1);
  var h = Math.abs(y2 - y1);

  var temp = Util.tempPoint();

  temp.x = x;
  temp.y = y;
  tt.transformPoint(temp);
  var fig = new PathFigure(temp.x, temp.y);

  temp.x = x + w;
  temp.y = y;
  tt.transformPoint(temp);
  fig.segments.add(new PathSegment(PathSegment.Line, temp.x, temp.y));

  temp.x = x + w;
  temp.y = y + h;
  tt.transformPoint(temp);
  fig.segments.add(new PathSegment(PathSegment.Line, temp.x, temp.y));

  temp.x = x;
  temp.y = y + h;
  tt.transformPoint(temp);
  fig.segments.add(new PathSegment(PathSegment.Line, temp.x, temp.y).close());

  Util.freePoint(temp);

  geom.type = Geometry.Path;
  geom.figures.add(fig);
  return geom;
};

/**
* @ignore
* Returns true if the Geometry contains the point
* @this {Geometry}
* @param {Point} p
* @param {number} sw
* @param {boolean} swOnFilled specifies whether or not the stroke width is greater than 1.
* @param {boolean=} precise whether or not to modify the strokewidth when checking unfilled paths.
* @return {boolean}
*/
Geometry.prototype.containsPoint = function(p, sw, swOnFilled, precise) {
  var px = p.x;
  var py = p.y;
  var p0x = this.bounds.x - 20;
  var p0y = p.y;

  var wind = 0;
  var lx, ly;

  // to avoid declaring same variables many times
  var seg, type, crosses, ex, ey;
  var figures = this.figures._arr;
  var l = figures.length;
  for (var i = 0; i < l; i++) {
    var fig = figures[i];

    // Determine containsPoint if the figure is not filled
    if (!fig.isFilled) {
      // See shape containsPointProtected for a similar + 2
      if (fig.containsPoint(px, py, precise ? sw : sw + 2)) return true;
      continue;
    } else if (swOnFilled && fig.containsPoint(px, py, sw)) {
      return true; // may not be necessary
    }

    // Determine containsPoint if the figure is filled

    var segs = fig.segments;
    lx = fig.startX;
    ly = fig.startY;

    // Keep track of the last move command issued for when a segment is closed
    // as this makes an implicit line to the last move location
    var lmX = lx;
    var lmY = ly;

    for (var j = 0; j <= segs.length; j++) {
      if (j !== segs.length) {
        seg = segs._arr[j];
        type = seg.type;
        ex = seg.endX;
        ey = seg.endY;
      } else {
        type = PathSegment.Line;
        ex = lmX;
        ey = lmY;
      }

      switch (type) {
        case PathSegment.Move:
          // move command mid-figure means a new subpath, since we are concerned with filling
          // there is always an implicit close
          var lw = this._lineWind(px, py, p0x, p0y, lx, ly, lmX, lmY);
          if (lw === true) return true; // right on the line
          wind += lw;
          lmX = ex;
          lmY = ey;

          // this was put in, but incorrectly.
          // Move commands must still remain the same winding number as they represent a subpath.
          //if (wind !== 0) return true;
          //wind = 0;
          break;
        case PathSegment.Line:
          var lw = this._lineWind(px, py, p0x, p0y, lx, ly, ex, ey);
          if (lw === true) return true; // right on the line
          wind += lw;
          break;
        case PathSegment.Bezier:
          crosses = Geo.bezierWinding(lx, ly, seg.point1X, seg.point1Y,
                seg.point2X, seg.point2Y, ex, ey, p0x, p0y, px, py, 0.5);
          wind += crosses;
          break;
        case PathSegment.QuadraticBezier:
          var p1x = (lx + 2 * seg.point1X) / 3;
          var p1y = (ly + 2 * seg.point1Y) / 3;
          var p2x = (seg.point1X + 2 * ex) / 3;
          var p2y = (seg.point1X + 2 * ex) / 3;
          crosses = Geo.bezierWinding(lx, ly, p1x, p1y, p2x, p2y, ex, ey, p0x, p0y, px, py, 0.5);
          wind += crosses;
          break;
        case PathSegment.Arc:
        case PathSegment.SvgArc:
          var curves = (seg.type === PathSegment.Arc) ? seg.buildBeziers(fig) : seg.buildSVGBeziers(fig, lx, ly);
          var clen = curves.length;
          var c = null;
          for (var k = 0; k < clen; k++) {
            c = curves[k];
            if (k === 0) {
              var lw = this._lineWind(px, py, p0x, p0y, lx, ly, c.x1, c.y1);
              if (lw === true) return true; // right on the line
              wind += lw;
            }
            crosses = Geo.bezierWinding(c.x1, c.y1, c.x2, c.y2, c.x3, c.y3, c.x4, c.y4, p0x, p0y, px, py, 0.5);
            wind += crosses;
          }
          if (c !== null) {
            ex = c.x4;
            ey = c.y4;
          }
          break;
        default:
          Util.throwError('Unknown Segment type: ' + seg.type);
          break;
      }

      lx = ex;
      ly = ey;
    } // end segment for loop

    if (wind !== 0) return true;
    wind = 0;
  }
  return wind !== 0;
};

/**
* @ignore
* Returns true if the geometry's unfilled path contains the point.
* @this {Geometry}
*/
Geometry.prototype._lineWind = function(px, py, p0x, p0y, lx, ly, ex, ey) {
  if (Geo.lineContainsPoint(lx, ly, ex, ey, .05, px, py)) return true;
  var d = (px - p0x) * (ly - ey);
  if (d === 0) return 0;  // horizontal line
  // The x/y intersect of the line
  var xint = ((px * p0y - py * p0x) * (lx - ex) - (px - p0x) * (lx * ey - ly * ex)) / d;
  var yint = ((px * p0y - py * p0x) * (ly - ey)) / d;

  if (xint >= px) return 0; // the line is to the right

  if ((lx > ex ? lx - ex : ex - lx) < (ly > ey ? ly - ey : ey - ly)) {
    var min, max;
    if (ly < ey) { min = ly; max = ey; } else { min = ey; max = ly; }
    if (yint < min || yint > max) return 0;
  } else {
    // make sure the x intersect is in the line segment
    var min, max;
    if (lx < ex) { min = lx; max = ex; } else { min = ex; max = lx; }
    if (xint < min || xint > max) return 0;
  }

  if (d > 0) return 1;
  return -1;
};

/**
* @ignore
* Returns true if the geometry's unfilled path contains the point.
* @this {Geometry}
* @param {number} px
* @param {number} py
* @param {number} strokeWidth
* @return {boolean}
*/
Geometry.prototype._pathContainsPoint = function(px, py, strokeWidth) {
  var numfigs = this.figures.length;
  for (var i = 0; i < numfigs; i++) {
    var fig = this.figures._arr[i];

    if (fig.containsPoint(px, py, strokeWidth)) { return true; }
  }
  return false;
};

Geometry.prototype['getPointAlongPath'] =
/**
* @ignore
* Returns the point in the fractional distance (0-1) along the path
* @this {Geometry}
* @param {number} fraction A fractional amount between 0 and 1, inclusive.
* @returns {Point}
*/
Geometry.prototype.getPointAlongPath = function(fraction) {
  if (fraction < 0 || fraction > 1) Util.throwRangeError(fraction, '0 <= fraction <= 1', Geometry, 'getPointAlongPath:fraction');

  // For now just deal with the first figure @@@
  var fig = this.figures.first();

  var allPaths = Util.tempArray();
  var currPath = [];
  currPath.push([fig.startX, fig.startY]);
  // lastPoint only needed for drawing dash approximations
  var lastpointX = fig.startX;
  var lastpointY = fig.startY;
  var lastSubX = lastpointX;
  var lastSubY = lastpointY;

  // for each segment of the PathFigure:
  var segments = fig.segments._arr;
  var sl = segments.length;
  for (var j = 0; j < sl; j++) {
    var seg = segments[j];
    switch (seg._type) {
      case PathSegment.Move:
        allPaths.push(currPath);
        currPath = [];  // restart
        currPath.push([seg.endX, seg.endY]);

        lastpointX = seg.endX;
        lastpointY = seg.endY;
        lastSubX = lastpointX;
        lastSubY = lastpointY;
        break;
      case PathSegment.Line:
        currPath.push([seg.endX, seg.endY]);
        lastpointX = seg.endX;
        lastpointY = seg.endY;
        break;
      case PathSegment.Bezier:
        Geo.bezierLines(lastpointX, lastpointY,
                        seg._point1X, seg._point1Y,
                        seg._point2X, seg._point2Y,
                        seg._pointX, seg._pointY,
                        0.5, currPath);
        lastpointX = seg.endX;
        lastpointY = seg.endY;
        break;
      case PathSegment.QuadraticBezier:
        Geo.quadraticBezierLines(lastpointX, lastpointY,
                                seg._point1X, seg._point1Y,
                                seg._pointX, seg._pointY,
                                0.5, currPath);
        lastpointX = seg.endX;
        lastpointY = seg.endY;
        break;
      case PathSegment.Arc:
        var curves = seg.buildBeziers(fig);
        var cl = curves.length;
        for (var cli = 0; cli < cl; cli++) {
          var cu = curves[cli];
          Geo.bezierLines(lastpointX, lastpointY,
                          cu.x2, cu.y2,
                          cu.x3, cu.y3,
                          cu.x4, cu.y4,
                          0.5, currPath);
          lastpointX = cu.x4;
          lastpointY = cu.y4;
        }
        break;
      case PathSegment.SvgArc:
        var curves = seg.buildSVGBeziers(fig, lastpointX, lastpointY);
        var cl = curves.length;
        for (var cli = 0; cli < cl; cli++) {
          var cu = curves[cli];
          Geo.bezierLines(lastpointX, lastpointY,
                          cu.x2, cu.y2,
                          cu.x3, cu.y3,
                          cu.x4, cu.y4,
                          0.5, currPath);
          lastpointX = cu.x4;
          lastpointY = cu.y4;
        }
        break;
      default:
        Util.throwError('Segment not of valid type');
    }
    if (seg._isClosed) {
      currPath.push([lastSubX, lastSubY]);
      // ??? this.drawAlong(context, diagram, currPath, s);
    }
  } // end segment iteration
  allPaths.push(currPath);
  var totalDist = 0;
  var l = allPaths.length;
  var lastpt = null;

  // ?? could be optimized

  for (var i = 0; i < l; i++) {
    var path = allPaths[i];
    var ll = path.length;
    for (var j = 0; j < ll; j++) {
      var pt = path[j];
      if (j === 0) { // its a new path because a moveTo occurred, so set the lastPt and move on
        lastpt = pt;
        continue;
      }
      // compare pt and lastpt
      var dist = Math.sqrt(Point.distanceSquared(lastpt[0],lastpt[1],pt[0], pt[1]));
      totalDist += dist;
      lastpt = pt;
    }
  }

  var fractionalDist = totalDist*fraction;
  var currentDist = 0;

  for (var i = 0; i < l; i++) {
    var path = allPaths[i];
    var ll = path.length;
    for (var j = 0; j < ll; j++) {
      var pt = path[j];
      if (j === 0) { // its a new path because a moveTo occurred, so set the lastPt and move on
        lastpt = pt;
        continue;
      }
      // compare pt and lastpt
      var dist = Math.sqrt(Point.distanceSquared(lastpt[0],lastpt[1],pt[0], pt[1]));

      if (currentDist+dist > fractionalDist) {
        var offsetDist = fractionalDist - currentDist;
        var offsetBetweenPoints = offsetDist / dist;
        Util.freeArray(allPaths);
        // now we have fraction between lastpt and pt
        var finalpt = new Point(
        lastpt[0] + (pt[0] - lastpt[0]) * offsetBetweenPoints,
        lastpt[1] + (pt[1] - lastpt[1]) * offsetBetweenPoints);
        return finalpt;
      }
      currentDist += dist;
      lastpt = pt;
    }
  }

  Util.freeArray(allPaths);
  return null;
};

/**
* Gets or sets the type of the Geometry.
* The default type is {@link Geometry#Path}.
* Other permissible values are {@link Geometry#Line}, {@link Geometry#Ellipse},
* or {@link Geometry#Rectangle}.
* @name Geometry#type
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
Geometry.prototype.type;
Util.exportProperty(Geometry, 'type', Geometry.prototype.type);
Util.defineProperty(Geometry, { type: 'type' },
  /** @this {Geometry} */
  function() { return this._type; },
  /** @this {Geometry} */
  function(val) {
    var old = this._type;
    if (old !== val) {
      if (Debug) Util.checkEnumValue(val, Geometry, Geometry, 'type');
      Util.checkFrozen(this, val);
      this._type = val;
      this._invalidBounds = true;
    }
  }
);

// simple Geometry specific:
/**
* Gets or sets the starting X coordinate of the Geometry if it is of type
* {@link #Line}, {@link #Rectangle}, or {@link #Ellipse}.
* The initial value is zero.
* @name Geometry#startX
* @function.
* @return {number}
*/
/** @type {number} */
Geometry.prototype.startX;
Util.exportProperty(Geometry, 'startX', Geometry.prototype.startX);
Util.defineProperty(Geometry, { startX: 'startX' },
  /** @this {Geometry} */
  function() { return this._startX; },
  /** @this {Geometry} */
  function(val) {
    var old = this._startX;
    if (old !== val) {
      if (Debug) Util.checkRealNumber(val, Geometry, 'startX');
      Util.checkFrozen(this, val);
      this._startX = val;
      this._invalidBounds = true;
    }
  }
);

/**
* Gets or sets the starting Y coordinate of the Geometry if it is of type
* {@link #Line}, {@link #Rectangle}, or {@link #Ellipse}.
* The initial value is zero.
* @name Geometry#startY
* @function.
* @return {number}
*/
/** @type {number} */
Geometry.prototype.startY;
Util.exportProperty(Geometry, 'startY', Geometry.prototype.startY);
Util.defineProperty(Geometry, { startY: 'startY' },
  /** @this {Geometry} */
  function() { return this._startY; },
  /** @this {Geometry} */
  function(val) {
    var old = this._startY;
    if (old !== val) {
      if (Debug) Util.checkRealNumber(val, Geometry, 'startY');
      Util.checkFrozen(this, val);
      this._startY = val;
      this._invalidBounds = true;
    }
  }
);

/**
* Gets or sets the ending X coordinate of the Geometry if it is of type
* {@link #Line}, {@link #Rectangle}, or {@link #Ellipse}.
* The initial value is zero.
* @name Geometry#endX
* @function.
* @return {number}
*/
/** @type {number} */
Geometry.prototype.endX;
Util.exportProperty(Geometry, 'endX', Geometry.prototype.endX);
Util.defineProperty(Geometry, { endX: 'endX' },
  /** @this {Geometry} */
  function() { return this._endX; },
  /** @this {Geometry} */
  function(val) {
    var old = this._endX;
    if (old !== val) {
      if (Debug) Util.checkRealNumber(val, Geometry, 'endX');
      Util.checkFrozen(this, val);
      this._endX = val;
      this._invalidBounds = true;
    }
  }
);

/**
* Gets or sets the ending Y coordinate of the Geometry if it is of type
* {@link #Line}, {@link #Rectangle}, or {@link #Ellipse}.
* The initial value is zero.
* @name Geometry#endY
* @function.
* @return {number}
*/
/** @type {number} */
Geometry.prototype.endY;
Util.exportProperty(Geometry, 'endY', Geometry.prototype.endY);
Util.defineProperty(Geometry, { endY: 'endY' },
  /** @this {Geometry} */
  function() { return this._endY; },
  /** @this {Geometry} */
  function(val) {
    var old = this._endY;
    if (old !== val) {
      if (Debug) Util.checkRealNumber(val, Geometry, 'endY');
      Util.checkFrozen(this, val);
      this._endY = val;
      this._invalidBounds = true;
    }
  }
);


// All Geometry:
// A collection of figures that describes the content of the path.
/**
* Gets or sets the {@link List} of {@link PathFigure}s
* that describes the content of the
* path for Geometries of type {@link #Path}.
* @name Geometry#figures
* @function.
* @return {List}
*/
/** @type {List} */
Geometry.prototype.figures;
Util.exportProperty(Geometry, 'figures', Geometry.prototype.figures);
Util.defineProperty(Geometry, { figures: 'figures' },
  /** @this {Geometry} */
  function() { return this._figures; },
  /** @this {Geometry} */
  function(val) {
    var old = this._figures;
    if (old !== val) {
      if (Debug) Util.checkClass(val, List, Geometry, 'figures');
      Util.checkFrozen(this, val);
      this._figures = val;
      this._invalidBounds = true;
    }
  }
);


/**
* Gets or sets the spot to use when the {@link Shape#spot1} value is {@link Spot#Default}.
* The default value is {@link Spot#TopLeft}.
* @name Geometry#spot1
* @function.
* @return {Spot}
*/
/** @type {Spot} */
Geometry.prototype.spot1;
Util.defineProperty(Geometry, { spot1: 'spot1' },
  /** @this {Geometry} */
  function() { return this._spot1; },
  /** @this {Geometry} */
  function(val) {
    if (Debug) Util.checkClass(val, Spot, Geometry, 'spot1');
    Util.checkFrozen(this, val);
    this._spot1 = val.copyFrozen();
  }
);

/**
* Gets or sets the spot to use when the {@link Shape#spot2} value is {@link Spot#Default}.
* The default value is {@link Spot#BottomRight}.
* @name Geometry#spot2
* @function.
* @return {Spot}
*/
/** @type {Spot} */
Geometry.prototype.spot2;
Util.defineProperty(Geometry, { spot2: 'spot2' },
  /** @this {Geometry} */
  function() { return this._spot2; },
  /** @this {Geometry} */
  function(val) {
    if (Debug) Util.checkClass(val, Spot, Geometry, 'spot2');
    Util.checkFrozen(this, val);
    this._spot2 = val.copyFrozen();
  }
);

/**
* Gets a rectangle that contains all points within the Geometry.
* The result will always contain the origin (0, 0).
* @name Geometry#bounds
* @function.
* @return {Rect}
*/
/** @type {Rect} */
Geometry.prototype.bounds;
Util.defineReadOnlyProperty(Geometry, { bounds: 'bounds' },
  /** @this {Geometry} */
  function() {
    if (this.isInvalidBounds()) {
      this.validateBounds();
      this.computeBounds();
    }
    return this._computedBounds;
  }
);

/**
* @ignore
* Gets or sets the minimum size of this Geometry in container coordinates
* (either a {@link Panel} or the document).
* Value must be of type Size.
* The default value is zero by zero.
* @name Geometry#minSize
* @function.
* @return {Size}
*/
/** @type {Size} */
Geometry.prototype.minSize;
Util.exportProperty(Geometry, 'minSize', Geometry.prototype.minSize);
Util.defineProperty(Geometry, { minSize: 'minSize' },
  /** @this {Geometry} */
  function() { return this._minSize; },
  /** @this {Geometry} */
  function(val) {
    var old = this._minSize;
    if (!old.equals(val)) {
      if (Debug) Util.checkClass(val, Size, Geometry, 'minSize');
      val = val.copyFrozen();
      if (isNaN(val.width)) val.width = 0;
      if (isNaN(val.height)) val.height = 0;
      val.freeze();
      this._minSize = val;
    }
  }
);


/**
* Constructs an empty figure.
* The optional arguments specify the starting point of the figure.
* You'll want to add a new instance of a PathFigure to the
* {@link Geometry#figures} list of a {@link Geometry}.
* @constructor
* @param {number=} sx optional: the X coordinate of the start point (default is zero).
* @param {number=} sy optional: the Y coordinate of the start point (default is zero).
* @param {boolean=} filled optional: whether the figure is filled (default is true).
* @category Geometry
* @class
* A PathFigure represents a section of a {@link Geometry}.
* It is a single connected series of
* two-dimensional geometric {@link PathSegment}s.
* <p/>
* The {@link Geometry#figures} property is a list of PathFigures.
* <p/>
* A PathFigure must not be modified once its containing {@link Geometry}
* has been assigned to a {@link Shape}.
*/
function PathFigure(sx, sy, filled) {
  Util.uniqueHash(this);
  if (filled === undefined/*notpresent*/) filled = true;
  /** @type {boolean} */
  this._isFilled = filled;
  /** @type {boolean} */
  this._isShadowed = true;
  if (sx !== undefined/*notpresent*/) {
    if (Debug) Util.checkRealNumber(sx, PathFigure, 'sx');
    /** @type {number} */
    this._startX = sx;
  } else {
    this._startX = 0;
  }
  if (sy !== undefined/*notpresent*/) {
    if (Debug) Util.checkRealNumber(sy, PathFigure, 'sy');
    /** @type {number} */
    this._startY = sy;
  } else {
    this._startY = 0;
  }
  /** @type {List} */
  this._segments = new List(PathSegment);
  /** @type {number} */
  this._segmentsChanged = this._segments._changed;
  /** @type {boolean} */
  this._invalidBounds = true;
}

Util.publish('PathFigure', PathFigure);

/**
* Create a copy of this PathFigure, with the same values and segments.
* @expose
* @this {PathFigure}
* @return {PathFigure}
*/
PathFigure.prototype.copy = function() {
  var copy = new PathFigure();
  copy._isFilled = this._isFilled;
  copy._isShadowed = this._isShadowed;
  copy._startX = this._startX;
  copy._startY = this._startY;
  var oldsegs = this._segments;
  var numsegs = oldsegs.length;
  var newsegs = copy._segments;
  for (var i = 0; i < numsegs; i++) {
    var oldseg = oldsegs._arr[i];
    var newseg = oldseg.copy();
    newsegs.add(newseg);
  }
  copy._segmentsChanged = this._segmentsChanged;
  copy._invalidBounds = this._invalidBounds;
  return copy;
};

PathFigure.prototype['equalsApprox'] =
/**
* @ignore
* @this {PathFigure}
* @param {PathFigure} f
* @return {boolean}
*/
PathFigure.prototype.equalsApprox = function(f) {
  if (!(f instanceof PathFigure)) return false;
  //??? if (this.isFilled !== f.isFilled) return false;
  // do not check isShadowed
  if (!Geo.isApprox(this.startX, f.startX)) return false;
  if (!Geo.isApprox(this.startY, f.startY)) return false;
  var segs1 = this.segments;
  var segs2 = f.segments;
  var numsegs = segs1.length;
  if (numsegs !== segs2.length) return false;
  for (var i = 0; i < numsegs; i++) {
    var seg1 = segs1._arr[i];
    var seg2 = segs2._arr[i];
    if (!seg1.equalsApprox(seg2)) return false;
  }
  return true;
};

/**
* @ignore
* @this {PathFigure}
* @param {number=} precision Optional: the amount of decimal places to round numbers to for debugging purposes,
* leaves number unchanged by default.
* @return {string}
*/
PathFigure.prototype.toString = function(precision) {
  if (precision === undefined) {
    var str = 'M' + this.startX.toString() + ' ' + this.startY.toString();
  } else {
    var str = 'M' + this.startX.toFixed(precision) + ' ' + this.startY.toFixed(precision);
  }
  var segs = this.segments;
  var numsegs = segs.length;
  for (var i = 0; i < numsegs; i++) {
    var seg = segs._arr[i];
    str += ' ' + seg.toString(precision);
  }
  return str;
};

/**
* @ignore
* Make this object 'frozen' or immutable.
* Future attempts to change its state, for example by setting any of its properties,
* may result in an exception, until it is thaw()'ed.
* @this {PathFigure}
* @return {PathFigure}
*/
PathFigure.prototype.freeze = function() {
  this._isFrozen = true;
  var segs = this.segments;
  segs.freeze();
  var numsegs = segs.length;
  for (var i = 0; i < numsegs; i++) {
    var seg = segs._arr[i];
    seg.freeze();
  }
  return this;
};

/**
* @ignore
* Make this object 'thawed' or mutable.
* @this {PathFigure}
* @return {PathFigure}
*/
PathFigure.prototype.thaw = function() {
  this._isFrozen = false;
  var segs = this.segments;
  segs.thaw();
  var numsegs = segs.length;
  for (var i = 0; i < numsegs; i++) {
    var seg = segs._arr[i];
    seg.thaw();
  }
  return this;
};

/**
* @ignore
* @this {PathFigure}
* @return {boolean}
*/
PathFigure.prototype.isInvalidBounds = function() {
  if (this._invalidBounds) return true;
  var segs = this.segments;
  if (this._segmentsChanged !== segs._changed) return true;
  var sl = segs.length;
  for (var j = 0; j < sl; j++) {
    var seg = segs._arr[j];
    if (seg._invalidBounds) return true;
  }
  return false;
};

/**
* @ignore
* @this {PathFigure}
*/
PathFigure.prototype.validateBounds = function() {
  this._invalidBounds = false;
  var segs = this.segments;
  this._segmentsChanged = segs._changed;
  var sl = segs.length;
  for (var j = 0; j < sl; j++) {
    var seg = segs._arr[j];
    seg._invalidBounds = false;
    seg._beziers = null;
  }
};

/**
* Gets or sets whether this PathFigure is drawn filled.
* The default value is true.
* @name PathFigure#isFilled
* @function.
* @return {boolean}
*/
/** @type {boolean} */
PathFigure.prototype.isFilled;
Util.exportProperty(PathFigure, 'isFilled', PathFigure.prototype.isFilled);
Util.defineProperty(PathFigure, { isFilled: 'isFilled' },
  /** @this {PathFigure} */
  function() { return this._isFilled; },
  /** @this {PathFigure} */
  function(val) {
    if (Debug) Util.checkPrimitive(val, 'boolean', PathFigure, 'isFilled');
    Util.checkFrozen(this, val);
    this._isFilled = val;
  }
);

/**
* Gets or sets whether this PathFigure will render a shadow if one is defined.
* This is used for turning off shadows on specific subpaths.
* The default value is true.
* @name PathFigure#isShadowed
* @function.
* @return {boolean}
*/
/** @type {boolean} */
PathFigure.prototype.isShadowed;
Util.exportProperty(PathFigure, 'isShadowed', PathFigure.prototype.isShadowed);
Util.defineProperty(PathFigure, { isShadowed: 'isShadowed' },
  /** @this {PathFigure} */
  function() { return this._isShadowed; },
  /** @this {PathFigure} */
  function(val) {
    if (Debug) Util.checkPrimitive(val, 'boolean', PathFigure, 'isShadowed');
    Util.checkFrozen(this, val);
    this._isShadowed = val;
  }
);

/**
* Gets or sets the starting point X coordinate of the PathFigure.
* The default value is zero.
* @name PathFigure#startX
* @function.
* @return {number}
*/
/** @type {number} */
PathFigure.prototype.startX;
Util.exportProperty(PathFigure, 'startX', PathFigure.prototype.startX);
Util.defineProperty(PathFigure, { startX: 'startX' },
  /** @this {PathFigure} */
  function() { return this._startX; },
  /** @this {PathFigure} */
  function(val) {
    if (Debug) Util.checkRealNumber(val, PathFigure, 'startX');
    Util.checkFrozen(this, val);
    this._startX = val;
    this._invalidBounds = true;
  }
);

/**
* Gets or sets the starting point Y coordinate of the PathFigure.
* The default value is zero.
* @name PathFigure#startY
* @function.
* @return {number}
*/
/** @type {number} */
PathFigure.prototype.startY;
Util.exportProperty(PathFigure, 'startY', PathFigure.prototype.startY);
Util.defineProperty(PathFigure, { startY: 'startY' },
  /** @this {PathFigure} */
  function() { return this._startY; },
  /** @this {PathFigure} */
  function(val) {
    if (Debug) Util.checkRealNumber(val, PathFigure, 'startY');
    Util.checkFrozen(this, val);
    this._startY = val;
    this._invalidBounds = true;
  }
);

/**
* Gets or sets the {@link List} of {@link PathSegment}s that define this PathFigure.
* @name PathFigure#segments
* @function.
* @return {List}
*/
/** @type {List} */
PathFigure.prototype.segments;
Util.exportProperty(PathFigure, 'segments', PathFigure.prototype.segments);
Util.defineProperty(PathFigure, { segments: 'segments' },
  /** @this {PathFigure} */
  function() { return this._segments; },
  /** @this {PathFigure} */
  function(val) {
    if (Debug) Util.checkClass(val, List, PathFigure, 'segments');
    Util.checkFrozen(this, val);
    this._segments = val;
    this._invalidBounds = true;
  }
);

/**
* @ignore
* @this {PathFigure}
* @param {number} px
* @param {number} py
* @param {number} strokeWidth
* @return {boolean}
*/
PathFigure.prototype.containsPoint = function(px, py, strokeWidth) {
  var fig = this;
  var lastX = fig.startX;
  var lastY = fig.startY;
  // The last move command must be recorded to deal with closed subpaths
  var lmX = lastX;
  var lmY = lastY;
  var segments = fig.segments._arr;
  var numsegs = segments.length;
  for (var j = 0; j < numsegs; j++) {
    var seg = segments[j];
    switch (seg.type) {
      case PathSegment.Move:
        lmX = seg.endX;
        lmY = seg.endY;
        lastX = seg.endX;
        lastY = seg.endY;
        break;
      case PathSegment.Line:
        if (Geo.lineContainsPoint(lastX, lastY,
                seg.endX, seg.endY,
                strokeWidth, px, py)) {
          return true;
        }
        lastX = seg.endX;
        lastY = seg.endY;
        break;
      case PathSegment.Bezier:
        if (Geo.bezierContainsPoint(lastX, lastY,
                seg.point1X, seg.point1Y,
                seg.point2X, seg.point2Y,
                seg.endX, seg.endY,
                0.5, px, py, strokeWidth)) {
          return true;
        }
        lastX = seg.endX;
        lastY = seg.endY;
        break;
      case PathSegment.QuadraticBezier:
        if (Geo.quadraticBezierContainsPoint(lastX, lastY,
              seg.point1X, seg.point1Y,
              seg.endX, seg.endY,
              0.5, px, py, strokeWidth)) {
          return true;
        }
        lastX = seg.endX;
        lastY = seg.endY;
        break;
      case PathSegment.Arc:
      case PathSegment.SvgArc:
        var curves = (seg.type === PathSegment.Arc) ? seg.buildBeziers(fig) : seg.buildSVGBeziers(fig, lastX, lastY);
        var clen = curves.length;
        var c = null;
        for (var i = 0; i < clen; i++) {
          c = curves[i];
          if (i === 0 && Geo.lineContainsPoint(lastX, lastY, c.x1, c.y1, strokeWidth, px, py))
            return true;
          if (Geo.bezierContainsPoint(c.x1, c.y1, c.x2, c.y2, c.x3, c.y3, c.x4, c.y4, 0.5, px, py, strokeWidth)) {
            return true;
          }
        }
        if (c !== null) {
          lastX = c.x4;
          lastY = c.y4;
        }
        break;
      default:
        Util.throwError('Unknown Segment type: ' + seg.type);
    } // end switch
    if (seg.isClosed && (lastX !== lmX || lastY !== lmY) &&
        Geo.lineContainsPoint(lastX, lastY, lmX, lmY, strokeWidth, px, py)) {
      return true;
    }

  }
  return false;
};



/**
* Constructs a segment that goes nowhere unless you specify some Points.
* The segment type must be one of the following values:
* {@link PathSegment#Line}, {@link PathSegment#Bezier},
* {@link PathSegment#QuadraticBezier}.
* Following the optional type argument, a pair of numbers specifies the end point for this segment.
* If the type is cubic or quadratic bezier, another pair of numbers specifies the first control point.
* If the type is cubic bezier, a final pair of numbers specifies the second control point.
* You will want to add a new instance of a PathSegment to the
* {@link PathFigure#segments} list of a {@link PathFigure}.
* @constructor
* @param {EnumValue=} type if not supplied, the default PathSegment type is {@link PathSegment#Line}.
*   But if the type is supplied, one must also provide the endpoint X and Y values,
*   either as arguments in this constructor or by setting the {@link #endX} and {@link #endY} properties.
*   If the type is QuadraticBezier, the X1 and Y1 control point values must both be supplied.
*   If the type is Bezier, X1, Y1, X2, and Y2 control point values must all be supplied.
* <p>
* If the type is {@link #Arc} it needs the following arguments:
* <p><code>(startAngle, sweepAngle, centerX, centerY, radiusX, radiusY)</code>
* <ul>
* <li><strong>ex</strong> describes the start angle, in degrees
* <li><strong>ey</strong> describes the sweep angle, in degrees
* <li><strong>x1, y1</strong> describe the center point
* <li><strong>x2, y2</strong> describe the radiusX and radiusY
* </ul>
* <p>
* If the type is {@link #SvgArc} it needs the following arguments:
* <p><code>(x y rx ry x-axis-rotation large-arc-flag sweep-flag)</code>
* <p>They are in the same order as arcs in SVG path strings, except the endpoint x and y values come first, not last.
* <ul>
* <li><strong>ex, ey</strong> describe the endpoint
* <li><strong>x1, y1</strong> describe the radius
* <li><strong>x2</strong> describes the {@link #xAxisRotation} (number in degrees)
* <li><strong>y2</strong> describes the {@link #isLargeArc} (true or false)
* <li><strong>sweepFlag</strong> describes the {@link #isClockwiseArc} (true or false).
* </ul>
* @param {number=} ex optional: the X coordinate of the end point.
* @param {number=} ey optional: the Y coordinate of the end point.
* @param {number=} x1 optional: the X coordinate of the first bezier control point.
* @param {number=} y1 optional: the Y coordinate of the first bezier control point.
* @param {number=} x2 optional: the X coordinate of the second cubic bezier control point.
* @param {number|boolean=} y2 optional: the Y coordinate of the second cubic bezier control point,
* or the large-arc-flag of an SvgArc.
* @param {boolean=} clockwise optional: whether an SvgArc goes clockwise or counterclockwise.
* @category Geometry
* @class
* A PathSegment represents a straight line or curved segment of a path between
* two or more points that are part of a {@link PathFigure}.
* <p/>
* A PathSegment must not be modified once its containing {@link PathFigure}'s
* {@link Geometry} has been assigned to a {@link Shape}.
*/
function PathSegment(type, ex, ey, x1, y1, x2, y2, clockwise) {
  Util.uniqueHash(this);
  if (type === undefined) {
    type = PathSegment.Line;
  } else {
    if (Debug) Util.checkEnumValue(type, PathSegment, PathSegment, 'constructor:type');
  }

  /** @type {EnumValue} */
  this._type = type;

  if (type === PathSegment.Arc) {
    //PathSegment(PathSegment.Arc, startAngle, sweepAngle, centerX, centerY, radiusX, radiusY)
    if (ex !== undefined) { // startAngle
      if (Debug) Util.checkRealNumber(ex, PathSegment, 'ex');
      /** @type {number} */
      this._startAngle = ex;
    } else {
      this._startAngle = 0;
    }
    if (ey !== undefined) { // sweepAngle
      if (Debug) Util.checkRealNumber(ey, PathSegment, 'ey');
      /** @type {number} */
      this._sweepAngle = ey;
    } else {
      this._sweepAngle = 0;
    }

    if (x1 !== undefined) {
      if (Debug) Util.checkRealNumber(x1, PathSegment, 'x1');
      /** @type {number} */
      this._centerX = x1;
    }
    if (y1 !== undefined) {
      if (Debug) Util.checkRealNumber(y1, PathSegment, 'y1');
      /** @type {number} */
      this._centerY = y1;
    }

    if (x2 !== undefined) {
      if (Debug) Util.checkRealNumber(x2, PathSegment, 'x2');
      /** @type {number} */
      this._radiusX = Math.max(x2 || 0, 0);
    }
    if (y2 !== undefined && typeof y2 === 'number') {
      if (Debug) Util.checkRealNumber(y2, PathSegment, 'y2');
      /** @type {number} */
      this._radiusY = Math.max(y2 || 0, 0);
    } else {
      this._radiusY = this._radiusX;
    }
  } else if (type === PathSegment.SvgArc) {
    if (ex !== undefined)
      if (Debug) Util.checkRealNumber(ex, PathSegment, 'ex');
    if (ey !== undefined)
      if (Debug) Util.checkRealNumber(ey, PathSegment, 'ey');
    if (x1 !== undefined)
      if (Debug) Util.checkRealNumber(x1, PathSegment, 'x1');
    if (y1 !== undefined)
      if (Debug) Util.checkRealNumber(y1, PathSegment, 'y1');

    /** @type {number} */
    this._pointX = ex || 0;
    /** @type {number} */
    this._pointY = ey || 0;

    this._radiusX = Math.max(x1 || 0, 0);
    this._radiusY = Math.max(y1 || 0, 0);

    // These properties are re-used for large-arc-flag and sweep-flag
    this._startAngle = y2 ? 1 : 0; // large arc flag
    this._sweepAngle = clockwise ? 1 : 0; // sweep flag


    var val = x2 || 0;
    val = val % 360;
    if (val < 0) val += 360;
    /** @type {number} */
    this._xAxisRotation = val;
  } else { // Everything but Arc
    if (ex !== undefined) {
      if (Debug) Util.checkRealNumber(ex, PathSegment, 'ex');
      this._pointX = ex;
    } else {
      this._pointX = 0;
    }
    if (ey !== undefined) {
      if (Debug) Util.checkRealNumber(ey, PathSegment, 'ey');
      this._pointY = ey;
    } else {
      this._pointY = 0;
    }

    if (x1 !== undefined) {
      if (Debug) Util.checkRealNumber(x1, PathSegment, 'x1');
      /** @type {number} */
      this._point1X = x1;
    }
    if (y1 !== undefined) {
      if (Debug) Util.checkRealNumber(y1, PathSegment, 'y1');
      /** @type {number} */
      this._point1Y = y1;
    }

    if (x2 !== undefined) {
      if (Debug) Util.checkRealNumber(x2, PathSegment, 'x2');
      /** @type {number} */
      this._point2X = x2;
    }
    if (y2 !== undefined && typeof y2 === 'number') {
      if (Debug) Util.checkRealNumber(y2, PathSegment, 'y2');
      /** @type {number} */
      this._point2Y = y2;
    }
  }
  /** @type {boolean} */
  this._invalidBounds = true;
  /** @type {boolean} */
  this._isClosed = false;
  /** @type {Array} */
  this._beziers = null;
}

Util.publish('PathSegment', PathSegment);

/**
* Create a copy of this PathSegment, of the same type and with the same point values.
* @expose
* @this {PathSegment}
* @return {PathSegment}
*/
PathSegment.prototype.copy = function() {
  var copy = new PathSegment();
  copy._type = this._type;
  if (this._type === PathSegment.Arc) {
    copy._startAngle = this._startAngle;
    copy._sweepAngle = this._sweepAngle;
    copy._centerX = this._centerX;
    copy._centerY = this._centerY;
    copy._radiusX = this._radiusX;
    copy._radiusY = this._radiusY;
  } else if (this._type === PathSegment.SvgArc) {
    copy._startAngle = this._startAngle;
    copy._sweepAngle = this._sweepAngle;
    copy._pointX = this._pointX;
    copy._pointY = this._pointY;
    copy._radiusX = this._radiusX;
    copy._radiusY = this._radiusY;
    copy._xAxisRotation = this._xAxisRotation;
  } else {
    copy._pointX = this._pointX;
    copy._pointY = this._pointY;
    copy._point1X = this._point1X;
    copy._point1Y = this._point1Y;
    copy._point2X = this._point2X;
    copy._point2Y = this._point2Y;
  }
  copy._invalidBounds = this._invalidBounds;
  copy._isClosed = this._isClosed;
  return copy;
};

PathSegment.prototype['equalsApprox'] =
/**
* @ignore
* @this {PathSegment}
* @param {PathSegment} s
* @return {boolean}
*/
PathSegment.prototype.equalsApprox = function(s) {
  if (!(s instanceof PathSegment)) return false;
  if (this.type !== s.type) return false;
  if (this.isClosed !== s.isClosed) return false;
  switch (this.type) {
    case PathSegment.Move:
    case PathSegment.Line:
      return Geo.isApprox(this.endX, s.endX) &&
             Geo.isApprox(this.endY, s.endY);
    case PathSegment.Bezier:
      return Geo.isApprox(this.endX, s.endX) &&
             Geo.isApprox(this.endY, s.endY) &&
             Geo.isApprox(this.point1X, s.point1X) &&
             Geo.isApprox(this.point1Y, s.point1Y) &&
             Geo.isApprox(this.point2X, s.point2X) &&
             Geo.isApprox(this.point2Y, s.point2Y);
    case PathSegment.QuadraticBezier:
      return Geo.isApprox(this.endX, s.endX) &&
             Geo.isApprox(this.endY, s.endY) &&
             Geo.isApprox(this.point1X, s.point1X) &&
             Geo.isApprox(this.point1Y, s.point1Y);
    case PathSegment.Arc:
      return Geo.isApprox(this.startAngle, s.startAngle) &&
             Geo.isApprox(this.sweepAngle, s.sweepAngle) &&
             Geo.isApprox(this.centerX, s.centerX) &&
             Geo.isApprox(this.centerY, s.centerY) &&
             Geo.isApprox(this.radiusX, s.radiusX) &&
             Geo.isApprox(this.radiusY, s.radiusY);
    case PathSegment.SvgArc:
      return this.isClockwiseArc === s.isClockwiseArc &&
             this.isLargeArc === s.isLargeArc &&
             Geo.isApprox(this.xAxisRotation, s.xAxisRotation) &&
             Geo.isApprox(this.endX, s.endX) &&
             Geo.isApprox(this.endY, s.endY) &&
             Geo.isApprox(this.radiusX, s.radiusX) &&
             Geo.isApprox(this.radiusY, s.radiusY);
    default:
      return false;
  }
};

/**
* @ignore
* @this {PathSegment}
* @param {number=} precision Optional: the amount of decimal places to round numbers to for debugging purposes,
* leaves number unchanged by default.
* @return {string}
*/
PathSegment.prototype.toString = function(precision) {
  var str;
  switch (this.type) {
    case PathSegment.Move:
      if (precision === undefined) {
        str = 'M' + this.endX.toString() + ' ' + this.endY.toString();
      } else {
        str = 'M' + this.endX.toFixed(precision) + ' ' + this.endY.toFixed(precision);
      }
      break;
    case PathSegment.Line:
      if (precision === undefined) {
        str = 'L' + this.endX.toString() + ' ' + this.endY.toString();
      } else {
        str = 'L' + this.endX.toFixed(precision) + ' ' + this.endY.toFixed(precision);
      }
      break;
    case PathSegment.Bezier:
      if (precision === undefined) {
        str = 'C' + this.point1X.toString() + ' ' + this.point1Y.toString() + ' ' +
                   this.point2X.toString() + ' ' + this.point2Y.toString() + ' ' +
                   this.endX.toString() + ' ' + this.endY.toString();
      } else {
        str = 'C' + this.point1X.toFixed(precision) + ' ' + this.point1Y.toFixed(precision) + ' ' +
                   this.point2X.toFixed(precision) + ' ' + this.point2Y.toFixed(precision) + ' ' +
                   this.endX.toFixed(precision) + ' ' + this.endY.toFixed(precision);
      }
      break;
    case PathSegment.QuadraticBezier:
      if (precision === undefined) {
        str = 'Q' + this.point1X.toString() + ' ' + this.point1Y.toString() + ' ' +
                   this.endX.toString() + ' ' + this.endY.toString();
      } else {
        str = 'Q' + this.point1X.toFixed(precision) + ' ' + this.point1Y.toFixed(precision) + ' ' +
                   this.endX.toFixed(precision) + ' ' + this.endY.toFixed(precision);
      }
      break;
    case PathSegment.Arc:
      // startAngle, sweepAngle, centerX, centerY, radiusX
      // TODO: radiusY?
      if (precision === undefined) {
        str = 'B' + this.startAngle.toString() + ' ' + this.sweepAngle.toString() + ' ' +
                  this.centerX.toString() + ' ' + this.centerY.toString() + ' ' +
                  this.radiusX;
      } else {
        str = 'B' + this.startAngle.toFixed(precision) + ' ' + this.sweepAngle.toFixed(precision) + ' ' +
                  this.centerX.toFixed(precision) + ' ' + this.centerY.toFixed(precision) + ' ' +
                  this.radiusX;
      }
      break;
    case PathSegment.SvgArc:
      if (precision === undefined) {
        str = 'A' +
        this.radiusX.toString() + ' ' + this.radiusY.toString() + ' ' +
        this.xAxisRotation.toString() + ' ' +
        (this.isLargeArc ? 1 : 0) + ' ' +
        (this.isClockwiseArc ? 1 : 0) + ' ' +
        this.endX.toString() + ' ' + this.endY.toString();
      } else {
        str = 'A' +
        this.radiusX.toFixed(precision) + ' ' + this.radiusY.toFixed(precision) + ' ' +
        this.xAxisRotation.toFixed(precision) + ' ' +
        (this.isLargeArc ? 1 : 0) + ' ' +
        (this.isClockwiseArc ? 1 : 0) + ' ' +
        this.endX.toFixed(precision) + ' ' + this.endY.toFixed(precision);
      }
      break;
    default:
      str = this.type.toString();
  }
  return str + (this._isClosed ? 'z' : '');
};


/**
* For beginning a new subpath, a value for {@link PathSegment#type}.
* @name PathSegment#Move
* @constant
* @static
* @return {EnumValue}
*/
PathSegment['Move'] = PathSegment.Move = Util.defineEnumValue(PathSegment, 'Move', 0);

/**
* For drawing a straight line segment, a value for {@link PathSegment#type}.
* @name PathSegment#Line
* @constant
* @static
* @return {EnumValue}
*/
PathSegment['Line'] = PathSegment.Line = Util.defineEnumValue(PathSegment, 'Line', 1);

/**
* For drawing a cubic bezier segment, a value for {@link PathSegment#type}.
* @name PathSegment#Bezier
* @constant
* @static
* @return {EnumValue}
*/
PathSegment['Bezier'] = PathSegment.Bezier = Util.defineEnumValue(PathSegment, 'Bezier', 2);

/**
* For drawing a quadratic bezier segment, a value for {@link PathSegment#type}.
* @name PathSegment#QuadraticBezier
* @constant
* @static
* @return {EnumValue}
*/
PathSegment['QuadraticBezier'] = PathSegment.QuadraticBezier = Util.defineEnumValue(PathSegment, 'QuadraticBezier', 3);

/**
* For drawing an arc segment, a value for {@link PathSegment#type}.
* @name PathSegment#Arc
* @constant
* @static
* @return {EnumValue}
*/
PathSegment['Arc'] = PathSegment.Arc = Util.defineEnumValue(PathSegment, 'Arc', 4);

/**
* For drawing an SVG arc segment, a value for {@link PathSegment#type}.
* See: http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands
* @name PathSegment#SvgArc
* @constant
* @static
* @return {EnumValue}
* @since 1.1
*/
PathSegment['SvgArc'] = PathSegment.SvgArc = Util.defineEnumValue(PathSegment, 'SvgArc', 4);

/**
* @ignore
* Make this object 'frozen' or immutable.
* Future attempts to change its state, for example by setting any of its properties,
* may result in an exception, until it is thaw()'ed.
* @this {PathSegment}
* @return {PathSegment}
*/
PathSegment.prototype.freeze = function() {
  this._isFrozen = true;
  return this;
};

/**
* @ignore
* Make this object 'thawed' or mutable.
* @this {PathSegment}
* @return {PathSegment}
*/
PathSegment.prototype.thaw = function() {
  this._isFrozen = false;
  return this;
};


PathSegment.prototype['close'] =
/**
* Closes the path after this PathSegment
* @this {PathSegment}
* @return {PathSegment} returns this PathSegment.
*/
PathSegment.prototype.close = function() {
  this._isClosed = true;
  return this;
};

/**
* @ignore
* Constructs an array of bezier curves that represent an Arc
* @this {PathSegment}
* @return {Array} of arc descriptor objects.
*/
PathSegment.prototype.buildBeziers = function(fig) {
  if (this._beziers !== null && fig._invalidBounds === false) return this._beziers;
  var rx = this.radiusX;
  var ry = this.radiusY;
  if (ry === undefined) ry = rx;

  // otherwise make a new list
  var curves = Geo.createArc(
    this._centerX,
    this._centerY,
    (rx < ry) ? rx : ry, // use the smaller radius
    this.startAngle,
    (this.startAngle + this.sweepAngle));

  if (rx !== ry) {
    // we need to normalize all curves before continuing based on x1/y1 equalling 0/0
    var tt = Util.tempTransform();
    tt.reset();
    if (rx < ry) //rx is smaller, scale up y
      tt.scale(1, ry / rx);
    else // ry is smaller, scale up x
      tt.scale(rx / ry, 1);
    Geometry.transformCurves(curves, tt);
    Util.freeTransform(tt);
  }
  this._beziers = curves;
  return this._beziers;
};

/**
* @ignore
* Constructs an array of bezier curves that represent an Arc
* @this {PathSegment}
* @return {Array} of arc descriptor objects.
*/
PathSegment.prototype.buildSVGBeziers = function(fig, lpx, lpy) {
  if (this._beziers !== null && fig._invalidBounds === false) return this._beziers;
  // otherwise make a new list

  // REQS:
  var currx = lpx;
  var curry = lpy;
  var rx = this._radiusX;
  var ry = this._radiusY;
  // pay attention to which is used below
  var xAxisRotationRadians = this._xAxisRotation * (Math.PI / 180.0);
  var largeArcFlag = this.startAngle;
  var sweepFlag = this._sweepAngle;
  var cpx = this._pointX;
  var cpy = this._pointY;
  //rx, ry xAxisRotation, largeArcFlag, sweepFlag, cpx, cp.y

  // Conversion from endpoint to center parameterization
  // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
  // x1', y1'
  var currpx = Math.cos(xAxisRotationRadians) * (currx - cpx) / 2.0 + Math.sin(xAxisRotationRadians) * (curry - cpy) / 2.0;
  var currpy = -Math.sin(xAxisRotationRadians) * (currx - cpx) / 2.0 + Math.cos(xAxisRotationRadians) * (curry - cpy) / 2.0;
  // adjust radii
  var l = Math.pow(currpx, 2) / Math.pow(rx, 2) + Math.pow(currpy, 2) / Math.pow(ry, 2);
  if (l > 1) {
    rx *= Math.sqrt(l);
    ry *= Math.sqrt(l);
  }
  // cx', cy'

  var s = (largeArcFlag === sweepFlag ? -1 : 1) * Math.sqrt(
    ((Math.pow(rx, 2) * Math.pow(ry, 2)) - (Math.pow(rx, 2) * Math.pow(currpy, 2)) - (Math.pow(ry, 2) * Math.pow(currpx, 2))) /
    (Math.pow(rx, 2) * Math.pow(currpy, 2) + Math.pow(ry, 2) * Math.pow(currpx, 2))
  );
  if (isNaN(s)) s = 0;
  var cppx = s * rx * currpy / ry;
  var cppy = s * -ry * currpx / rx;
  if (isNaN(cppx)) cppx = 0;
  if (isNaN(cppy)) cppy = 0;
  // cx, cy
  var centpx = (currx + cpx) / 2.0 + Math.cos(xAxisRotationRadians) * cppx - Math.sin(xAxisRotationRadians) * cppy;
  var centpy = (curry + cpy) / 2.0 + Math.sin(xAxisRotationRadians) * cppx + Math.cos(xAxisRotationRadians) * cppy;
  // vector magnitude
  /** @ignore */
  var m = function(v) { return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2)); };
  // ratio between two vectors
  /** @ignore */
  var r = function(u, v) { return (u[0] * v[0] + u[1] * v[1]) / (m(u) * m(v)) };
  // angle between two vectors
  /** @ignore */
  var a = function(u, v) { return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(r(u, v)); };
  // initial angle
  var a1 = a([1, 0], [(currpx - cppx) / rx, (currpy - cppy) / ry]);
  // angle delta
  var u = [(currpx - cppx) / rx, (currpy - cppy) / ry];
  var v = [(-currpx - cppx) / rx, (-currpy - cppy) / ry];
  var ad = a(u, v);
  if (r(u, v) <= -1) ad = Math.PI;
  if (r(u, v) >= 1) ad = 0;

  if (sweepFlag === 0 && ad > 0) ad = ad - 2 * Math.PI;
  if (sweepFlag === 1 && ad < 0) ad = ad + 2 * Math.PI;

  /*
  // for markers
  var dir = 1 - sweepFlag ? 1.0 : -1.0;
  var ah = a1 + dir * (ad / 2.0);
  var halfWayx = centpx + rx * Math.cos(ah);
  var halfWayy = centpy + ry * Math.sin(ah);
  */

  var rr = (rx > ry) ? rx : ry;
  var sx = rx > ry ? 1 : rx / ry;
  var sy = rx > ry ? ry / rx : 1;

  //x, y, radius, startAngle, endAngle
  var curves = Geo.createArc(0, 0, rr, a1, a1 + ad, true);

  var tt = Util.tempTransform();
  tt.reset();
  tt.translate(centpx, centpy);
  tt.rotate(this._xAxisRotation, 0, 0); // rotate uses degrees not radians
  tt.scale(sx, sy);
  Geometry.transformCurves2(curves, tt);
  Util.freeTransform(tt);

  /* If we wanted to make path segments instead
  for (var ii = 0; ii < curves.length; ii++) {
    var c = curves[ii];
    ctx.bezierTo(c.x2, c.y2, c.x3, c.y3, c.x4, c.y4);
  }
  */

  /* for drawing maybe
  ctx.translate(centpx, centpy);
  ctx.rotate(xAxisRotationRadians);
  ctx.scale(sx, sy);
  ctx.arc(0, 0, r, a1, a1 + ad, 1 - sweepFlag);
  ctx.scale(1/sx, 1/sy);
  ctx.rotate(-xAxisRotationRadians);
  ctx.translate(-centpx, -centpy);
  */

  this._beziers = curves;
  return this._beziers;
};

/**
* Gets or sets whether the path is closed after this PathSegment.
* Default value is false.
* @name PathSegment#isClosed
* @function.
* @return {boolean}
*/
/** @type {boolean} */
PathSegment.prototype.isClosed;
Util.exportProperty(PathSegment, 'isClosed', PathSegment.prototype.isClosed);
Util.defineProperty(PathSegment, { isClosed: 'isClosed' },
  /** @this {PathSegment} */
  function() { return this._isClosed; },
  /** @this {PathSegment} */
  function(val) {
    if (this._isClosed !== val) {
     this._isClosed = val;
     this._invalidBounds = true;
    }
  }
);


/**
* Gets or sets the type of the PathSegment.
* The value must be one of the following:
* {@link PathSegment#Line}, {@link PathSegment#Bezier},
* {@link PathSegment#QuadraticBezier}, {@link PathSegment#Arc},
* {@link PathSegment#Move}, {@link PathSegment#Arc}, and {@link PathSegment#SvgArc}.
* @name PathSegment#type
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
PathSegment.prototype.type;
Util.exportProperty(PathSegment, 'type', PathSegment.prototype.type);
Util.defineProperty(PathSegment, { type: 'type' },
  /** @this {PathSegment} */
  function() { return this._type; },
  /** @this {PathSegment} */
  function(val) {
    if (Debug) Util.checkEnumValue(val, PathSegment, PathSegment, 'type');
    Util.checkFrozen(this, val);
    this._type = val;
    this._invalidBounds = true;
  }
);


// all PathSegments:
/**
* Gets or sets the X coordinate of the end point for all kinds of PathSegment.
* The default value is zero.
* @name PathSegment#endX
* @function.
* @return {number}
*/
/** @type {number} */
PathSegment.prototype.endX;
Util.exportProperty(PathSegment, 'endX', PathSegment.prototype.endX);
Util.defineProperty(PathSegment, { endX: 'endX' },
  /** @this {PathSegment} */
  function() { return this._pointX; },
  /** @this {PathSegment} */
  function(val) {
    if (Debug) Util.checkRealNumber(val, PathSegment, 'endX');
    Util.checkFrozen(this, val);
    this._pointX = val;
    this._invalidBounds = true;
  }
);

/**
* Gets or sets the Y coordinate of the end point for all kinds of PathSegment.
* The default value is zero.
* @name PathSegment#endY
* @function.
* @return {number}
*/
/** @type {number} */
PathSegment.prototype.endY;
Util.exportProperty(PathSegment, 'endY', PathSegment.prototype.endY);
Util.defineProperty(PathSegment, { endY: 'endY' },
  /** @this {PathSegment} */
  function() { return this._pointY; },
  /** @this {PathSegment} */
  function(val) {
    if (Debug) Util.checkRealNumber(val, PathSegment, 'endY');
    Util.checkFrozen(this, val);
    this._pointY = val;
    this._invalidBounds = true;
  }
);


// Bezier PathSegments:
/**
* Gets or sets the X value of the first control point for a PathSegment
* of type {@link #Bezier} or {@link #QuadraticBezier}.
* @name PathSegment#point1X
* @function.
* @return {number}
*/
/** @type {number} */
PathSegment.prototype.point1X;
Util.defineProperty(PathSegment, { point1X: 'point1X' },
  /** @this {PathSegment} */
  function() { return this._point1X; },
  /** @this {PathSegment} */
  function(val) {
    if (Debug) Util.checkRealNumber(val, PathSegment, 'point1X');
    Util.checkFrozen(this, val);
    this._point1X = val;
    this._invalidBounds = true;
  }
);

/**
* Gets or sets the Y value of the first control point for a PathSegment
* of type {@link #Bezier} or {@link #QuadraticBezier}.
* @name PathSegment#point1Y
* @function.
* @return {number}
*/
/** @type {number} */
PathSegment.prototype.point1Y;
Util.defineProperty(PathSegment, { point1Y: 'point1Y' },
  /** @this {PathSegment} */
  function() { return this._point1Y; },
  /** @this {PathSegment} */
  function(val) {
    if (Debug) Util.checkRealNumber(val, PathSegment, 'point1Y');
    Util.checkFrozen(this, val);
    this._point1Y = val;
    this._invalidBounds = true;
  }
);

/**
* Gets or sets the X value of the second control point for a PathSegment
* of type cubic {@link #Bezier}.
* @name PathSegment#point2X
* @function.
* @return {number}
*/
/** @type {number} */
PathSegment.prototype.point2X;
Util.defineProperty(PathSegment, { point2X: 'point2X' },
  /** @this {PathSegment} */
  function() { return this._point2X; },
  /** @this {PathSegment} */
  function(val) {
    if (Debug) Util.checkRealNumber(val, PathSegment, 'point2X');
    Util.checkFrozen(this, val);
    this._point2X = val;
    this._invalidBounds = true;
  }
);

/**
* Gets or sets the Y value of the second control point for a PathSegment
* of type cubic {@link #Bezier}.
* @name PathSegment#point2Y
* @function.
* @return {number}
*/
/** @type {number} */
PathSegment.prototype.point2Y;
Util.defineProperty(PathSegment, { point2Y: 'point2Y' },
  /** @this {PathSegment} */
  function() { return this._point2Y; },
  /** @this {PathSegment} */
  function(val) {
    if (Debug) Util.checkRealNumber(val, PathSegment, 'point2Y');
    Util.checkFrozen(this, val);
    this._point2Y = val;
    this._invalidBounds = true;
  }
);

/**
* Gets or sets the center X value of the Arc for a PathSegment of type {@link #Arc}.
* @name PathSegment#centerX
* @function.
* @return {number}
*/
/** @type {number} */
PathSegment.prototype.centerX;
Util.defineProperty(PathSegment, { centerX: 'centerX' },
  /** @this {PathSegment} */
  function() { return this._centerX; },
  /** @this {PathSegment} */
  function(val) {
    if (Debug) Util.checkRealNumber(val, PathSegment, 'centerX');
    Util.checkFrozen(this, val);
    this._centerX = val;
    this._invalidBounds = true;
  }
);

/**
* Gets or sets the center Y value of the Arc for a PathSegment of type {@link #Arc}.
* @name PathSegment#centerY
* @function.
* @return {number}
*/
/** @type {number} */
PathSegment.prototype.centerY;
Util.defineProperty(PathSegment, { centerY: 'centerY' },
  /** @this {PathSegment} */
  function() { return this._centerY; },
  /** @this {PathSegment} */
  function(val) {
    if (Debug) Util.checkRealNumber(val, PathSegment, 'centerY');
    Util.checkFrozen(this, val);
    this._centerY = val;
    this._invalidBounds = true;
  }
);

/**
* Gets or sets the X value of the radius for a PathSegment of type {@link #Arc}.
* Value must be a positive number.
* @name PathSegment#radiusX
* @function.
* @return {number}
*/
/** @type {number} */
PathSegment.prototype.radiusX;
Util.defineProperty(PathSegment, { radiusX: 'radiusX' },
  /** @this {PathSegment} */
  function() { return this._radiusX; },
  /** @this {PathSegment} */
  function(val) {
    if (Debug) Util.checkRealNumber(val, PathSegment, 'radiusX');
    if (val < 0) Util.throwRangeError(val, '>= zero', PathSegment, 'radiusX');
    Util.checkFrozen(this, val);
    this._radiusX = val;
    this._invalidBounds = true;
  }
);

/**
* Gets or sets the Y value of the radius for a PathSegment of type {@link #Arc}.
* Value must be a positive number.
* @name PathSegment#radiusY
* @function.
* @return {number}
*/
/** @type {number} */
PathSegment.prototype.radiusY;
Util.defineProperty(PathSegment, { radiusY: 'radiusY' },
  /** @this {PathSegment} */
  function() { return this._radiusY; },
  /** @this {PathSegment} */
  function(val) {
    if (Debug) Util.checkRealNumber(val, PathSegment, 'radiusY');
    if (val < 0) Util.throwRangeError(val, '>= zero', PathSegment, 'radiusY');
    Util.checkFrozen(this, val);
    this._radiusY = val;
    this._invalidBounds = true;
  }
);

/**
* Gets or sets the starting angle for a PathSegment of type {@link #Arc}.
* Value must within the range: (0 <= val < 360).
* @name PathSegment#startAngle
* @function.
* @return {number}
*/
/** @type {number} */
PathSegment.prototype.startAngle;
Util.defineProperty(PathSegment, { startAngle: 'startAngle' },
  /** @this {PathSegment} */
  function() { return this._startAngle; },
  /** @this {PathSegment} */
  function(val) {
    if (this._startAngle !== val) {
      Util.checkFrozen(this, val);
      if (Debug) Util.checkRealNumber(val, PathSegment, 'startAngle');
      val = val % 360;
      if (val < 0) val += 360;
      this._startAngle = val;
      this._invalidBounds = true;
    }
  }
);

/**
* Gets or sets the length of angle in degrees, or amount of arc to "sweep" for a PathSegment of type {@link #Arc}.
* Must be between -360 and 360, inclusive.
* @name PathSegment#sweepAngle
* @function.
* @return {number}
*/
/** @type {number} */
PathSegment.prototype.sweepAngle;
Util.defineProperty(PathSegment, { sweepAngle: 'sweepAngle' },
  /** @this {PathSegment} */
  function() { return this._sweepAngle; },
  /** @this {PathSegment} */
  function(val) {
    if (Debug) Util.checkRealNumber(val, PathSegment, 'sweepAngle');
    Util.checkFrozen(this, val);
    if (val > 360) val = 360;
    if (val < -360) val = -360;
    this._sweepAngle = val;
    this._invalidBounds = true;
  }
);

/**
* Gets or sets the sweep-flag for a PathSegment of type {@link #SvgArc}.
* SVG Arcs specify a radius and an endpoint, and are always a portion of an ellipse.
* The parameters allow for two potential ellipses and four potential arcs.
* A sweep-flag set to true true will use one of the two possible positive-angle arcs,
* and false will use one of the two negative-angle arcs. Which arc is chosen (small or large)
* depends on the value of {@link #isLargeArc}.
* For more information see the visual examples in the
* <a href="http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands">W3 SVG Arc specification</a>
* @name PathSegment#isClockwiseArc
* @function.
* @return {boolean}
*/
/** @type {boolean} */
PathSegment.prototype.isClockwiseArc;
Util.defineProperty(PathSegment, { isClockwiseArc: 'isClockwiseArc' },
  /** @this {PathSegment} */
  function() { return !!this._sweepAngle; },
  /** @this {PathSegment} */
  function(val) {
    Util.checkFrozen(this, val);
    this._sweepAngle = (!!val) ? 1 : 0;
    this._invalidBounds = true;
  }
);

/**
* Gets or sets the large-arc-flag for a PathSegment of type {@link #SvgArc}.
* SVG Arcs specify a radius and an endpoint, and are always a portion of an ellipse.
* The parameters allow for two potential ellipses and four potential arcs.
* A large-arc-flag set to true true will choose the larger of the two arc sweeps.
* Which way the arc sweeps (positive angle or negative angle) depends on the value of {@link #isClockwiseArc}
* For more information see the visual examples in the
* <a href="http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands">W3 SVG Arc specification</a>
* @name PathSegment#isLargeArc
* @function.
* @return {boolean}
*/
/** @type {boolean} */
PathSegment.prototype.isLargeArc;
Util.defineProperty(PathSegment, { isLargeArc: 'isLargeArc' },
  /** @this {PathSegment} */
  function() { return !!this._startAngle; },
  /** @this {PathSegment} */
  function(val) {
    Util.checkFrozen(this, val);
    this._startAngle = (!!val) ? 1 : 0;
    this._invalidBounds = true;
  }
);

/**
* Gets or sets the X-axis rotation for a PathSegment of type {@link #SvgArc}.
* X-axis rotation is used to rotate the ellipse that the arc is created from,
* and must be between 0 and 360 degrees.
* Default is 0.
* @name PathSegment#xAxisRotation
* @function.
* @return {number}
*/
/** @type {number} */
PathSegment.prototype.xAxisRotation;
Util.defineProperty(PathSegment, { xAxisRotation: 'xAxisRotation' },
  /** @this {PathSegment} */
  function() { return this._xAxisRotation; },
  /** @this {PathSegment} */
  function(val) {
    if (Debug) Util.checkRealNumber(val, PathSegment, 'xAxisRotation');
    val = val % 360;
    if (val < 0) val += 360;
    Util.checkFrozen(this, val);
    this._xAxisRotation = val;
    this._invalidBounds = true;
  }
);

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
InputEvent
DiagramEvent
*/

/**
* The InputEvent class constructor produces an empty InputEvent.
* You should not need to call this constructor.
* @constructor
* @class
* An InputEvent represents a mouse or keyboard or touch event.
* The principal properties hold information about a particular input event.
* These properties include the {@link #documentPoint} at which a mouse event
* occurred in document coordinates,
* the corresponding point in view/element coordinates, {@link #viewPoint},
* the {@link #key} for keyboard events,
* and the {@link #modifiers} and {@link #button} at the time.
* Additional descriptive properties include {@link #clickCount}, {@link #delta},
* {@link #timestamp}, and the source event {@link #event} (if available).
* <p/>
* Many of its properties are provided for convenient access to the state of the input event,
* such as asking whether the {@link #control} key was held down at the time,
* or the {@link #targetObject} (a {@link GraphObject}) that the mouse was over .
*/
function InputEvent() {
  /** @type {Diagram} */
  this._diagram = null;
  /** @type {Point} */
  this._viewPoint = new Point(0, 0).freeze();  // keep own instance of a Point
  /** @type {Point} */
  this._documentPoint = new Point(0, 0).freeze();  // keep own instance of a Point
  /** @type {number} */
  this._modifiers = 0;
  /** @type {number} */
  this._button = 0;
  /** @type {string} */
  this._key = '';
  /** @type {boolean} */
  this._down = false;
  /** @type {boolean} */
  this._up = false;
  /** @type {number} */
  this._clickCount = 0;
  /** @type {number} */
  this._delta = 0;
  /** @type {boolean} */
  this._handled = false;
  /** @type {boolean} */
  this._bubbles = false;
  /** @type {Event} */
  this._event = null;
  /** @type {number} */
  this._timestamp = 0;
  /** @type {Diagram} */
  this._targetDiagram = null;
  /** @type {GraphObject} */
  this._targetObject = null;
}

Util.publish('InputEvent', InputEvent);

/**
* Make a copy of this InputEvent.
* @expose
* @this {InputEvent}
* @return {InputEvent}
*/
InputEvent.prototype.copy = function() {
  var copy = new InputEvent();
  copy._diagram = this._diagram;
  copy._viewPoint = this.viewPoint.copy().freeze();  // keep own instance of a Point
  copy._documentPoint = this.documentPoint.copy().freeze();  // keep own instance of a Point
  copy._modifiers = this._modifiers;
  copy._button = this._button;
  copy._key = this._key;
  copy._down = this._down;
  copy._up = this._up;
  copy._clickCount = this._clickCount;
  copy._delta = this._delta;
  copy._handled = this._handled;
  copy._bubbles = this._bubbles;
  copy._event = this._event;
  copy._timestamp = this._timestamp;
  copy._targetDiagram = this._targetDiagram;
  copy._targetObject = this._targetObject;
  return copy;
};

/**
* @ignore
* @this {InputEvent}
* @return {string}
*/
InputEvent.prototype.toString = function() {
  var s = '^';
  if (this.modifiers) s += 'M:' + this.modifiers;
  if (this.button) s += 'B:' + this.button;
  if (this.key) s += 'K:' + this.key;
  if (this.clickCount) s += 'C:' + this.clickCount;
  if (this.delta) s += 'D:' + this.delta;
  if (this.handled) s += 'h';
  if (this.bubbles) s += 'b';
  if (this.documentPoint !== null) s += '@' + this.documentPoint.toString();
  return s;
};


/**
* Gets the source diagram associated with the event.
* @name InputEvent#diagram
* @function.
* @return {Diagram}
*/
/** @type {Diagram} */
InputEvent.prototype.diagram;
Util.exportProperty(InputEvent, 'diagram', InputEvent.prototype.diagram);
Util.defineProperty(InputEvent, {diagram: 'diagram'},
  /** @this {InputEvent} */
  function() { return this._diagram; },
  /** @this {InputEvent} */
  function(val) { this._diagram = val; }
);

/**
* Gets or sets the point at which this input event occurred.
* The Point is in view coordinates within the viewport, not in document coordinates.
* This should be valid for mouse events.
* For keyboard events, this is the last available mouse point.
* @name InputEvent#viewPoint
* @function.
* @return {Point}
* @see #documentPoint
*/
/** @type {Point} */
InputEvent.prototype.viewPoint;
Util.exportProperty(InputEvent, 'viewPoint', InputEvent.prototype.viewPoint);
Util.defineProperty(InputEvent, {viewPoint: 'viewPoint'},
  /** @this {InputEvent} */
  function() { return this._viewPoint; },
  /** @this {InputEvent} */
  function(val) {
    Util.checkClass(val, Point, InputEvent, 'viewPoint');
    this._viewPoint.assign(val);  // keep own instance of a Point
  }
);

/**
* Gets or sets the point at which this input event occurred, in document coordinates.
* The Point is in document coordinates, the same as the {@link GraphObject#position}
* for {@link Part}s in the diagram.
* This should be valid for mouse events.
* For keyboard events, this is the last available mouse point.
* @name InputEvent#documentPoint
* @function.
* @return {Point}
* @see #viewPoint
*/
/** @type {Point} */
InputEvent.prototype.documentPoint;
Util.exportProperty(InputEvent, 'documentPoint', InputEvent.prototype.documentPoint);
Util.defineProperty(InputEvent, {documentPoint: 'documentPoint'},
  /** @this {InputEvent} */
  function() { return this._documentPoint; },
  /** @this {InputEvent} */
  function(val) {
    Util.checkClass(val, Point, InputEvent, 'documentPoint');
    this._documentPoint.assign(val);  // keep own instance of a Point
  }
);

/**
* Gets or sets the modifier keys that were used with the mouse or keyboard event.
* The number will be a combination of flags representing Control, Shift, Alt or Meta.
* @name InputEvent#modifiers
* @function.
* @return {number}
* @see #control
* @see #shift
* @see #alt
* @see #meta
*/
/** @type {number} */
InputEvent.prototype.modifiers;
Util.exportProperty(InputEvent, 'modifiers', InputEvent.prototype.modifiers);
Util.defineProperty(InputEvent, {modifiers: 'modifiers'},
  /** @this {InputEvent} */
  function() { return this._modifiers; },
  /** @this {InputEvent} */
  function(val) { this._modifiers = val; }
);

/**
* Gets or sets the button that caused this event.
* This property is valid if this is a mouse event.
* @name InputEvent#button
* @function.
* @return {number}
* @see #left
* @see #middle
* @see #right
*/
/** @type {number} */
InputEvent.prototype.button;
Util.exportProperty(InputEvent, 'button', InputEvent.prototype.button);
Util.defineProperty(InputEvent, {button: 'button'},
  /** @this {InputEvent} */
  function() { return this._button; },
  /** @this {InputEvent} */
  function(val) { this._button = val; }
);

/**
* Gets or sets the key pressed or released as this event.
* This property is valid if this is a keyboard event.
* @name InputEvent#key
* @function.
* @return {string}
*/
/** @type {string} */
InputEvent.prototype.key;
Util.exportProperty(InputEvent, 'key', InputEvent.prototype.key);
Util.defineProperty(InputEvent, {key: 'key'},
  /** @this {InputEvent} */
  function() { return this._key; },
  /** @this {InputEvent} */
  function(val) { this._key = val; }
);

/**
* Gets or sets whether the InputEvent represents a mouse-down or a key-down event.
* The default value is false.
* @name InputEvent#down
* @function.
* @return {boolean}
* @since 1.1
*/
/** @type {boolean} */
InputEvent.prototype.down;
Util.exportProperty(InputEvent, 'down', InputEvent.prototype.down);
Util.defineProperty(InputEvent, { down: 'down' },
  /** @this {InputEvent} */
  function() { return this._down; },
  /** @this {InputEvent} */
  function(val) { this._down = val; }
);

/**
* Gets or sets whether the InputEvent represents a mouse-up or a key-up event.
* The default value is false.
* @name InputEvent#up
* @function.
* @return {boolean}
* @since 1.1
*/
/** @type {boolean} */
InputEvent.prototype.up;
Util.exportProperty(InputEvent, 'up', InputEvent.prototype.up);
Util.defineProperty(InputEvent, { up: 'up' },
  /** @this {InputEvent} */
  function() { return this._up; },
  /** @this {InputEvent} */
  function(val) { this._up = val; }
);

/**
* Gets or sets whether this event represents a click or a double-click.
* It is zero if not a click; one if a single-click; two if a double-click.
* This property is valid if this is a mouse event.
* @name InputEvent#clickCount
* @function.
* @return {number}
*/
/** @type {number} */
InputEvent.prototype.clickCount;
Util.exportProperty(InputEvent, 'clickCount', InputEvent.prototype.clickCount);
Util.defineProperty(InputEvent, {clickCount: 'clickCount'},
  /** @this {InputEvent} */
  function() { return this._clickCount; },
  /** @this {InputEvent} */
  function(val) { this._clickCount = val; }
);

/**
* Gets or sets the amount of change associated with a mouse-wheel rotation.
* It is an abstract number, either positive or negative.
* This property is valid if this is a mouse-wheel event.
* @name InputEvent#delta
* @function.
* @return {number}
*/
/** @type {number} */
InputEvent.prototype.delta;
Util.exportProperty(InputEvent, 'delta', InputEvent.prototype.delta);
Util.defineProperty(InputEvent, {delta: 'delta'},
  /** @this {InputEvent} */
  function() { return this._delta; },
  /** @this {InputEvent} */
  function(val) { this._delta = val; }
);

/**
* Gets or sets whether an InputEvent that applies to a {@link GraphObject} and bubbles
* up the chain of containing {@link Panel}s is stopped from continuing up the chain.
* <p/>
* Some event handlers may set this to true to avoid getting any behavior from the containing Panels.
* The default value is false.
* @name InputEvent#handled
* @function.
* @return {boolean}
* @see #bubbles
*/
/** @type {boolean} */
InputEvent.prototype.handled;
Util.exportProperty(InputEvent, 'handled', InputEvent.prototype.handled);
Util.defineProperty(InputEvent, {handled: 'handled'},
  /** @this {InputEvent} */
  function() { return this._handled; },
  /** @this {InputEvent} */
  function(val) { this._handled = val; }
);

/**
* Gets or sets whether the underlying {@link #event} is prevented from bubbling up
* the hierarchy of HTML elements outside of the Diagram and whether any default action is canceled.
* <p/>
* Some event handlers may set this to true if the event should continue beyond the diagram's DIV
* and result in any default behaviors by the user-agent.
* The default value is false.
* @name InputEvent#bubbles
* @function.
* @return {boolean}
* @see #handled
*/
/** @type {boolean} */
InputEvent.prototype.bubbles;
Util.exportProperty(InputEvent, 'bubbles', InputEvent.prototype.bubbles);
Util.defineProperty(InputEvent, {bubbles: 'bubbles'},
  /** @this {InputEvent} */
  function() { return this._bubbles; },
  /** @this {InputEvent} */
  function(val) { this._bubbles = val; }
);

/**
* Gets or sets the platform's user-agent-supplied event for this event.
* It may be null if no underlying event exists.
* @name InputEvent#event
* @function.
* @return {Event}
* @see #timestamp
*/
/** @type {Event} */
InputEvent.prototype.event;
Util.exportProperty(InputEvent, 'event', InputEvent.prototype.event);
Util.defineProperty(InputEvent, {event: 'event'},
  /** @this {InputEvent} */
  function() { return this._event; },
  /** @this {InputEvent} */
  function(val) { this._event = val; }
);

/**
* @ignore
* Gets whether the meta key is being held down.
* This is true if the key is currently pressed.
* @name InputEvent#isTouchEvent
* @function.
* @return {boolean}
*/
/** @type {boolean} */
InputEvent.prototype.isTouchEvent;
Util.defineReadOnlyProperty(InputEvent, { isTouchEvent: 'isTouchEvent' },
  /** @this {InputEvent} */
  function() {
    var te = window['TouchEvent'];
    return te && this.event instanceof te;
  }
);

/**
* Gets or sets the time at which the event occurred, in milliseconds.
* @name InputEvent#timestamp
* @function.
* @return {number}
*/
/** @type {number} */
InputEvent.prototype.timestamp;
Util.exportProperty(InputEvent, 'timestamp', InputEvent.prototype.timestamp);
Util.defineProperty(InputEvent, {timestamp: 'timestamp'},
  /** @this {InputEvent} */
  function() { return this._timestamp; },
  /** @this {InputEvent} */
  function(val) { this._timestamp = val; }
);


/**
* Gets or sets the diagram associated with the canvas that the event is currently targeting.
* @name InputEvent#targetDiagram
* @function.
* @return {Diagram}
*/
/** @type {Diagram} */
InputEvent.prototype.targetDiagram;
Util.exportProperty(InputEvent, 'targetDiagram', InputEvent.prototype.targetDiagram);
Util.defineProperty(InputEvent, { targetDiagram: 'targetDiagram' },
  /** @this {InputEvent} */
  function() { return this._targetDiagram; },
  /** @this {InputEvent} */
  function(val) { this._targetDiagram = val; }
);

/**
* Gets or sets the {@link GraphObject} that is at the current mouse point, if any.
* <p/>
* For those events that are bubbled up the chain of parent {@link Panel}s,
* this property provides access to the original {@link GraphObject} where the input event occurred.
* @name InputEvent#targetObject
* @function.
* @return {GraphObject}
* @see #handled
*/
/** @type {GraphObject} */
InputEvent.prototype.targetObject;
Util.exportProperty(InputEvent, 'targetObject', InputEvent.prototype.targetObject);
Util.defineProperty(InputEvent, {targetObject: 'targetObject'},
  /** @this {InputEvent} */
  function() { return this._targetObject; },
  /** @this {InputEvent} */
  function(val) { this._targetObject = val; }
);


// Convenience properties

/**
* Gets whether the control key is being held down.
* This is true if the key is currently pressed.
* @name InputEvent#control
* @function.
* @return {boolean}
* @see #modifiers
* @see #shift
* @see #alt
* @see #meta
*/
/** @type {boolean} */
InputEvent.prototype.control;
Util.defineReadOnlyProperty(InputEvent, {control: 'control'},
  /** @this {InputEvent} */
  function() { return (this.modifiers & 1) !== 0; }
);

/**
* Gets whether the shift key is being held down.
* This is true if the key is currently pressed.
* @name InputEvent#shift
* @function.
* @return {boolean}
* @see #modifiers
* @see #control
* @see #alt
* @see #meta
*/
/** @type {boolean} */
InputEvent.prototype.shift;
Util.defineReadOnlyProperty(InputEvent, {shift: 'shift'},
  /** @this {InputEvent} */
  function() { return (this.modifiers & 4) !== 0; }
);

/**
* Gets whether the alt key is being held down.
* This is true if the key is currently pressed.
* @name InputEvent#alt
* @function.
* @return {boolean}
* @see #modifiers
* @see #control
* @see #shift
* @see #meta
*/
/** @type {boolean} */
InputEvent.prototype.alt;
Util.defineReadOnlyProperty(InputEvent, {alt: 'alt'},
  /** @this {InputEvent} */
  function() { return (this.modifiers & 2) !== 0; }
);

/**
* Gets whether the meta key is being held down.
* This is true if the key is currently pressed.
* @name InputEvent#meta
* @function.
* @return {boolean}
* @see #modifiers
* @see #control
* @see #shift
* @see #alt
*/
/** @type {boolean} */
InputEvent.prototype.meta;
Util.defineReadOnlyProperty(InputEvent, {meta: 'meta'},
  /** @this {InputEvent} */
  function() { return (this.modifiers & 8) !== 0; }
);

/**
* Gets whether the logical left mouse button is being held down.
* This is true if the button is currently pressed.
* @name InputEvent#left
* @function.
* @return {boolean}
* @see #button
* @see #middle
* @see #right
*/
/** @type {boolean} */
InputEvent.prototype.left;
Util.defineReadOnlyProperty(InputEvent, {left: 'left'},
  /** @this {InputEvent} */
  function() { return this.button === 0; }
);

/**
* Gets whether the logical middle mouse button is being held down.
* This is true if the button is currently pressed.
* @name InputEvent#middle
* @function.
* @return {boolean}
* @see #button
* @see #left
* @see #right
*/
/** @type {boolean} */
InputEvent.prototype.middle;
Util.defineReadOnlyProperty(InputEvent, {middle: 'middle'},
  /** @this {InputEvent} */
  function() { return this.button === 1; }
);

/**
* Gets whether the logical right mouse button is being held down.
* This is true if the button is currently pressed.
* @name InputEvent#right
* @function.
* @return {boolean}
* @see #button
* @see #left
* @see #middle
*/
/** @type {boolean} */
InputEvent.prototype.right;
Util.defineReadOnlyProperty(InputEvent, {right: 'right'},
  /** @this {InputEvent} */
  function() { return this.button === 2; }
);


/**
* The DiagramEvent class constructor produces an empty DiagramEvent.
* You should not need to call this constructor.
* @constructor
* @class
* A DiagramEvent represents a more abstract event than an {@link InputEvent}.
* They are raised on the {@link Diagram} class.
* One can receive such events by registering a DiagramEvent listener on a Diagram
* by calling {@link Diagram#addDiagramListener}.
* The listener function, when called, will be passed an instance of a {@link DiagramEvent}.
* Use the {@link #name} property to decide what kind of diagram event it is.
* The {@link #diagram} property refers to the Diagram, and you can get additional information
* from that, such as the {@link Diagram#lastInput}, which in turn provides information
* such as {@link InputEvent#documentPoint} that may be relevant for that kind of DiagramEvent.
* <p/>
* The {@link #subject} and {@link #parameter} properties optionally provide additional information
* about the diagram event.  The subject could be a collection of {@link Part}s or it could be
* an individual object such as a {@link Link} or a {@link GraphObject} within a {@link Node}.
* Everything depends on the kind of diagram event that it is.
* <p/>
* Some DiagramEvents such as "ObjectSingleClicked" or "BackgroundDoubleClicked" are normally
* associated with {@link InputEvent}s.
* Some DiagramEvents such as "SelectionMoved" or "PartRotated" are associated with the
* results of {@link Tool}-handled gestures or {@link CommandHandler} actions.
* Some DiagramEvents are not necessarily associated with any input events at all,
* such as "ViewportBoundsChanged", which can happen due to programmatic
* changes to the {@link Diagram#position} and {@link Diagram#scale} properties.
* <p/>
* Currently defined diagram event names include:
* <ul>
*   <li><b>"BackgroundSingleClicked"</b>, a click that was not on any Part; </li>
*   <li><b>"BackgroundDoubleClicked"</b>, a double-click that was not on any Part</li>
*   <li><b>"BackgroundContextClicked"</b>, a context-click that was not on any Part</li>
*   <li><b>"ChangingSelection"</b>, an operation is about to change the {@link Diagram#selection} collection</li>
*   <li><b>"ChangedSelection"</b>, an operation has just changed the {@link Diagram#selection} collection</li>
*   <li><b>"ClipboardChanged"</b>, Parts have been copied to the clipboard by {@link CommandHandler#copySelection}; the {@link DiagramEvent#subject} is the collection of {@link Part}s</li>
*   <li><b>"ClipboardPasted"</b>, Parts have been copied from the clipboard into the Diagram by {@link CommandHandler#pasteSelection}; the {@link DiagramEvent#subject} is the {@link Diagram#selection}</li>
*   <li><b>"DocumentBoundsChanged"</b>, the area of the diagram's Parts, {@link Diagram#documentBounds}, has changed; the {@link DiagramEvent#parameter} is the old {@link Rect}</li>
*   <li><b>"ExternalObjectsDropped"</b>, Parts have been copied into the Diagram by drag-and-drop from outside of the Diagram; the {@link DiagramEvent#subject} is the {@link Diagram#selection}</li>
*   <li><b>"InitialLayoutCompleted"</b>, the whole diagram layout has updated for the first time since a major change to the Diagram, such as replacing the Model</li>
*   <li><b>"LayoutCompleted"</b>, the whole diagram layout has just been updated</li>
*   <li><b>"LinkDrawn"</b>, the user has just created a new Link using {@link LinkingTool}; the {@link DiagramEvent#subject} is the new {@link Link}</li>
*   <li><b>"LinkRelinked"</b>, the user has just reconnected an existing Link using {@link RelinkingTool}; the {@link DiagramEvent#subject} is the modified {@link Link}, the {@link DiagramEvent#parameter} is the {@link GraphObject} port that the link was disconnected from</li>
*   <li><b>"LinkReshaped"</b>, the user has just rerouted an existing Link using {@link LinkReshapingTool}; the {@link DiagramEvent#subject} is the modified {@link Link}</li>
*   <li><b>"ObjectSingleClicked"</b>, a click that occurred on a GraphObject; the {@link DiagramEvent#subject} is the {@link GraphObject}</li>
*   <li><b>"ObjectDoubleClicked"</b>, a double-click that occurred on a GraphObject; the {@link DiagramEvent#subject} is the {@link GraphObject}</li>
*   <li><b>"ObjectContextClicked"</b>, a context-click that occurred on a GraphObject; the {@link DiagramEvent#subject} is the {@link GraphObject}</li>
*   <li><b>"PartCreated"</b>, the user inserted a new Part by {@link ClickCreatingTool}; the {@link DiagramEvent#subject} is the new {@link Part}</li>
*   <!--<li><b>"PartReshaped"</b>, the user has changed the geometry of a Shape by {@link PartReshapingTool}</li>-->
*   <li><b>"PartResized"</b>, the user has changed the size of a GraphObject by {@link ResizingTool}; the {@link DiagramEvent#subject} is the {@link GraphObject}, the {@link DiagramEvent#parameter} is the original Size</li>
*   <li><b>"PartRotated"</b>, the user has changed the angle of a GraphObject by {@link RotatingTool}; the {@link DiagramEvent#subject} is the {@link GraphObject}, the {@link DiagramEvent#parameter} is the original angle</li>
*   <li><b>"SelectionMoved"</b>, the user has moved selected Parts by {@link DraggingTool}; the {@link DiagramEvent#subject} is the moved {@link Diagram#selection}</li>
*   <li><b>"SelectionCopied"</b>, the user has copied selected Parts by {@link DraggingTool}; the {@link DiagramEvent#subject} is the newly copied {@link Diagram#selection}</li>
*   <li><b>"SelectionDeleting"</b>, the user is about to delete selected Parts by {@link CommandHandler#deleteSelection}; you can cancel the deletion by setting {@link DiagramEvent#cancel} to true</li>
*   <li><b>"SelectionDeleted"</b>, the user has deleted selected Parts by {@link CommandHandler#deleteSelection}; the {@link DiagramEvent#subject} is the collection of {@link Part}s that were deleted</li>
*   <li><b>"SelectionGrouped"</b>, the user has made a new Group out of the selected Parts by {@link CommandHandler#groupSelection}; the {@link DiagramEvent#subject} is the new {@link Group}</li>
*   <li><b>"SelectionUngrouped"</b>, the user has removed a selected Group but kept its members by {@link CommandHandler#ungroupSelection}; the {@link DiagramEvent#subject} is the collection of {@link Group}s that were ungrouped, the {@link Diagram#Event#parameter} is the collection of former member {@link Part}s that were ungrouped</li>
*   <li><b>"SubGraphCollapsed"</b>, the user has collapsed selected Groups by {@link CommandHandler#collapseSubGraph}; the {@link DiagramEvent#subject} is the collection of {@link Group}s that were collapsed</li>
*   <li><b>"SubGraphExpanded"</b>, the user has expanded selected Groups by {@link CommandHandler#expandSubGraph}; the {@link DiagramEvent#subject} is the collection of {@link Group}s that were expanded</li>
*   <li><b>"TextEdited"</b>, the user has changed the string value of a TextBlock by {@link TextEditingTool}; the {@link DiagramEvent#subject} is the edited {@link TextBlock}, the {@link DiagramEvent#parameter} is the original string</li>
*   <li><b>"TreeCollapsed"</b>, the user has collapsed selected Nodes with subtrees by {@link CommandHandler#collapseTree}; the {@link DiagramEvent#subject} is the collection of {@link Node}s that were collapsed</li>
*   <li><b>"TreeExpanded"</b>, the user has expanded selected Nodes with subtrees by {@link CommandHandler#expandTree}; the {@link DiagramEvent#subject} is the collection of {@link Node}s that were expanded</li>
*   <li><b>"ViewportBoundsChanged"</b>, the visible area of the Diagram, {@link Diagram#viewportBounds}, has changed; the {@link DiagramEvent#parameter} is the old {@link Rect}</li>
* </ul>
*/
function DiagramEvent() {
  /** @type {Diagram} */
  this._diagram = null;
  /** @type {string} */
  this._name = '';
  /** @type {Object} */
  this._subject = null;
  /** @type {*} */
  this._parameter = null;
  /** @type {boolean} */
  this._cancel = false;
}

Util.publish('DiagramEvent', DiagramEvent);

/**
* @ignore
* Make a copy of this DiagramEvent.
* @expose
* @this {DiagramEvent}
* @return {DiagramEvent}
*/
DiagramEvent.prototype.copy = function() {
  var copy = new DiagramEvent();
  copy._diagram = this._diagram;
  copy._name = this._name;
  copy._subject = this._subject;
  copy._parameter = this._parameter;
  copy._cancel = this._cancel;
  return copy;
};

/**
* @ignore
* @this {DiagramEvent}
* @return {string}
*/
DiagramEvent.prototype.toString = function() {
  var s = '*' + this.name;
  if (this.cancel) s += 'x';
  if (this.subject !== null) s += ':' + this.subject.toString();
  if (this.parameter !== null) s += '(' + this.parameter.toString() + ')';
  return s;
};

/**
* Gets the diagram associated with the event.
* @name DiagramEvent#diagram
* @function.
*/
/** @type {Diagram} */
DiagramEvent.prototype.diagram;
Util.exportProperty(DiagramEvent, 'diagram', DiagramEvent.prototype.diagram);
Util.defineProperty(DiagramEvent, {diagram: 'diagram'},
  /** @this {DiagramEvent} */
  function() { return this._diagram; },
  /** @this {DiagramEvent} */
  function(val) { this._diagram = val; }
);

/**
* Gets or sets the name of the kind of diagram event that this represents.
* This property should always be set to one of the recognized list of names,
* as listed in the documentation for {@link DiagramEvent}.
* @name DiagramEvent#name
* @function.
* @return {string}
*/
/** @type {string} */
DiagramEvent.prototype.name;
Util.exportProperty(DiagramEvent, 'name', DiagramEvent.prototype.name);
Util.defineProperty(DiagramEvent, {name: 'name'},
  /** @this {DiagramEvent} */
  function() { return this._name; },
  /** @this {DiagramEvent} */
  function(val) { this._name = val; }
);

/**
* Gets or sets an optional object that is the subject of the diagram event.
* This property defaults to null.
* @name DiagramEvent#subject
* @function.
* @return {Object}
*/
/** @type {Object} */
DiagramEvent.prototype.subject;
Util.exportProperty(DiagramEvent, 'subject', DiagramEvent.prototype.subject);
Util.defineProperty(DiagramEvent, { subject: 'subject' },
  /** @this {DiagramEvent} */
  function() { return this._subject; },
  /** @this {DiagramEvent} */
  function(val) { this._subject = val; }
);

/**
* Gets or sets an optional object that describes the change to the subject of the diagram event.
* This property defaults to null.
* @name DiagramEvent#parameter
* @function.
* @return {*}
*/
/** @type {*} */
DiagramEvent.prototype.parameter;
Util.exportProperty(DiagramEvent, 'parameter', DiagramEvent.prototype.parameter);
Util.defineProperty(DiagramEvent, { parameter: 'parameter' },
  /** @this {DiagramEvent} */
  function() { return this._parameter; },
  /** @this {DiagramEvent} */
  function(val) { this._parameter = val; }
);

/**
* Gets or sets whether any default actions associated with this diagram event
* should be avoided or cancelled.
* <p/>
* Most diagram event types ignore this property.
* The default value is false -- any actions proceed normally.
* @name DiagramEvent#cancel
* @function.
* @return {boolean}
*/
/** @type {boolean} */
DiagramEvent.prototype.cancel;
Util.exportProperty(DiagramEvent, 'cancel', DiagramEvent.prototype.cancel);
Util.defineProperty(DiagramEvent, {cancel: 'cancel'},
  /** @this {DiagramEvent} */
  function() { return this._cancel; },
  /** @this {DiagramEvent} */
  function(val) { this._cancel = val; }
);

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
ChangedEvent
*/


/**
* The ChangedEvent class constructor produces an empty ChangedEvent object.
* @constructor
* @category Model
* @class
* A ChangedEvent represents a change to an object, typically a {@link GraphObject},
* but also for model data, a {@link Model}, or a {@link Diagram}.
* The most common case is for remembering the name of a property
* and the before-and-after values for that property.
* <p>
* You can listen for changed events on the model using {@link Model#addChangedListener}
* and on the Diagram using {@link Diagram#addChangedListener}.
* <p>
* There are four kinds of changes, represented by enumerated values:
* {@link ChangedEvent.Property} (the most common), {@link ChangedEvent.Insert} and {@link ChangedEvent.Remove}
* (to represent inserting or removing objects from collections),
* and {@link ChangedEvent.Transaction} (to notify about beginning or ending transactions or undo or redo).
* <p/>
* The most common kind of ChangedEvent is a Property change.
* The name of the property is given by {@link #propertyName}.
* The modified object is given by {@link #object}.
* Use the {@link #oldValue} and {@link #newValue} properties for the before and after property values.
* <p/>
* For an Insert ChangedEvent, the modified collection (often an Array) is a property value on the {@link #object}.
* The {@link #propertyName} helps distinguish between different collections on the object.
* Use the {@link #newValue} property to indicate the value that was inserted.
* Use the {@link #newParam} property to indicate where or how, such as an array index or dictionary key.
* <p/>
* For a Remove ChangedEvent, the modified collection is a property value on the {@link #object}.
* The {@link #propertyName} helps distinguish between different collections on the object.
* Use the {@link #oldValue} property to indicate the value that was removed.
* Use the {@link #oldParam} property to indicate where or how, such as an array index or dictionary key.
* <p/>
* Transaction ChangedEvents are generated by the {@link UndoManager}.
* The {@link #propertyName} names the nature of the ChangedEvent.
* For the very first transaction, the property name is "StartingFirstTransaction".
* This ChangedEvent precedes a ChangedEvent whose property name is "StartedTransaction",
* which occurs for every top-level transaction.
* <p/>
* When ending a transaction, there is first a ChangedEvent whose name is "ComittingTransaction".
* This is followed by one with either "CommittedTransaction" or "RolledBackTransaction",
* depending on how the transaction is ending.
* The {@link #oldValue} provides the transaction name and the {@link #object} is the {@link Transaction} being finished.
* (Note that the Transaction value may be null if no Transaction is available at that time,
* perhaps because there were no changes made during the transaction.)
* That Transaction can be scanned to look for ChangedEvents that you may wish to record in a database,
* all within a single database transaction.
* <p/>
* There are also Transaction ChangedEvents corresponding to "StartingUndo", "FinishedUndo",
* "StartingRedo", and "FinishedRedo".
* The {@link #object} property provides the {@link Transaction} that is about-to-be or just-was undone or redone.
* <p/>
* Non-Transaction ChangedEvents are remembered by the {@link UndoManager}, if {@link UndoManager#isEnabled},
* and held in the {@link UndoManager#history} as {@link Transaction}s which hold lists of ChangedEvents.
* That is why ChangedEvent implements {@link #undo} and {@link #redo} of the change that it remembers.
* <p/>
* When the ChangedEvent represents a change to a {@link Model}, the value of {@link #model} is non-null
* and the value of {@link #diagram} is meaningless.
* If the change is a structural change to the model,
* the value of {@link #modelChange} indicates the kind of change.
* Currently defined model changed event names include:
* <ul>
*   <li><b>"nodeDataArray"</b>, after the model's {@link Model#nodeDataArray} is replaced, inserted into or removed from
*       (setting {@link Model#nodeDataArray} or calling {@link Model#addNodeData} or {@link Model#removeNodeData})
*   </li>
*   <li><b>"nodeKey"</b>, after changing a node data's unique key ({@link Model#setKeyForNodeData})</li>
*   <li><b>"nodeCategory"</b>, after changing a node data's category ({@link Model#setCategoryForNodeData})</li>
*   <li><b>"linkFromKey"</b>, after changing a link data's "from" node key ({@link GraphLinksModel#setFromKeyForLinkData})</li>
*   <li><b>"linkToKey"</b>, after changing a link data's "to" node key ({@link GraphLinksModel#setToKeyForLinkData})</li>
*   <li><b>"linkFromPortId"</b>, after changing a link data's "from" port ({@link GraphLinksModel#setFromPortIdForLinkData})</li>
*   <li><b>"linkToPortId"</b>, after changing a link data's "to" port ({@link GraphLinksModel#setToPortIdForLinkData})</li>
*   <li><b>"linkLabelKeys"</b>, after replacing, inserting into, or removing from a link data's array of keys to label nodes
*        (calling {@link GraphLinksModel#setLabelKeysForLinkData}, {@link GraphLinksModel#addLabelKeyForLinkData},
*         or {@link GraphLinksModel#removeLabelKeyForLinkData})
*   </li>
*   <li><b>"linkDataArray"</b>, after the model's {@link GraphLinksModel#linkDataArray} is replaced, inserted into or removed from
*       (setting {@link GraphLinksModel#linkDataArray} or calling {@link GraphLinksModel#addLinkData}
*        or {@link GraphLinksModel#removeLinkData})
*   </li>
*   <li><b>"nodeGroupKey"</b>, after changing a node data's key for a containing group data ({@link GraphLinksModel#setGroupKeyForNodeData})</li>
*   <li><b>"linkCategory"</b>, after changing a link data's category ({@link GraphLinksModel#setCategoryForLinkData})</li>
*   <li><b>"nodeParentKey"</b>, after changing a node data's "parent" node key ({@link TreeModel#setParentKeyForNodeData})</li>
*   <li><b>"parentLinkCategory"</b>, after changing a node data's "parent" link's category({@link TreeModel#setParentLinkCategoryForNodeData})</li>
*   <li><b>"SourceChanged"</b>, for internal implementation use only</li>
* </ul>
* The value of {@link ChangedEvent#propertyName} indicates the actual name of the property that was modified.
* {@link ChangedEvent#modelChange} is a non-empty string only when there is a known structural change to the model,
* not just the setting of some property on some object.
* <p/>
* When the ChangedEvent represents a change to a {@link Diagram} or a {@link GraphObject} within a diagram,
* the value of {@link #diagram} is non-null and
* the values of {@link #model} and {@link #modelChange} are meaningless.
*/
function ChangedEvent() {
  this.clear();
}

Util.publish('ChangedEvent', ChangedEvent);

/**
* For informational events, such as transactions and undo/redo operations,
* and used as the value for {@link ChangedEvent#change}.
* The {@link ChangedEvent#object} refers to the {@link Transaction} affected, if any.
* The {@link ChangedEvent#propertyName} distinguishes the different transaction or undo or redo stages.
* The {@link ChangedEVent#oldValue} may provide the transaction name, if available, as given to {@link UndoManager#commitTransaction}.
* @name ChangedEvent#Transaction
* @constant
* @static
* @return {EnumValue}
*/
ChangedEvent['Transaction'] = ChangedEvent.Transaction = Util.defineEnumValue(ChangedEvent, 'Transaction', -1);

/**
* For simple property changes,
* and used as the value for {@link ChangedEvent#change}.
* The name of the property is given by {@link ChangedEvent#propertyName}.
* The modified object is given by {@link ChangedEvent#object}.
* Use the {@link ChangedEvent#oldValue} and {@link ChangedEvent#newValue} properties for the previous and next property values.
* <p>
* For model changes, the {@link ChangedEvent#modelChange} may be non-empty, indicating a structural change to the model.
* @name ChangedEvent#Property
* @constant
* @static
* @return {EnumValue}
*/
ChangedEvent['Property'] = ChangedEvent.Property = Util.defineEnumValue(ChangedEvent, 'Property', 0);

/**
* For inserting into collections,
* and used as the value for {@link ChangedEvent#change}.
* The modified object is given by {@link ChangedEvent#object}.
* Use the optional {@link ChangedEvent#propertyName} to distinguish between different collections on the object.
* Use the {@link ChangedEvent#newValue} property to indicate the value that was inserted.
* Use the optional {@link ChangedEvent#newParam} property to indicate where or how, such as an array index or dictionary key.
* @name ChangedEvent#Insert
* @constant
* @static
* @return {EnumValue}
*/
ChangedEvent['Insert'] = ChangedEvent.Insert = Util.defineEnumValue(ChangedEvent, 'Insert', 1);

/**
* For removing from collections,
* and used as the value for {@link ChangedEvent#change}.
* The modified object is given by {@link ChangedEvent#object}.
* Use the optional {@link ChangedEvent#propertyName} to distinguish between different collections on the object.
* Use the {@link ChangedEvent#oldValue} property to indicate the value that was removed.
* Use the optional {@link ChangedEvent#oldParam} property to indicate where or how, such as an array index or dictionary key.
* @name ChangedEvent#Remove
* @constant
* @static
* @return {EnumValue}
*/
ChangedEvent['Remove'] = ChangedEvent.Remove = Util.defineEnumValue(ChangedEvent, 'Remove', 2);

ChangedEvent.prototype['clear'] =
/**
* Forget any object references that this ChangedEvent may have.
* @this {ChangedEvent}
*/
ChangedEvent.prototype.clear = function() {
  /** @type {EnumValue} */
  this._change = ChangedEvent.Property;
  /** @type {string} */
  this._modelChange = '';
  /** @type {string|function(Object):*} */
  this._propertyName = '';
  /** @type {Model} */
  this._model = null;
  /** @type {Diagram} */
  this._diagram = null;
  /** @type {Object} */
  this._object = null;
  this._oldValue = null;
  this._oldParam = null;
  this._newValue = null;
  this._newParam = null;
};

/**
* Make a copy of this ChangedEvent.
* ChangedEvents are copied when the {@link UndoManager} adds to a {@link Transaction}.
* @expose
* @this {ChangedEvent}
* @return {ChangedEvent}
*/
ChangedEvent.prototype.copy = function() {
  var copy = new ChangedEvent();
  copy._model = this._model;
  copy._diagram = this._diagram;
  copy._change = this._change;
  copy._modelChange = this._modelChange;
  copy._propertyName = this._propertyName;
  copy._object = this._object;
  var v = this._oldValue;
  if (Util.isObject(v) && typeof v.copyFrozen === 'function') {
    copy._oldValue = v.copyFrozen();
  } else {
    copy._oldValue = v;
  }
  v = this._oldParam;
  if (Util.isObject(v) && typeof v.copyFrozen === 'function') {
    copy._oldParam = v.copyFrozen();
  } else {
    copy._oldParam = v;
  }
  v = this._newValue;
  if (Util.isObject(v) && typeof v.copyFrozen === 'function') {
    copy._newValue = v.copyFrozen();
  } else {
    copy._newValue = v;
  }
  v = this._newParam;
  if (Util.isObject(v) && typeof v.copyFrozen === 'function') {
    copy._newParam = v.copyFrozen();
  } else {
    copy._newParam = v;
  }
  return copy;
};

/**
* @ignore
* @this {ChangedEvent}
* @return {string}
*/
ChangedEvent.prototype.toString = function() {
  var s = '';
  if (this.change === ChangedEvent.Transaction) {
    s += '* ';
  } else if (this.change === ChangedEvent.Property) {
    s += (this.model !== null ? '!m' : '!d');
  } else {
    s += (this.model !== null ? '!m' : '!d') + this.change;
  }
  if (this.propertyName && typeof this.propertyName === 'string') s += ' ' + this.propertyName;
  if (this.modelChange && this.modelChange !== this.propertyName) s += ' ' + this.modelChange;
  s += ': ';
  if (this.change === ChangedEvent.Transaction) {
    if (this.oldValue !== null) s += ' ' + this.oldValue;
  } else {
    if (this.object !== null) s += Binding.toString(this.object);
    if (this.oldValue !== null) s += '  old: ' + Binding.toString(this.oldValue);
    if (this.oldParam !== null) s += ' ' + this.oldParam;
    if (this.newValue !== null) s += '  new: ' + Binding.toString(this.newValue);
    if (this.newParam !== null) s += ' ' + this.newParam;
  }
  return s;
};


ChangedEvent.prototype['getValue'] =
/**
* This is a convenient method to get the right value, depending on the value of undo,
* when implementing a state change as part of an undo or a redo.
* @this {ChangedEvent}
* @param {boolean} undo If true, returns the oldValue, otherwise returns the newValue.
* @return {*} Either the oldValue or the newValue.
*/
ChangedEvent.prototype.getValue = function(undo) {
  if (undo)
    return this.oldValue;
  else
    return this.newValue;
};

ChangedEvent.prototype['getParam'] =
/**
* This is a convenient method to get the right parameter value, depending on the value of undo,
* when implementing a state change as part of an undo or a redo.
* @this {ChangedEvent}
* @param {boolean} undo If true, returns the oldParam, otherwise returns the newParam.
* @return {*} Either the oldParam or the newParam.
*/
ChangedEvent.prototype.getParam = function(undo) {
  if (undo)
    return this.oldParam;
  else
    return this.newParam;
};


ChangedEvent.prototype['canUndo'] =
/**
* This predicate returns true if you can call undo().
* @this {ChangedEvent}
* @return {boolean} true if ready for undo() to be called.
*/
ChangedEvent.prototype.canUndo = function() {
  if (this.model !== null) return true;
  if (this.diagram !== null) return true;
  return false;
};

ChangedEvent.prototype['undo'] =
/**
* Reverse the effects of this object change.
* canUndo() must be true for this method to have any effect.
* @this {ChangedEvent}
*/
ChangedEvent.prototype.undo = function() {
  if (this.canUndo()) {
    if (this.model !== null) this.model.changeState(this, true);
    else if (this.diagram !== null) this.diagram.changeState(this, true);
  }
};

ChangedEvent.prototype['canRedo'] =
/**
* This predicate returns true if you can call redo().
* @this {ChangedEvent}
* @return {boolean} true if ready for redo() to be called.
*/
ChangedEvent.prototype.canRedo = function() {
  if (this.model !== null) return true;
  if (this.diagram !== null) return true;
  return false;
};

ChangedEvent.prototype['redo'] =
/**
* Re-perform this object change after an undo().
* canRedo() must be true for this method to have any effect.
* @this {ChangedEvent}
*/
ChangedEvent.prototype.redo = function() {
  if (this.canRedo()) {
    if (this.model !== null) this.model.changeState(this, false);
    else if (this.diagram !== null) this.diagram.changeState(this, false);
  }
};


/**
 * Gets or sets the {@link Model} or {@link TreeModel} or {@link GraphLinksModel} that was modified.
 * When this property is non-null, the {@link #diagram} property will be null.
 * However this property and the {@link #diagram} property may both be null simultaneously,
 * when no particular model or diagram applies.
 * @name ChangedEvent#model
 * @function.
 * @return {Model}
 */
/** @type {Model} */
ChangedEvent.prototype.model;
Util.exportProperty(ChangedEvent, 'model', ChangedEvent.prototype.model);
Util.defineProperty(ChangedEvent, {model: 'model'},
  /** @this {ChangedEvent} */
  function() { return this._model; },
  /** @this {ChangedEvent} */
  function(val) { this._model = val; }
);

/**
 * Gets or sets the {@link Diagram} that was modified.
 * When this property is non-null, the {@link #model} property will be null.
 * However this property and the {@link #model} property may both be null simultaneously,
 * when no particular model or diagram applies.
 * @name ChangedEvent#diagram
 * @function.
 * @return {Diagram}
 */
/** @type {Diagram} */
ChangedEvent.prototype.diagram;
Util.exportProperty(ChangedEvent, 'diagram', ChangedEvent.prototype.diagram);
Util.defineProperty(ChangedEvent, {diagram: 'diagram'},
  /** @this {ChangedEvent} */
  function() { return this._diagram; },
  /** @this {ChangedEvent} */
  function(val) { this._diagram = val; }
);

/**
* Gets or sets the nature of change that occurred.
* The default is {@link ChangedEvent.Property}.
* Other values are {@link ChangedEvent.Insert}, {@link ChangedEvent.Remove},
* and {@link ChangedEvent.Transaction}.
* @name ChangedEvent#change
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
ChangedEvent.prototype.change;
Util.exportProperty(ChangedEvent, 'change', ChangedEvent.prototype.change);
Util.defineProperty(ChangedEvent, {change: 'change'},
  /** @this {ChangedEvent} */
  function() { return this._change; },
  /** @this {ChangedEvent} */
  function(val) {
    if (Debug) Util.checkEnumValue(val, ChangedEvent, ChangedEvent, 'change');
    this._change = val;
  }
);

/**
* Gets the name of the model change, reflecting a change to
* model data in addition to a change to the model itself.
* <p/>
* The default is an empty string, which indicates that this is just
* a regular change to some object's state, probably its property.
* For a list of possible model change names, see the documentation for {@link ChangedEvent}.
* @name ChangedEvent#modelChange
* @function.
* @return {string}
*/
/** @type {string} */
ChangedEvent.prototype.modelChange;
Util.exportProperty(ChangedEvent, 'modelChange', ChangedEvent.prototype.modelChange);
Util.defineProperty(ChangedEvent, {modelChange: 'modelChange'},
  /** @this {ChangedEvent} */
  function() { return this._modelChange; },
  /** @this {ChangedEvent} */
  function(val) {
    if (Debug) Util.checkPrimitive(val, 'string', ChangedEvent, 'modelChange');
    this._modelChange = val;
  }
);

/**
* Gets or sets the name of the property change.
* The default is an empty string, which is not a valid property name.
* This property can be useful even when the type of change is
* not {@link ChangedEvent.Property}, because it can help identify
* the collection in the {@link #object} that was modified
* (for {@link ChangedEvent.Insert} or {@Link ChangedEvent.Remove})
* or the stage of the current transaction (for {@link ChangedEvent.Transaction}).
* @name ChangedEvent#propertyName
* @function.
* @return {string|function(Object):*}
*/
/** @type {string|function(Object):*} */
ChangedEvent.prototype.propertyName;
Util.exportProperty(ChangedEvent, 'propertyName', ChangedEvent.prototype.propertyName);
Util.defineProperty(ChangedEvent, {propertyName: 'propertyName'},
  /** @this {ChangedEvent} */
  function() { return this._propertyName; },
  /** @this {ChangedEvent} */
  function(val) {
    if (Debug && typeof val !== 'string') Util.checkClass(val, Function, ChangedEvent, 'propertyName');
    this._propertyName = val;
  }
);

/**
* Gets or sets the Object that was modified.
* The default is null.
* <p>
* For {@link ChangedEvent.Transaction} changes, this may be the {@link Transaction}.
* @name ChangedEvent#object
* @function.
* @return {Object}
*/
/** @type {Object} */
ChangedEvent.prototype.object;
Util.exportProperty(ChangedEvent, 'object', ChangedEvent.prototype.object);
Util.defineProperty(ChangedEvent, {object: 'object'},
  /** @this {ChangedEvent} */
  function() { return this._object; },
  /** @this {ChangedEvent} */
  function(val) { this._object = val; }
);

/**
* Gets or sets the previous or old value that the property had.
* The default is null.
* @name ChangedEvent#oldValue
* @function.
* @return {*}
*/
/** @type {*} */
ChangedEvent.prototype.oldValue;
Util.exportProperty(ChangedEvent, 'oldValue', ChangedEvent.prototype.oldValue);
Util.defineProperty(ChangedEvent, {oldValue: 'oldValue'},
  /** @this {ChangedEvent} */
  function() { return this._oldValue; },
  /** @this {ChangedEvent} */
  function(val) { this._oldValue = val; }
);

/**
* Gets or sets an optional value associated with the old value.
* Most properties do not require any parameter to describe the change.
* This is typically a value that helps distinguish the old value, such as an index into an array.
* It is null if it is not used.
* The default is null.
* @name ChangedEvent#oldParam
* @function.
* @return {*}
*/
/** @type {*} */
ChangedEvent.prototype.oldParam;
Util.exportProperty(ChangedEvent, 'oldParam', ChangedEvent.prototype.oldParam);
Util.defineProperty(ChangedEvent, {oldParam: 'oldParam'},
  /** @this {ChangedEvent} */
  function() { return this._oldParam; },
  /** @this {ChangedEvent} */
  function(val) { this._oldParam = val; }
);

/**
* Gets or sets the next or current value that the property has.
* The default is null.
* @name ChangedEvent#newValue
* @function.
* @return {*}
*/
/** @type {*} */
ChangedEvent.prototype.newValue;
Util.exportProperty(ChangedEvent, 'newValue', ChangedEvent.prototype.newValue);
Util.defineProperty(ChangedEvent, {newValue: 'newValue'},
  /** @this {ChangedEvent} */
  function() { return this._newValue; },
  /** @this {ChangedEvent} */
  function(val) { this._newValue = val; }
);

/**
* Gets or sets an optional value associated with the new value.
* Most properties do not require any parameter to describe the change.
* This is typically a value that helps distinguish the new value, such as an index into an array.
* It is null if it is not used.
* The default is null.
* @name ChangedEvent#newParam
* @function.
* @return {*}
*/
/** @type {*} */
ChangedEvent.prototype.newParam;
Util.exportProperty(ChangedEvent, 'newParam', ChangedEvent.prototype.newParam);
Util.defineProperty(ChangedEvent, {newParam: 'newParam'},
  /** @this {ChangedEvent} */
  function() { return this._newParam; },
  /** @this {ChangedEvent} */
  function(val) { this._newParam = val; }
);

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
Model
GraphLinksModel
TreeModel
Binding
*/

/**
* You probably don't want to call this constructor, because this class
* does not support links (relationships between nodes) or groups (nodes and links and subgraphs as nodes):
* instead, create instances of a subclass such as {@link GraphLinksModel} or {@link TreeModel}.
* @constructor
* @param {Array=} nodedataarray an optional Array containing JavaScript objects to be represented by {@link Part}s.
* @category Model
* @class
* Models hold the essential data of a diagram, describing the basic entities and their properties and relationships
* without specifying the appearance and behavior of the Nodes and Links and Groups that represent them visually.
* Models tend to hold only relatively simple data, making them easy to persist by serialization as JSON or XML formatted text.
* <p/>
* Models hold simple data objects, not {@link Part}s such as {@link Node}s or {@link Link}s.
* Node data is normally represented in a {@link Diagram} by instances of {@link Node},
* but they could be represented by simple {@link Part}s or by {@link Group}s.
* A Diagram constructs Parts for its {@link Diagram#model}'s data by copying templates.
* Templates are {@link Panel}s of {@link GraphObject}s that get some property values from the model data,
* accessible via the {@link Panel#data} property, using data {@link Binding}.
* See <a href="../../intro/usingModels.html">Using Models</a> and <a href="../../intro/dataBinding.html">Data Binding</a> for an introduction.
* <p/>
* This Model class only supports holding an array of node data
* and interpreting properties on that data to be able to refer to them
* using unique key values.
* To support simple tree-structured graphs, use a {@link TreeModel}, which inherits from this class.
* To support links and grouping, use a {@link GraphLinksModel}.
* <p/>
* Each node data object is assumed to have a unique key value.
* The {@link #nodeKeyProperty} property names the property on the node data whose value
* is the unique key for that node data object.
* The default value for this property is "key".
* You should not have a TwoWay data binding on the node key property,
* because that might cause the property value to be set to a duplicate key value.
* <p/>
* The key values must be either strings or numbers or undefined.
* If the key is undefined, or if there are duplicate key values,
* the model will automatically try to assign a new unique key value.
* <p/>
* For example, one can define a graph consisting of just two nodes:
* <pre class="javascript">
*  model.nodeDataArray = [
*    { key: "Alpha" },
*    { key: "Beta" }
*  ];
* </pre>
* <p/>
* This model cannot detect the modification of the {@link #nodeDataArray} array
* or the modification of any node data object.
* If you want to add or remove node data from the {@link #nodeDataArray},
* call the {@link #addNodeData} or {@link #removeNodeData} methods.
* <p/>
* If you want to modify a node data object, it depends on whether the property you want to change
* is a structural property that the model needs to know about, or whether it is a property
* that is only used for data binding or other application-specific purposes.
* <p/>
* For the former case, call the appropriate method, such as
* {@link #setKeyForNodeData}, {@link #setCategoryForNodeData},
* {@link GraphLinksModel#setToKeyForLinkData}, or {@link GraphLinksModel#setGroupKeyForNodeData}.
* These methods have names that start with "set", "add", "insert", or "remove".
* <p/>
* For the latter case, when setting an application-specific property, typically for data binding,
* and to support undo/redo, call {@link #setDataProperty}.
* <p/>
* Each model comes with its own {@link UndoManager} that is initially not enabled.
* You will need to set {@link UndoManager#isEnabled} to true in order for the
* UndoManager to record model changes and for your users to perform undo and redo.
* <p/>
* You can temporarily turn off the recording of changes by setting
* {@link #skipsUndoManager} to true.
* A number of places within the system do that routinely in order to avoid recording temporary changes,
* so be sure to remember the original value beforehand and restore it afterwards.
* <p/>
* One normally saves a diagram by just saving its model.
* If you can use JSON-formatted text, this is easy to do -- just call {@link #toJson}
* to get the string representation of the model, and save that string.
* Load the diagram by replacing the {@link Diagram#model} with one created by calling
* the static function {@link Model.fromJson}:
* <pre class="javascript">
*   myDiagram.model = go.Model.fromJson(loadedString);
* </pre>
* Note that JSON and other textual data formats cannot faithfully store all JavaScript functions.
* {@link #toJson} and {@link Model.fromJson} do not try to save and load functional property values.
* You should arrange that all such functions, including event handlers, are established by your app.
* {@link #toJson} and {@link Model.fromJson} also cannot handle circular references; any sharing of
* references will be lost too.
* <p/>
* Note that models also do not store the templates used by diagrams,
* nor any transient or temporary parts such as {@link Adornment}s, nor any tools,
* nor any {@link UndoManager} state.
* These objects and all other properties of diagrams must be established by your app.
* It is possible to add JavaScript data properties to a Model, and then save and load them,
* but your app must be responsible for their management and use.
*/
function Model(nodedataarray) {
  if (arguments.length > 1) {
    Util.throwError('Model constructor can only take one optional argument, the Array of node data.');
  }
  Util.uniqueHash(this);
  /** @type {string} */
  this._name = '';
  /** @type {string} */
  this._dataFormat = '';
  /** @type {boolean} */
  this._isReadOnly = false;

  /** @type {Array.<Object>} */
  this._nodeDataArray = [];
  /** @type {Map} */
  this._mapKeyNodeData = new Map(null, Object);
  /** @type {string|function(Object):(number|string)} */
  this._nodeKeyProperty = 'key';
  /** @type {function(Model, Object):(number|string) | null} */
  this._makeUniqueKeyFunction = null;
  /** @type {function(Object, Model):Object | null} */
  this._copyNodeDataFunction = null;
  /** @type {string|function(Object):string} */
  this._nodeCategoryProperty = 'category';
  /** @type {Map} */
  this._delayedNodeReferences = new Map(null, Set);

  /** @type {List} */
  this._listeners = null;

  /** @type {boolean} */
  this._skipsUndoManager = false;
  /** @type {UndoManager} */
  this._undoManager = null;
  // setup the UndoManager via property setter
  this.undoManager = new UndoManager();

  if (nodedataarray !== undefined/*not present*/) this.nodeDataArray = nodedataarray;
}

Util.publish('Model', Model);


Model.prototype['clear'] =
/**
* Clear out all references to any model data.
* This also clears out the {@link UndoManager}, so this operation is not undoable.
* This method is called by {@link Diagram#clear}; it does not notify any {@link Diagram}s or other listeners.
* <p>
* Instead of calling this method, you may prefer to set {@link #nodeDataArray} to an empty JavaScript Array.
* If this model is a {@link GraphLinksModel}, you would also want to set {@link GraphLinksModel#linkDataArray} to a separate empty JavaScript Array.
* @this {Model}
*/
Model.prototype.clear = function() {
  this._nodeDataArray = [];
  this._mapKeyNodeData.clear();
  this._delayedNodeReferences.clear();
  this.undoManager.clear();
};


/**
* @ignore
* Write out the persistent properties of this model into a string using JSON syntax property pairs.
* @expose
* @this {Model}
* @return {string}
*/
Model.prototype.writeJsonProtected = function() {
  var s = '';
  if (this.name !== '') s += ',\n  "name": ' + this.quote(this.name);
  if (this.dataFormat !== '') s += ',\n  "dataFormat": ' + this.quote(this.dataFormat);
  if (this.isReadOnly) s += ',\n  "isReadOnly": ' + this.isReadOnly;
  if (this.nodeKeyProperty !== 'key' && typeof this.nodeKeyProperty === 'string') s += ',\n  "nodeKeyProperty": ' + this.quote(this.nodeKeyProperty);
  if (this.nodeCategoryProperty !== 'category' && typeof this.nodeCategoryProperty === 'string') s += ',\n  "nodeCategoryProperty": ' + this.quote(this.nodeCategoryProperty);
  return s;
};

/**
* @ignore
* @this {Model}
* @return {string}
*/
Model.prototype.writeJsonData = function() {
  return ',\n  "nodeDataArray": ' + this.writeJsonArray(this.nodeDataArray, true);
};

/**
* @ignore
* Find the persistent model properties of the given Object and assign them to this model.
* @expose
* @this {Model}
* @param {Object} obj
*/
Model.prototype.readJsonProtected = function(obj) {
  if (obj['name']) this.name = obj['name'];
  if (obj['dataFormat']) this.dataFormat = obj['dataFormat'];
  if (obj['isReadOnly']) this.isReadOnly = obj['isReadOnly'];
  if (obj['nodeKeyProperty']) this.nodeKeyProperty = obj['nodeKeyProperty'];
  if (obj['nodeCategoryProperty']) this.nodeCategoryProperty = obj['nodeCategoryProperty'];
};

/**
* @ignore
* @this {Model}
* @param {Object} obj
*/
Model.prototype.readJsonData = function(obj) {
  if (obj['nodeDataArray']) {
    var arr = obj['nodeDataArray'];
    this.replaceJsonObjects(arr);
    this.nodeDataArray = arr;
  }
};


/**
* @ignore
* @this {Model}
* @param {number=} details Optional: If greater than zero, this includes descriptions of each node data.
* @return {string}
*/
Model.prototype.toString = function(details) {
  if (details === undefined/*notpresent*/) details = 0;
  if (details > 1) {
    return this.toJson();
  } else {
    var s = (this.name !== '' ? this.name : '') + ' Model';
    if (details > 0) {
      s += '\n node data:';
      var arr = this.nodeDataArray;
      var len = Util.arrayLength(arr);
      var i;
      for (i = 0; i < len; i++) {
        var item = Util.arrayElt(arr, i);
        s += ' ' + this.getKeyForNodeData(item) + ':' + Binding.toString(item);
      }
    }
    return s;
  }
};

Model.prototype['toJson'] =
/**
* Generate a string representation of the persistent data in this model, in JSON format.
* <p/>
* Object properties whose names start with "_" are not written out.
* <p/>
* Functions are not able to be written in JSON format, so any properties that have function values
* will not be saved in the JSON string.
* <p/>
* There must not be any circular references within the model data.
* Any sharing of object references will be lost in the written JSON.
* @this {Model}
* @param {string=} classname The optional name of the model class to use in the output;
*     for the standard models, this is their class name prefixed with "go.".
* @return {string} a String in JSON format containing all of the persistent properties of the model.
*/
Model.prototype.toJson = function(classname) {
  if (classname === undefined/*notpresent*/) {
    if (this.constructor === Model) classname = 'go.Model';
    else if (this.constructor === GraphLinksModel) classname = 'go.GraphLinksModel';
    else if (this.constructor === TreeModel) classname = 'go.TreeModel';
    else classname = Util.getClassName(this);
  }
  return '{ "class": ' + this.quote(classname) +
         this.writeJsonProtected() +
         this.writeJsonData() +
         '}';
};

Model['fromJson'] =
/**
* This static method parses a string in JSON format and constructs, initializes, and returns a model.
* <p/>
* Note that properties with values that are functions are not written out by {@link #toJson},
* so reading in such a model will require constructing such a model, initializing its functional property values,
* and explicitly passing it in as the second argument.
* @this {Model}
* @param {string|Object} s a String in JSON format containing all of the persistent properties of the model, or an Object already read from JSON text.
* @param {Model=} model an optional model to be modified; if not supplied, it constructs a new model whose name is specified by the "class" property.
* @return {Model} the supplied or created model loaded with data from the given string.
*/
Model.fromJson = function(s, model) {
  if (model === undefined/*notpresent*/) model = null;
  if (model) Util.checkClass(model, Model, Model, 'fromJson:model');

  var modeldata = null;
  if (typeof s === 'string') {
    if (window && window['JSON'] && window['JSON']['parse']) {
      try {
        modeldata = window['JSON']['parse'](s);
      } catch (ex) {
        if (Debug) Util.trace('JSON.parse error: ' + ex.toString());
      }
    } else {
      Util.trace('WARNING: no JSON.parse available');
    }
  } else if (typeof s === 'object') {
    modeldata = s;
  } else {
    Util.throwError('Unable to construct a Model from: ' + s);
  }

  if (model === null) {
    var m = Model.makeJsonClass(modeldata);
    if (m === null || m instanceof Model) {
      model = m;
    } else {
      Util.throwError('Unable to construct a Model of declared class: ' + modeldata['class']);
    }
  }
  if (model === null) {
    model = new GraphLinksModel();
  }
  model.readJsonProtected(modeldata);
  model.readJsonData(modeldata);
  return model;
};

/**
* @ignore
* Create an object whose class name is given by the "class" property of the given data object.
* @param {Object} data
* @return {Object}
*/
Model.makeJsonClass = function(data) {
  var result = null;
  var classname = data['class'];
  if (typeof classname === 'string') {
    try {
      var classfunc = null;
      if (classname.indexOf('go.') === 0) {  // if prefixed with "go.", only look in the GoJS namespace
        classname = classname.substr(3);
        classfunc = go[classname];
      } else {  // otherwise try both "go" and "window"
        classfunc = go[classname];
        if (!classfunc) classfunc = window[classname];
      }
      if (typeof classfunc === 'function') result = new classfunc;
    } catch (ex) { }
  }
  return result;
};

/**
* @ignore
* Walk a JavaScript tree of objects, finding simple JavaScript Objects
* that should be replaced with instances of special classes.
*/
Model.prototype.replaceJsonObjects = function(x) {
  if (Util.isArray(x)) {
    // recurse through array items
    var len = Util.arrayLength(x);
    for (var i = 0; i < len; i++) {
      var d = Util.arrayElt(x, i);
      if (Util.isObject(d)) {
        Util.arraySetElt(x, i, this.replaceJsonObjects(d));
      }
    }
  } else if (Util.isObject(x)) {
    // recurse through object properties
    for (var p in x) {
      var d = x[p];
      if (Util.isObject(d)) {
        var replaced = this.replaceJsonObjects(d);
        x[p] = replaced;
        // handle special case of List of Points as an Array of x,y pairs
        if (p === 'points' && Array.isArray(replaced)) {  // not Util.isArray
          // make sure the values are all numbers
          var allpoints = true;
          for (var j = 0; j < replaced.length; j++) {
            if (typeof replaced[j] !== 'number') {
              allpoints = false;
              break;
            }
          }
          if (allpoints) {
            var list = new List(Point);
            for (var k = 0; k < replaced.length / 2; k++) {
              var pt = new Point(replaced[k * 2], replaced[k * 2 + 1]);
              list.add(pt);
            }
            list.freeze();
            x[p] = list;
          }
        }
      }
    }
    // maybe replace the whole Object too
    return this.replaceJsonObject(x);
  }
  // otherwise just return the value
  return x;
};

/**
* @ignore
* @this {Model}
* @param {string} str
* @return {string}
*/
Model.prototype.quote = function(str) {
  var s = '';
  var len = str.length;
  for (var i = 0; i < len; i++) {
    var c = str[i];
    if (c === '\"' || c === '\\') {
      s += '\\' + c;
    } else if (c === '\b') {
      s += '\\b';
    } else if (c === '\f') {
      s += '\\f';
    } else if (c === '\n') {
      s += '\\n';
    } else if (c === '\r') {
      s += '\\r';
    } else if (c === '\t') {
      s += '\\t';
    } else {
      s += c;
    }
  }
  return '"' + s + '"';
};

Model.prototype['writeJsonValue'] =
/**
* @ignore
* @this {Model}
* @param {*} x
* @return {string}
*/
Model.prototype.writeJsonValue = function(x) {
  if (x === undefined) return 'undefined';  // shouldn't happen
  if (x === null) return 'null';
  if (x === true) return 'true';
  if (x === false) return 'false';
  if (typeof x === 'string') return this.quote(x);
  if (typeof x === 'number') {
    if (x === Infinity) return '9e9999';
    if (x === -Infinity) return '-9e9999';
    if (isNaN(x)) return '{"class":"NaN"}';
    return x.toString();
  }
  if (Util.isArray(x)) return this.writeJsonArray(x);
  if (Util.isObject(x)) return this.writeJsonObject(x);
  if (typeof x === 'function') return 'null';  //?? function
  return x.toString();  //?? XML objects, DOM elements
};

/**
* @ignore
* @this {Model}
* @param arr
* @param {boolean=} newlines
* @return {string}
*/
Model.prototype.writeJsonArray = function(arr, newlines) {
  var len = Util.arrayLength(arr);
  var str = '[ ';
  if (newlines && len > 1) str += '\n';
  for (var i = 0; i < len; i++) {
    var v = Util.arrayElt(arr, i);
    if (v === undefined) continue;
    if (i > 0) {
      str += ',';
      if (newlines) str += '\n';
    }
    str += this.writeJsonValue(v);
  }
  if (newlines && len > 1) str += '\n';
  str += ' ]';
  return str;
};

/**
* @ignore
* @this {Model}
* @param {Object} data
* @param {string} propname
* @param {*} propval
* @return {boolean}
*/
Model.prototype.skipsJsonObjectProperty = function(data, propname, propval) {
  if (propval === undefined) return true;
  if (propname === '__gohashid') return true;  // definitely want to skip this!
  if (propname[0] === '_') return true; //?? do we want to skip such Json properties
  if (typeof propval === 'function') return true;
  return false;
};

/**
* @ignore
* When you know the value must be a number, use a JSON-safe representation.
* @this {Model}
* @param {number} n
* @return {string|number}
*/
Model.prototype.safeJsonNumber = function(n) {
  if (isNaN(n)) return 'NaN';
  if (n === Infinity) return '9e9999';
  if (n === -Infinity) return '-9e9999';
  return n;
};

/**
* @ignore
* @this {Model}
* @param data
* @return {string}
*/
Model.prototype.writeJsonObject = function(data) {
  // maybe substitute a JSON-writable object for special classes
  //?? someday generalize this
  var d = data;
  if (d instanceof Point) {
    data = { 'class': 'go.Point', 'x': this.safeJsonNumber(d.x), 'y': this.safeJsonNumber(d.y) };
  } else if (d instanceof Size) {
    data = { 'class': 'go.Size', 'width': this.safeJsonNumber(d.width), 'height': this.safeJsonNumber(d.height) };
  } else if (d instanceof Rect) {
    data = { 'class': 'go.Rect', 'x': this.safeJsonNumber(d.x), 'y': this.safeJsonNumber(d.y), 'width': this.safeJsonNumber(d.width), 'height': this.safeJsonNumber(d.height) };
  } else if (d instanceof Margin) {
    data = { 'class': 'go.Margin', 'top': this.safeJsonNumber(d.top), 'right': this.safeJsonNumber(d.right), 'bottom': this.safeJsonNumber(d.bottom), 'left': this.safeJsonNumber(d.left) };
  } else if (d instanceof Spot) {
    if (!d.isSpot()) {  // if a special Spot value, write the name instead
      data = { 'class': 'go.Spot', 'enum': d.toString() };
    } else {
      data = { 'class': 'go.Spot', 'x': this.safeJsonNumber(d.x), 'y': this.safeJsonNumber(d.y), 'offsetX': this.safeJsonNumber(d.offsetX), 'offsetY': this.safeJsonNumber(d.offsetY) };
    }
  } else if (d instanceof Brush) {
    data = { 'class': 'go.Brush', type: d.type.name };
    if (d.type === Brush.Solid) {
      data['color'] = d.color;
    } else if (d.type === Brush.Linear || d.type === Brush.Radial) {
      data['start'] = d.start;
      data['end'] = d.end;
      if (d.type === Brush.Radial) {
        if (d.startRadius !== 0) data['startRadius'] = this.safeJsonNumber(d.startRadius);
        if (!isNaN(d.endRadius)) data['endRadius'] = this.safeJsonNumber(d.endRadius);
      }
      //??? Brush.pattern
    }
    if (d.colorStops !== null) {
      var map = {};  // generating JSON
      var it = d.colorStops.iterator;
      while (it.next()) {  // JSON keys must be strings, not numbers
        map[it.key.toString()] = it.value;
      }
      data['colorStops'] = map;
    }
  } else if (d instanceof Geometry) {
    data = { 'class': 'go.Geometry', type: d.type.name };
    if (d.startX !== 0) data['startX'] = this.safeJsonNumber(d.startX);
    if (d.startY !== 0) data['startY'] = this.safeJsonNumber(d.startY);
    if (d.endX !== 0) data['endX'] = this.safeJsonNumber(d.endX);
    if (d.endY !== 0) data['endY'] = this.safeJsonNumber(d.endY);
    if (!d.spot1.equals(Spot.TopLeft)) data['spot1'] = d.spot1;
    if (!d.spot2.equals(Spot.BottomRight)) data['spot2'] = d.spot2;
    if (d.type === Geometry.Path) {
      data['path'] = Geometry.stringify(d);
    }
  }

  // now we write out all of DATA's enumerable properties that we don't skip
  var str = '{';
  var first = true;
  for (var p in data) {
    var v = Util.safePropertyValue(data, p);
    if (this.skipsJsonObjectProperty(data, p, v)) continue;
    if (first) {
      first = false;
    } else {
      str += ', ';
    }
    str += '"' + p + '":';
    // handle special case of List of Points as an Array of x,y pairs
    if (p === 'points' && v instanceof List && v._type === Point) {
      var s = '[';
      var it = v.iterator;
      while (it.next()) {
        var pt = it.value;
        if (s.length > 1) s += ',';
        s += this.writeJsonValue(pt.x);
        s += ',';
        s += this.writeJsonValue(pt.y);
      }
      s += ']';
      str += s;
    } else {
      str += this.writeJsonValue(v);
    }
  }
  str += '}';
  return str;
};

/**
* @ignore
* Parse our JSON-safe representation of a number as a number.
* @this {Model}
* @param n a number or a string.
* @return {number}
*/
Model.prototype.readSafeJsonNumber = function(n) {
  if (typeof n === 'number') return n;
  if (n === 'NaN') return NaN;
  if (n === '9e9999') return Infinity;
  if (n === '-9e9999') return - Infinity;
  return parseFloat(n);
};

/**
* @ignore
* Substitute a "real" object for a plain JavaScript object with 'class: "go.ClassName"'.
* This assumes all subproperties have already been replaced if needed.
*/
Model.prototype.replaceJsonObject = function(d) {
  if (typeof d !== 'object') return d;
  var obj = d;
  var cname = d['class'];
  if (cname === 'NaN') {
    obj = NaN;
  } else if (cname === 'go.Point') {
    obj = new Point(this.readSafeJsonNumber(d['x']), this.readSafeJsonNumber(d['y']));
  } else if (cname === 'go.Size') {
    obj = new Size(this.readSafeJsonNumber(d['width']), this.readSafeJsonNumber(d['height']));
  } else if (cname === 'go.Rect') {
    obj = new Rect(this.readSafeJsonNumber(d['x']), this.readSafeJsonNumber(d['y']), this.readSafeJsonNumber(d['width']), this.readSafeJsonNumber(d['height']));
  } else if (cname === 'go.Margin') {
    obj = new Margin(this.readSafeJsonNumber(d['top']), this.readSafeJsonNumber(d['right']), this.readSafeJsonNumber(d['bottom']), this.readSafeJsonNumber(d['left']));
  } else if (cname === 'go.Spot') {
    if (typeof d['enum'] === 'string') {
      obj = Spot.parse(d['enum']);
    } else {
      obj = new Spot(this.readSafeJsonNumber(d['x']), this.readSafeJsonNumber(d['y']), this.readSafeJsonNumber(d['offsetX']), this.readSafeJsonNumber(d['offsetY']));
    }
  } else if (cname === 'go.Brush') {
    obj = new Brush();
    obj.type = Util.findEnumValueForName(Brush, d['type']);
    if (d['start'] instanceof Spot) obj.start = d['start'];
    if (d['end'] instanceof Spot) obj.end = d['end'];
    if (typeof d['startRadius'] === 'number') obj.startRadius = this.readSafeJsonNumber(d['startRadius']);
    if (typeof d['endRadius'] === 'number') obj.endRadius = this.readSafeJsonNumber(d['endRadius']);
    var stops = d['colorStops'];
    if (stops) {
      for (var p in stops) {
        var f = parseFloat(p);
        obj.addColorStop(f, stops[p]);
      }
    }
  } else if (cname === 'go.Geometry') {
    if (typeof d['path'] === 'string') {
      obj = Geometry.parse(d['path']);
    } else {
      obj = new Geometry();
    }
    obj.type = Util.findEnumValueForName(Geometry, d['type']);
    if (typeof d['startX'] === 'number') obj.startX = this.readSafeJsonNumber(d['startX']);
    if (typeof d['startY'] === 'number') obj.startY = this.readSafeJsonNumber(d['startY']);
    if (typeof d['endX'] === 'number') obj.endX = this.readSafeJsonNumber(d['endX']);
    if (typeof d['endY'] === 'number') obj.endY = this.readSafeJsonNumber(d['endY']);
    if (d['spot1'] instanceof Spot) obj.spot1 = d['spot1'];
    if (d['spot2'] instanceof Spot) obj.spot2 = d['spot2'];
  }
  return obj;
};


/**
* Gets or sets the name of this model.
* The initial name is an empty string.
* The value must not be null.
* @name Model#name
* @function.
* @return {string}
*/
/** @type {string} */
Model.prototype.name;
Util.exportProperty(Model, 'name', Model.prototype.name);
Util.defineProperty(Model, {name: 'name'},
  /** @this {Model} */
  function() { return this._name; },
  /** @this {Model} */
  function(val) {
    var old = this._name;
    if (old !== val) {
      Util.checkPrimitive(val, 'string', Model, 'name');
      this._name = val;
      this.raiseChanged('name', old, val);
    }
  }
);

/**
* Gets or sets the name of the format of the diagram data.
* The default value is the empty string.
* The value must not be null.
* Use different values to prevent parts from one model to be copy/pasted or drag-and-dropped into another diagram/model.
* @name Model#dataFormat
* @function.
* @return {string}
*/
/** @type {string} */
Model.prototype.dataFormat;
Util.exportProperty(Model, 'dataFormat', Model.prototype.dataFormat);
Util.defineProperty(Model, {dataFormat: 'dataFormat'},
  /** @this {Model} */
  function() { return this._dataFormat; },
  /** @this {Model} */
  function(val) {
    var old = this._dataFormat;
    if (old !== val) {
      Util.checkPrimitive(val, 'string', Model, 'dataFormat');
      this._dataFormat = val;
      this.raiseChanged('dataFormat', old, val);
    }
  }
);

/**
* Gets or sets whether this model may be modified, such as adding nodes.
* By default this value is false.
* Setting the {@link #nodeDataArray} to something that is not a true Array of Objects
* will cause this to be set to true.
* <p/>
* Model methods and property setters do not heed this property.
* It is up to code that uses a model to check this property when it might want to
* prevent changes to the model.
* @name Model#isReadOnly
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Model.prototype.isReadOnly;
Util.exportProperty(Model, 'isReadOnly', Model.prototype.isReadOnly);
Util.defineProperty(Model, {isReadOnly: 'isReadOnly'},
  /** @this {Model} */
  function() { return this._isReadOnly; },
  /** @this {Model} */
  function(val) {
    var old = this._isReadOnly;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Model, 'isReadOnly');
      this._isReadOnly = val;
      this.raiseChanged('isReadOnly', old, val);
    }
  }
);

// For ChangedEvents and notification:

Model.prototype['addChangedListener'] =
/**
* Register an event handler that is called when there is a ChangedEvent.
* <p/>
* This registration does not raise a {@link ChangedEvent}.
* @this {Model}
* @param {function(ChangedEvent)} listener a function that takes a {@link ChangedEvent} as its argument.
*/
Model.prototype.addChangedListener = function(listener) {
  Util.checkPrimitive(listener, 'function', Model, 'addChangedListener:listener');
  if (this._listeners === null) this._listeners = new List('function');
  this._listeners.add(listener);
};

Model.prototype['removeChangedListener'] =
/**
* Unregister an event handler listener.
* <p/>
* This deregistration does not raise a {@link ChangedEvent}.
* @this {Model}
* @param {function(ChangedEvent)} listener a function that takes a {@link ChangedEvent} as its argument.
*/
Model.prototype.removeChangedListener = function(listener) {
  Util.checkPrimitive(listener, 'function', Model, 'removeChangedListener:listener');
  if (this._listeners !== null) {
    this._listeners.remove(listener);
    if (this._listeners.count === 0) this._listeners = null;
  }
};

/**
* @ignore
* Notify any ChangedEvent listeners.
* This is called by {@link #raiseModelChangedEvent}.
* Each listener function registered with calls to {@link #addChangedListener} is called with the given event.
* Unless {@link #skipsUndoManager} is true, this then calls {@link UndoManager#handleChanged}
* so that the UndoManager gets the opportunity to record the change.
* @this {Model}
* @param {ChangedEvent} e
*/
Model.prototype.callChangedListeners = function(e) {
  if (!this.skipsUndoManager) {
    this.undoManager.handleChanged(e);
  }

  if (this._listeners !== null) {
    var list = this._listeners;
    var l = list.length;
    if (l === 1) {
      var func = list.elt(0);
      func(e);
    } else if (l !== 0) {
      var arr = list.toArray();
      for (var i = 0; i < l; i++) {
        var func = arr[i];
        func(e);
      }
    }
  }
};

Model.prototype['raiseChangedEvent'] =
/**
* Call this method to notify that the model or its objects have changed.
* This constructs a {@link ChangedEvent} and calls all Changed listeners.
* @this {Model}
* @param {EnumValue} change specifies the general nature of the change; typically the value is {@link ChangedEvent#Property}.
* @param {string|function(Object):*} propertyname names the property that was modified, or a function that takes an Object and returns the property value.
* @param {Object} obj the object that was modified, typically a {@link GraphObject}, {@link Diagram}, or a {@link Model}.
* @param {*} oldval the previous or older value.
* @param {*} newval the next or newer value.
* @param {*=} oldparam an optional value that helps describe the older value.
* @param {*=} newparam an optional value that helps describe the newer value.
*/
Model.prototype.raiseChangedEvent = function(change, propertyname, obj, oldval, newval, oldparam, newparam) {
  this.raiseModelChangedEvent('', change, propertyname, obj, oldval, newval, oldparam, newparam);
};

Model.prototype['raiseChanged'] =
/**
* @ignore
* Call this method to notify about a model property having changed value.
* This constructs a {@link ChangedEvent} and calls all Changed listeners..
* @this {Model}
* @param {string|function(Object):*} propertyname the name of the property, or a function that takes an Object and returns the property value.
* @param {*} oldval the previous or old value for the property.
* @param {*} newval the next or new value for the property.
* @param {*=} oldparam an optional value additionally describing the old value.
* @param {*=} newparam an optional value additionally describing the new value.
*/
Model.prototype.raiseChanged = function(propertyname, oldval, newval, oldparam, newparam) {
  this.raiseModelChangedEvent('', ChangedEvent.Property, propertyname, this, oldval, newval, oldparam, newparam);
};

Model.prototype['raiseDataChanged'] =
/**
* Call this method to notify about a data property having changed value.
* This constructs a {@link ChangedEvent} and calls all Changed listeners.
* <p/>
* You should call this method only if the property value actually changed.
* This method is called by {@link #setDataProperty}.
* @this {Model}
* @param {Object} data the data object whose property changed value.
* @param {string|function(Object):*} propertyname the name of the property, or a function that takes an Object and returns the property value.
* @param {*} oldval the previous or old value for the property.
* @param {*} newval the next or new value for the property.
* @param {*=} oldparam an optional value additionally describing the old value.
* @param {*=} newparam an optional value additionally describing the new value.
*/
Model.prototype.raiseDataChanged = function(data, propertyname, oldval, newval, oldparam, newparam) {
  this.raiseModelChangedEvent('', ChangedEvent.Property, propertyname, data, oldval, newval, oldparam, newparam);
};

/**
* @ignore
* This is an internal method for notifying about changes to the model structure.
* @this {Model}
* @param {string} modelchangename the kind of model change;
*   use the empty string for regular property changes that do not affect the model.
* @param {EnumValue} change specifies the general nature of the change;
* permissible values de {@link ChangedEvent#Property}, {@link ChangedEvent#Insert},
* {@link ChangedEvent#Remove}, and {@link ChangedEvent#Transaction}.
* @param {string|function(Object):*} propertyname names the property that was modified, or a function that takes an Object and returns the property value.
* @param {Object} obj the object that was modified, typically a {@link GraphObject}, {@link Model}, or a {@link Layer}.
* @param {*} oldval the previous or older value.
* @param {*} newval the next or newer value.
* @param {*=} oldparam helps describe the older value.
* @param {*=} newparam helps describe the newer value.
*/
Model.prototype.raiseModelChangedEvent = function(modelchangename, change, propertyname, obj, oldval, newval, oldparam, newparam) {
  if (oldparam === undefined/*notpresent*/) oldparam = null;
  if (newparam === undefined/*notpresent*/) newparam = null;
  // ChangedEvent property setters will check argument types

  var e = new ChangedEvent();  //?? cache event objects
  e.model = this;
  e.change = change;
  e.modelChange = modelchangename;
  e.propertyName = propertyname;
  e.object = obj;
  e.oldValue = oldval;
  e.oldParam = oldparam;
  e.newValue = newval;
  e.newParam = newparam;

  this.callChangedListeners(e);
};


// for undo/redo:

/**
* Gets or sets the {@link UndoManager} for this Model.
* <p/>
* The default UndoManager has its {@link UndoManager#isEnabled} property set to false.
* If you want users to undo and redo, you should set that property to true once you have initialized the Diagram or its Model.
* <p/>
* This property setter does not raise a {@link ChangedEvent}.
* @name Model#undoManager
* @function.
* @return {UndoManager}
*/
/** @type {UndoManager} */
Model.prototype.undoManager;
Util.exportProperty(Model, 'undoManager', Model.prototype.undoManager);
Util.defineProperty(Model, {undoManager: 'undoManager'},
  /** @this {Model} */
  function() { return this._undoManager; },
  /** @this {Model} */
  function(val) {
    var old = this._undoManager;
    if (old !== val) {
      Util.checkClass(val, UndoManager, Model, 'undoManager');
      if (old !== null) old.removeModel(this);
      this._undoManager = val;
      if (val !== null) val.addModel(this);
    }
  }
);

/**
* Gets or sets whether {@link ChangedEvent}s are not recorded by the {@link UndoManager}.
* The initial and normal value is false.
* <p/>
* When this property is true, changing the Model or any data object does not call {@link UndoManager#handleChanged}.
* Even when this property is true,
* transactions (such as calls to {@link #startTransaction}) and undo/redo (such as calls to {@link CommandHandler#undo})
* are still delegated to the {@link #undoManager}.
* <p/>
* You should set this to true only temporarily, and you should remember its previous value before setting this to true.
* When finishing the period for which you want the UndoManager to be disabled,
* do not blindly set this property to false.
* You should set this back to the value it had before you set it to true.
* For more permanent disabling of the {@link UndoManager}, set {@link UndoManager#isEnabled} to false.
* <p/>
* This property is also set when setting {@link Diagram#skipsUndoManager}.
* Setting this property does not raise a {@link ChangedEvent}.
* @name Model#skipsUndoManager
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Model.prototype.skipsUndoManager;
Util.exportProperty(Model, 'skipsUndoManager', Model.prototype.skipsUndoManager);
Util.defineProperty(Model, {skipsUndoManager: 'skipsUndoManager'},
  /** @this {Model} */
  function() { return this._skipsUndoManager; },
  /** @this {Model} */
  function(val) {
    Util.checkPrimitive(val, 'boolean', Model, 'skipsUndoManager');
    this._skipsUndoManager = val;
  }
);

/**
* @ignore
* This is called during an undo or redo to modify the model or its objects.
* <p/>
* This does not raise a {@link ChangedEvent}.
* @expose
* @this {Model}
* @param {ChangedEvent} e This describes the change that needs to be done.
* @param {boolean} undo If true, this method should restore the older state, otherwise the newer state.
*/
Model.prototype.changeState = function(e, undo) {
  if (e === null) return;
  if (e.model !== this) return;  // ignore changes to Diagram or other Models
  if (e.change === ChangedEvent.Property) {
    var obj = e.object;
    var pn = e.propertyName;
    var v = e.getValue(undo);
    Util.safePropertySet(obj, pn, v);
  } else if (e.change === ChangedEvent.Insert) {
    if (e.modelChange === 'nodeDataArray') {
      var data = e.newValue;
      if (Util.isObject(data)) {
        var key = this.getKeyForNodeData2(data);
        if (key !== undefined) {
          if (undo) {
            Util.arrayRemoveAt(this._nodeDataArray, e.newParam);
            this._mapKeyNodeData.remove(key);
          } else {
            Util.arrayInsertAt(this._nodeDataArray, e.newParam, data);
            this._mapKeyNodeData.add(key, data);
          }
        }
      }
    } else if (e.modelChange === '') {  // inserting an item into an array that is a data property value
      var arr = e.object;
      if (!Util.isArray(arr) && e.propertyName) arr = Util.safePropertyValue(e.object, e.propertyName);
      if (Util.isArray(arr)) {
        var item = e.newValue;
        var idx = e.newParam;
        if (undo) {
          Util.arrayRemoveAt(arr, idx);
        } else {
          Util.arrayInsertAt(arr, idx, item);
        }
      }
    } else {
      Util.throwError('unknown ChangedEvent.Insert object: ' + e.toString());
    }
  } else if (e.change === ChangedEvent.Remove) {
    if (e.modelChange === 'nodeDataArray') {
      var data = e.oldValue;
      if (Util.isObject(data)) {
        var key = this.getKeyForNodeData2(data);
        if (key !== undefined) {
          if (undo) {
            Util.arrayInsertAt(this._nodeDataArray, e.oldParam, data);
            this._mapKeyNodeData.add(key, data);
          } else {
            Util.arrayRemoveAt(this._nodeDataArray, e.oldParam);
            this._mapKeyNodeData.remove(key);
          }
        }
      }
    } else if (e.modelChange === '') {  // removing an item from an array that is a data property value
      var arr = e.object;
      if (!Util.isArray(arr) && e.propertyName) arr = Util.safePropertyValue(e.object, e.propertyName);
      if (Util.isArray(arr)) {
        var item = e.oldValue;
        var idx = e.oldParam;
        if (undo) {
          Util.arrayInsertAt(arr, idx, item);
        } else {
          Util.arrayRemoveAt(arr, idx);
        }
      }
    } else {
      Util.throwError('unknown ChangedEvent.Remove object: ' + e.toString());
    }
  } else if (e.change === ChangedEvent.Transaction) {
    // don't do anything
  } else {
    Util.throwError('unknown ChangedEvent: ' + e.toString());
  }
};


Model.prototype['startTransaction'] =
/**
* Begin a transaction, where the changes are held by a {@link Transaction} object
* in the {@link UndoManager}.
* This just calls {@link UndoManager#startTransaction}.
* @this {Model}
* @param {string=} tname a descriptive name for the transaction.
* @return {boolean} the value returned by {@link UndoManager#startTransaction}.
*/
Model.prototype.startTransaction = function(tname) {
  return this.undoManager.startTransaction(tname);
};

Model.prototype['commitTransaction'] =
/**
* Commit the changes of the current transaction.
* This just calls {@link UndoManager#commitTransaction}.
* @this {Model}
* @param {string} tname a descriptive name for the transaction.
* @return {boolean} the value returned by {@link UndoManager#commitTransaction}.
*/
Model.prototype.commitTransaction = function(tname) {
  return this.undoManager.commitTransaction(tname);
};

Model.prototype['rollbackTransaction'] =
/**
* Rollback the current transaction, undoing any recorded changes.
* This just calls {@link UndoManager#rollbackTransaction}.
* @this {Model}
* @return {boolean} the value returned by {@link UndoManager#rollbackTransaction}.
*/
Model.prototype.rollbackTransaction = function() {
  return this.undoManager.rollbackTransaction();
};


Model.prototype['updateTargetBindings'] =
/**
* Find a {@link Part} corresponding to the given data and
* call its {@link Panel#updateTargetBindings} method, in each {@link Diagram}
* that uses this Model.
* @this {Model}
* @param {Object} data The data object in this model that was modified.
* @param {string=} srcpropname If not present or the empty string,
*   update all bindings on the target {@link Part} or item {@link Panel};
*   otherwise update only those bindings using this source property name.
*/
Model.prototype.updateTargetBindings = function(data, srcpropname) {
  if (srcpropname === undefined/*not present*/) srcpropname = '';
  this.raiseModelChangedEvent('SourceChanged', ChangedEvent.Transaction, srcpropname, data, null, null);
};


/**
* Gets or sets the name of the data property that returns a unique id number or string
* for each node data object, or a function taking a node data object and returning the key value;
* the default value is the name 'key'.
* The name must not be null or the empty string.
* You must set this property before assigning the {@link #nodeDataArray}.
* @name Model#nodeKeyProperty
* @function.
* @return {string|function(Object):(string|number)}
* @see #getKeyForNodeData
*/
/** @type {string|function(Object):(string|number)} */
Model.prototype.nodeKeyProperty;
Util.exportProperty(Model, 'nodeKeyProperty', Model.prototype.nodeKeyProperty);
Util.defineProperty(Model, {nodeKeyProperty: 'nodeKeyProperty'},
  /** @this {Model} */
  function() { return this._nodeKeyProperty; },
  /** @this {Model} */
  function(val) {
    var old = this._nodeKeyProperty;
    if (old !== val) {
      this.checkStringOrFunction(val, Model, 'nodeKeyProperty');
      if (this._mapKeyNodeData.count > 0) Util.throwError('Cannot set Model.nodeKeyProperty when there is existing node data');
      this._nodeKeyProperty = val;
      this.raiseChanged('nodeKeyProperty', old, val);
      //?? recompute relationships
    }
  }
);

/**
* @ignore
* @this {Model}
*/
Model.prototype.checkStringOrFunction = function(val, name, member) {
  if (typeof val !== 'string' && typeof val !== 'function') {
    Util.throwTypeError(val, 'string or function', name, member);
  }
};

Model.prototype['getKeyForNodeData'] =
/**
* Given a node data object return its unique key: a number or a string.
* <p/>
* It is possible to change the key for a node data object by calling {@link #setKeyForNodeData}.
* @this {Model}
* @param {Object} nodedata a JavaScript object representing a node, group, or non-link.
* @return {number|string|undefined} This returns undefined if there is no key value.
* @see #nodeKeyProperty
* @see #setKeyForNodeData
* @see #findNodeDataForKey
*/
Model.prototype.getKeyForNodeData = function(nodedata) {
  if (nodedata === null) return undefined;
  var kname = this._nodeKeyProperty;
  if (kname === '') return undefined;  //?? support direct references to node data
  var key = Util.safePropertyValue(nodedata, kname);
  if (key === undefined) return undefined;
  if (this.isKeyType(key)) return key;
  if (Debug) Util.trace('Key value for node data ' + nodedata + ' is not a number or a string: ' + key);
  return undefined;
};
/**
* @ignore
* This is only defined to avoid a warning in the Closure compiler.
* @this {Model}
* @param nodedata
* @return {number|string|undefined} This returns undefined if there is no key value.
*/
Model.prototype.getKeyForNodeData2 = function(nodedata) {
  return this.getKeyForNodeData(nodedata);
};

Model.prototype['setKeyForNodeData'] =
/**
* Change the unique key of a given node data that is already in this model.
* The new key value must be unique -- i.e. not in use by another node data object.
* You can call {@link #findNodeDataForKey} to check if a proposed new key is already in use.
* <p/>
* This operation will check all data objects in the model and replace all references
* using the old key value with the new one.
* <p/>
* If this is called on a node data object that is not (yet) in this model,
* this unconditionally modifies the property to the new key value.
* @this {Model}
* @param {Object} nodedata a JavaScript object representing a node, group, or non-link.
* @param {number|string|undefined} key
* @see #nodeKeyProperty
* @see #getKeyForNodeData
* @since 1.1
*/
Model.prototype.setKeyForNodeData = function(nodedata, key) {
  if (key === null) key = undefined;
  if (key !== undefined && !this.isKeyType(key)) {
    Util.throwTypeError(key, 'number or string', Model, 'setKeyForNodeData:key');
  }
  if (nodedata === null) return;
  var kname = this._nodeKeyProperty;
  if (kname === '') return;
  if (!this.containsNodeData(nodedata)) {
    Util.safePropertySet(nodedata, kname, key);
    return;
  }
  var old = Util.safePropertyValue(nodedata, kname);
  if (old !== key) {
    if (this.findNodeDataForKey(key) !== null) {
      //Util.throwError('Model.setKeyForNodeData: trying to replace the key: ' + old + ' with a key used by another node data object: ' + key);
      return;
    }
    Util.safePropertySet(nodedata, kname, key);
    // update the key->data Map
    this._mapKeyNodeData.remove(old);
    this._mapKeyNodeData.add(key, nodedata);
    this.raiseModelChangedEvent('nodeKey', ChangedEvent.Property, kname, nodedata, old, key);
    if (typeof kname === 'string') this.updateTargetBindings(nodedata, kname);
    // need to update all references using the old key so that all relationships are maintained
    this.replaceAllKeyReferences(old, key);
  }
};
/**
* @ignore
* This is only defined to avoid a warning in the Closure compiler.
* @param nodedata
* @param key
* @this {Model}
*/
Model.prototype.setKeyForNodeData2 = function(nodedata, key) {
  this.setKeyForNodeData(nodedata, key);
};

/**
* Gets or sets a function that returns a unique id number or string for a node data object.
* This function is called by {@link #makeNodeDataKeyUnique}
* when a node data object is added to the model, either as part of a new
* {@link #nodeDataArray} or by a call to {@link #addNodeData}, to make sure the value of
* {@link #getKeyForNodeData} is unique within the model.
* <p/>
* The value may be null in order to cause {@link #makeNodeDataKeyUnique} behave in the standard manner.
* You may want to supply a function here in order to make sure all of the automatically generated keys
* are in a particular format.
* Setting this property after setting {@link #nodeDataArray} has no real effect until there is a call
* to {@link #addNodeData}.
* <p/>
* If a node data object is already in the model and you want to change its key value,
* call {@link #setKeyForNodeData} with a new and unique key.
* @name Model#makeUniqueKeyFunction
* @function.
* @return {function(Model, Object):(string|number) | null}
*/
/** @type {function(Model, Object):(string|number) | null} */
Model.prototype.makeUniqueKeyFunction;
Util.exportProperty(Model, 'makeUniqueKeyFunction', Model.prototype.makeUniqueKeyFunction);
Util.defineProperty(Model, { makeUniqueKeyFunction: 'makeUniqueKeyFunction' },
  /** @this {Model} */
  function() { return this._makeUniqueKeyFunction; },
  /** @this {Model} */
  function(val) {
    var old = this._makeUniqueKeyFunction;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', Model, 'makeUniqueKeyFunction');
      this._makeUniqueKeyFunction = val;
      this.raiseChanged('makeUniqueKeyFunction', old, val);
    }
  }
);


/**
* @ignore
* @this {Model}
* @param {*} x
* @return {boolean} true if the value might be used as a key identifying a node.
*/
Model.prototype.isKeyType = function(x) {
  return (typeof x === 'number' || typeof x === 'string');
};


Model.prototype['containsNodeData'] =
/**
* Decide if a given node data is in this model.
* @this {Model}
* @param {Object} nodedata a JavaScript object representing a node, group, or non-link.
* @return {boolean} true if it is a node data object in this model; false otherwise.
*/
Model.prototype.containsNodeData = function(nodedata) {
  var key = this.getKeyForNodeData(nodedata);
  if (key === undefined) return false;
  return this._mapKeyNodeData.contains(key);
};

Model.prototype['findNodeDataForKey'] =
/**
* Given a number or string, find the node data in this model
* that uses the given value as its unique key.
* @this {Model}
* @param {*} key a string or a number.
* @return {Object} null if the key is not present in the model,
* or if the key is null or undefined or not a string or number.
* @see #containsNodeData
* @see #getKeyForNodeData
*/
Model.prototype.findNodeDataForKey = function(key) {
  if (key === null) Util.throwError('Model.findNodeDataForKey:key must not be null');
  if (key === undefined) return null;
  if (!this.isKeyType(key)) return null;
  return this._mapKeyNodeData.getValue(key);
};


// Node data

/**
* Gets or sets the array of node data objects that correspond to {@link Node}s,
* {@link Group}s, or non-Link {@link Part}s in the {@link Diagram}.
* <p/>
* For each Object in the Array, {@link #getKeyForNodeData} should return a number or string
* uniquely identifying the node data within the model.
* If it returns undefined, this calls {@link #makeNodeDataKeyUnique},
* to make sure the node data has a unique key.
* These key values may be used by other objects to refer to that particular node data object.
* If more than one node data object has the same key,
* there may be some confusion about which object to reference.
* <p/>
* If you want to use a custom data property for holding the unique key value on a node data object,
* you should set {@link #nodeKeyProperty} before you set this <code>nodeDataArray</code> property.
* <p/>
* Adding or removing data from this Array will not notify this model or the diagram
* that there are any new nodes or that any nodes have been deleted.
* Instead you should call {@link #addNodeData} or {@link #removeNodeData}.
* @name Model#nodeDataArray
* @function.
* @return {Array.&lt;Object&gt;}
*/
/** @type {Array.<Object>} */
Model.prototype.nodeDataArray;
Util.exportProperty(Model, 'nodeDataArray', Model.prototype.nodeDataArray);
Util.defineProperty(Model, {nodeDataArray: 'nodeDataArray'},
  /** @this {Model} */
  function() { return this._nodeDataArray; },
  /** @this {Model} */
  function(val) {
    var old = this._nodeDataArray;
    if (old !== val) {
      Util.checkArray(val, Model, 'nodeDataArray');
      // completely replacing all node data, so are replacing all key information
      this._mapKeyNodeData.clear();
      // This does not optimize cases where some of the same node data objects are in the new array.
      // (Such an optimization might not even be desired, in case the node data objects have been modified.)
      // Establish as unresolved all references in link data.
      this.unresolveAllReferencesToNodeData();

      // Assign unique numbers as keys for each node data.
      // The actual key values are needed for hashing in Diagram.
      var len = Util.arrayLength(val);
      for (var i = 0; i < len; i++) {
        var data = Util.arrayElt(val, i);
        if (!Util.isObject(data)) {
          Util.throwError('Model.nodeDataArray must only contain Objects, not: ' + data);
          return;
        }
        Util.hashIdUnique(data);
      }

      this._nodeDataArray = val;

      // Find the key for each node data, and remember in a Map.
      var delayed = new List(Object);
      for (var i = 0; i < len; i++) {
        var data = Util.arrayElt(val, i);
        var key = this.getKeyForNodeData(data);
        if (key === undefined) {
          delayed.add(data);
        } else if (this._mapKeyNodeData.getValue(key) !== null) {
          // duplicate keys: call makeNodeDataKeyUnique soon
          delayed.add(data);
        } else {
          this._mapKeyNodeData.add(key, data);
        }
      }

      // Some node data didn't have a key value;
      // generate a unique number by modifying the data, then remember it.
      // We delay the calls to makeNodeDataKeyUnique to avoid accidentally
      // generating a new key that happens to be the same as one that
      // is in a not-yet-seen node data.
      var dit = delayed.iterator;
      while (dit.next()) {
        var data = dit.value;
        this.makeNodeDataKeyUnique(data);
        var newkey = this.getKeyForNodeData(data);
        this._mapKeyNodeData.add(newkey, data);
      }

      // Notify about the property change
      this.raiseModelChangedEvent('nodeDataArray', ChangedEvent.Property, 'nodeDataArray', this, old, val);

      // Now resolve references
      for (var i = 0; i < len; i++) {
        var data = Util.arrayElt(val, i);
        this.resolveReferencesToNodeData(data);
        this.resolveReferencesInNodeData(data);
      }

      // assume setting nodeDataArray means all nodes are known, at least for now
      this.clearUnresolvedReferences();

      if (!Array.isArray(val)) {  // not Util.isArray
        this.isReadOnly = true;
      }
    }
  }
);

Model.prototype['makeNodeDataKeyUnique'] =
/**
* This method is called when a node data object is added to the model to make sure that
* {@link #getKeyForNodeData} returns a unique key value.
* <p/>
* The key value should be unique within the set of data managed by this model:
* {@link #nodeDataArray}.
* If the key is already in use, this will assign an unused number to the
* {@link #nodeKeyProperty} property on the data.
* <p/>
* If you want to customize the way in which node data gets a unique key,
* you can set the {@link #makeUniqueKeyFunction} functional property.
* <p/>
* If the node data object is already in the model and you want to change its key value,
* call {@link #setKeyForNodeData} and give it a new unique key value.
* @this {Model}
* @param {Object} nodedata a JavaScript object representing a node, group, or non-link.
*/
Model.prototype.makeNodeDataKeyUnique = function(nodedata) {
  if (nodedata === null) return;
  var kname = this._nodeKeyProperty;
  if (kname === '') return;  // not using key values
  // maybe already has a unique key?
  var key = this.getKeyForNodeData(nodedata);
  if (key !== undefined && !this._mapKeyNodeData.contains(key)) return;
  // try a programmer-supplied function for generating a key
  var func = this._makeUniqueKeyFunction;
  if (func !== null) {
    key = func(this, nodedata);
    // if the return value is unique, set the key on the node data, just to be sure
    if (key !== undefined && key !== null && !this._mapKeyNodeData.contains(key)) {
      Util.safePropertySet(nodedata, kname, key);
      return;
    }
    // otherwise drop through to really make it unique
  }
  // Note that this does NOT call setKeyForNodeData, because this should not notify
  // and should not modify any references using the duplicate key.
  // no key or not unique key
  if (typeof key === 'string') {
    var j = 2;
    while (this._mapKeyNodeData.contains(key + j)) j++;
    Util.safePropertySet(nodedata, kname, key + j);
  } else if (key === undefined || typeof key === 'number') {
    // use negatives to reduce chance of future conflicts
    var j = -this._mapKeyNodeData.count - 1;
    while (this._mapKeyNodeData.contains(j)) j--;
    Util.safePropertySet(nodedata, kname, j);
  } else {
    Util.throwError('Model.getKeyForNodeData returned something other than a string or a number: ' + key);
  }
};

Model.prototype['addNodeData'] =
/**
* When you want to add a node or group to the diagram,
* call this method with a new data object.
* This will add that data to the {@link #nodeDataArray} and
* notify all listeners that a new node data object has been inserted into the collection.
* <p/>
* To remove a node from the diagram, you can remove its data object by calling {@link #removeNodeData}.
* <p/>
* To add or remove an object or value from an item array, call {@link #insertArrayItem} or {@link #removeArrayItem}.
* @this {Model}
* @param {Object} nodedata a JavaScript object representing a node, group, or non-link.
*/
Model.prototype.addNodeData = function(nodedata) {
  if (nodedata === null) return;
  Util.hashIdUnique(nodedata);
  // see if already in key->data Map
  var key = this.getKeyForNodeData(nodedata);
  if (key === undefined) {  // no key, need key to be unique
    this.makeNodeDataKeyUnique(nodedata);
    key = this.getKeyForNodeData(nodedata);
  } else {  // has key -- is this node data already in the Map?
    if (this._mapKeyNodeData.getValue(key) === nodedata) return;
    // if not, duplicate key!
    this.makeNodeDataKeyUnique(nodedata);
    key = this.getKeyForNodeData(nodedata);
  }
  // update the key->data Map
  this._mapKeyNodeData.add(key, nodedata);
  // modify the nodeDataArray
  var idx = Util.arrayLength(this._nodeDataArray);
  Util.arrayInsertAt(this._nodeDataArray, idx, nodedata);
  // notify
  this.raiseModelChangedEvent('nodeDataArray', ChangedEvent.Insert, 'nodeDataArray', this, null, nodedata, null, idx);
  // resolve some references?
  this.resolveReferencesToNodeData(nodedata);
  this.resolveReferencesInNodeData(nodedata);
};

Model.prototype['removeNodeData'] =
/**
* When you want to remove a node or group from the diagram,
* call this method with an existing data object.
* This will remove that data from the {@link #nodeDataArray} and
* notify all listeners that a node data object has been removed from the collection.
* <p/>
* Removing a node data from a model does not automatically remove
* any connected link data from the model.
* Removing a node data that represents a group does not automatically remove
* any member node data or link data from the model.
* <p/>
* To add a node to the diagram, you can add its data object by calling {@link #addNodeData}.
* <p/>
* To add or remove an object or value from an item array, call {@link #insertArrayItem} or {@link #removeArrayItem}.
* @this {Model}
* @param {Object} nodedata a JavaScript object representing a node, group, or non-link.
*/
Model.prototype.removeNodeData = function(nodedata) {
  if (nodedata === null) return;
  // see if already removed from key->data Map
  var key = this.getKeyForNodeData(nodedata);
  if (key === undefined) return;
  if (!this._mapKeyNodeData.contains(key)) return;
  // update the key->data Map
  this._mapKeyNodeData.remove(key);
  // modify the nodeDataArray
  var idx = Util.arrayIndexOf(this._nodeDataArray, nodedata);
  if (idx < 0) return;
  Util.arrayRemoveAt(this._nodeDataArray, idx);
  // notify
  this.raiseModelChangedEvent('nodeDataArray', ChangedEvent.Remove, 'nodeDataArray', this, nodedata, null, idx, null);
  //?? Diagrams will call-back to delayReference
  // unresolve some references?
  this.unresolveReferencesInNodeData(nodedata);
};


// These internal methods are overridden by subclasses

/**
* @ignore
* When a node data changes its key, we need to update all data references to that node data
* that are using the old key value by replacing them with the new key value.
* The goal is to maintain all of the original relationships in all of the data maintained by the model.
* @param oldkey
* @param newkey
* @this {Model}
*/
Model.prototype.replaceAllKeyReferences = function(oldkey, newkey) {
  var coll = this.findDelayedReferences(oldkey);
  if (coll instanceof Set) {
    this._delayedNodeReferences.add(newkey, coll);
  }
};

/**
* @ignore
* This is overridden by GraphLinksModel, since that is the only kind of model that
* has data objects other than node data to have key references to node data.
* @this {Model}
*/
Model.prototype.unresolveAllReferencesToNodeData = function() {
  // nothing to do, Model data do not support any kind of references to nodes
};

/**
* @ignore
* Find any delayed references to the given node data by its key,
* notify listeners that that reference now exists,
* and finally forget that there were any delayed references to this data/key.
* This is overridden by subclasses.
* @this {Model}
* @param {Object} nodedata
*/
Model.prototype.resolveReferencesToNodeData = function(nodedata) {
  // nothing to do, Model data do not support any kind of references to nodes
};

/**
* @ignore
* For each reference in the given node data to node data that does not (yet?) exist in this model,
* delay that reference by remembering it, by calling {@link #delayReference}.
* This is overridden by subclasses.
* @this {Model}
* @param {Object} nodedata
*/
Model.prototype.resolveReferencesInNodeData = function(nodedata) {
  // nothing to do, Model data do not support any kind of references from nodes
};

/**
* @ignore
* Forget any delayed references to node data that this node data has within it,
* by calling {@link #forgetDelayedReference} on them.
* This is overridden by subclasses.
* @this {Model}
* @param {Object} nodedata
*/
Model.prototype.unresolveReferencesInNodeData = function(nodedata) {
  // nothing to do, Model data do not support any kind of references from nodes
};


/**
* @ignore
* Remember that a given object has a node reference using a given key,
* but that the node data is not presently in the model.
* @this {Model}
* @param {number|string|undefined} key
* @param {*} data Either node data or link data.
* @see #forgetDelayedReference
* @see #findDelayedReferences
*/
Model.prototype.delayReference = function(key, data) {
  if (key === undefined) return;
  var coll = this._delayedNodeReferences.getValue(key);
  if (coll === null) {
    coll = new Set();
    this._delayedNodeReferences.add(key, coll);
  }
  coll.add(data);
};

/**
* @ignore
* Forget a data object that may have had a reference to a node using the given key.
* This is called when the data is being removed from the model,
* and we want to make sure there is no memory of that data object.
* @this {Model}
* @param {number|string|undefined} key
* @param {*=} data Either node data or link data.
* @see #delayReference
* @see #findDelayedReferences
*/
Model.prototype.forgetDelayedReference = function(key, data) {
  if (key === undefined) return;
  var coll = this._delayedNodeReferences.getValue(key);
  if (coll instanceof Set) {
    if (data === undefined || data === null) {
      this._delayedNodeReferences.remove(key);
    } else {
      coll.remove(data);
      if (coll.count === 0) {
        this._delayedNodeReferences.remove(key);
      }
    }
  }
};

Model.prototype['dumpDelayedReferences'] =
/**
* @ignore
* This exists for debugging.
* @this {Model}
*/
Model.prototype.dumpDelayedReferences = function() {
  Util.trace('DelayedReferences (' + this._delayedNodeReferences.count + ')');
  var it = this._delayedNodeReferences.iterator;
  while (it.next()) {
    var uses = '';
    var refs = it.value.iterator;
    while (refs.next()) {
      uses += Binding.toString(refs.value) + ', ';
    }
    Util.trace('  ' + it.key + ': ' + uses);
  }
};

/**
* @ignore
* @this {Model}
* @param {number|string|undefined} key
* @return {Set} data objects that each have one or more references to the given key.
* @see #delayReference
* @see #forgetDelayedReference
*/
Model.prototype.findDelayedReferences = function(key) {
  if (key === undefined) return null;
  var coll = this._delayedNodeReferences.getValue(key);
  if (coll instanceof Set) return coll;
  return null;
};

Model.prototype['clearUnresolvedReferences'] =
/**
* @ignore
* @this {Model}
* @param {number|string=} key
* @see #delayReference
*/
Model.prototype.clearUnresolvedReferences = function(key) {
  if (key === undefined) {
    this._delayedNodeReferences.clear();
  } else {
    this._delayedNodeReferences.remove(key);
  }
};


/**
* Gets or sets a function that makes a copy of a node data object.
* <p/>
* You may need to set this property in order to ensure that a copied {@link Node} is bound
* to data that does not share certain data structures between the original node data and the copied node data.
* The value may be null in order to cause {@link #copyNodeData} to make a shallow copy of a JavaScript Object.
* The default value is null.
* <p/>
* It is common to implement a copying function when the node data has an Array of data
* and that Array needs to be copied rather than shared.
* Often the objects that are in the Array also need to be copied.
* @name Model#copyNodeDataFunction
* @function.
* @return {function(Object, Model):Object | null}
*/
/** @type {function(Object, Model):Object | null} */
Model.prototype.copyNodeDataFunction;
Util.exportProperty(Model, 'copyNodeDataFunction', Model.prototype.copyNodeDataFunction);
Util.defineProperty(Model, { copyNodeDataFunction: 'copyNodeDataFunction' },
  /** @this {Model} */
  function() { return this._copyNodeDataFunction; },
  /** @this {Model} */
  function(val) {
    var old = this._copyNodeDataFunction;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', Model, 'copyNodeDataFunction');
      this._copyNodeDataFunction = val;
      this.raiseChanged('copyNodeDataFunction', old, val);
    }
  }
);

Model.prototype['copyNodeData'] =
/**
* Make a copy of a node data object.
* This uses the value of {@link #copyNodeDataFunction} to actually perform the copy,
* unless it is null, in which case this method just makes a shallow copy of the JavaScript Object.
* <p/>
* This does not modify the model -- the returned data object is not added to this model.
* This assumes that the data's constructor can be called with no arguments.
* @this {Model}
* @param {Object} nodedata a JavaScript object representing a node, group, or non-link.
* @return {Object}
* @see #addNodeData
*/
Model.prototype.copyNodeData = function(nodedata) {
  if (nodedata === null) return null;
  var copy = null;
  // try a programmer-supplied function for copying the data
  var func = this._copyNodeDataFunction;
  if (func !== null) {
    copy = func(nodedata, this);
  } else {  // otherwise assume there's a constructor
    copy = new nodedata.constructor;
    // and we copy enumerable data properties
    for (var k in nodedata) {
      Util.safePropertySet(copy, k, Util.safePropertyValue(nodedata, k));
    }
  }
  if (copy) Util.uniqueHash(copy);
  return copy;
};

Model.prototype['setDataProperty'] =
/**
* Change the value of some property of a node data, a link data, or an item data, given a string naming the property
* and the new value, in a manner that can be undone/redone and that automatically updates any bindings.
* <p/>
* This gets the old value of the property; if the value is the same as the new value, no side-effects occur.
* @this {Model}
* @param {Object} data a JavaScript object representing a Node, Link, Group, simple Part, or item in a {@link Panel#itemArray}.
* @param {string} propname a string that is not null or the empty string.
* @param {*} val the new value for the property.
*/
Model.prototype.setDataProperty = function(data, propname, val) {
  if (Debug) {
    Util.checkPrimitive(data, 'object', Model, 'setDataProperty:data');
    Util.checkPrimitive(propname, 'string', Model, 'setDataProperty:propname');
    if (propname === '') Util.throwError('Model.setDataProperty: property name must not be an empty string when setting ' + data + ' to ' + val);
  }
  if (this.containsNodeData(data)) {
    if (propname === this.nodeKeyProperty) {
      this.setKeyForNodeData2(data, val);
    } else if (propname === this.nodeCategoryProperty) {
      this.setCategoryForNodeData2(data, val);
      return;
    }
  } else {
    if (!Util.warnedAboutModifyingGraphObject && data instanceof GraphObject) {
      Util.warnedAboutModifyingGraphObject = true;
      Util.trace('Model.setDataProperty is modifying a GraphObject, "' + data.toString() + '"');
      Util.trace('  Is that really your intent?');
    }
  }
  // set the property and raise a Property ChangedEvent with the old and new values
  var old = Util.safePropertyValue(data, propname);
  if (old !== val) {
    Util.safePropertySet(data, propname, val);
    this.raiseDataChanged(data, propname, old, val);
  }
};

Model.prototype['addArrayItem'] =
/**
* Add an item at the end of a data array that may be data bound by a {@link Panel} as its {@link Panel#itemArray},
* in a manner that can be undone/redone and that automatically updates any bindings.
* <p/>
* This also calls {@link #raiseChangedEvent} to notify all listeners about the {@link ChangedEvent#Insert}.
* <p/>
* If you want to add a new node or part to the diagram, call {@link #addNodeData}.
* @this {Model}
* @param {Array} arr an Array that is the value of some {@link Panel}'s {@link Panel#itemArray}.
* @param {*} val the new value to be pushed onto the array.
* @see #insertArrayItem
* @since 1.1
*/
Model.prototype.addArrayItem = function(arr, val) {
  this.insertArrayItem(arr, -1, val);
};

Model.prototype['insertArrayItem'] =
/**
* Add an item to a data array that may be data bound by a {@link Panel} as its {@link Panel#itemArray},
* given a new data value and the index at which to insert the new value, in a manner that can be undone/redone and that automatically updates any bindings.
* <p/>
* This also calls {@link #raiseChangedEvent} to notify all listeners about the {@link ChangedEvent#Insert}.
* <p/>
* If you want to add a new node or part to the diagram, call {@link #addNodeData}.
* @this {Model}
* @param {Array} arr an Array that is the value of some {@link Panel}'s {@link Panel#itemArray}.
* @param {number} idx the zero-based array index where the new value will be inserted; use -1 to push the new value on the end of the array.
* @param {*} val the new value to be inserted into the array.
* @see #removeArrayItem
*/
Model.prototype.insertArrayItem = function(arr, idx, val) {
  if (Debug) {
    Util.checkArray(arr, Model, 'insertArrayItem:arr');
    Util.checkRealNumber(idx, Model, 'insertArrayItem:idx');
  }
  if (arr === this._nodeDataArray) {
    Util.throwError('Model.insertArrayItem or Model.addArrayItem should not be called on the Model.nodeDataArray');
  }
  if (idx < 0) idx = Util.arrayLength(arr);
  Util.arrayInsertAt(arr, idx, val);
  this.raiseModelChangedEvent('', ChangedEvent.Insert, '', arr, null, val, null, idx);
};

Model.prototype['removeArrayItem'] =
/**
* Remove an item from a data array that may be data bound by a {@link Panel} as its {@link Panel#itemArray},
* given the index at which to remove a data value, in a manner that can be undone/redone and that automatically updates any bindings.
* <p/>
* This also calls {@link #raiseChangedEvent} to notify all listeners about the {@link ChangedEvent#Remove}.
* <p/>
* If you want to remove a node from the diagram, call {@link #removeNodeData}.
* <p/>
* Note that there is no version of this method that takes an item value instead of an index into the array.
* Because item arrays may hold any JavaScript value, including numbers and strings, there may be duplicate entries with that value in the array.
* To avoid ambiguity, removing an item from an array requires an index.
* @this {Model}
* @param {Array} arr an Array that is the value of some {@link Panel}'s {@link Panel#itemArray}.
* @param {number=} idx the zero-based array index of the data item to be removed from the array;
*   if not supplied it will remove the last item of the array.
* @see #insertArrayItem
*/
Model.prototype.removeArrayItem = function(arr, idx) {
  if (idx === undefined/*notpresent*/) idx = -1;
  if (Debug) {
    Util.checkArray(arr, Model, 'removeArrayItem:arr');
    Util.checkRealNumber(idx, Model, 'removeArrayItem:idx');
  }
  if (arr === this._nodeDataArray) {
    Util.throwError('Model.removeArrayItem should not be called on the Model.nodeDataArray');
  }
  if (idx === -1) idx = Util.arrayLength(arr) - 1;
  var oldval = Util.arrayElt(arr, idx);
  Util.arrayRemoveAt(arr, idx);
  this.raiseModelChangedEvent('', ChangedEvent.Remove, '', arr, oldval, null, idx, null);
};


/**
* Gets or sets the name of the node data property that returns a string describing that data's category,
* or a function that takes a node data object and returns the category name;
* the default value is the name 'category'.
* This is used by the diagram to distinguish between different kinds of nodes.
* The name must not be null.
* If the value is an empty string,
* {@link #getCategoryForNodeData} will return an empty string for all node data objects.
* @name Model#nodeCategoryProperty
* @function.
* @return {string|function(Object):string}
* @see #getCategoryForNodeData
* @see #setCategoryForNodeData
*/
/** @type {string|function(Object):string} */
Model.prototype.nodeCategoryProperty;
Util.exportProperty(Model, 'nodeCategoryProperty', Model.prototype.nodeCategoryProperty);
Util.defineProperty(Model, {nodeCategoryProperty: 'nodeCategoryProperty'},
  /** @this {Model} */
  function() { return this._nodeCategoryProperty; },
  /** @this {Model} */
  function(val) {
    var old = this._nodeCategoryProperty;
    if (old !== val) {
      this.checkStringOrFunction(val, Model, 'nodeCategoryProperty');
      this._nodeCategoryProperty = val;
      this.raiseChanged('nodeCategoryProperty', old, val);
    }
  }
);

Model.prototype['getCategoryForNodeData'] =
/**
* Find the category of a given node data, a string naming the node template
* or group template or part template
* that the {@link Diagram} should use to represent the node data.
* @this {Model}
* @param {Object} nodedata a JavaScript object representing a node, group, or non-link.
* @return {string}
* @see #nodeCategoryProperty
* @see #setCategoryForNodeData
*/
Model.prototype.getCategoryForNodeData = function(nodedata) {
  if (nodedata === null) return '';
  var cname = this._nodeCategoryProperty;
  if (cname === '') return '';
  var cat = Util.safePropertyValue(nodedata, cname);
  if (cat === undefined) return '';
  if (typeof cat === 'string') return cat;
  if (Debug) Util.trace('getCategoryForNodeData found a non-string category for ' + nodedata + ': ' + cat);
  return '';
};

Model.prototype['setCategoryForNodeData'] =
/**
* Change the category of a given node data, a string naming the node template
* or group template or part template
* that the {@link Diagram} should use to represent the node data.
* <p/>
* Changing the node template for a node data will cause the existing {@link Node}, {@link Group}, or {@link Part}
* to be replaced with a new {@link Node}, {@link Group}, or {@link Part}
* created by copying the new node template and applying any data-bindings.
* @this {Model}
* @param {Object} nodedata a JavaScript object representing a node, group, or non-link.
* @param {string} cat Must not be null.
* @see #nodeCategoryProperty
* @see #getCategoryForNodeData
*/
Model.prototype.setCategoryForNodeData = function(nodedata, cat) {
  Util.checkPrimitive(cat, 'string', Model, 'setCategoryForNodeData:cat');
  if (nodedata === null) return;
  var cname = this._nodeCategoryProperty;
  if (cname === '') return;
  if (!this.containsNodeData(nodedata)) {
    Util.safePropertySet(nodedata, cname, cat);
    return;
  }
  var old = Util.safePropertyValue(nodedata, cname);
  if (old === undefined) old = '';
  if (old !== cat) {
    Util.safePropertySet(nodedata, cname, cat);
    this.raiseModelChangedEvent('nodeCategory', ChangedEvent.Property, cname, nodedata, old, cat);
  }
};
/**
* @ignore
* This is only defined to avoid a warning in the Closure compiler.
* @param nodedata
* @param cat
* @this {Model}
*/
Model.prototype.setCategoryForNodeData2 = function(nodedata, cat) {
  this.setCategoryForNodeData(nodedata, cat);
};


/**
* This constructs an empty GraphLinksModel unless one provides arguments as the initial data array values
* for the {@link Model#nodeDataArray} and {@link GraphLinksModel#linkDataArray} properties.
* @constructor
* @param {Array=} nodedataarray an optional Array containing JavaScript objects to be represented by Nodes.
* @param {Array=} linkdataarray an optional Array containing JavaScript objects to be represented by Links.
* @extends Model
* @category Model
* @class
* GraphLinksModels support links between nodes and grouping nodes and links into subgraphs.
* GraphLinksModels hold node data and link data in separate arrays.
* Node data is normally represented in a {@link Diagram} by instances of {@link Node},
* but they could be represented by simple {@link Part}s or by {@link Group}s.
* Link data should be represented by instances of {@link Link}.
* <p/>
* Each link data object is assumed to have two values, one referring to the node that the
* link is coming from and one that the link is going to.
* The {@link #linkFromKeyProperty} property names the property on the link data whose value
* is the key of the "from" node.
* The {@link #linkToKeyProperty} property names the property on the link data whose value
* is the key of the "to" node.
* The default values for these properties are "from" and "to" respectively.
* <p/>
* For example, one can define a graph consisting of two nodes with one link connecting them:
* <pre class="javascript">
*  model.nodeDataArray = [
*    { key: "Alpha" },
*    { key: "Beta" }
*  ];
*  model.linkDataArray = [
*    { from: "Alpha", to: "Beta" }
*  ];
* </pre>
* <p/>
* If you want to have subgraphs in your diagram, where a group node contains some number of nodes and links,
* you need to declare that some node data actually represent groups,
* and you need to provide a reference from a member node data to its containing group node data.
* The {@link #nodeIsGroupProperty} property names the property on a node data that is true
* if that node data represents a group.
* The {@link #nodeGroupKeyProperty} property names the property on a node data whose value
* is the key of the containing group's node data.
* The default values for these properties are "isGroup" and "group" respectively.
* <p/>
* For example, one can define a graph consisting of one group containing a subgraph of
* two nodes connected by a link, with a second link from that group to a third node
* that is not a member of that group:
* <pre>
*  model.nodeDataArray = [
*    { key: "Group1", isGroup: true},
*    { key: "Alpha", group: "Group1" },
*    { key: "Beta", group: "Group1" },
*    { key: "Gamma" }
*  ];
*  model.linkDataArray = [
*    { from: "Alpha", to: "Beta" },
*    { from: "Group1", to: "Gamma" }
*  ];
* </pre>
* <p/>
* GraphLinksModels also support distinguishing the "port" element of a node to which
* a link can connect, at either end of the link.
* This identification is a string that names the "port" element in the node.
* However, you need to set the {@link #linkFromPortIdProperty} and/or
* {@link #linkToPortIdProperty} properties before the model is able to
* get the "port id" information from the link data.
* <p/>
* For example, one can define a graph consisting of a "subtraction" node and two inputs and one output.
* The "subtraction" node has two distinct inputs called "subtrahend" and "minuend";
* the output is called "difference".
* <pre>
*  model.linkFromPortIdProperty = "fromPort";
*  model.linkToPortIdProperty = "toPort";
*  model.nodeDataArray = [
*    { key: 1, constant: 5 },  // a constant input node
*    { key: 2, constant: 2 },  // another constant node
*    { key: 3, operation: "subtract" },
*    { key: 4, value: 3 }  // the output node
*  ];
*  model.linkDataArray = [
*    { from: 1, to: 3, toPort: "subtrahend" },
*    { from: 2, to: 3, toPort: "minuend" },
*    { from: 3, to: 4, fromPort: "difference" }
*  ];
* </pre>
* In this case links connected to node 3 (which is the subtraction operation)
* are distinguished by port id.
* The connections to the other nodes do not have any port identification,
* presumably because there is only one port on those nodes, representing the node value.
* <p/>
* This model does not support the modification of whether a node data object is a group.
* <p/>
* This model cannot detect the modification of the {@link #linkDataArray} array
* or the modification of any link data object.
* If you want to add or remove link data from the {@link #linkDataArray},
* call the {@link #addLinkData} or {@link #removeLinkData} methods.
* If you want to modify the node a link connects to, call the
* {@link #setFromKeyForLinkData} and/or {@link #setToKeyForLinkData} methods.
* If you want to change the membership of a node data in a group,
* call the {@link #setGroupKeyForNodeData} method.
*/
function GraphLinksModel(nodedataarray, linkdataarray) {
  if (arguments.length > 2) {
    Util.throwError('GraphLinksModel constructor can only take two optional arguments, the Array of node data and the Array of link data.');
  }
  Model.call(this);
  /** @type {Array.<Object>} */
  this._linkDataArray = [];
  /** @type {Set} */
  this._linkDataSet = new Set(Object);
  /** @type {function(Object, GraphLinksModel):Object | null} */
  this._copyLinkDataFunction = null;
  /** @type {Object} */
  this._archetypeNodeData = null;
  /** @type {string|function(Object):(string|number)} */
  this._linkFromKeyProperty = 'from';
  /** @type {string|function(Object):(string|number)} */
  this._linkToKeyProperty = 'to';
  /** @type {string|function(Object):string} */
  this._linkFromPortIdProperty = '';
  /** @type {string|function(Object):string} */
  this._linkToPortIdProperty = '';
  /** @type {string|function(Object):string} */
  this._linkCategoryProperty = 'category';
  /** @type {string|function(Object):boolean} */
  this._nodeIsLinkLabelProperty = '';
  /** @type {string|function(Object):Array.<(string|number)>} */
  this._linkLabelKeysProperty = '';

  /** @type {string|function(Object):boolean} */
  this._nodeIsGroupProperty = 'isGroup';
  /** @type {string|function(Object):(string|number)} */
  this._nodeGroupKeyProperty = 'group';

  if (nodedataarray !== undefined/*not present*/) this.nodeDataArray = nodedataarray;
  if (linkdataarray !== undefined/*not present*/) this.linkDataArray = linkdataarray;
}

Util.publish('GraphLinksModel', GraphLinksModel);

Util.inherit(GraphLinksModel, Model);

GraphLinksModel.prototype['clear'] =
/**
* @ignore
* Clear out all references to any model data.
* This also clears out the {@link UndoManager}.
* @this {GraphLinksModel}
*/
GraphLinksModel.prototype.clear = function() {
  Model.prototype.clear.call(this);
  this._linkDataArray = [];
  this._linkDataSet.clear();
};


/**
* @ignore
* @this {GraphLinksModel}
* @param {number=} details Optional: If greater than zero, this includes descriptions of each node data and link data.
* @return {string}
*/
GraphLinksModel.prototype.toString = function(details) {
  if (details === undefined) details = 0;
  if (details >= 2) {
    return this.toJson();
  } else {
    var s = (this.name !== '' ? this.name : '') + ' GraphLinksModel';
    if (details > 0) {
      s += '\n node data:';
      var arr = this.nodeDataArray;
      var len = Util.arrayLength(arr);
      var i;
      for (i = 0; i < len; i++) {
        var item = Util.arrayElt(arr, i);
        s += ' ' + this.getKeyForNodeData(item) + ':' + Binding.toString(item);
      }
      s += '\n link data:';
      arr = this.linkDataArray;
      len = Util.arrayLength(arr);
      for (i = 0; i < len; i++) {
        var item = Util.arrayElt(arr, i);
        s += ' ' + this.getFromKeyForLinkData(item) + '-->' + this.getToKeyForLinkData(item);
      }
    }
    return s;
  }
};

/**
* @ignore
* Write out the persistent properties of this model into a string using JSON syntax property pairs.
* @this {GraphLinksModel}
* @return {string}
*/
GraphLinksModel.prototype.writeJsonProtected = function() {
  var basestr = Model.prototype.writeJsonProtected.call(this);
  var s = '';
  if (this.linkCategoryProperty !== 'category' && typeof this.linkCategoryProperty === 'string') s += ',\n  "linkCategoryProperty": ' + this.quote(this.linkCategoryProperty);
  if (this.linkFromKeyProperty !== 'from' && typeof this.linkFromKeyProperty === 'string') s += ',\n "linkFromKeyProperty": ' + this.quote(this.linkFromKeyProperty);
  if (this.linkToKeyProperty !== 'to' && typeof this.linkToKeyProperty === 'string') s += ',\n  "linkToKeyProperty": ' + this.quote(this.linkToKeyProperty);
  if (this.linkFromPortIdProperty !== '' && typeof this.linkFromPortIdProperty === 'string') s += ',\n  "linkFromPortIdProperty": ' + this.quote(this.linkFromPortIdProperty);
  if (this.linkToPortIdProperty !== '' && typeof this.linkToPortIdProperty === 'string') s += ',\n  "linkToPortIdProperty": ' + this.quote(this.linkToPortIdProperty);
  if (this.nodeIsLinkLabelProperty !== '' && typeof this.nodeIsLinkLabelProperty === 'string') s += ',\n "nodeIsLinkLabelProperty": ' + this.quote(this.nodeIsLinkLabelProperty);
  if (this.linkLabelKeysProperty !== '' && typeof this.linkLabelKeysProperty === 'string') s += ',\n  "linkLabelKeysProperty": ' + this.quote(this.linkLabelKeysProperty);
  if (this.nodeIsGroupProperty !== 'isGroup' && typeof this.nodeIsGroupProperty === 'string') s += ',\n "nodeIsGroupProperty": ' + this.quote(this.nodeIsGroupProperty);
  if (this.nodeGroupKeyProperty !== 'group' && typeof this.nodeGroupKeyProperty === 'string') s += ',\n  "nodeGroupKeyProperty": ' + this.quote(this.nodeGroupKeyProperty);
  return basestr + s;
};

/**
* @ignore
* @this {GraphLinksModel}
* @return {string}
*/
GraphLinksModel.prototype.writeJsonData = function() {
  var basestr = Model.prototype.writeJsonData.call(this);
  var str = ',\n  "linkDataArray": ' + this.writeJsonArray(this.linkDataArray, true);
  return basestr + str;
};

/**
* @ignore
* Find the persistent model properties of the given Object and assign them to this model.
* @this {GraphLinksModel}
* @param {Object} obj
*/
GraphLinksModel.prototype.readJsonProtected = function(obj) {
  Model.prototype.readJsonProtected.call(this, obj);
  if (obj['linkFromKeyProperty']) this.linkFromKeyProperty = obj['linkFromKeyProperty'];
  if (obj['linkToKeyProperty']) this.linkToKeyProperty = obj['linkToKeyProperty'];
  if (obj['linkFromPortIdProperty']) this.linkFromPortIdProperty = obj['linkFromPortIdProperty'];
  if (obj['linkToPortIdProperty']) this.linkToPortIdProperty = obj['linkToPortIdProperty'];
  if (obj['linkCategoryProperty']) this.linkCategoryProperty = obj['linkCategoryProperty'];
  if (obj['nodeIsLinkLabelProperty']) this.nodeIsLinkLabelProperty = obj['nodeIsLinkLabelProperty'];
  if (obj['linkLabelKeysProperty']) this.linkLabelKeysProperty = obj['linkLabelKeysProperty'];
  if (obj['nodeIsGroupProperty']) this.nodeIsGroupProperty = obj['nodeIsGroupProperty'];
  if (obj['nodeGroupKeyProperty']) this.nodeGroupKeyProperty = obj['nodeGroupKeyProperty'];
};

/**
* @ignore
* @this {GraphLinksModel}
* @param {Object} obj
*/
GraphLinksModel.prototype.readJsonData = function(obj) {
  Model.prototype.readJsonData.call(this, obj);
  if (obj['linkDataArray']) {
    var arr = obj['linkDataArray'];
    this.replaceJsonObjects(arr);
    this.linkDataArray = arr;
  }
};


/**
* @ignore
* @this {GraphLinksModel}
* @param {ChangedEvent} e This describes the change that needs to be done.
* @param {boolean} undo If true, this method should restore the older state, otherwise the newer state.
*/
GraphLinksModel.prototype.changeState = function(e, undo) {
  if (e.change === ChangedEvent.Insert) {
    var arr = null;
    if (e.modelChange === 'linkDataArray') arr = this.linkDataArray;
    else if (e.modelChange === 'linkLabelKeys') arr = this.getLabelKeysForLinkData(e.object);
    if (Util.isArray(arr)) {
      if (undo) {
        Util.arrayRemoveAt(arr, e.newParam);
      } else {
        Util.arrayInsertAt(arr, e.newParam, e.newValue);
      }
      return;
    }
  } else if (e.change === ChangedEvent.Remove) {
    var arr = null;
    if (e.modelChange === 'linkDataArray') arr = this.linkDataArray;
    else if (e.modelChange === 'linkLabelKeys') arr = this.getLabelKeysForLinkData(e.object);
    if (Util.isArray(arr)) {
      if (undo) {
        Util.arrayInsertAt(arr, e.oldParam, e.oldValue);
      } else {
        Util.arrayRemoveAt(arr, e.oldParam);
      }
      return;
    }
  }
  // maybe the Model class can handle this change request
  Model.prototype.changeState.call(this, e, undo);
};


/**
* Gets or sets a data object that will be copied and added to the model as a new node data each time there
* is a link reference (either the "to" or the "from" of a link data) to a node key that does not yet exist in the model.
* <p/>
* The default value is null -- node data is not automatically copied and added to the model
* when there is an unresolved reference in a link data.
* When adding or modifying a link data if there is a "from" or "to" key value for which {@link Model#findNodeDataForKey} returns null,
* it will call {@link Model#copyNodeData} on this property value and {@link Model#addNodeData} on the result.
* @name GraphLinksModel#archetypeNodeData
* @function.
* @return {Object}
* @since 1.1
*/
/** @type {Object} */
GraphLinksModel.prototype.archetypeNodeData;
Util.exportProperty(GraphLinksModel, 'archetypeNodeData', GraphLinksModel.prototype.archetypeNodeData);
Util.defineProperty(GraphLinksModel, { archetypeNodeData: 'archetypeNodeData' },
  /** @this {GraphLinksModel} */
  function() { return this._archetypeNodeData; },
  /** @this {GraphLinksModel} */
  function(val) {
    var old = this._archetypeNodeData;
    if (old !== val) {
      if (val !== null) Util.checkClass(val, Object, GraphLinksModel, 'archetypeNodeData');
      this._archetypeNodeData = val;
      this.raiseChanged('archetypeNodeData', old, val);
    }
  }
);

/**
* @ignore
* @this {GraphLinksModel}
* @param {number|string|undefined} key
* @return {number|string|undefined}
*/
GraphLinksModel.prototype.maybeEnsureLinkReference = function(key) {
  if (key === undefined) return undefined;
  var arch = this._archetypeNodeData;
  if (arch !== null) {
    var data = this.findNodeDataForKey(key);
    if (data === null) {
      data = this.copyNodeData(arch);
      Util.safePropertySet(data, this._nodeKeyProperty, key);
      this.addNodeData(data);
    }
  }
  return key;
};


/**
* Gets or sets the name of the data property that returns
* the key of the node data that the link data is coming from,
* or a function that takes a link data object and returns that key;
* the default value is the name 'from'.
* The name must not be null.
* If the value is an empty string,
* {@link #getFromKeyForLinkData} will return undefined for all link data objects.
* @name GraphLinksModel#linkFromKeyProperty
* @function.
* @return {string|function(Object):(string|number)}
* @see #getFromKeyForLinkData
* @see #setFromKeyForLinkData
*/
/** @type {string|function(Object):(string|number)} */
GraphLinksModel.prototype.linkFromKeyProperty;
Util.exportProperty(GraphLinksModel, 'linkFromKeyProperty', GraphLinksModel.prototype.linkFromKeyProperty);
Util.defineProperty(GraphLinksModel, {linkFromKeyProperty: 'linkFromKeyProperty'},
  /** @this {GraphLinksModel} */
  function() { return this._linkFromKeyProperty; },
  /** @this {GraphLinksModel} */
  function(val) {
    var old = this._linkFromKeyProperty;
    if (old !== val) {
      this.checkStringOrFunction(val, GraphLinksModel, 'linkFromKeyProperty');
      this._linkFromKeyProperty = val;
      this.raiseChanged('linkFromKeyProperty', old, val);
    }
  }
);

GraphLinksModel.prototype['getFromKeyForLinkData'] =
/**
* From a link data retrieve a value uniquely identifying the node data
* from which this link is connected.
* @this {GraphLinksModel}
* @param {Object} linkdata a JavaScript object representing a link.
* @return {number|string|undefined}  This may return undefined if
* the link is not coming from any node.
* @see #linkFromKeyProperty
* @see #setFromKeyForLinkData
*/
GraphLinksModel.prototype.getFromKeyForLinkData = function(linkdata) {
  if (linkdata === null) return undefined;
  var kname = this._linkFromKeyProperty;
  if (kname === '') return undefined;
  var key = Util.safePropertyValue(linkdata, kname);
  if (key === undefined) return undefined;
  if (this.isKeyType(key)) return key;
  if (Debug) Util.trace('FromKey value for link data ' + linkdata + ' is not a number or a string: ' + key);
  return undefined;
};

GraphLinksModel.prototype['setFromKeyForLinkData'] =
/**
* Change the node key that the given link data references as the
* source of the link.
* @this {GraphLinksModel}
* @param {Object} linkdata a JavaScript object representing a link.
* @param {number|string|undefined} key This may be undefined if
* the link should no longer come from any node.
* @see #linkFromKeyProperty
* @see #getFromKeyForLinkData
*/
GraphLinksModel.prototype.setFromKeyForLinkData = function(linkdata, key) {
  if (key === null) key = undefined;
  if (key !== undefined && !this.isKeyType(key)) {
    Util.throwTypeError(key, 'number or string', GraphLinksModel, 'setFromKeyForLinkData:key');
  }
  if (linkdata === null) return;
  var kname = this._linkFromKeyProperty;
  if (kname === '') return;
  key = this.maybeEnsureLinkReference(key);
  if (!this.containsLinkData(linkdata)) {
    Util.safePropertySet(linkdata, kname, key);
    return;
  }
  var old = Util.safePropertyValue(linkdata, kname);
  if (old !== key) {
    this.forgetDelayedReference(old, linkdata);
    Util.safePropertySet(linkdata, kname, key);
    if (this.findNodeDataForKey(key) === null) {
      this.delayReference(key, linkdata);
    }
    this.raiseModelChangedEvent('linkFromKey', ChangedEvent.Property, kname, linkdata, old, key);
    if (typeof kname === 'string') this.updateTargetBindings(linkdata, kname);
  }
};
/**
* @ignore
* This is only defined to avoid a warning in the Closure compiler.
* @param linkdata
* @param key
* @this {GraphLinksModel}
*/
GraphLinksModel.prototype.setFromKeyForLinkData2 = function(linkdata, key) {
  this.setFromKeyForLinkData(linkdata, key);
};

/**
* Gets or sets the name of the data property that returns
* the key of the node data that the link data is going to,
* or a function that takes a link data object and returns that key;
* the default value is the name 'to'.
* The name must not be null.
* If the value is an empty string,
* {@link #getToKeyForLinkData} will return undefined for all link data objects.
* @name GraphLinksModel#linkToKeyProperty
* @function.
* @return {string|function(Object):(string|number)}
* @see #getToKeyForLinkData
* @see #setToKeyForLinkData
*/
/** @type {string|function(Object):(string|number)} */
GraphLinksModel.prototype.linkToKeyProperty;
Util.exportProperty(GraphLinksModel, 'linkToKeyProperty', GraphLinksModel.prototype.linkToKeyProperty);
Util.defineProperty(GraphLinksModel, {linkToKeyProperty: 'linkToKeyProperty'},
  /** @this {GraphLinksModel} */
  function() { return this._linkToKeyProperty; },
  /** @this {GraphLinksModel} */
  function(val) {
    var old = this._linkToKeyProperty;
    if (old !== val) {
      this.checkStringOrFunction(val, GraphLinksModel, 'linkToKeyProperty');
      this._linkToKeyProperty = val;
      this.raiseChanged('linkToKeyProperty', old, val);
    }
  }
);

GraphLinksModel.prototype['getToKeyForLinkData'] =
/**
* From a link data retrieve a value uniquely identifying the node data
* to which this link is connected.
* @this {GraphLinksModel}
* @param {Object} linkdata a JavaScript object representing a link.
* @return {number|string|undefined}  This may return undefined if
* the link is not going to any node.
* @see #linkToKeyProperty
* @see #setToKeyForLinkData
*/
GraphLinksModel.prototype.getToKeyForLinkData = function(linkdata) {
  if (linkdata === null) return undefined;
  var kname = this._linkToKeyProperty;
  if (kname === '') return undefined;
  var key = Util.safePropertyValue(linkdata, kname);
  if (key === undefined) return undefined;
  if (this.isKeyType(key)) return key;
  if (Debug) Util.trace('ToKey value for link data ' + linkdata + ' is not a number or a string: ' + key);
  return undefined;
};

GraphLinksModel.prototype['setToKeyForLinkData'] =
/**
* Change the node key that the given link data references as the
* destination of the link.
* @this {GraphLinksModel}
* @param {Object} linkdata a JavaScript object representing a link.
* @param {number|string|undefined} key This may be undefined if
* the link should no longer go to any node.
* @see #linkToKeyProperty
* @see #getToKeyForLinkData
*/
GraphLinksModel.prototype.setToKeyForLinkData = function(linkdata, key) {
  if (key === null) key = undefined;
  if (key !== undefined && !this.isKeyType(key)) {
    Util.throwTypeError(key, 'number or string', GraphLinksModel, 'setToKeyForLinkData:key');
  }
  if (linkdata === null) return;
  var kname = this._linkToKeyProperty;
  if (kname === '') return;
  key = this.maybeEnsureLinkReference(key);
  if (!this.containsLinkData(linkdata)) {
    Util.safePropertySet(linkdata, kname, key);
    return;
  }
  var old = Util.safePropertyValue(linkdata, kname);
  if (old !== key) {
    this.forgetDelayedReference(old, linkdata);
    Util.safePropertySet(linkdata, kname, key);
    if (this.findNodeDataForKey(key) === null) {
      this.delayReference(key, linkdata);
    }
    this.raiseModelChangedEvent('linkToKey', ChangedEvent.Property, kname, linkdata, old, key);
    if (typeof kname === 'string') this.updateTargetBindings(linkdata, kname);
  }
};
/**
* @ignore
* This is only defined to avoid a warning in the Closure compiler.
* @param linkdata
* @param key
* @this {GraphLinksModel}
*/
GraphLinksModel.prototype.setToKeyForLinkData2 = function(linkdata, key) {
  this.setToKeyForLinkData(linkdata, key);
};


/**
* Gets or sets the name of the data property that returns
* the optional parameter naming a "port" element on the node that the link data is connected from,
* or a function that takes a link data object and returns that string.
* The default value is the empty string indicating that one cannot distinguish
* different logical connection points for any links.
* The name must not be null.
* If the value is an empty string,
* {@link #getFromPortIdForLinkData} will return an empty string for all link data objects.
* @name GraphLinksModel#linkFromPortIdProperty
* @function.
* @return {string|function(Object):string}
* @see #getFromPortIdForLinkData
* @see #setFromPortIdForLinkData
*/
/** @type {string|function(Object):string} */
GraphLinksModel.prototype.linkFromPortIdProperty;
Util.exportProperty(GraphLinksModel, 'linkFromPortIdProperty', GraphLinksModel.prototype.linkFromPortIdProperty);
Util.defineProperty(GraphLinksModel, {linkFromPortIdProperty: 'linkFromPortIdProperty'},
  /** @this {GraphLinksModel} */
  function() { return this._linkFromPortIdProperty; },
  /** @this {GraphLinksModel} */
  function(val) {
    var old = this._linkFromPortIdProperty;
    if (old !== val) {
      this.checkStringOrFunction(val, GraphLinksModel, 'linkFromPortIdProperty');
      this._linkFromPortIdProperty = val;
      this.raiseChanged('linkFromPortIdProperty', old, val);
    }
  }
);

GraphLinksModel.prototype['getFromPortIdForLinkData'] =
/**
* From a link data retrieve a value identifying the port object of the node
* from which this link is connected.
* @this {GraphLinksModel}
* @param {Object} linkdata a JavaScript object representing a link.
* @return {string}  This may return the empty string if
* there is no particular port parameter information.
* @see #linkFromPortIdProperty
* @see #setFromPortIdForLinkData
*/
GraphLinksModel.prototype.getFromPortIdForLinkData = function(linkdata) {
  if (linkdata === null) return '';
  var pname = this._linkFromPortIdProperty;
  if (pname === '') return '';  // not using PortId
  var id = Util.safePropertyValue(linkdata, pname);
  if (id === undefined) return '';
  return id;
};

GraphLinksModel.prototype['setFromPortIdForLinkData'] =
/**
* Change the information that the given link data uses to identify the
* particular "port" that the link is coming from.
* @this {GraphLinksModel}
* @param {Object} linkdata a JavaScript object representing a link.
* @param {string} portname This may be the empty string if
* the link should no longer be associated with any particular "port".
* @see #linkFromPortIdProperty
* @see #getFromPortIdForLinkData
*/
GraphLinksModel.prototype.setFromPortIdForLinkData = function(linkdata, portname) {
  Util.checkPrimitive(portname, 'string', GraphLinksModel, 'setFromPortIdForLinkData:portname');
  if (linkdata === null) return;
  var pname = this._linkFromPortIdProperty;
  if (pname === '') return;  // not using PortId
  if (!this.containsLinkData(linkdata)) {
    Util.safePropertySet(linkdata, pname, portname);
    return;
  }
  var old = Util.safePropertyValue(linkdata, pname);
  if (old === undefined) old = '';
  if (old !== portname) {
    Util.safePropertySet(linkdata, pname, portname);
    this.raiseModelChangedEvent('linkFromPortId', ChangedEvent.Property, pname, linkdata, old, portname);
    if (typeof pname === 'string') this.updateTargetBindings(linkdata, pname);
  }
};
/**
* @ignore
* This is only defined to avoid a warning in the Closure compiler.
* @param linkdata
* @param portname
* @this {GraphLinksModel}
*/
GraphLinksModel.prototype.setFromPortIdForLinkData2 = function(linkdata, portname) {
  this.setFromPortIdForLinkData(linkdata, portname);
};

/**
* Gets or sets the name of the data property that returns
* the optional parameter naming a "port" element on the node that the link data is connected to,
* or a function that takes a link data object and returns that string.
* The default value is the empty string indicating that one cannot distinguish
* different logical connection points for any links.
* The name must not be null.
* If the value is an empty string,
* {@link #getToPortIdForLinkData} will return an empty string for all link data objects.
* @name GraphLinksModel#linkToPortIdProperty
* @function.
* @return {string|function(Object):string}
* @see #getToPortIdForLinkData
* @see #setToPortIdForLinkData
*/
/** @type {string|function(Object):string} */
GraphLinksModel.prototype.linkToPortIdProperty;
Util.exportProperty(GraphLinksModel, 'linkToPortIdProperty', GraphLinksModel.prototype.linkToPortIdProperty);
Util.defineProperty(GraphLinksModel, {linkToPortIdProperty: 'linkToPortIdProperty'},
  /** @this {GraphLinksModel} */
  function() { return this._linkToPortIdProperty; },
  /** @this {GraphLinksModel} */
  function(val) {
    var old = this._linkToPortIdProperty;
    if (old !== val) {
      this.checkStringOrFunction(val, GraphLinksModel, 'linkToPortIdProperty');
      this._linkToPortIdProperty = val;
      this.raiseChanged('linkToPortIdProperty', old, val);
    }
  }
);

GraphLinksModel.prototype['getToPortIdForLinkData'] =
/**
* From a link data retrieve a value identifying the port object of the node
* to which this link is connected.
* @this {GraphLinksModel}
* @param {Object} linkdata a JavaScript object representing a link.
* @return {string}  This may return the empty string if
* there is no particular port parameter information.
* @see #linkToPortIdProperty
* @see #setToPortIdForLinkData
*/
GraphLinksModel.prototype.getToPortIdForLinkData = function(linkdata) {
  if (linkdata === null) return '';
  var pname = this._linkToPortIdProperty;
  if (pname === '') return '';  // not using PortId
  var id = Util.safePropertyValue(linkdata, pname);
  if (id === undefined) return '';
  return id;
};

GraphLinksModel.prototype['setToPortIdForLinkData'] =
/**
* Change the information that the given link data uses to identify the
* particular "port" that the link is going to.
* @this {GraphLinksModel}
* @param {Object} linkdata a JavaScript object representing a link.
* @param {string} portname This may be the empty string if
* the link should no longer be associated with any particular "port".
* @see #linkToPortIdProperty
* @see #getToPortIdForLinkData
*/
GraphLinksModel.prototype.setToPortIdForLinkData = function(linkdata, portname) {
  Util.checkPrimitive(portname, 'string', GraphLinksModel, 'setToPortIdForLinkData:portname');
  if (linkdata === null) return;
  var pname = this._linkToPortIdProperty;
  if (pname === '') return;  // not using PortId
  if (!this.containsLinkData(linkdata)) {
    Util.safePropertySet(linkdata, pname, portname);
    return;
  }
  var old = Util.safePropertyValue(linkdata, pname);
  if (old === undefined) old = '';
  if (old !== portname) {
    Util.safePropertySet(linkdata, pname, portname);
    this.raiseModelChangedEvent('linkToPortId', ChangedEvent.Property, pname, linkdata, old, portname);
    if (typeof pname === 'string') this.updateTargetBindings(linkdata, pname);
  }
};
/**
* @ignore
* This is only defined to avoid a warning in the Closure compiler.
* @param linkdata
* @param portname
* @this {GraphLinksModel}
*/
GraphLinksModel.prototype.setToPortIdForLinkData2 = function(linkdata, portname) {
  this.setToPortIdForLinkData(linkdata, portname);
};


/**
* Gets or sets the name of the boolean property on node data that indicates
* whether the data should be represented as a node acting as a label on a link
* instead of being a regular node,
* or a function that takes a node data object and returns true or false;
* the default value is the empty string: ''.
* The name must not be null.
* <p/>
* If the value is an empty string,
* {@link #isLinkLabelForNodeData} will return false for all node data objects.
* @name GraphLinksModel#nodeIsLinkLabelProperty
* @function.
* @return {string|function(Object):boolean}
*/
/** @type {string|function(Object):boolean} */
GraphLinksModel.prototype.nodeIsLinkLabelProperty;
Util.exportProperty(GraphLinksModel, 'nodeIsLinkLabelProperty', GraphLinksModel.prototype.nodeIsLinkLabelProperty);
Util.defineProperty(GraphLinksModel, {nodeIsLinkLabelProperty: 'nodeIsLinkLabelProperty'},
  /** @this {GraphLinksModel} */
  function() { return this._nodeIsLinkLabelProperty; },
  /** @this {GraphLinksModel} */
  function(val) {
    var old = this._nodeIsLinkLabelProperty;
    if (old !== val) {
      this.checkStringOrFunction(val, GraphLinksModel, 'nodeIsLinkLabelProperty');
      this._nodeIsLinkLabelProperty = val;
      this.raiseChanged('nodeIsLinkLabelProperty', old, val);
    }
  }
);

GraphLinksModel.prototype['isLinkLabelForNodeData'] =
/**
* See if the given node data should act as a label on a link, in order to support
* the appearance and behavior of having links connected to links.
* <p/>
* This value must not change as long as the node data is part of the model.
* At the current time there is no <code>setIsLinkLabelForNodeData</code> method.
* @this {GraphLinksModel}
* @param {Object} nodedata a JavaScript object representing a node, group, or non-link.
* @return {boolean}  If the property was not present, this defaults to false.
* @see #nodeIsLinkLabelProperty
*/
GraphLinksModel.prototype.isLinkLabelForNodeData = function(nodedata) {
  if (nodedata === null) return false;
  var lname = this._nodeIsLinkLabelProperty;
  if (lname === '') return false;
  if (Util.safePropertyValue(nodedata, lname)) return true;
  return false;
};

//?? setIsLinkLabelForNodeData

/**
* Gets or sets the name of the data property that returns
* an array of keys of node data that are labels on that link data,
* or a function that takes a link data object and returns such an array;
* the default value is the empty string: ''.
* <p/>
* The name must not be null.
* If the value is an empty string,
* {@link #getLabelKeysForLinkData} will return an empty array for all link data objects.
* You will need to set this property in order to support nodes as link labels.
* @name GraphLinksModel#linkLabelKeysProperty
* @function.
* @return {string|function(Object):Array.<(string|number)>}
* @see #getLabelKeysForLinkData
* @see #setLabelKeysForLinkData
*/
/** @type {string|function(Object):Array.<(string|number)>} */
GraphLinksModel.prototype.linkLabelKeysProperty;
Util.exportProperty(GraphLinksModel, 'linkLabelKeysProperty', GraphLinksModel.prototype.linkLabelKeysProperty);
Util.defineProperty(GraphLinksModel, {linkLabelKeysProperty: 'linkLabelKeysProperty'},
  /** @this {GraphLinksModel} */
  function() { return this._linkLabelKeysProperty; },
  /** @this {GraphLinksModel} */
  function(val) {
    var old = this._linkLabelKeysProperty;
    if (old !== val) {
      this.checkStringOrFunction(val, GraphLinksModel, 'linkLabelKeysProperty');
      this._linkLabelKeysProperty = val;
      this.raiseChanged('linkLabelKeysProperty', old, val);
    }
  }
);

GraphLinksModel.prototype['getLabelKeysForLinkData'] =
/**
* Gets an Array of node key values that identify node data acting as labels on the given link data.
* <p/>
* This method only works if {@link #linkLabelKeysProperty} has been set to something other than an empty string.
* @this {GraphLinksModel}
* @param {Object} linkdata a JavaScript object representing a link.
* @return {Array} an Array of node keys; an empty Array if the property was not present.
* @see #linkLabelKeysProperty
* @see #setLabelKeysForLinkData
* @see #addLabelKeyForLinkData
* @see #removeLabelKeyForLinkData
*/
GraphLinksModel.prototype.getLabelKeysForLinkData = function(linkdata) {
  if (linkdata === null) return Util.EmptyArray;  // this is a constant, frozen JavaScript Array
  var kname = this._linkLabelKeysProperty;
  if (kname === '') return Util.EmptyArray;  // not using label nodes
  var keys = Util.safePropertyValue(linkdata, kname);
  if (keys === undefined) return Util.EmptyArray;
  return keys;
};

GraphLinksModel.prototype['setLabelKeysForLinkData'] =
/**
* Replaces an Array of node key values that identify node data acting as labels on the given link data.
* <p/>
* This method only works if {@link #linkLabelKeysProperty} has been set to something other than an empty string.
* @this {GraphLinksModel}
* @param {Object} linkdata a JavaScript object representing a link.
* @param arr an Array of node keys; an empty Array if the property was not present.
* @see #linkLabelKeysProperty
* @see #getLabelKeysForLinkData
* @see #addLabelKeyForLinkData
* @see #removeLabelKeyForLinkData
*/
GraphLinksModel.prototype.setLabelKeysForLinkData = function(linkdata, arr) {
  Util.checkArray(arr, GraphLinksModel, 'setLabelKeysForLinkData:arr');
  if (linkdata === null) return;
  var kname = this._linkLabelKeysProperty;
  if (kname === '') return;  // not using label nodes
  if (!this.containsLinkData(linkdata)) {
    Util.safePropertySet(linkdata, kname, arr);
    return;
  }
  var old = Util.safePropertyValue(linkdata, kname);
  if (old === undefined) old = Util.EmptyArray;
  if (old !== arr) {
    var oldlen = Util.arrayLength(old);
    for (var i = 0; i < oldlen; i++) {
      var key = Util.arrayElt(old, i);
      this.forgetDelayedReference(key, linkdata);
    }
    Util.safePropertySet(linkdata, kname, arr);
    var newlen = Util.arrayLength(arr);
    for (var i = 0; i < newlen; i++) {
      var key = Util.arrayElt(arr, i);
      if (this.findNodeDataForKey(key) === null) {
        this.delayReference(key, linkdata);
      }
    }
    this.raiseModelChangedEvent('linkLabelKeys', ChangedEvent.Property, kname, linkdata, old, arr);
    if (typeof kname === 'string') this.updateTargetBindings(linkdata, kname);
  }
};
/**
* @ignore
* This is only defined to avoid a warning in the Closure compiler.
* @param linkdata
* @param arr
* @this {GraphLinksModel}
*/
GraphLinksModel.prototype.setLabelKeysForLinkData2 = function(linkdata, arr) {
  this.setLabelKeysForLinkData(linkdata, arr);
};

GraphLinksModel.prototype['addLabelKeyForLinkData'] =
/**
* Adds a node key value that identifies a node data acting as a new label node on the given link data.
* <p/>
* This method only works if {@link #linkLabelKeysProperty} has been set to something other than an empty string.
* @this {GraphLinksModel}
* @param {Object} linkdata a JavaScript object representing a link.
* @param {number|string} key a number or string that is the key of the new label node.
* @see #removeLabelKeyForLinkData
* @see #setLabelKeysForLinkData
*/
GraphLinksModel.prototype.addLabelKeyForLinkData = function(linkdata, key) {
  if (key === null || key === undefined) return;  // no-op
  if (!this.isKeyType(key)) {
    Util.throwTypeError(key, 'number or string', GraphLinksModel, 'addLabelKeyForLinkData:key');
  }
  if (linkdata === null) return;
  var kname = this._linkLabelKeysProperty;
  if (kname === '') return;  // not using label nodes
  var keys = Util.safePropertyValue(linkdata, kname);
  if (keys === undefined) {
    this.setLabelKeysForLinkData(linkdata, [key]);
  } else if (Util.isArray(keys)) {
    // already there?
    var idx = Util.arrayIndexOf(keys, key);
    if (idx >= 0) return;
    // modify Array
    Util.arrayInsertAt(keys, Infinity, key);
    if (this.containsLinkData(linkdata)) {
      // handle any references
      if (this.findNodeDataForKey(key) === null) {
        this.delayReference(key, linkdata);
      }
      // notify
      this.raiseModelChangedEvent('linkLabelKeys', ChangedEvent.Insert, kname, linkdata, null, key);
    }
  } else {
    Util.throwError(kname + ' property is not an Array; cannot addLabelKeyForLinkData: ' + linkdata);
  }
};

GraphLinksModel.prototype['removeLabelKeyForLinkData'] =
/**
* Removes a node key value that identifies a node data acting as a former label node on the given link data.
* <p/>
* Removing a reference to a node data from the collection of link label keys
* does not automatically remove any node data from the model.
* <p/>
* This method only works if {@link #linkLabelKeysProperty} has been set to something other than an empty string.
* @this {GraphLinksModel}
* @param {Object} linkdata a JavaScript object representing a link.
* @param {number|string} key a number or string that is the key of the label node being removed from the link.
* @see #addLabelKeyForLinkData
* @see #setLabelKeysForLinkData
*/
GraphLinksModel.prototype.removeLabelKeyForLinkData = function(linkdata, key) {
  if (key === null || key === undefined) return;  // no-op
  if (!this.isKeyType(key)) {
    Util.throwTypeError(key, 'number or string', GraphLinksModel, 'removeLabelKeyForLinkData:key');
  }
  if (linkdata === null) return;
  var kname = this._linkLabelKeysProperty;
  if (kname === '') return;  // not using label nodes
  var keys = Util.safePropertyValue(linkdata, kname);
  if (Util.isArray(keys)) {
    // not there?
    var idx = Util.arrayIndexOf(keys, key);
    if (idx < 0) return;
    // modify Array
    Util.arrayRemoveAt(keys, idx);
    if (this.containsLinkData(linkdata)) {
      // handle any references
      this.forgetDelayedReference(key, linkdata);
      // notify
      this.raiseModelChangedEvent('linkLabelKeys', ChangedEvent.Remove, kname, linkdata, key, null);
    }
  } else if (keys !== undefined) {
    Util.throwError(kname + ' property is not an Array; cannot removeLabelKeyforLinkData: ' + linkdata);
  }
};


// Link data

/**
* Gets or sets the array of link data objects that correspond to {@link Link}s in the {@link Diagram}.
* @name GraphLinksModel#linkDataArray
* @function.
* @return {Array.&lt;Object&gt;}
*/
/** @type {Array.<Object>} */
GraphLinksModel.prototype.linkDataArray;
Util.exportProperty(GraphLinksModel, 'linkDataArray', GraphLinksModel.prototype.linkDataArray);
Util.defineProperty(GraphLinksModel, { linkDataArray: 'linkDataArray' },
  /** @this {GraphLinksModel} */
  function() { return this._linkDataArray; },
  /** @this {GraphLinksModel} */
  function(val) {
    var old = this._linkDataArray;
    if (old !== val) {
      Util.checkArray(val, GraphLinksModel, 'linkDataArray');

      // Blindly assign unique numbers as keys for each link data.
      // The actual key values are needed for hashing in Diagram.
      var len = Util.arrayLength(val);
      for (var i = 0; i < len; i++) {
        var data = Util.arrayElt(val, i);
        if (!Util.isObject(data)) {
          Util.throwError('GraphLinksModel.linkDataArray must only contain Objects, not: ' + data);
          return;
        }
        Util.hashIdUnique(data);
      }

      this._linkDataArray = val;

      // also keep all link data in a Set for quicker implementation of containsLinkData
      var alllinks = new Set(Object);
      for (var i = 0; i < len; i++) {
        var data = Util.arrayElt(val, i);
        alllinks.add(data);
      }
      this._linkDataSet = alllinks;  // this also discards the old Set

      // Notify about the property change
      this.raiseModelChangedEvent('linkDataArray', ChangedEvent.Property, 'linkDataArray', this, old, val);

      // maybe delay references
      for (var i = 0; i < len; i++) {
        var data = Util.arrayElt(val, i);
        this.resolveReferencesInLinkData(data);
      }
    }
  }
);

GraphLinksModel.prototype['containsLinkData'] =
/**
* Decide if a given link data is in this model.
* @this {GraphLinksModel}
* @param {Object} linkdata a JavaScript object representing a link.
* @return {boolean}
* @see #addLinkData
* @see #removeLinkData
*/
GraphLinksModel.prototype.containsLinkData = function(linkdata) {
  if (linkdata === null) return false;
  return this._linkDataSet.contains(linkdata);
};

GraphLinksModel.prototype['addLinkData'] =
/**
* When you want to add a link to the diagram, call this method with a new data object.
* This will add that data to the {@link #linkDataArray} and
* notify all listeners that a new link data object has been inserted into the collection.
* <p/>
* Presumably the link data object will already have its "from" and "to" node key references set,
* but it is also possible to set them after the link data is in the model
* by calling {@link #setFromKeyForLinkData} and {@link #setToKeyForLinkData}.
* <p/>
* This operation does nothing if the link data is already part of this model's {@link #linkDataArray}.
* @this {GraphLinksModel}
* @param {Object} linkdata a JavaScript object representing a link.
* @see #removeLinkData
*/
GraphLinksModel.prototype.addLinkData = function(linkdata) {
  if (linkdata === null) return;
  // see if already present
  if (Util.hashId(linkdata) === undefined) {
    Util.uniqueHash(linkdata);
  } else if (this.containsLinkData(linkdata)) {
    return;
  }
  this._linkDataSet.add(linkdata);
  // modify linkDataArray
  var idx = Util.arrayLength(this._linkDataArray);
  Util.arrayInsertAt(this._linkDataArray, idx, linkdata);
  // notify
  this.raiseModelChangedEvent('linkDataArray', ChangedEvent.Insert, 'linkDataArray', this, null, linkdata, null, idx);
  // maybe delay some references
  this.resolveReferencesInLinkData(linkdata);
};

GraphLinksModel.prototype['removeLinkData'] =
/**
* When you want to remove a link from the diagram, call this method with an existing link data object.
* This will remove that data from the {@link #linkDataArray} and
* notify all listeners that a link data object has been removed from the collection.
* <p/>
* Removing a link data from a model does not automatically remove
* any associated label node data from the model.
* <p/>
* This operation does nothing if the link data is not present in the {@link #linkDataArray}.
* @this {GraphLinksModel}
* @param {Object} linkdata a JavaScript object representing a link.
* @see #addLinkData
*/
GraphLinksModel.prototype.removeLinkData = function(linkdata) {
  if (linkdata === null) return;
  this._linkDataSet.remove(linkdata);
  // see if already removed
  var idx = this._linkDataArray.indexOf(linkdata);
  if (idx < 0) return;
  // modify linkDataArray
  Util.arrayRemoveAt(this._linkDataArray, idx);
  // notify
  this.raiseModelChangedEvent('linkDataArray', ChangedEvent.Remove, 'linkDataArray', this, linkdata, null, idx, null);
  // maybe forget some delayed references
  this.unresolveReferencesInLinkData(linkdata);
};

/**
* @ignore
* @this {GraphLinksModel}
* @param {Object} data
*/
GraphLinksModel.prototype.resolveReferencesInLinkData = function(data) {
  var key = this.getFromKeyForLinkData(data);
  key = this.maybeEnsureLinkReference(key);
  if (this.findNodeDataForKey(key) === null) {
    this.delayReference(key, data);
  }
  key = this.getToKeyForLinkData(data);
  key = this.maybeEnsureLinkReference(key);
  if (this.findNodeDataForKey(key) === null) {
    this.delayReference(key, data);
  }
  var keyarray = this.getLabelKeysForLinkData(data);
  var len = Util.arrayLength(keyarray);
  for (var j = 0; j < len; j++) {
    key = Util.arrayElt(keyarray, j);
    if (this.findNodeDataForKey(key) === null) {
      this.delayReference(key, data);
    }
  }
};

/**
* @ignore
* @this {GraphLinksModel}
* @param {Object} data
*/
GraphLinksModel.prototype.unresolveReferencesInLinkData = function(data) {
  var key = this.getFromKeyForLinkData(data);
  this.forgetDelayedReference(key, data);
  key = this.getToKeyForLinkData(data);
  this.forgetDelayedReference(key, data);
  var keyarray = this.getLabelKeysForLinkData(data);
  var len = Util.arrayLength(keyarray);
  for (var j = 0; j < len; j++) {
    key = Util.arrayElt(keyarray, j);
    this.forgetDelayedReference(key, data);
  }
};


/**
* Gets or sets a function that makes a copy of a link data object.
* <p/>
* You may need to set this property in order to ensure that a copied {@link Link} is bound
* to data that does not share certain data structures between the original link data and the copied link data.
* The value may be null in order to cause {@link #copyLinkData} to make a shallow copy of a JavaScript Object.
* The default value is null.
* @name GraphLinksModel#copyLinkDataFunction
* @function.
* @return {function(Object, GraphLinksModel):Object | null}
*/
/** @type {function(Object, GraphLinksModel):Object | null} */
GraphLinksModel.prototype.copyLinkDataFunction;
Util.exportProperty(GraphLinksModel, 'copyLinkDataFunction', GraphLinksModel.prototype.copyLinkDataFunction);
Util.defineProperty(GraphLinksModel, { copyLinkDataFunction: 'copyLinkDataFunction' },
  /** @this {Model} */
  function() { return this._copyLinkDataFunction; },
  /** @this {Model} */
  function(val) {
    var old = this._copyLinkDataFunction;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', GraphLinksModel, 'copyLinkDataFunction');
      this._copyLinkDataFunction = val;
      this.raiseChanged('copyLinkDataFunction', old, val);
    }
  }
);

GraphLinksModel.prototype['copyLinkData'] =
/**
* Make a copy of a link data object.
* This uses the value of {@link #copyLinkDataFunction} to actually perform the copy,
* unless it is null, in which case this method just makes a shallow copy of the JavaScript Object.
* <p/>
* This does not modify the model -- the returned data object is not added to this model.
* This assumes that the data's constructor can be called with no arguments.
* This also makes sure there is no reference to either the "from" or the "to" node of the original data.
* @this {GraphLinksModel}
* @param {Object} linkdata a JavaScript object representing a link.
* @return {Object}
* @see #addLinkData
*/
GraphLinksModel.prototype.copyLinkData = function(linkdata) {
  if (linkdata === null) return null;
  var copy = null;
  // try a programmer-supplied function for copying the data
  var func = this._copyLinkDataFunction;
  if (func !== null) {
    copy = func(linkdata, this);
  } else {
    copy = new linkdata.constructor;
    for (var k in linkdata) {
      Util.safePropertySet(copy, k, Util.safePropertyValue(linkdata, k));
    }
  }
  if (copy) {
    Util.uniqueHash(copy);
    if (this._linkFromKeyProperty !== '') {
      Util.safePropertySet(copy, this._linkFromKeyProperty, undefined);
    }
    if (this._linkToKeyProperty !== '') {
      Util.safePropertySet(copy, this._linkToKeyProperty, undefined);
    }
    // cannot share label keys array
    if (this._linkLabelKeysProperty !== '') {
      Util.safePropertySet(copy, this._linkLabelKeysProperty, []);
    }
  }
  return copy;
};


/**
* Gets or sets the name of the boolean property on node data that indicates
* whether the data should be represented as a group of nodes and links or
* as a simple node,
* or a function that takes a node data object and returns true or false;
* the default value is the name 'isGroup'.
* <p/>
* The value must not be null.
* If the value is an empty string,
* {@link #isGroupForNodeData} will return false for all node data objects.
* @name GraphLinksModel#nodeIsGroupProperty
* @function.
* @return {string|function(Object):boolean}
*/
/** @type {string|function(Object):boolean} */
GraphLinksModel.prototype.nodeIsGroupProperty;
Util.exportProperty(GraphLinksModel, 'nodeIsGroupProperty', GraphLinksModel.prototype.nodeIsGroupProperty);
Util.defineProperty(GraphLinksModel, {nodeIsGroupProperty: 'nodeIsGroupProperty'},
  /** @this {GraphLinksModel} */
  function() { return this._nodeIsGroupProperty; },
  /** @this {GraphLinksModel} */
  function(val) {
    var old = this._nodeIsGroupProperty;
    if (old !== val) {
      this.checkStringOrFunction(val, GraphLinksModel, 'nodeIsGroupProperty');
      this._nodeIsGroupProperty = val;
      this.raiseChanged('nodeIsGroupProperty', old, val);
    }
  }
);

GraphLinksModel.prototype['isGroupForNodeData'] =
/**
* See if the given node data should be represented as a group or as a simple node.
* <p/>
* This value must not change as long as the node data is part of the model.
* At the current time there is no <code>setIsGroupForNodeData</code> method.
* @this {GraphLinksModel}
* @param {Object} nodedata a JavaScript object representing a node, group, or non-link.
* @return {boolean}
* @see #nodeIsGroupProperty
*/
GraphLinksModel.prototype.isGroupForNodeData = function(nodedata) {
  if (nodedata === null) return false;
  var gname = this._nodeIsGroupProperty;
  if (gname === '') return false;
  if (Util.safePropertyValue(nodedata, gname)) return true;
  return false;
};

//?? setIsGroupForNodeData

/**
* Gets or sets the name of the property on node data that specifies
* the string or number key of the group data that "owns" that node data,
* or a function that takes a node data object and returns that group key.
* the default value is the name 'group'.
* <p/>
* The value must not be null.
* If the value is an empty string,
* {@link #getGroupKeyForNodeData} will return undefined for all node data objects.
* @name GraphLinksModel#nodeGroupKeyProperty
* @function.
* @return {string|function(Object):(string|number)}
* @see #getGroupKeyForNodeData
* @see #setGroupKeyForNodeData
*/
/** @type {string|function(Object):(string|number)} */
GraphLinksModel.prototype.nodeGroupKeyProperty;
Util.exportProperty(GraphLinksModel, 'nodeGroupKeyProperty', GraphLinksModel.prototype.nodeGroupKeyProperty);
Util.defineProperty(GraphLinksModel, {nodeGroupKeyProperty: 'nodeGroupKeyProperty'},
  /** @this {GraphLinksModel} */
  function() { return this._nodeGroupKeyProperty; },
  /** @this {GraphLinksModel} */
  function(val) {
    var old = this._nodeGroupKeyProperty;
    if (old !== val) {
      this.checkStringOrFunction(val, GraphLinksModel, 'nodeGroupKeyProperty');
      this._nodeGroupKeyProperty = val;
      this.raiseChanged('nodeGroupKeyProperty', old, val);
    }
  }
);

GraphLinksModel.prototype['getGroupKeyForNodeData'] =
/**
* If there is a container group for the given node data, return the group's key.
* @this {GraphLinksModel}
* @param {Object} nodedata a JavaScript object representing a node, group, or non-link.
* @return {number|string|undefined}  This returns undefined if there is no containing group data.
* @see #nodeGroupKeyProperty
* @see #setGroupKeyForNodeData
*/
GraphLinksModel.prototype.getGroupKeyForNodeData = function(nodedata) {
  if (nodedata === null) return undefined;
  var kname = this._nodeGroupKeyProperty;
  if (kname === '') return undefined;
  var key = Util.safePropertyValue(nodedata, kname);
  if (key === undefined) return undefined;
  if (this.isKeyType(key)) return key;
  if (Debug) Util.trace('GroupKey value for node data ' + nodedata + ' is not a number or a string: ' + key);
  return undefined;
};

GraphLinksModel.prototype['setGroupKeyForNodeData'] =
/**
* Change the container group for the given node data, given a key for the new group.
* @this {GraphLinksModel}
* @param {Object} nodedata a JavaScript object representing a node, group, or non-link.
* @param {number|string|undefined} key This may be undefined if there should be no containing group data.
* @see #nodeGroupKeyProperty
* @see #getGroupKeyForNodeData
*/
GraphLinksModel.prototype.setGroupKeyForNodeData = function(nodedata, key) {
  if (key === null) key = undefined;
  if (key !== undefined && !this.isKeyType(key)) {
    Util.throwTypeError(key, 'number or string', GraphLinksModel, 'setGroupKeyForNodeData:key');
  }
  if (nodedata === null) return;
  var kname = this._nodeGroupKeyProperty;
  if (kname === '') return;
  if (!this.containsNodeData(nodedata)) {
    Util.safePropertySet(nodedata, kname, key);
    return;
  }
  var old = Util.safePropertyValue(nodedata, kname);
  if (old !== key) {
    this.forgetDelayedReference(old, nodedata);
    Util.safePropertySet(nodedata, kname, key);
    if (this.findNodeDataForKey(key) === null) {
      this.delayReference(key, nodedata);
    }
    this.raiseModelChangedEvent('nodeGroupKey', ChangedEvent.Property, kname, nodedata, old, key);
    if (typeof kname === 'string') this.updateTargetBindings(nodedata, kname);
  }
};
/**
* @ignore
* This is only defined to avoid a warning in the Closure compiler.
* @param nodedata
* @param key
* @this {GraphLinksModel}
*/
GraphLinksModel.prototype.setGroupKeyForNodeData2 = function(nodedata, key) {
  this.setGroupKeyForNodeData(nodedata, key);
};

GraphLinksModel.prototype['copyNodeData'] =
/**
* @ignore
* This override also makes sure any copied node data does not have a reference to the containing group.
* @this {GraphLinksModel}
* @param {Object} nodedata a JavaScript object representing a node, group, or non-link.
* @return {Object}
*/
GraphLinksModel.prototype.copyNodeData = function(nodedata) {
  if (nodedata === null) return null;
  var copy = Model.prototype.copyNodeData.call(this, nodedata);
  if (this._nodeGroupKeyProperty !== '') {
    Util.safePropertySet(copy, this._nodeGroupKeyProperty, undefined);
  }
  return copy;
};

GraphLinksModel.prototype['setDataProperty'] =
/**
* @ignore
* Change the value of some property of a node data, a link data, or an item data, given a string naming the property
* and the new value, in a manner that can be undone/redone and that automatically updates any bindings.
* This override handles link data as well as node data.
* <p/>
* This gets the old value of the property; if the value is the same as the new value, no side-effects occur.
* @this {GraphLinksModel}
* @param {Object} data a JavaScript object representing a Node, Link, Group, simple Part, or item in a {@link Panel#itemArray}.
* @param {string} propname a string that is not null or the empty string.
* @param {*} val the new value for the property.
*/
GraphLinksModel.prototype.setDataProperty = function(data, propname, val) {
  if (Debug) {
    Util.checkPrimitive(data, 'object', GraphLinksModel, 'setDataProperty:data');
    Util.checkPrimitive(propname, 'string', GraphLinksModel, 'setDataProperty:propname');
    if (propname === '') Util.throwError('GraphLinksModel.setDataProperty: property name must not be an empty string when setting ' + data + ' to ' + val);
  }
  if (this.containsNodeData(data)) {
    if (propname === this.nodeKeyProperty) {
      this.setKeyForNodeData2(data, val);
    } else if (propname === this.nodeCategoryProperty) {
      this.setCategoryForNodeData2(data, val);
      return;
    } else if (propname === this.nodeGroupKeyProperty) {
      this.setGroupKeyForNodeData2(data, val);
      return;
    } else if (propname === this.nodeIsGroupProperty) {
      Util.throwError('GraphLinksModel.setDataProperty: property name must not be the nodeIsGroupProperty: ' + propname);
    } else if (propname === this.nodeIsLinkLabelProperty) {
      Util.throwError('GraphLinksModel.setDataProperty: property name must not be the nodeIsLinkLabelProperty: ' + propname);
    }
  } else if (this.containsLinkData(data)) {
    if (propname === this.linkFromKeyProperty) {
      this.setFromKeyForLinkData2(data, val);
      return;
    } else if (propname === this.linkToKeyProperty) {
      this.setToKeyForLinkData2(data, val);
      return;
    } else if (propname === this.linkFromPortIdProperty) {
      this.setFromPortIdForLinkData2(data, val);
      return;
    } else if (propname === this.linkToPortIdProperty) {
      this.setToPortIdForLinkData2(data, val);
      return;
    } else if (propname === this.linkCategoryProperty) {
      this.setCategoryForLinkData2(data, val);
      return;
    } else if (propname === this.linkLabelKeysProperty) {
      this.setLabelKeysForLinkData2(data, val);
      return;
    }
  } else {
    if (!Util.warnedAboutModifyingGraphObject && data instanceof GraphObject) {
      Util.warnedAboutModifyingGraphObject = true;
      Util.trace('GraphLinksModel.setDataProperty is modifying a GraphObject, "' + data.toString() + '"');
      Util.trace('  Is that really your intent?');
    }
  }
  // set the property and raise a Property ChangedEvent with the old and new values
  var old = Util.safePropertyValue(data, propname);
  if (old !== val) {
    Util.safePropertySet(data, propname, val);
    this.raiseDataChanged(data, propname, old, val);
  }
};

//?? nodeMemberKeysName, getMemberKeysForNodeData, setMemberKeysForNodeData
//   addMemberKeyForNodeData, removeMemberKeyForNodeData

/**
* @ignore
* When a node data changes its key, we need to update all data references to that node data
* that are using the old key value by replacing them with the new key value.
* The goal is to maintain all of the original relationships in all of the data maintained by the model.
* @this {GraphLinksModel}
*/
GraphLinksModel.prototype.replaceAllKeyReferences = function(oldkey, newkey) {
  Model.prototype.replaceAllKeyReferences.call(this, oldkey, newkey);
  //?? this is very slow, but it might not be worth it to remember and maintain back-pointers
  var nit = this._mapKeyNodeData.iterator;
  while (nit.next()) {
    this.replaceKeyReferencesInNodeData(nit.value, oldkey, newkey);
  }
  var lit = this._linkDataSet.iterator;
  while (lit.next()) {
    this.replaceKeyReferencesInLinkData(lit.value, oldkey, newkey);
  }
};

/**
* @ignore
* When a node data changes its key, we need to update all data references to that node data
* that are using the old key value by replacing them with the new key value.
* @param {Object} d a node data object.
* @this {GraphLinksModel}
*/
GraphLinksModel.prototype.replaceKeyReferencesInNodeData = function(d, oldkey, newkey) {
  var gkey = this.getGroupKeyForNodeData(d);
  if (gkey === oldkey) {
    var kname = this._nodeGroupKeyProperty;
    Util.safePropertySet(d, kname, newkey);
    this.raiseModelChangedEvent('nodeGroupKey', ChangedEvent.Property, kname, d, oldkey, newkey);
    if (typeof kname === 'string') this.updateTargetBindings(d, kname);
  }
};

/**
* @ignore
* When a node data changes its key, we need to update all data references to that node data
* that are using the old key value by replacing them with the new key value.
* @param {Object} d a link data object.
* @this {GraphLinksModel}
*/
GraphLinksModel.prototype.replaceKeyReferencesInLinkData = function(d, oldkey, newkey) {
  var fkey = this.getFromKeyForLinkData(d);
  if (fkey === oldkey) {
    var kname = this._linkFromKeyProperty;
    Util.safePropertySet(d, kname, newkey);
    this.raiseModelChangedEvent('linkFromKey', ChangedEvent.Property, kname, d, oldkey, newkey);
    if (typeof kname === 'string') this.updateTargetBindings(d, kname);
  }
  var tkey = this.getToKeyForLinkData(d);
  if (tkey === oldkey) {
    var kname = this._linkToKeyProperty;
    Util.safePropertySet(d, kname, newkey);
    this.raiseModelChangedEvent('linkToKey', ChangedEvent.Property, kname, d, oldkey, newkey);
    if (typeof kname === 'string') this.updateTargetBindings(d, kname);
  }
  var lkeys = this.getLabelKeysForLinkData(d);
  var len = Util.arrayLength(lkeys);
  var kname = this._linkLabelKeysProperty;
  for (var j = 0; j < len; j++) {
    var lkey = Util.arrayElt(lkeys, j);
    if (lkey === oldkey) {
      Util.arraySetElt(lkeys, j, newkey);
      this.raiseModelChangedEvent('linkLabelKeys', ChangedEvent.Insert, kname, d, oldkey, newkey);
    }
  }
};

/**
* @ignore
* @this {GraphLinksModel}
*/
GraphLinksModel.prototype.unresolveAllReferencesToNodeData = function() {
  Model.prototype.unresolveAllReferencesToNodeData.call(this);
  var array = this.linkDataArray;
  var len = Util.arrayLength(array);
  for (var i = 0; i < len; i++) {
    var data = Util.arrayElt(array, i);
    this.resolveReferencesInLinkData(data);
  }
};

/**
* @ignore
* Overridden.
* @this {GraphLinksModel}
* @param {Object} nodedata
*/
GraphLinksModel.prototype.resolveReferencesToNodeData = function(nodedata) {
  Model.prototype.resolveReferencesToNodeData.call(this, nodedata);
  var key = this.getKeyForNodeData(nodedata);
  var refdata = this.findDelayedReferences(key);
  if (refdata !== null) {
    var removes = new List(Object);
    var dit = refdata.iterator;
    while (dit.next()) {
      var d = dit.value;
      if (this.containsNodeData(d)) {  // D is a node data
        var gkey = this.getGroupKeyForNodeData(d);
        if (gkey === key) {
          var kname = this._nodeGroupKeyProperty;
          this.raiseModelChangedEvent('nodeGroupKey', ChangedEvent.Property, kname, d, key, key);
          if (typeof kname === 'string') this.updateTargetBindings(d, kname);
          removes.add(d);
        }
      } else {  // D is a link data
        var fkey = this.getFromKeyForLinkData(d);
        if (fkey === key) {
          var kname = this._linkFromKeyProperty;
          this.raiseModelChangedEvent('linkFromKey', ChangedEvent.Property, kname, d, key, key);
          if (typeof kname === 'string') this.updateTargetBindings(d, kname);
          removes.add(d);
        }
        var tkey = this.getToKeyForLinkData(d);
        if (tkey === key) {
          var kname = this._linkToKeyProperty;
          this.raiseModelChangedEvent('linkToKey', ChangedEvent.Property, kname, d, key, key);
          if (typeof kname === 'string') this.updateTargetBindings(d, kname);
          removes.add(d);
        }
        var lkeys = this.getLabelKeysForLinkData(d);
        var len = Util.arrayLength(lkeys);
        var kname = this._linkLabelKeysProperty;
        for (var j = 0; j < len; j++) {
          var lkey = Util.arrayElt(lkeys, j);
          if (lkey === key) {
            this.raiseModelChangedEvent('linkLabelKeys', ChangedEvent.Insert, kname, d, key, key);
            removes.add(d);
          }
        }
      }
    }
    var rit = removes.iterator;
    while (rit.next()) {
      this.forgetDelayedReference(key, rit.value);
    }
  }
};

/**
* @ignore
* Overridden.
* @this {GraphLinksModel}
* @param {Object} nodedata
*/
GraphLinksModel.prototype.resolveReferencesInNodeData = function(nodedata) {
  Model.prototype.resolveReferencesInNodeData.call(this, nodedata);
  var gkey = this.getGroupKeyForNodeData(nodedata);
  if (this.findNodeDataForKey(gkey) === null) {
    this.delayReference(gkey, nodedata);
  }
};

/**
* @ignore
* Overridden.
* @this {GraphLinksModel}
* @param {Object} nodedata
*/
GraphLinksModel.prototype.unresolveReferencesInNodeData = function(nodedata) {
  Model.prototype.unresolveReferencesInNodeData.call(this, nodedata);
  var gkey = this.getGroupKeyForNodeData(nodedata);
  this.forgetDelayedReference(gkey, nodedata);
};


/**
* Gets or sets the name of the data property that returns a string describing that data's category,
* or a function that takes a link data object and returns that category string;
* the default value is the name 'category'.
* This is used by the diagram to distinguish between different kinds of links.
* The name must not be null.
* If the value is an empty string,
* {@link #getCategoryForLinkData} will return an empty string for all link data objects.
* @name GraphLinksModel#linkCategoryProperty
* @function.
* @return {string|function(Object):string}
* @see #getCategoryForLinkData
* @see #setCategoryForLinkData
*/
/** @type {string|function(Object):string} */
GraphLinksModel.prototype.linkCategoryProperty;
Util.exportProperty(GraphLinksModel, 'linkCategoryProperty', GraphLinksModel.prototype.linkCategoryProperty);
Util.defineProperty(GraphLinksModel, {linkCategoryProperty: 'linkCategoryProperty'},
  /** @this {GraphLinksModel} */
  function() { return this._linkCategoryProperty; },
  /** @this {GraphLinksModel} */
  function(val) {
    var old = this._linkCategoryProperty;
    if (old !== val) {
      this.checkStringOrFunction(val, GraphLinksModel, 'linkCategoryProperty');
      this._linkCategoryProperty = val;
      this.raiseChanged('linkCategoryProperty', old, val);
    }
  }
);

GraphLinksModel.prototype['getCategoryForLinkData'] =
/**
* Find the category of a given link data, a string naming the link template
* that the {@link Diagram} should use to represent the link data.
* @this {GraphLinksModel}
* @param {Object} linkdata a JavaScript object representing a link.
* @return {string}
* @see #linkCategoryProperty
* @see #setCategoryForLinkData
*/
GraphLinksModel.prototype.getCategoryForLinkData = function(linkdata) {
  if (linkdata === null) return '';
  var cname = this._linkCategoryProperty;
  if (cname === '') return '';
  var cat = Util.safePropertyValue(linkdata, cname);
  if (cat === undefined) return '';
  if (typeof cat === 'string') return cat;
  if (Debug) Util.trace('getCategoryForLinkData found a non-string category for ' + linkdata + ': ' + cat);
  return '';
};

GraphLinksModel.prototype['setCategoryForLinkData'] =
/**
* Change the category of a given link data, a string naming the link template
* that the {@link Diagram} should use to represent the link data.
* <p/>
* Changing the link template for a link data will cause the existing {@link Link}
* to be removed from the {@link Diagram} and replaced with a new {@link Link}
* created by copying the new link template and applying any data-bindings.
* @this {GraphLinksModel}
* @param {Object} linkdata a JavaScript object representing a link.
* @param {string} cat Must not be null.
* @see #linkCategoryProperty
* @see #getCategoryForLinkData
*/
GraphLinksModel.prototype.setCategoryForLinkData = function(linkdata, cat) {
  Util.checkPrimitive(cat, 'string', GraphLinksModel, 'setCategoryForLinkData:cat');
  if (linkdata === null) return;
  var cname = this._linkCategoryProperty;
  if (cname === '') return '';
  if (!this.containsLinkData(linkdata)) {
    Util.safePropertySet(linkdata, cname, cat);
    return;
  }
  var old = Util.safePropertyValue(linkdata, cname);
  if (old === undefined) old = '';
  if (old !== cat) {
    Util.safePropertySet(linkdata, cname, cat);
    this.raiseModelChangedEvent('linkCategory', ChangedEvent.Property, cname, linkdata, old, cat);
    if (typeof cname === 'string') this.updateTargetBindings(linkdata, cname);
  }
};
/**
* @ignore
* This is only defined to avoid a warning in the Closure compiler.
* @param linkdata
* @param cat
* @this {GraphLinksModel}
*/
GraphLinksModel.prototype.setCategoryForLinkData2 = function(linkdata, cat) {
  this.setCategoryForLinkData(linkdata, cat);
};


/**
* This constructs an empty TreeModel unless one provides arguments as the initial data array values
* for the {@link Model#nodeDataArray} property.
* @constructor
* @param {Array=} nodedataarray an optional Array containing JavaScript objects to be represented by Nodes.
* @extends Model
* @category Model
* @since 1.1
* @class
* TreeModels support tree-structured graphs of nodes and links.
* Each node can have at most one "tree parent"; cycles are not permitted.
* The reference to the parent node's key is a property of the child node data.
* <p/>
* TreeModels, unlike {@link GraphLinksModel}s, do not support arbitrary link relationships between nodes,
* nor is there a separate link data object for each parent-child relationship.
* Furthermore there is no support for grouping or label nodes.
* <p/>
* The {@link #nodeParentKeyProperty} property names the property on the node data whose value
* is the key of the "tree parent" node.
* The default value for this property is "parent".
* <p/>
* For example, one can define a graph consisting of one parent node with two child nodes:
* <pre class="javascript">
*  model.nodeDataArray = [
*    { key: "Alpha" },
*    { key: "Beta", parent: "Alpha" },
*    { key: "Gamma", parent: "Alpha" }
*  ];
* </pre>
* <p/>
* If you need to show a more complicated graph structure than a tree, use a {@link GraphLinksModel}.
* If you want to have multiple links between the same pair of nodes,
* or if you want to associate more information with each link and cannot put the information on the child node,
* you will need to have a separate link data object for each link,
* and that would require the use of {@link GraphLinksModel}.
*/
function TreeModel(nodedataarray) {
  if (arguments.length > 1) {
    Util.throwError('TreeModel constructor can only take one optional argument, the Array of node data.');
  }
  Model.call(this);

  /** @type {string|function(Object):(string|number)} */
  this._nodeParentKeyProperty = 'parent';
  /** @type {string|function(Object):(string|number)} */
  this._parentLinkCategoryProperty = 'parentLinkCategory';

  if (nodedataarray !== undefined/*not present*/) this.nodeDataArray = nodedataarray;
}

Util.publish('TreeModel', TreeModel);

Util.inherit(TreeModel, Model);


/**
* @ignore
* @this {TreeModel}
* @param {number=} details Optional: If greater than zero, this includes descriptions of each node data and link data.
* @return {string}
*/
TreeModel.prototype.toString = function(details) {
  if (details === undefined) details = 0;
  if (details >= 2) {
    return this.toJson();
  } else {
    var s = (this.name !== '' ? this.name : '') + ' TreeModel';
    if (details > 0) {
      s += '\n node data:';
      var arr = this.nodeDataArray;
      var len = Util.arrayLength(arr);
      var i;
      for (i = 0; i < len; i++) {
        var item = Util.arrayElt(arr, i);
        s += ' ' + this.getKeyForNodeData(item) + ':' + Binding.toString(item);
      }
    }
    return s;
  }
};

/**
* @ignore
* Write out the persistent properties of this model into a string using JSON syntax property pairs.
* @this {TreeModel}
* @return {string}
*/
TreeModel.prototype.writeJsonProtected = function() {
  var basestr = Model.prototype.writeJsonProtected.call(this);
  var s = '';
  if (this.nodeParentKeyProperty !== 'parent' && typeof this.nodeParentKeyProperty === 'string') s += ',\n  "nodeParentKeyProperty": ' + this.quote(this.nodeParentKeyProperty);
  return basestr + s;
};

/**
* @ignore
* Find the persistent model properties of the given Object and assign them to this model.
* @this {TreeModel}
* @param {Object} obj
*/
TreeModel.prototype.readJsonProtected = function(obj) {
  Model.prototype.readJsonProtected.call(this, obj);
  if (obj['nodeParentKeyProperty']) this.nodeParentKeyProperty = obj['nodeParentKeyProperty'];
};


/**
* @ignore
* Not really needed, but maybe some day there might be a use....
* @this {TreeModel}
* @param {number|string|undefined} key
* @return {number|string|undefined}
*/
TreeModel.prototype.maybeEnsureLinkReference = function(key) {
  return key;
};


/**
* Gets or sets the name of the property on node data that specifies
* the string or number key of the node data that acts as the "parent" for this "child" node data,
* or a function that takes a node data object and returns that parent key;
* the default value is the name 'parent'.
* The value must not be null nor an empty string.
* @name TreeModel#nodeParentKeyProperty
* @function.
* @return {string|function(Object):(string|number)}
* @see #getParentKeyForNodeData
* @see #setParentKeyForNodeData
*/
/** @type {string|function(Object):(string|number)} */
TreeModel.prototype.nodeParentKeyProperty;
Util.exportProperty(TreeModel, 'nodeParentKeyProperty', TreeModel.prototype.nodeParentKeyProperty);
Util.defineProperty(TreeModel, { nodeParentKeyProperty: 'nodeParentKeyProperty' },
  /** @this {TreeModel} */
  function() { return this._nodeParentKeyProperty; },
  /** @this {TreeModel} */
  function(val) {
    var old = this._nodeParentKeyProperty;
    if (old !== val) {
      this.checkStringOrFunction(val, TreeModel, 'nodeParentKeyProperty');
      this._nodeParentKeyProperty = val;
      this.raiseChanged('nodeParentKeyProperty', old, val);
    }
  }
);

TreeModel.prototype['getParentKeyForNodeData'] =
/**
* If there is a parent node for the given node data, return the parent's key.
* @this {TreeModel}
* @param {Object} nodedata a JavaScript object representing a node.
* @return {number|string|undefined}  This returns undefined if there is no parent node data object.
* @see #nodeParentKeyProperty
* @see #setParentKeyForNodeData
*/
TreeModel.prototype.getParentKeyForNodeData = function(nodedata) {
  if (nodedata === null) return undefined;
  var kname = this._nodeParentKeyProperty;
  if (kname === '') return undefined;
  var key = Util.safePropertyValue(nodedata, kname);
  if (key === undefined) return undefined;
  if (this.isKeyType(key)) return key;
  if (Debug) Util.trace('ParentKey value for node data ' + nodedata + ' is not a number or a string: ' + key);
  return undefined;
};

TreeModel.prototype['setParentKeyForNodeData'] =
/**
* Change the parent node for the given node data, given a key for the new parent, or undefined if there should be no parent.
* @this {TreeModel}
* @param {Object} nodedata a JavaScript object representing a node.
* @param {number|string|undefined} key This may be undefined if there should be no parent node data.
* @see #nodeParentKeyProperty
* @see #getParentKeyForNodeData
*/
TreeModel.prototype.setParentKeyForNodeData = function(nodedata, key) {
  if (key === null) key = undefined;
  if (key !== undefined && !this.isKeyType(key)) {
    Util.throwTypeError(key, 'number or string', TreeModel, 'setParentKeyForNodeData:key');
  }
  if (nodedata === null) return;
  var kname = this._nodeParentKeyProperty;
  if (kname === '') return;
  key = this.maybeEnsureLinkReference(key);
  if (!this.containsNodeData(nodedata)) {
    Util.safePropertySet(nodedata, kname, key);
    return;
  }
  var old = Util.safePropertyValue(nodedata, kname);
  if (old !== key) {
    this.forgetDelayedReference(old, nodedata);
    Util.safePropertySet(nodedata, kname, key);
    if (this.findNodeDataForKey(key) === null) {
      this.delayReference(key, nodedata);
    }
    this.raiseModelChangedEvent('nodeParentKey', ChangedEvent.Property, kname, nodedata, old, key);
    if (typeof kname === 'string') this.updateTargetBindings(nodedata, kname);
  }
};
/**
* @ignore
* This is only defined to avoid a warning in the Closure compiler.
* @param nodedata
* @param key
* @this {TreeModel}
*/
TreeModel.prototype.setParentKeyForNodeData2 = function(nodedata, key) {
  this.setParentKeyForNodeData(nodedata, key);
};


/**
* Gets or sets the name of the data property that returns a string describing that node data's parent link's category,
* or a function that takes a node data object and returns its parent link's category string;
* the default value is the name 'parentLinkCategory'.
* This is used by the diagram to distinguish between different kinds of links.
* The name must not be null.
* If the value is an empty string,
* {@link #getParentLinkCategoryForNodeData} will return an empty string for all node data objects.
* @name TreeModel#parentLinkCategoryProperty
* @function.
* @return {string|function(Object):string}
* @see #getParentLinkCategoryForNodeData
* @see #setParentLinkCategoryForNodeData
*/
/** @type {string|function(Object):string} */
TreeModel.prototype.parentLinkCategoryProperty;
Util.exportProperty(TreeModel, 'parentLinkCategoryProperty', TreeModel.prototype.parentLinkCategoryProperty);
Util.defineProperty(TreeModel, { parentLinkCategoryProperty: 'parentLinkCategoryProperty' },
  /** @this {TreeModel} */
  function() { return this._parentLinkCategoryProperty; },
  /** @this {TreeModel} */
  function(val) {
    var old = this._parentLinkCategoryProperty;
    if (old !== val) {
      this.checkStringOrFunction(val, TreeModel, 'parentLinkCategoryProperty');
      this._parentLinkCategoryProperty = val;
      this.raiseChanged('parentLinkCategoryProperty', old, val);
    }
  }
);

TreeModel.prototype['getParentLinkCategoryForNodeData'] =
/**
* Find the category for the parent link of a given child node data, a string naming the link template
* that the {@link Diagram} should use to represent the link.
* @this {TreeModel}
* @param {Object} childdata a JavaScript object representing a node data.
* @return {string}
* @see #parentLinkCategoryProperty
* @see #setParentLinkCategoryForNodeData
*/
TreeModel.prototype.getParentLinkCategoryForNodeData = function(childdata) {
  if (childdata === null) return '';
  var cname = this._parentLinkCategoryProperty;
  if (cname === '') return '';
  var cat = Util.safePropertyValue(childdata, cname);
  if (cat === undefined) return '';
  if (typeof cat === 'string') return cat;
  if (Debug) Util.trace('getParentLinkCategoryForNodeData found a non-string category for ' + childdata + ': ' + cat);
  return '';
};

TreeModel.prototype['setParentLinkCategoryForNodeData'] =
/**
* Change the category for the parent link of a given child node data, a string naming the link template
* that the {@link Diagram} should use to represent the link.
* <p/>
* Changing the link template will cause any existing {@link Link}
* to be removed from the {@link Diagram} and replaced with a new {@link Link}
* created by copying the new link template and applying any data-bindings.
* @this {TreeModel}
* @param {Object} childdata a JavaScript object representing a node data.
* @param {string} cat Must not be null.
* @see #parentLinkCategoryProperty
* @see #getParentLinkCategoryForNodeData
*/
TreeModel.prototype.setParentLinkCategoryForNodeData = function(childdata, cat) {
  Util.checkPrimitive(cat, 'string', TreeModel, 'setParentLinkCategoryForNodeData:cat');
  if (childdata === null) return;
  var cname = this._parentLinkCategoryProperty;
  if (cname === '') return '';
  if (!this.containsNodeData(childdata)) {
    Util.safePropertySet(childdata, cname, cat);
    return;
  }
  var old = Util.safePropertyValue(childdata, cname);
  if (old === undefined) old = '';
  if (old !== cat) {
    Util.safePropertySet(childdata, cname, cat);
    this.raiseModelChangedEvent('parentLinkCategory', ChangedEvent.Property, cname, childdata, old, cat);
    if (typeof cname === 'string') this.updateTargetBindings(childdata, cname);
  }
};


TreeModel.prototype['copyNodeData'] =
/**
* @ignore
* This override also makes sure any copied node data does not have a reference to a parent node.
* @this {TreeModel}
* @param {Object} nodedata a JavaScript object representing a node, group, or non-link.
* @return {Object}
*/
TreeModel.prototype.copyNodeData = function(nodedata) {
  if (nodedata === null) return null;
  var copy = Model.prototype.copyNodeData.call(this, nodedata);
  if (this._nodeParentKeyProperty !== '') {
    Util.safePropertySet(copy, this._nodeParentKeyProperty, undefined);
  }
  return copy;
};

TreeModel.prototype['setDataProperty'] =
/**
* @ignore
* Change the value of some property of a node data or an item data, given a string naming the property
* and the new value, in a manner that can be undone/redone and that automatically updates any bindings.
* <p/>
* This gets the old value of the property; if the value is the same as the new value, no side-effects occur.
* @this {TreeModel}
* @param {Object} data a JavaScript object representing a Node, simple Part, or item in a {@link Panel#itemArray}.
* @param {string} propname a string that is not null or the empty string.
* @param {*} val the new value for the property.
*/
TreeModel.prototype.setDataProperty = function(data, propname, val) {
  if (Debug) {
    Util.checkPrimitive(data, 'object', TreeModel, 'setDataProperty:data');
    Util.checkPrimitive(propname, 'string', TreeModel, 'setDataProperty:propname');
    if (propname === '') Util.throwError('TreeModel.setDataProperty: property name must not be an empty string when setting ' + data + ' to ' + val);
  }
  if (this.containsNodeData(data)) {
    if (propname === this.nodeKeyProperty) {
      this.setKeyForNodeData2(data, val);
    } else if (propname === this.nodeCategoryProperty) {
      this.setCategoryForNodeData2(data, val);
      return;
    } else if (propname === this.nodeParentKeyProperty) {
      this.setParentKeyForNodeData2(data, val);
      return;
    }
  } else {
    if (!Util.warnedAboutModifyingGraphObject && data instanceof GraphObject) {
      Util.warnedAboutModifyingGraphObject = true;
      Util.trace('TreeModel.setDataProperty is modifying a GraphObject, "' + data.toString() + '"');
      Util.trace('  Is that really your intent?');
    }
  }
  // set the property and raise a Property ChangedEvent with the old and new values
  var old = Util.safePropertyValue(data, propname);
  if (old !== val) {
    Util.safePropertySet(data, propname, val);
    this.raiseDataChanged(data, propname, old, val);
  }
};


/**
* @ignore
* When a node data changes its key, we need to update all data references to that node data
* that are using the old key value by replacing them with the new key value.
* The goal is to maintain all of the original relationships in all of the data maintained by the model.
* @this {TreeModel}
*/
TreeModel.prototype.replaceAllKeyReferences = function(oldkey, newkey) {
  Model.prototype.replaceAllKeyReferences.call(this, oldkey, newkey);
  //?? this is very slow, but it might not be worth it to remember and maintain back-pointers
  var it = this._mapKeyNodeData.iterator;
  while (it.next()) {
    this.replaceKeyReferencesInNodeData(it.value, oldkey, newkey);
  }
};

/**
* @ignore
* When a node key has changed its key, we need to update all data references to that node data
* that are using the old key value by replacing them with the new key value.
* @this {TreeModel}
*/
TreeModel.prototype.replaceKeyReferencesInNodeData = function(d, oldkey, newkey) {
  var pkey = this.getParentKeyForNodeData(d);
  if (pkey === oldkey) {
    var kname = this._nodeParentKeyProperty;
    Util.safePropertySet(d, kname, newkey);
    this.raiseModelChangedEvent('nodeParentKey', ChangedEvent.Property, kname, d, oldkey, newkey);
    if (typeof kname === 'string') this.updateTargetBindings(d, kname);
  }
};

/**
* @ignore
* Overridden.
* @this {TreeModel}
* @param {Object} nodedata
*/
TreeModel.prototype.resolveReferencesToNodeData = function(nodedata) {
  Model.prototype.resolveReferencesToNodeData.call(this, nodedata);
  var key = this.getKeyForNodeData(nodedata);
  var refdata = this.findDelayedReferences(key);
  if (refdata !== null) {
    var removes = new List(Object);
    var dit = refdata.iterator;
    while (dit.next()) {
      var d = dit.value;
      if (this.containsNodeData(d)) {  // D is a node data
        var pkey = this.getParentKeyForNodeData(d);
        if (pkey === key) {
          var kname = this._nodeParentKeyProperty;
          this.raiseModelChangedEvent('nodeParentKey', ChangedEvent.Property, kname, d, key, key);
          if (typeof kname === 'string') this.updateTargetBindings(d, kname);
          removes.add(d);
        }
      }
    }
    var rit = removes.iterator;
    while (rit.next()) {
      this.forgetDelayedReference(key, rit.value);
    }
  }
};

/**
* @ignore
* Overridden.
* @this {TreeModel}
* @param {Object} nodedata
*/
TreeModel.prototype.resolveReferencesInNodeData = function(nodedata) {
  Model.prototype.resolveReferencesInNodeData.call(this, nodedata);
  var pkey = this.getParentKeyForNodeData(nodedata);
  pkey = this.maybeEnsureLinkReference(pkey);
  if (this.findNodeDataForKey(pkey) === null) {
    this.delayReference(pkey, nodedata);
  }
};

/**
* @ignore
* Overridden.
* @this {TreeModel}
* @param {Object} nodedata
*/
TreeModel.prototype.unresolveReferencesInNodeData = function(nodedata) {
  Model.prototype.unresolveReferencesInNodeData.call(this, nodedata);
  var pkey = this.getParentKeyForNodeData(nodedata);
  this.forgetDelayedReference(pkey, nodedata);
};


/**
* The constructor creates an empty one-way binding.
* @constructor
* @param {string=} targetprop A string naming the target property on the target object.
*   If this is the empty string or not supplied, the whole {@link GraphObject} is used in the call to the conversion function,
*   which should modify the {@link GraphObject} directly.
* @param {string=} sourceprop A string naming the source property on the bound data object.
*   If this is the empty string, the whole {@link Panel#data} object is used.
*   If this argument is not supplied, the source property is assumed to be the same as the target property.
* @param {function(*,*=) | null=} conv A function converting the data property value to the value to set the target property.
*   If the function is null or not supplied, no conversion takes place.
* @category Model
* @class
* A Binding describes how to automatically set a property on a {@link GraphObject}
* to a value of a property of data in the model.
* The target property name and the data source property name are strings.
* All name matching is case-sensitive.
* <p/>
* Register bindings by calling {@link GraphObject#bind} with a new Binding.
* Existing bindings become read-only, and no new bindings may be added,
* when a template (a {@link Part}) is copied.
* Bindings will be shared by all copies of the template's GraphObjects.
* <p/>
* For example, your node data might be like:
* <pre>
* { key: 23, say: "hello!" }
* </pre>
* <p/>
* Your simple node template might be like:
* <pre>
*   var template = new go.Node(go.Panel.Auto);
*   . . . define the rest of the Node's visual tree . . .
*   var txt = new go.TextBlock();
*   txt.bind(new go.Binding("text", "say"));
*   template.add(txt);
*   myDiagram.nodeTemplate = template;
* </pre>
* <p/>
* The data binding causes the {@link TextBlock#text} property of
* the TextBlock to be set to the value of the data's "say" property.
* <p/>
* Sometimes the data value needs to be modified or converted in order
* to be used as the new value of a {@link GraphObject} property.
* The most common conversion functions are provided for you --
* they convert a string to a geometric class:
* {@link Point.parse}, {@link Size.parse}, {@link Rect.parse},
* {@link Margin.parse}, {@link Spot.parse}, and {@link Geometry.parse}.
* But you can easily define your own conversion function.
* <p/>
* As an example of a conversion function, let's use a function that adds some
* text prefixing the data property value:
* <pre>
*   new go.Binding("text", "say", function(v) { return "I say: " + v; })
* </pre>
* <p/>
* By default bindings are {@link Binding#OneWay}.
* OneWay bindings are evaluated when the {@link Panel#data} property is set
* or when you call {@link Panel#updateTargetBindings}.
* OneWay bindings only transfer values from the source to the target.
* <p/>
* TwoWay bindings are evaluated in the source-to-target direction just as OneWay
* bindings are evaluated.
* However when the {@link GraphObject} target property is modified, the TwoWay
* bindings are evaluated in the target-to-source direction.
* <p/>
* You should not have a TwoWay binding on a node data object's key property.
* Unintentionally changing the node key value to be the same as another node data's key value
* may cause indeterminate behavior.
* Furthermore, changing a node data key without changing any references to that node
* using the key value will result in "dangling" references and inconsistent relationships.
* You can make that change safely by calling {@link Model#setKeyForNodeData},
* but not via a data binding.
* <p/>
* The target-to-source update can also go through a conversion function.
* The most common back-conversion functions are provided for you.
* They convert a geometric class to a string:
* {@link Point.stringify}, {@link Size.stringify}, {@link Rect.stringify},
* {@link Margin.stringify}, {@link Spot.stringify}, and {@link Geometry.stringify}.
* <p/>
* It is common to want to update some data properties based on changes to the diagram.
* For example, as the user changes the {@link Part#location} by dragging a Node,
* you can automatically keep the node's model data in sync using a TwoWay binding.
* <pre>
*   new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify)
* </pre>
* The call to {@link Binding#makeTwoWay} changes the {@link Binding#mode}
* to be {@link Binding#TwoWay} and specifies the {@link Binding#backConverter}
* function to be the {@link Point.stringify} static function.
* <p/>
* Because the Binding is on the whole Node (<code>template</code>),
* the target object is the whole {@link Node} and the target property is "location".
* The value of <code>data.loc</code> will be a string representation of the <code>Node.location</code> value.
* <p/>
* The source of a Binding is normally a property of a data object in the model.
* The target of a Binding is always a property of a {@link GraphObject}.
* But it is also possible to have the source of a Binding be another GraphObject that is in the same Part.
* You just have to make sure that object has a unique {@link GraphObject#name} or is the Part itself.
* <p/>
* As a common kind of example of data binding between two properties of GraphObjects,
* consider this Binding on a {@link Shape} which changes the color of the {@link Shape#stroke}
* depending on whether the Node is selected ({@link Part#isSelected}):
* <pre>
*   new go.Binding("stroke", "isSelected", function(s) { return s ? "magenta" : "gray"; }).ofObject()
* </pre>
* Note the call to {@link Binding#ofObject}, which tells the Binding that it should use as the source
* a GraphObject with a particular name.  However that name argument is optional -- supplying no name
* (or supplying an empty string) will cause the binding to operate with the root GraphObject.
* In this case that would be the Node itself.
* Now with this binding whenever the value of {@link Part#isSelected"} changes, this Shape's stroke changes color.
* The conversion function is what changes the boolean "isSelected" value to a brush color specifier.
* <p/>
* Here's an example of a two-way data-binding using two custom conversion functions working with two separate data properties.
* First we define the two conversion functions.
* <pre>
*   function toLocation(data, node) {
*     return new go.Point(data.x, data.y);
*   };
*   function fromLocation(loc, data) {
*     data.x = loc.x;
*     data.y = loc.y;
*   };
* </pre>
* <p/>
* Then to data-bind the default template's {@link Part#location} property
* to two separate data properties, "x" and "y":
* <pre>
*   new go.Binding("location", "", toLocation).makeTwoWay(fromLocation)
* </pre>
* <p/>
* An empty string argument for the <i>sourceprop</i> parameter indicates
* that the whole data object should be passed to the <code>toLocation</code> function,
* rather than the value of some property of that data.
* The return value is used as the new value for the {@link Part#location} property.
* <p/>
* The binding works normally for the source-to-target direction.
* But when the target property is modified it is the source property that is
* set with the (back-)converted value from the target object.
* Because in this example the source property name is the empty string,
* and because one cannot replace the whole source data object,
* any return value from the conversion function is ignored.
* Instead the conversion function has to modify the data object directly,
* as this example <code>fromLocation</code> function does.
*/
function Binding(targetprop, sourceprop, conv) {
  Util.uniqueHash(this);
  if (targetprop === undefined/*notpresent*/) targetprop = '';
  else Util.checkPrimitive(targetprop, 'string', Binding, 'constructor:targetprop');
  if (sourceprop === undefined/*notpresent*/) sourceprop = targetprop;
  else Util.checkPrimitive(sourceprop, 'string', Binding, 'constructor:sourceprop');
  if (conv === undefined/*notpresent*/) conv = null;
  else if (conv !== null) Util.checkPrimitive(conv, 'function', Binding, 'constructor:conv');
  /** @type {string} */
  this._targetId = '';
  /** @type {Object} */
  this._targetObject = null;
  /** @type {string} */
  this._targetProperty = targetprop;
  /** @ignore @type {number} */
  this._targetKind = 0;  // 1 for column definitions, 2 for row definitions; only for 1st prop in path
  /** @ignore @type {number} */
  this._targetArg = 0;  // the column or row number, if targetKind is 1 or 2
  /** @type {?string} */
  this._sourceName = null;
  /** @type {string} */
  this._sourceProperty = sourceprop;
  /** @type {function(*,*=) | null} */
  this._converter = conv;
  /** @type {EnumValue} */
  this._mode = Binding.OneWay;
  /** @type {function(*,*=) | null} */
  this._backConverter = null;
}

Util.publish('Binding', Binding);

/**
* This value for {@link Binding#mode} uses data source values and sets {@link GraphObject} properties.
* Bindings are evaluated when {@link Panel#updateTargetBindings} is called.
* @name Binding#OneWay
* @constant
* @static
* @return {EnumValue}
*/
Binding['OneWay'] = Binding.OneWay = Util.defineEnumValue(Binding, 'OneWay', 1);

/**
* This value for {@link Binding#mode} uses data source values and {@link GraphObject} properties and keeps them in sync.
* When {@link Panel#updateTargetBindings} is called, the {@link GraphObject} properties are set.
* When {@link GraphObject} properties are modified, the {@link Panel#data} properties are set.
* @name Binding#TwoWay
* @constant
* @static
* @return {EnumValue}
*/
Binding['TwoWay'] = Binding.TwoWay = Util.defineEnumValue(Binding, 'TwoWay', 2);

Binding['parseEnum'] =
/**
* This static method can be used to create a function that parses
* a string into an enumerated value, given the class that the enumeration values
* are defined on and a default value if the string cannot be parsed successfully.
* <p/>
* The normal usage is to pass the result of this function as the conversion function of a {@link Binding}.
* <pre>
* linktemplate.bind(new go.Binding('routing', 'dataPropName', go.Binding.parseEnum(go.Link, go.Link.Normal)));
* </pre>
* This binding will try to parse the string that is the value of the bound data's "dataPropName" property.
* If it is a legitimate enumerated value defined on the {@link Link} class, the conversion
* function will return that value.
* If the bound data's "dataPropName" property is not present or has an unrecognized value,
* the {@link Link#routing} property gets the default value, {@link Link#Normal}.
* @param {function()} ctor the class constructor that defines the enumerated values that are being parsed.
* @param {EnumValue} defval the default enumerated value to return if it fails to parse the given string.
* @return {function(string):EnumValue} a function that takes a string and returns an enumerated value.
*/
Binding.parseEnum = function(ctor, defval) {
  Util.checkPrimitive(ctor, 'function', Binding, 'parseEnum:ctor');
  Util.checkEnumValue(defval, ctor, Binding, 'parseEnum:defval');
  return function(str) {
    var v = Util.findEnumValueForName(ctor, str);
    return v || defval;
  };
};

Binding['toString'] =
/**
* This static method can be used to convert an object to a string,
* looking for commonly defined data properties, such as "text", "name", "key", or "id".
* If none are found, this just calls toString() on it.
* @this {Binding}
* @param {*} val
* @return {string}
*/
Binding.toString = function(val) {
  var v = val;
  if (Util.isObject(val)) {
    if (val['text']) v = val['text'];
    else if (val['Text']) v = val['Text'];
    else if (val['name']) v = val['name'];
    else if (val['Name']) v = val['Name'];
    else if (val['key'] !== undefined) v = val['key'];
    else if (val['Key'] !== undefined) v = val['Key'];
    else if (val['id'] !== undefined) v = val['id'];
    else if (val['Id'] !== undefined) v = val['Id'];
    else if (val['ID'] !== undefined) v = val['ID'];
  }
  if (v === undefined) return 'undefined';
  if (v === null) return 'null';
  return v.toString();
};

/**
* @ignore
* @this {Binding}
* @return {string}
*/
Binding.prototype.toString = function() {
  return 'Binding(' + this.targetId + ' ' + this.targetProperty + ':' + this.sourceProperty + ')';
};

/**
* @ignore
* Make this object 'frozen' or immutable.
* Future attempts to change its state, for example by setting any of its properties,
* may result in an exception, until it is thaw()'ed.
* @this {Binding}
* @return {Binding} this.
*/
Binding.prototype.freeze = function() {
  this._isFrozen = true;
  return this;
};

/**
* @ignore
* Make this object 'thawed' or mutable.
* @this {Binding}
* @return {Binding}
*/
Binding.prototype.thaw = function() {
  this._isFrozen = false;
  return this;
};

/**
* @ignore
* Gets or sets the name of the {@link GraphObject} whose property should be set
* by this data binding.
* The default value is the empty string, which uses the {@link Part},
* typically a {@link Node}, as the target object.
* Because Bindings may be shared, the targetId is needed to find in the Part
* the actual object whose property is data-bound.
* @name Binding#targetId
* @function.
* @return {string}
*/
/** @type {string} */
Binding.prototype.targetId;
Util.exportProperty(Binding, 'targetId', Binding.prototype.targetId);
Util.defineProperty(Binding, {targetId: null},
  /** @this {Binding} */
  function() { return this._targetId; },
  /** @this {Binding} */
  function(val) {
    Util.checkFrozen(this);
    Util.checkPrimitive(val, 'string', Binding, 'targetId');
    this._targetId = val;
  }
);

/**
* Gets or sets the name of the property to be set on the target {@link GraphObject}.
* The default value is the empty string; you normally set this to be the name of a property.
* @name Binding#targetProperty
* @function.
* @return {string}
*/
/** @type {string} */
Binding.prototype.targetProperty;
Util.exportProperty(Binding, 'targetProperty', Binding.prototype.targetProperty);
Util.defineProperty(Binding, {targetProperty: 'targetProperty'},
  /** @this {Binding} */
  function() { return this._targetProperty; },
  /** @this {Binding} */
  function(val) {
    Util.checkFrozen(this);
    Util.checkPrimitive(val, 'string', Binding, 'targetProperty');
    this._targetProperty = val;
  }
);

/**
* Gets or sets the name of the {@link GraphObject} that should act as a source object
* whose property should be gotten by this data binding.
* The default value is null, which uses the bound {@link Panel#data} as the source.
* If the value is a string, it should be the name of a {@link GraphObject} in the
* visual tree of the {@link Panel} that is bound to the data.
* Use the empty string to refer to the root panel.
* @name Binding#sourceName
* @function.
* @return {?string}
*/
/** @type {?string} */
Binding.prototype.sourceName;
Util.exportProperty(Binding, 'sourceName', Binding.prototype.sourceName);
Util.defineProperty(Binding, {sourceName: 'sourceName'},
  /** @this {Binding} */
  function() { return this._sourceName; },
  /** @this {Binding} */
  function(val) {
    Util.checkFrozen(this);
    Util.checkPrimitive(val, 'string', Binding, 'sourceName');
    this._sourceName = val;
  }
);

/**
* Gets or sets the name of the property to get from the bound data object,
* the value of {@link Panel#data}.
* The default value is the empty string, which results in setting the target
* property to the whole data object, rather than to a property value of the data object.
* @name Binding#sourceProperty
* @function.
* @return {string}
*/
/** @type {string} */
Binding.prototype.sourceProperty;
Util.exportProperty(Binding, 'sourceProperty', Binding.prototype.sourceProperty);
Util.defineProperty(Binding, {sourceProperty: 'sourceProperty'},
  /** @this {Binding} */
  function() { return this._sourceProperty; },
  /** @this {Binding} */
  function(val) {
    Util.checkFrozen(this);
    Util.checkPrimitive(val, 'string', Binding, 'sourceProperty');
    this._sourceProperty = val;
  }
);

/**
* Gets or sets a converter function to apply to the data property value
* in order to produce the value to set to the target property.
* This conversion function is used in both OneWay and TwoWay bindings,
* when transferring a value from the source to the target.
* The default value is null -- no conversion takes place.
* Otherwise the value should be a function that takes one or two arguments
* and returns the desired value.
* However, the return value is ignored when the {@link #targetProperty}
* is the empty string.
* @name Binding#converter
* @function.
* @return {function(*,*=) | null}  A function that is passed the value from the source
* (the first argument) and the target {@link GraphObject} (the second argument).
* If the {@link #targetProperty} is a property name, that property is set to
* the function's return value.
* If the {@link #targetProperty} is the empty string, the function should
* modify the second argument, which will be the target object.
*/
/** @type {function(*,*=) | null} */
Binding.prototype.converter;
Util.exportProperty(Binding, 'converter', Binding.prototype.converter);
Util.defineProperty(Binding, {converter: 'converter'},
  /** @this {Binding} */
  function() { return this._converter; },
  /** @this {Binding} */
  function(val) {
    Util.checkFrozen(this);
    if (val !== null) Util.checkPrimitive(val, 'function', Binding, 'converter');
    this._converter = val;
  }
);

/**
* Gets or sets a converter function to apply to the {@link GraphObject} property value
* in order to produce the value to set to a data property.
* This conversion function is only used in a TwoWay binding,
* when transferring a value from the target to the source.
* The default value is null -- no conversion takes place.
* Otherwise the value should be a function that takes one or two arguments
* and returns the desired value.
* However, the return value is ignored when the {@link #sourceProperty}
* is the empty string.
* @name Binding#backConverter
* @function.
* @return {function(*,*=) | null}  A function that is passed the value from the target
* (the first argument) and the source {@link Panel#data} object (the second argument).
* If the {@link #sourceProperty} is a property name, that property is set to
* the function's return value.
* If the {@link #sourceProperty} is the empty string, the function should
* modify the second argument, which will be the source data object.
*/
/** @type {function(*,*=) | null} */
Binding.prototype.backConverter;
Util.exportProperty(Binding, 'backConverter', Binding.prototype.backConverter);
Util.defineProperty(Binding, {backConverter: 'backConverter'},
  /** @this {Binding} */
  function() { return this._backConverter; },
  /** @this {Binding} */
  function(val) {
    Util.checkFrozen(this);
    if (val !== null) Util.checkPrimitive(val, 'function', Binding, 'backConverter');
    this._backConverter = val;
  }
);

/**
* Gets or sets the directions and frequency in which the binding may be evaluated.
* The default value is {@link Binding#OneWay}.
* {@link Binding#TwoWay} is the other choice.
* <p/>
* You should not have a TwoWay binding on a node data object's key property.
* @name Binding#mode
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
Binding.prototype.mode;
Util.exportProperty(Binding, 'mode', Binding.prototype.mode);
Util.defineProperty(Binding, {mode: 'mode'},
  /** @this {Binding} */
  function() { return this._mode; },
  /** @this {Binding} */
  function(val) {
    Util.checkFrozen(this);
    Util.checkEnumValue(val, Binding, Binding, 'mode');
    this._mode = val;
  }
);

Binding.prototype['makeTwoWay'] =
/**
* Modify this Binding to set its {@link #mode} to be {@link Binding#TwoWay}, and
* provide an optional conversion function to convert {@link GraphObject} property
* values back to data values.
* <p/>
* You should not have a TwoWay binding on a node data object's key property.
* @this {Binding}
* @param {function(*,*=) | null=} backconv
* @return {Binding} this two-way Binding.
*/
Binding.prototype.makeTwoWay = function(backconv) {
  if (backconv === undefined/*notpresent*/) backconv = null;
  this.mode = Binding.TwoWay;
  this.backConverter = backconv;
  return this;
};

Binding.prototype['ofObject'] =
/**
* Modify this Binding to set its {@link #sourceName} property so as to identify
* a {@link GraphObject} in the visual tree of the bound {@link Panel}.
* @this {Binding}
* @param {string=} srcname the {@link GraphObject#name} of an element in the visual tree of the bound {@link Panel};
* use an empty string to refer to the root panel of that visual tree.
* @return {Binding} this Binding to another GraphObject.
*/
Binding.prototype.ofObject = function(srcname) {
  if (srcname === undefined/*notpresent*/) srcname = '';
  if (Debug) Util.checkPrimitive(srcname, 'string', Binding, 'ofObject:srcname');
  this.sourceName = srcname;
  return this;
};


Binding.prototype['updateTarget'] =
/**
* @ignore
* @this {Binding}
* @param {Object} elt  the normal target element whose property will be copied.
* @param {Object} data  the normal source data object that will be modified.
* @param {string=} srcprop  an optional property name on the DATA that should be copied;
*   if supplied this will update the ELT only if the property name matches.
*/
Binding.prototype.updateTarget = function(elt, data, srcprop) {
  // might be limited to updating for a particular source property name
  var sprop = this._sourceProperty;
  if (srcprop && sprop !== srcprop) return;

  // get the target property name
  var tprop = this._targetProperty;
  // if there's a converter but no target property name, no can do!
  var conv = this._converter;
  if (conv === null && tprop === '') return;  // can't replace GraphObject!

  // check that the target property name is defined on the target object;
  // "name.prop" syntax is not supported
  if (Debug && typeof tprop === 'string' && typeof elt.setAttribute !== 'function' &&
      tprop[0] !== '_' && !Util.hasDefinedProperty(elt, tprop)) {
    Util.trace('Binding error: undefined target property: ' + tprop + ' on ' + elt.toString());
  }

  // find the property value on the data; use the DATA itself if the name is empty
  var val = data;
  if (sprop !== '') val = Util.safePropertyValue(data, sprop);
  if (val === undefined) return;  //?? don't set property if new value is undefined

  // modify the target
  if (conv === null) {
    if (tprop !== '') {
      Util.safePropertySet(elt, tprop, val);
    }
  } else {  // apply conversion function
    try {  // call conversion function safely, with tracing information for debugging
      if (tprop !== '') {
        var cvtval = conv(val, elt);
        Util.safePropertySet(elt, tprop, cvtval);
      } else {
        conv(val, elt);
      }
    } catch (ex) {
      if (Debug) Util.trace('Binding error: ' + ex.toString());
    }
  }
};

Binding.prototype['updateSource'] =
/**
* @ignore
* Apply this Binding to given element in order to update
* a property on a given source data object.
* @this {Binding}
* @param {Object} elt  the normal target element whose property will be copied.
* @param {Object} data  the normal source data object that will be modified.
* @param {string=} trgtprop  an optional property name on the ELT that should be copied;
*   if supplied this will update the DATA only if the property name matches.
* @param {Diagram=} diagram  the Diagram whose Model holds the given data, or null if data is a GraphObject.
*/
Binding.prototype.updateSource = function(elt, data, trgtprop, diagram) {
  if (this._mode !== Binding.TwoWay) return;

  // get the target property name
  var tprop = this._targetProperty;
  // might be limited to updating for a particular target property name
  if (trgtprop && tprop !== trgtprop) return;

  // if there's a back-converter but no source property name, no can do!
  var sprop = this._sourceProperty;
  var conv = this._backConverter;
  if (conv === null && sprop === '') return;  // can't replace data object!

  // find the property value on the element; use the ELT itself if the name is empty
  var val = elt;
  if (tprop !== '') val = Util.safePropertyValue(elt, tprop);
  if (val === undefined) return;  //?? don't set property if new value is undefined

  // modify the source data
  if (conv === null) {
    if (diagram && diagram.model) {
      diagram.model.setDataProperty(data, sprop, val);
    } else {
      Util.safePropertySet(data, sprop, val);
    }
  } else {  // apply conversion function
    try {  // call conversion function safely, with tracing information for debugging
      if (sprop !== '') {
        var cvtval = conv(val, data);
        if (diagram && diagram.model) {
          diagram.model.setDataProperty(data, sprop, cvtval);
        } else {
          Util.safePropertySet(data, sprop, cvtval);
        }
      } else {
        conv(val, data);
      }
    } catch (ex) {
      if (Debug) Util.trace('Binding error: ' + ex.toString());
    }
  }
};

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
Transaction
UndoManager
*/

/**
* Construct an object holding an empty list of {@link ChangedEvent}s
* and no {@link #name}.
* @constructor
* @category Model
* @class
* A Transaction holds a list of {@link ChangedEvent}s collected during a transaction,
* as the value of the read-only {@link #changes} property.
* <p/>
* Start a transaction by calling {@link UndoManager#startTransaction}
* (or {@link Model#startTransaction} or {@link Diagram#startTransaction}, which call that method).
* Be sure to finish a transaction with a matching call to {@link UndoManager#commitTransaction}
* (or {@link Model#commitTransaction} or {@link Diagram#commitTransaction}),
* or a call to {@link UndoManager#rollbackTransaction}
* (or the same named methods on {@link Model} or {@link Diagram}).
* <p/>
* Undoing or redoing a transaction is done by calling {@link UndoManager#undo} or {@link UndoManager#redo}.
* Those methods call the {@link #undo} or {@link #redo} methods here.
* <p/>
* The {@link UndoManager} holds a list of Transactions in its {@link UndoManager#history}.
*/
function Transaction() {
  /** @type {List} */
  this._changes = new List(ChangedEvent).freeze();
  /** @type {string} */
  this._name = '';
  /** @type {boolean} */
  this._isComplete = false;
}

Util.publish('Transaction', Transaction);

/**
* @ignore
* @this {Transaction}
* @param {number=} details Optional: If greater than zero, this also includes information about each {@link ChangedEvent}.
* @return {string}
*/
Transaction.prototype.toString = function(details) {
  var s = 'Transaction: ' + this.name + ' ' +
    this.changes.count.toString() + (this.isComplete ? '' : ', incomplete');
  if (details !== undefined/*notpresent*/ && details > 0) {
    var len = this.changes.count;
    for (var i = 0; i < len; i++) {
      var c = this.changes.elt(i);
      if (c !== null) s += '\n  ' + c.toString(details - 1);
    }
  }
  return s;
};

Transaction.prototype['clear'] =
/**
* Clear all of the saved changes.
* @this {Transaction}
*/
Transaction.prototype.clear = function() {
  var chs = this.changes;
  chs.thaw();
  for (var i = chs.count - 1; i >= 0; i--) {
    var c = chs.elt(i);
    if (c !== null) c.clear();
  }
  chs.clear();
  chs.freeze();
};


Transaction.prototype['canUndo'] =
/**
* This predicate returns true if you can call {@link #undo},
* namely when {@link #isComplete} is true.
* @this {Transaction}
* @return {boolean} true if ready for {@link #undo} to be called.
*/
Transaction.prototype.canUndo = function() {
  return this.isComplete;
};

Transaction.prototype['undo'] =
/**
* Undo all of the changes, in reverse order.
* This is normally called only by the {@link UndoManager}.
* {@link #canUndo} must be true for this method to have any effect.
* @this {Transaction}
*/
Transaction.prototype.undo = function() {
  if (!this.canUndo()) return;
  for (var i = this.changes.count - 1; i >= 0; i--) {
    var c = this.changes.elt(i);
    if (c !== null) c.undo();
  }
};

Transaction.prototype['canRedo'] =
/**
* This predicate returns true if you can call {@link #redo},
* namely when {@link #isComplete} is true.
* @this {Transaction}
* @return {boolean} true if ready for {@link #redo} to be called.
*/
Transaction.prototype.canRedo = function() {
  return this.isComplete;
};

Transaction.prototype['redo'] =
/**
* Re-perform these changes after an {@link #undo}.
* This is normally called only by the {@link UndoManager}.
* {@link #canRedo} must be true for this method to have any effect.
* @this {Transaction}
*/
Transaction.prototype.redo = function() {
  if (!this.canRedo()) return;
  var len = this.changes.count;
  for (var i = 0; i < len; i++) {
    var c = this.changes.elt(i);
    if (c !== null) c.redo();
  }
};

/**
* @ignore
* Partial undo, to implement rollback for nested rollbackTransaction() calls.
* @this {Transaction}
* @param {number} start
*/
Transaction.prototype.rollbackTo = function(start) {
  var chs = this.changes;
  for (var i = chs.count - 1; i >= start; i--) {
    var c = chs.elt(i);
    if (c !== null) c.undo();
    chs.thaw();  // each undo might freeze the list of changes
    chs.removeAt(i);
  }
  chs.freeze();
};


/**
* Gets the list of {@link ChangedEvent}s.
* The changes are stored in order of occurrence.
* <p/>
* You should not modify this list.
* @name Transaction#changes
* @function.
* @return {List}
*/
/** @type {List} */
Transaction.prototype.changes;
Util.defineReadOnlyProperty(Transaction, {changes: 'changes'},
  /** @this {Transaction} */
  function() { return this._changes; }
);

/**
* Gets or sets the transaction name for this collection of changes.
* This is set by a top-level call to {@link UndoManager#commitTransaction}.
* @name Transaction#name
* @function.
* @return {string}
*/
/** @type {string} */
Transaction.prototype.name;
Util.exportProperty(Transaction, 'name', Transaction.prototype.name);
Util.defineProperty(Transaction, {name: 'name'},
  /** @this {Transaction} */
  function() { return this._name; },
  /** @this {Transaction} */
  function(val) { this._name = val; }
);

/**
* Gets or sets whether we can add more {@link ChangedEvent}s to this list of changes.
* This is initially false.
* It is set to true by {@link UndoManager#commitTransaction} and {@link UndoManager#rollbackTransaction}.
* @name Transaction#isComplete
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Transaction.prototype.isComplete;
Util.exportProperty(Transaction, 'isComplete', Transaction.prototype.isComplete);
Util.defineProperty(Transaction, {isComplete: 'isComplete'},
  /** @this {Transaction} */
  function() { return this._isComplete; },
  /** @this {Transaction} */
  function(val) { this._isComplete = val; }
);



/**
 * The constructor produces an empty UndoManager
 * with no transaction history.
 * @constructor
 * @category Model
 * @class
 * UndoManager observes and records model and diagram changes in transactions and
 * supports undo/redo operations.
 * You will need to set the {@link #isEnabled} property to true
 * in order for users to perform an undo or a redo.
 * <p/>
 * Typically an operation will call {@link #startTransaction},
 * make some changes to the {@link Model} or {@link Diagram},
 * and then call {@link #commitTransaction}.
 * Any {@link ChangedEvent}s that occur will be recorded in a
 * {@link Transaction} object.
 * If for some reason you do not wish to complete the transaction
 * successfully, you can call {@link #rollbackTransaction} instead
 * of {@link #commitTransaction}.
 * <p/>
 * The {@link #history} property is a list of {@link Transaction}s.
 * {@link #commitTransaction} will add the {@link #currentTransaction}
 * to the {@link #history} list.
 * {@link #rollbackTransaction} will undo the changes remembered in the
 * {@link #currentTransaction} and then discard it, without changing the {@link #history}.
 * You can limit how many transactions are remembered in the history
 * by setting {@link #maxHistoryLength}.
 * <p/>
 * Transactions may be nested.
 * Be sure to call either {@link #commitTransaction} or {@link #rollbackTransaction}
 * after each call to {@link #startTransaction}.
 * {@link #transactionLevel} indicates the current depth of nesting.
 * {@link #nestedTransactionNames} shows the stack of transaction names supplied to
 * {@link #startTransaction} calls.
 * {@link #currentTransaction} holds the flattened list of all {@link ChangedEvent}s.
 * {@link #history} holds only complete top-level transactions.
 * <p/>
 * If you want to restore the diagram to the state before the latest complete
 * transaction, call {@link #undo}.
 * {@link #historyIndex} indicates which {@link Transaction} in the {@link #history} is the next to be "undone";
 * this is decremented by each undo.
 * Call {@link #redo} to change the diagram to a later state.
 * If after some number of undo's you start a transaction,
 * all of the history after the current state is discarded,
 * and a new transaction may be recorded.
 * You cannot undo or redo during a transaction.
 * <p/>
 * Initially each {@link Model} has its own UndoManager.
 * UndoManagers may be shared by multiple Models by replacing
 * the standard {@link Model#undoManager} created by the model constructor.
 */
function UndoManager() {
  /** @type {Set} */
  this._models = new Set(Model);
  /** @type {boolean} */
  this._isEnabled = false;
  /** @type {List} */
  this._history = new List(Transaction).freeze();
  /** @type {number} */
  this._historyIndex = -1;
  /** @type {number} */
  this._maxHistoryLength = 999;
  /** @type {boolean} */
  this._isUndoingRedoing = false;
  /** @type {Transaction} */
  this._currentTransaction = null;
  /** @type {number} */
  this._transactionLevel = 0;
  /** @type {boolean} */
  this._checksTransactionLevel = false;
  if (Debug) this._checksTransactionLevel = true;
  /** @type {List} */
  this._nestedTransactionNames = new List('string').freeze();
  /** @type {List} */
  this._nestedTransactionStarts = new List('number');
  /** @type {boolean} */
  this._firstTransaction = true;
}

Util.publish('UndoManager', UndoManager);

/**
* @ignore
* @this {UndoManager}
* @param {number=} details Optional: If greater than zero, this includes descriptions of each {@link Transaction} in its {@link #history}.
* @return {string}
*/
UndoManager.prototype.toString = function(details) {
  var s = 'UndoManager ' + this.historyIndex + '<' +
    this.history.count + '<=' + this.maxHistoryLength;
  s += '[';
  var len = this.nestedTransactionNames.count;
  for (var i = 0; i < len; i++) {
    if (i > 0) s += ' ';
    s += this.nestedTransactionNames.elt(i);
  }
  s += ']';
  if (details !== undefined/*notpresent*/ && details > 0) {
    len = this.history.count;
    for (var i = 0; i < len; i++) {
      s += '\n ' + this.history.elt(i).toString(details - 1);
    }
  }
  return s;
};

UndoManager.prototype['clear'] =
/**
* Clear all of the {@link Transaction}s and clear all other state,
* including any ongoing transaction without rolling back.
* However, this maintains its references to its {@link Model}s.
* <p/>
* You should not call this method during a transaction.
* @this {UndoManager}
*/
UndoManager.prototype.clear = function() {
  var hist = this.history;
  hist.thaw();
  for (var i = hist.count - 1; i >= 0; i--) {
    var c = hist.elt(i);
    if (c !== null) c.clear();
  }
  hist.clear();
  this._historyIndex = -1;
  hist.freeze();
  this._isUndoingRedoing = false;
  this._currentTransaction = null;
  this._transactionLevel = 0;
  this._nestedTransactionNames.thaw();
  this._nestedTransactionNames.clear();
  this._nestedTransactionNames.freeze();
  this._nestedTransactionStarts.clear();
};


UndoManager.prototype['addModel'] =
/**
* Make sure this UndoManager knows about a {@link Model} for which
* it may receive {@link ChangedEvent}s when the given {@link Model} is changed.
* The model will also receive notifications about transactions and undo or redo operations.
* <p/>
* You should not call this method during a transaction.
* @this {UndoManager}
* @param {Model} model A {@link Model} that this UndoManager is managing.
* @see UndoManager#models
* @see UndoManager#removeModel
*/
UndoManager.prototype.addModel = function(model) {
  this._models.add(model);
};

UndoManager.prototype['removeModel'] =
/**
* Inform this UndoManager that it will no longer be receiving {@link ChangedEvent}s
* when the given {@link Model} is changed.
* The model will no longer receive notifications about transactions and undo or redo operations.
* <p/>
* You should not call this method during a transaction.
* If you call this method between transactions when there is a transaction history,
* you should be careful that there are no {@link ChangedEvent}s referring to that model in any {@link Transactions}.
* @this {UndoManager}
* @param {Model} model A {@link Model} that this UndoManager should no longer manage.
* @see UndoManager#models
* @see UndoManager#addModel
*/
UndoManager.prototype.removeModel = function(model) {
  this._models.remove(model);
};


UndoManager.prototype['startTransaction'] =
/**
* Begin a transaction, where the changes are held by a {@link Transaction} object
* as the value of {@link #currentTransaction}.
* You must call either {@link #commitTransaction} or {@link #rollbackTransaction} afterwards.
* <p/>
* For convenience, this method is called by {@link Model#startTransaction} and {@link Diagram#startTransaction}.
* <p/>
* Transactions can be nested.
* Starting or ending a nested transaction will return false.
* Nested transactions will share the same {@link Transaction} list of {@link ChangedEvent}s.
* <p/>
* Starting a transaction will not necessarily cause {@link #currentTransaction} to be non-null.
* A {@link Transaction} object is usually only created by {@link #handleChanged} when a {@link ChangedEvent} first occurs.
* @this {UndoManager}
* @param {string=} tname a short string describing the transaction, pushed onto the {@link #nestedTransactionNames} stack.
* @return {boolean} true if starting a top-level transaction.
* @see #commitTransaction
* @see #rollbackTransaction
*/
UndoManager.prototype.startTransaction = function(tname) {
  if (tname === undefined/*notpresent*/) tname = '';
  if (tname === null) tname = '';
  if (this.isUndoingRedoing) return false;
  if (this._firstTransaction === true) {
    this._firstTransaction = false;
    // do initial layout, pretend we are within a transaction, even if isEnabled is false
    this._transactionLevel++;
    this._raiseChanged('StartingFirstTransaction', tname, this.currentTransaction);
    if (this._transactionLevel > 0) this._transactionLevel--;
  }
  if (this.isEnabled) {
    this._nestedTransactionNames.thaw();
    this._nestedTransactionNames.add(tname);
    this._nestedTransactionNames.freeze();
    if (this.currentTransaction === null) {
      this._nestedTransactionStarts.add(0);
    } else {
      this._nestedTransactionStarts.add(this.currentTransaction.changes.count);
    }
  }
  this._transactionLevel++;
  var result = (this.transactionLevel === 1);
  if (result) {
    this._raiseChanged('StartedTransaction', tname, this.currentTransaction);
  }
  return result;
};

UndoManager.prototype['commitTransaction'] =
/**
* Commit the current transaction started by a call to {@link #startTransaction}.
* <p/>
* For convenience, this method is called by {@link Model#commitTransaction} and {@link Diagram#commitTransaction}.
* <p/>
* If this call stops a top-level transaction,
* we mark the {@link #currentTransaction} as complete ({@link Transaction#isComplete}),
* we add the {@link Transaction} to the {@link #history} list,
* and we return true.
* Committing a transaction when there have been some undos without corresponding
* redos will throw away the {@link Transaction}s holding changes that happened
* after the current state, before adding the new {@link Transaction} to the
* {@link #history} list.
* @this {UndoManager}
* @param {string} tname a short string describing the transaction;
*        this is recorded as the {@link Transaction#name} and need not be the same as the string passed to {@link #startTransaction}.
* @return {boolean} true if ending a top-level transaction.
* @see #startTransaction
* @see #rollbackTransaction
*/
UndoManager.prototype.commitTransaction = function(tname) {
  return this._endTransaction(true, tname);
};

UndoManager.prototype['rollbackTransaction'] =
/**
* Rollback the current transaction started by a call to {@link #startTransaction}, undoing any changes.
* <p/>
* For convenience, this method is called by {@link Model#rollbackTransaction} and {@link Diagram#rollbackTransaction}.
* <p/>
* This undoes and then discards the changes in the {@link #currentTransaction}.
* You must have started a transaction previously.
* @this {UndoManager}
* @return {boolean} true if ending a top-level transaction.
* @see #startTransaction
* @see #commitTransaction
*/
UndoManager.prototype.rollbackTransaction = function() {
  return this._endTransaction(false, '');
};

/**
* @ignore
* @param {boolean} commit
* @param {string} tname a short string describing the transaction.
* @return {boolean}
*/
UndoManager.prototype._endTransaction = function(commit, tname) {
  if (this.isUndoingRedoing) return false;
  if (this.checksTransactionLevel && this.transactionLevel < 1) {
    Util.trace('Ending transaction without having started a transaction: ' + tname);
  }
  var toplevel = (this.transactionLevel === 1);
  // before decrementing the transaction level, notify diagrams so that they can update,
  // especially any invalid layouts
  if (toplevel && commit && this.isEnabled) {
    this._raiseChanged('CommittingTransaction', tname, this.currentTransaction);
  }
  var start = 0;
  // decrement the transaction level, but not below zero
  if (this.transactionLevel > 0) {
    this._transactionLevel--;
    if (this.isEnabled) {
      var numnames = this._nestedTransactionNames.count;
      if (numnames > 0) {
        if (tname === '') tname = this._nestedTransactionNames.elt(0);
        this._nestedTransactionNames.thaw();
        this._nestedTransactionNames.removeAt(numnames - 1);
        this._nestedTransactionNames.freeze();
      }
      var numstarts = this._nestedTransactionStarts.count;
      if (numstarts > 0) {
        start = this._nestedTransactionStarts.elt(numstarts - 1);
        this._nestedTransactionStarts.removeAt(numstarts - 1);
      }
    }
  }
  var curr = this.currentTransaction;
  if (toplevel) {
    if (commit) {
      if (this.isEnabled) {
        // finish the current transaction
        if (curr !== null) {
          var cedit = curr;
          cedit.isComplete = true;
          cedit.name = tname;
          var hist = this.history;
          hist.thaw();
          // throw away any compound edits following the current index
          for (var i = hist.count - 1; i > this.historyIndex; i--) {
            var t = hist.elt(i);
            if (t !== null) t.clear();
            hist.removeAt(i);
          }
          // if there is a limit, just throw away the oldest transaction
          var max = this.maxHistoryLength;
          if (max === 0) max = 1;
          if (max > 0) {
            if (hist.count >= max) {
              var t = hist.elt(0);
              if (t !== null) t.clear();
              hist.removeAt(0);
              this._historyIndex--;
            }
          }
          // add to History list
          hist.add(cedit);
          this._historyIndex++;
          hist.freeze();
          curr = cedit;
        }
      }
      this._raiseChanged('CommittedTransaction', tname, curr);
    } else {  // !commit
      this._isUndoingRedoing = true;
      try {
        if (this.isEnabled && curr !== null) {
          // rollback the current transaction by undoing all of its changes
          curr.isComplete = true;
          curr.undo();
        }
      } finally {
        this._raiseChanged('RolledBackTransaction', tname, curr);
        this._isUndoingRedoing = false;
      }
      // now we can throw away all those undone changes
      if (curr !== null) curr.clear();
    }
    this._currentTransaction = null;
    return true;
  } else {  // !toplevel
    if (this.isEnabled) {
      // rollback the current transaction by undoing all of its edits,
      // but not of parent transactions
      if (!commit && curr !== null) {
        curr.rollbackTo(start);
      }
    }
    return false;
  }
};


UndoManager.prototype['canUndo'] =
/**
* This predicate returns true if you can call {@link #undo}.
* This will return false if {@link #isEnabled} is false (as it is by default),
* if any transaction is ongoing, if any undo or redo is occurring, or
* if there is no {@link #transactionToUndo} that can be undone.
* @this {UndoManager}
* @return {boolean} true if ready for {@link #undo} to be called.
*/
UndoManager.prototype.canUndo = function() {
  if (!this.isEnabled) return false;
  if (this.transactionLevel > 0) return false;
  if (this.isUndoingRedoing) return false;
  var curr = this.transactionToUndo;
  if (curr !== null && curr.canUndo()) return true;
  return false;
};

UndoManager.prototype['undo'] =
/**
* Reverse the effects of the {@link #transactionToUndo}.
* {@link #canUndo} must be true for this method to have any effect.
* <p/>
* This is called by {@link CommandHandler#undo}.
* <p/>
* This will raise a "StartingUndo" {@link ChangedEvent} of type {@link ChangedEvent#Transaction},
* perform the {@link Transaction#undo} on the {@link #transactionToUndo}, and then
* raise a "FinishedUndo" {@link ChangedEvent} of type {@link ChangedEvent#Transaction}.
* The two ChangedEvents are to let model listeners know that an undo is about to take place
* and that it just finished.
* {@link #isUndoingRedoing} will temporarily be set to true during this operation.
* @this {UndoManager}
*/
UndoManager.prototype.undo = function() {
  if (!this.canUndo()) return;
  var tx = this.transactionToUndo;
  try {
    this._raiseChanged('StartingUndo', 'Undo', tx);
    this._isUndoingRedoing = true;
    this._historyIndex--;
    tx.undo();
  } catch (ex) {
    Util.trace('undo error: ' + ex.toString());
  } finally {
    this._isUndoingRedoing = false;
    this._raiseChanged('FinishedUndo', 'Undo', tx);
  }
};

UndoManager.prototype['canRedo'] =
/**
* This predicate returns true if you can call {@link #redo}.
* This will return false if {@link #isEnabled} is false (as it is by default),
* if any transaction is ongoing, if any undo or redo is occurring, or
* if there is no {@link #transactionToRedo} that can be redone.
* @this {UndoManager}
* @return {boolean} true if ready for {@link #redo} to be called.
*/
UndoManager.prototype.canRedo = function() {
  if (!this.isEnabled) return false;
  if (this.transactionLevel > 0) return false;
  if (this.isUndoingRedoing) return false;
  var curr = this.transactionToRedo;
  if (curr !== null && curr.canRedo()) return true;
  return false;
};

UndoManager.prototype['redo'] =
/**
* After an {@link #undo}, re-perform the changes in {@link #transactionToRedo}.
* {@link #canRedo} must be true for this method to have any effect.
* <p/>
* This is called by {@link CommandHandler#redo}.
* <p/>
* This will raise a "StartingRedo" {@link ChangedEvent} of type {@link ChangedEvent#Transaction},
* perform the {@link Transaction#redo} on the {@link #transactionToRedo}, and then
* raise a "FinishedRedo" {@link ChangedEvent} of type {@link ChangedEvent#Transaction}.
* The two ChangedEvents are to let model listeners know that a redo is about to take place
* and that it just finished.
* {@link #isUndoingRedoing} will temporarily be set to true during this operation.
* @this {UndoManager}
*/
UndoManager.prototype.redo = function() {
  if (!this.canRedo()) return;
  var tx = this.transactionToRedo;
  try {
    this._raiseChanged('StartingRedo', 'Redo', tx);
    this._isUndoingRedoing = true;
    this._historyIndex++;
    tx.redo();
  } catch (ex) {
    Util.trace('redo error: ' + ex.toString());
  } finally {
    this._isUndoingRedoing = false;
    this._raiseChanged('FinishedRedo', 'Redo', tx);
  }
};


/**
* @ignore
* An internal method for raising Transaction ChangedEvents.
* @this {UndoManager}
* @param {string} ch the transaction type.
* @param {string} tname the Transaction name, or "Undo" or "Redo", or the property name for Property changes.
* @param {Transaction=} val the Transaction itself, if available.
*/
UndoManager.prototype._raiseChanged = function(ch, tname, val) {
  if (val === undefined/*notpresent*/) val = null;
  var e = new ChangedEvent();
  e.change = ChangedEvent.Transaction;
  e.propertyName = ch;
  e.object = val;  // might be null
  e.oldValue = tname;
  var mit = this.models;
  while (mit.next()) {
    var m = mit.value;
    e.model = m;
    m.callChangedListeners(e);
  }
};

UndoManager.prototype['handleChanged'] =
/**
* Maybe record a {@link ChangedEvent} in the {@link #currentTransaction}.
* This calls {@link #skipsEvent} to see if this should ignore the change.
* If {@link #skipsEvent} returns false, this creates a copy of the {@link ChangedEvent}
* and adds it to the {@link #currentTransaction}.
* If there is no {@link #currentTransaction}, this first creates and remembers it.
* <p/>
* This method always ignores all changes while performing
* an {@link #undo} or {@link #redo}.
* This method is also a no-op if {@link #isEnabled} is false.
* @this {UndoManager}
* @param {ChangedEvent} e a {@link ChangedEvent}.
*/
UndoManager.prototype.handleChanged = function(e) {
  if (!this.isEnabled) return;
  if (this.isUndoingRedoing) return;
  if (!this.skipsEvent(e)) {
    var curr = this.currentTransaction;
    if (curr === null) {
      curr = new Transaction();
      this._currentTransaction = curr;
    }
    var copy = e.copy();
    var chs = curr.changes;
    chs.thaw();
    chs.add(copy);
    chs.freeze();
    if (this.checksTransactionLevel && this.transactionLevel <= 0 && !this._firstTransaction) {
      var diagram = e.diagram;
      if (diagram !== null && diagram._initialLayoutCompleted === false) return;
      Util.trace('Change not within a transaction: ' + copy.toString());
    }
  }
};

/**
* This predicate is called by {@link #handleChanged} to decide if a {@link ChangedEvent}
* is not interesting enough to be remembered.
* <p/>
* Transactional events (of change type {@link ChangedEvent#Transaction}) are always skipped.
* Changed events for {@link GraphObject}s that are in {@link Layer#isTemporary} layers are also skipped.
* <p/>
* Sometimes changed events do not even get to {@link #handleChanged} because
* {@link Model#skipsUndoManager} or {@link Diagram#skipsUndoManager} is true.
* @expose
* @this {UndoManager}
* @param {ChangedEvent} e the {@link ChangedEvent} received by {@link #handleChanged}.
* @return {boolean} true to not record the change.
*/
UndoManager.prototype.skipsEvent = function(e) {
  if (e === null) return true;
  if (e.change.value < 0) return true;

  var obj = e.object;
  if (obj instanceof GraphObject) {
    var lay = obj.layer;
    if (lay !== null) {
      if (lay.isTemporary) return true;
    }
  } else if (obj instanceof Layer) {
    if (obj.isTemporary) return true;
  }

  return false;
};

/**
* Gets an iterator for all of the {@link Model}s that this UndoManager is handling.
* @name UndoManager#models
* @function.
* @return {Iterator}
* @see UndoManager#addModel
* @see UndoManager#removeModel
*/
/** @type {Iterator} */
UndoManager.prototype.models;
Util.defineReadOnlyProperty(UndoManager, {models: 'models'},
  /** @this {UndoManager} */
  function() { return this._models.iterator; }
);

/**
* Gets or sets whether this UndoManager records any changes.
* The default value is false -- you need to set this to true if
* you want the user to be able to undo or redo.
* <p/>
* You can temporarily turn off recording by setting {@link Diagram#skipsUndoManager}
* and {@link Model#skipsUndoManager} to true.
* @name UndoManager#isEnabled
* @function.
* @return {boolean}
*/
/** @type {boolean} */
UndoManager.prototype.isEnabled;
Util.exportProperty(UndoManager, 'isEnabled', UndoManager.prototype.isEnabled);
Util.defineProperty(UndoManager, { isEnabled: 'isEnabled' },
  /** @this {UndoManager} */
  function() { return this._isEnabled; },
  /** @this {UndoManager} */
  function(val) { this._isEnabled = val; }
);

/**
* Gets the {@link Transaction} in the {@link #history} to be undone next.
* The value may be null if the UndoManager is not ready to perform an undo.
* @name UndoManager#transactionToUndo
* @function.
* @return {Transaction}
* @see UndoManager#transactionToRedo
*/
/** @type {Transaction} */
UndoManager.prototype.transactionToUndo;
Util.defineReadOnlyProperty(UndoManager, {transactionToUndo: 'transactionToUndo'},
  /** @this {UndoManager} */
  function() {
    if (this.historyIndex >= 0 &&
      this.historyIndex <= this.history.count - 1) {
      return this.history.elt(this.historyIndex);
    }
    return null;
  }
);

/**
* Gets the {@link Transaction} in the {@link #history} to be redone next.
* The value may be null if the UndoManager is not ready to perform a redo.
* @name UndoManager#transactionToRedo
* @function.
* @return {Transaction}
* @see UndoManager#transactionToUndo
*/
/** @type {Transaction} */
UndoManager.prototype.transactionToRedo;
Util.defineReadOnlyProperty(UndoManager, {transactionToRedo: 'transactionToRedo'},
  /** @this {UndoManager} */
  function() {
    if (this.historyIndex < this.history.count - 1) {
      return this.history.elt(this.historyIndex + 1);
    }
    return null;
  }
);

/**
* This property is true during a call to {@link #undo} or {@link #redo}.
* @name UndoManager#isUndoingRedoing
* @function.
* @return {boolean}
*/
/** @type {boolean} */
UndoManager.prototype.isUndoingRedoing;
Util.defineReadOnlyProperty(UndoManager, {isUndoingRedoing: 'isUndoingRedoing'},
  /** @this {UndoManager} */
  function() { return this._isUndoingRedoing; }
);

/**
* Gets the whole history, a list of all of the {@link Transaction}s,
* each representing a transaction with some number of {@link ChangedEvent}s.
* <p/>
* You should not modify this List.
* @name UndoManager#history
* @function.
* @return {List}
*/
/** @type {List} */
UndoManager.prototype.history;
Util.defineReadOnlyProperty(UndoManager, {history: 'history'},
  /** @this {UndoManager} */
  function() { return this._history; }
);

/**
* Gets or sets the maximum number of transactions that this undo manager will remember.
* When a transaction is committed and the number exceeds this value,
* the UndoManager will discard the oldest transaction(s).
* The initial value is 999.
* A negative value is treated as if there were no limit.
* <p/>
* This property is useful in helping limit the memory consumption of typical applications.
* But this does not limit the number of {@link ChangedEvent}s that are recorded,
* because there may be an unlimited number of those within each {@link Transaction}.
* Decreasing this value will not necessarily remove any existing {@link Transaction}s
* if there currently exist more in {@link #history} than the new value permits.
* @name UndoManager#maxHistoryLength
* @function.
* @return {number}
*/
/** @type {number} */
UndoManager.prototype.maxHistoryLength;
Util.exportProperty(UndoManager, 'maxHistoryLength', UndoManager.prototype.maxHistoryLength);
Util.defineProperty(UndoManager, { maxHistoryLength: 'maxHistoryLength' },
  /** @this {UndoManager} */
  function() { return this._maxHistoryLength; },
  /** @this {UndoManager} */
  function(val) { this._maxHistoryLength = val; }
);

/**
* Gets the index into {@link #history} for the current undoable {@link Transaction}.
* The value is -1 if there is no undoable {@link Transaction} to be undone.
* @name UndoManager#historyIndex
* @function.
* @return {number}
*/
/** @type {number} */
UndoManager.prototype.historyIndex;
Util.defineReadOnlyProperty(UndoManager, {historyIndex: 'historyIndex'},
  /** @this {UndoManager} */
  function() { return this._historyIndex; }
);

/**
* Gets the current {@link Transaction} for recording additional model change events.
* This is initialized and augmented by {@link #handleChanged}
* before it is added to {@link #history} by a top-level call
* to {@link #commitTransaction}.
* The value will be null between transactions.
* @name UndoManager#currentTransaction
* @function.
* @return {Transaction}
*/
/** @type {Transaction} */
UndoManager.prototype.currentTransaction;
Util.defineReadOnlyProperty(UndoManager, {currentTransaction: 'currentTransaction'},
  /** @this {UndoManager} */
  function() { return this._currentTransaction; }
);

/**
* Gets the current transaction level.
* The value is zero when there is no ongoing transaction.
* The initial value is zero.
* {@link #startTransaction} will increment this value;
* {@link #commitTransaction} or {@link #rollbackTransaction} will decrement it.
* When this value is greater than zero, {@link #canUndo}
* and {@link #canRedo} will be false, because
* additional logically related model change events may occur.
* @name UndoManager#transactionLevel
* @function.
* @return {number}
*/
/** @type {number} */
UndoManager.prototype.transactionLevel;
Util.defineReadOnlyProperty(UndoManager, {transactionLevel: 'transactionLevel'},
  /** @this {UndoManager} */
  function() { return this._transactionLevel; }
);

/**
* This property is true after the first call to {@link #startTransaction}
* and before a corresponding call to {@link #commitTransaction} or {@link #rollbackTransaction}.
* <p/>
* During a transaction {@link #canUndo} and {@link #canRedo} will be false.
* {@link #currentTransaction} may be non-null if any {@link ChangedEvent}s were recorded.
* @name UndoManager#isInTransaction
* @function.
* @return {boolean}
*/
/** @type {boolean} */
UndoManager.prototype.isInTransaction;
Util.defineReadOnlyProperty(UndoManager, {isInTransaction: 'isInTransaction'},
  /** @this {UndoManager} */
  function() { return this._transactionLevel > 0; }
);

/**
* @ignore
* Gets or sets whether the system should issue warnings if the {@link #transactionLevel}
* appears to be inconsistent with current behavior.
* The default value is false.
* @name UndoManager#checksTransactionLevel
* @function.
* @return {boolean}
*/
/** @type {boolean} */
UndoManager.prototype.checksTransactionLevel;
Util.defineProperty(UndoManager, {checksTransactionLevel: 'checksTransactionLevel'},
  /** @this {UndoManager} */
  function() { return this._checksTransactionLevel; },
  /** @this {UndoManager} */
  function(val) { this._checksTransactionLevel = val; }
);

/**
* Gets a stack of ongoing transaction names.
* The outermost transaction name will be the first item in the list.
* The last one will be the name of the most recent (nested) call
* to {@link #startTransaction}.
* <p/>
* You should not modify this List.
* @name UndoManager#nestedTransactionNames
* @function.
* @return {List}
*/
/** @type {List} */
UndoManager.prototype.nestedTransactionNames;
Util.defineReadOnlyProperty(UndoManager, {nestedTransactionNames: 'nestedTransactionNames'},
  /** @this {UndoManager} */
  function() { return this._nestedTransactionNames; }
);

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
CommandHandler
*/

/**
 * The constructor produces a CommandHandler with the default key bindings.
 * @constructor
 * @class
 * The {@link Diagram#commandHandler} implements various
 * commands such as {@link CommandHandler#deleteSelection} or {@link CommandHandler#redo}.
 * The CommandHandler includes keyboard event handling to interpret
 * key presses as commands.
 * <p/>
 * CommandHandlers cannot be shared amongst multiple Diagrams.
 * <p/>
 * You may define a CommandHandler subclass and override methods.
 * However you must seriously consider calling the base method in order to gets its default behavior.
 * There may be situations where not calling the base method may cause subtle bugs,
 * but that depends on the method.
 * <p>
 * The CommandHandler implements the following command bindings for keyboard input in {@link #doKeyDown}:
 * </p>
 * <ul>
 *   <li><code>Del</code> invokes {@link #deleteSelection}</li>
 *   <li><code>Ctrl-X</code> & <code>Shift-Del</code> invoke {@link #cutSelection}</li>
 *   <li><code>Ctrl-C</code> & <code>Ctrl-Insert</code> invoke {@link #copySelection}</li>
 *   <li><code>Ctrl-V</code> & <code>Shift-Insert</code> invoke {@link #pasteSelection}</li>
 *   <li><code>Ctrl-A</code> invokes {@link #selectAll}</li>
 *   <li><code>Ctrl-Z</code> & <code>Alt-Backspace</code> invoke {@link #undo}</li>
 *   <li><code>Ctrl-Y</code> & <code>Alt-Shift-Backspace</code> invoke {@link #redo}</li>
 *   <li><code>Up</code> & <code>Down</code> & <code>Left</code> & <code>Right</code> (arrow keys) invoke <a>Diagram.scroll}</li>
 *   <li><code>PageUp</code> & <code>PageDown</code> invoke <a>Diagram.scroll}</li>
 *   <li><code>Home</code> & <code>End</code> set <a>Diagram.position}</li>
 *   <li><code>Keypad--</code> (minus) invokes {@link #decreaseZoom}</li>
 *   <li><code>Keypad-+</code> (plus) invokes {@link #increaseZoom}</li>
 *   <li><code>Ctrl-0</code> invokes {@link #resetZoom}</li>
 *   <li><code>Shift-Z</code> invokes {@link #zoomToFit}; repeat to return to the original scale and position</li>
 *   <li><code>Ctrl-G</code> invokes {@link #groupSelection}</li>
 *   <li><code>Ctrl-Shift-G</code> invokes {@link #ungroupSelection}</li>
 *   <li><code>F2</code> invokes {@link #editTextBlock}</li>
 *   <li><code>Menu Key</code> invokes {@link #showContextMenu}</li>
 *   <li><code>Esc</code> invokes {@link #stopCommand}</li>
 * </ul>
 */
function CommandHandler() {
  if (arguments.length > 0) {
    Util.throwError('CommandHandler constructor cannot take any arguments.');
  }
  /** @type {Diagram} */
  this._diagram = null;
  /** @type {boolean} */
  this._copiesTree = false;
  /** @type {boolean} */
  this._deletesTree = false;
  /** @type {Object} */
  this._archetypeGroupData = null;
  /** @type {function(Group, Part):boolean | null} */
  this._memberValidation = null;
  /** @type {number} */
  this._zoomFactor = 1.05;
  /** @type {number} */
  this._lastScale = NaN;
  /** @type {Point} */
  this._lastPosition = null;
  /** @type {number} */
  this._zoomScale = NaN;
}

Util.publish('CommandHandler', CommandHandler);

/**
* @ignore
* @this {CommandHandler}
* @param {number=} details Optional: If greater than zero, this may include additional descriptions.
* @return {string} A human-readable string.
*/
CommandHandler.prototype.toString = function(details) {
  return 'CommandHandler';
};


/**
* Gets the {@link Diagram} that is using this CommandHandler.
* @name CommandHandler#diagram
* @function.
* @return {Diagram}
*/
/** @type {Diagram} */
CommandHandler.prototype.diagram;
Util.defineReadOnlyProperty(CommandHandler, {diagram: 'diagram'},
  /** @this {CommandHandler} */
  function() { return this._diagram; }
);

/**
* @ignore
* @this {CommandHandler}
* @param {Diagram} val
*/
CommandHandler.prototype.setDiagram = function(val) {
  if (Debug && val !== null) Util.checkClass(val, Diagram, CommandHandler, 'setDiagram');
  this._diagram = val;
};


/**
* This is called by tools to handle keyboard commands.
* For most commands, this calls the "can..." predicate; if that returns true it calls the command method.
* For key-down events that are not keyboard commands, this sets {@link InputEvent#bubbles} to true
* to allow the browser to handle those events in its normal manner.
* <p>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
*/
CommandHandler.prototype.doKeyDown = function() {
  var diagram = this.diagram;
  if (diagram === null) return;

  var e = diagram.lastInput;
  var control = e.control;
  var shift = e.shift;
  var alt = e.alt;
  var key = e.key;

  if (control && (key === 'C' || key === 'Insert')) {
    if (this.canCopySelection()) this.copySelection();
  } else if ((control && key === 'X') || (shift && key === 'Del')) {
    if (this.canCutSelection()) this.cutSelection();
  } else if (key === 'Del') {
    if (this.canDeleteSelection()) this.deleteSelection();
  } else if ((control && key === 'V') || (shift && key === 'Insert')) {
    if (this.canPasteSelection()) this.pasteSelection();
  } else if ((control && key === 'Y') || (alt && shift && key === 'Backspace')) {
    if (this.canRedo()) this.redo();
  } else if ((control && key === 'Z') || (alt && key === 'Backspace')) {
    if (this.canUndo()) this.undo();
  } else if (control && key === 'A') {
    if (this.canSelectAll()) this.selectAll();
  } else if (key === 'Esc') {
    if (this.canStopCommand()) this.stopCommand();
  } else if (key === 'Up') {
    if (diagram.allowVerticalScroll) {
      if (control)
        diagram.scroll('pixel', 'up');
      else
        diagram.scroll('line', 'up');
    }
  } else if (key === 'Down') {
    if (diagram.allowVerticalScroll) {
      if (control)
        diagram.scroll('pixel', 'down');
      else
        diagram.scroll('line', 'down');
    }
  } else if (key === 'Left') {
    if (diagram.allowHorizontalScroll) {
      if (control)
        diagram.scroll('pixel', 'left');
      else
        diagram.scroll('line', 'left');
    }
  } else if (key === 'Right') {
    if (diagram.allowHorizontalScroll) {
      if (control)
        diagram.scroll('pixel', 'right');
      else
        diagram.scroll('line', 'right');
    }
  } else if (key === 'PageUp') {
    if (shift && diagram.allowHorizontalScroll)
      diagram.scroll('page', 'left');
    else if (diagram.allowVerticalScroll)
      diagram.scroll('page', 'up');
  } else if (key === 'PageDown') {
    if (shift && diagram.allowHorizontalScroll)
      diagram.scroll('page', 'right');
    else if (diagram.allowVerticalScroll)
      diagram.scroll('page', 'down');
  } else if (key === 'Home') {
    var b = diagram.documentBounds;
    if (control && diagram.allowVerticalScroll) {
      diagram.position = new Point(diagram.position.x, b.y);
    } else if (!control && diagram.allowHorizontalScroll) {
      diagram.position = new Point(b.x, diagram.position.y);
    }
  } else if (key === 'End') {
    var b = diagram.documentBounds;
    var v = diagram.viewportBounds;
    if (control && diagram.allowVerticalScroll) {
      diagram.position = new Point(v.x, b.bottom - v.height);
    } else if (!control && diagram.allowHorizontalScroll) {
      diagram.position = new Point(b.right - v.width, v.y);
    }
  } else if (key === 'Subtract') {  //?? keypad: different than '-'
    if (this.canDecreaseZoom()) this.decreaseZoom();
  } else if (key === 'Add') {  //?? keypad: different than '+'
    if (this.canIncreaseZoom()) this.increaseZoom();
  } else if (control && key === '0') {
    if (this.canResetZoom()) this.resetZoom();
  } else if (shift && key === 'Z') {
    if (this.canZoomToFit()) this.zoomToFit();
  } else if (control && !shift && key === 'G') {
    if (this.canGroupSelection()) this.groupSelection();
  } else if (control && shift && key === 'G') {
    if (this.canUngroupSelection()) this.ungroupSelection();
  } else if (e.event && e.event.which === 113) { // F2
    if (this.canEditTextBlock()) this.editTextBlock();
  } else if (e.event && e.event.which === 93) { // Context Menu button
    if (this.canShowContextMenu()) this.showContextMenu();
  } else {
    e.bubbles = true;  // pass on other keys up to the browser
  }
};

/**
* This is called by tools to handle keyboard commands.
* <p/>
* By default this sets {@link InputEvent#bubbles} to true
* to allow the browser to handle key-up events in its normal manner.
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
*/
CommandHandler.prototype.doKeyUp = function() {
  var diagram = this.diagram;
  if (diagram === null) return;

  var e = diagram.lastInput;
  e.bubbles = true;  // pass on other keys up to the browser
};


/**
* Cancel the operation of the current tool.
* This is typically called when the user presses ESCAPE.
* If the current tool is a {@link ToolManager}, this clears the diagram's selection.
* This then calls {@link Tool#doCancel} on the current tool.
* @expose
* @this {CommandHandler}
*/
CommandHandler.prototype.stopCommand = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  var tool = diagram.currentTool;
  if (tool instanceof ToolManager && diagram.allowSelect) {
    diagram.clearSelection();  // raises ChangingSelection/Finished
  }
  if (tool !== null) {
    tool.doCancel();
  }
};

/**
* This predicate controls whether the user may stop the current tool.
* This just returns true.
* This method may be overridden.
* @expose
* @this {CommandHandler}
* @return {boolean} true.
*/
CommandHandler.prototype.canStopCommand = function() {
  return true;
};


/**
* Select all of the selectable {@link Part}s in the diagram.
* <p/>
* This method raises the "ChangingSelection" and "ChangedSelection" diagram events.
* This ignores all parts in temporary layers.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
*/
CommandHandler.prototype.selectAll = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  // since every object on the screen will probably need a redraw,
  // might as well skip viewport optimizations:
  diagram.invalidateDraw();
  try {
    diagram.currentCursor = 'wait';
    diagram.raiseDiagramEvent('ChangingSelection');
    var it = diagram.parts;
    while (it.next()) {
      var part = it.value;
      part.isSelected = true;
    }
    it = diagram.nodes;
    while (it.next()) {
      var node = it.value;
      node.isSelected = true;
    }
    it = diagram.links;
    while (it.next()) {
      var link = it.value;
      link.isSelected = true;
    }
  } finally {
    diagram.raiseDiagramEvent('ChangedSelection');
    diagram.currentCursor = '';
  }
};

/**
* This predicate controls whether or not the user can invoke the {@link #selectAll} command.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @return {boolean}
* This returns true if {@link Diagram#allowSelect} is true.
*/
CommandHandler.prototype.canSelectAll = function() {
  var diagram = this.diagram;
  return (diagram !== null && diagram.allowSelect);
};


/**
* Delete the currently selected parts from the diagram.
* <p/>
* This will raise the "SelectionDeleting" {@link DiagramEvent} beforehand,
* and the "SelectionDeleted" diagram event afterwards.
* The "SelectionDeleting" event is cancelable -- if the {@link DiagramEvent#cancel}
* property is set to true by any DiagramEvent listeners,
* the selection will not be deleted.
* <p/>
* Because this command, if not canceled, changes the selection,
* this method also raises the "ChangingSelection" and "ChangedSelection" diagram events.
* All changes are performed within a transaction.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
*/
CommandHandler.prototype.deleteSelection = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  if (diagram.raiseDiagramEvent('SelectionDeleting', diagram.selection)) return;
  try {
    diagram.currentCursor = 'wait';
    diagram.startTransaction('Delete');
    diagram.raiseDiagramEvent('ChangingSelection');
    // collect all of the parts to delete
    var allobjs = new Set(Part);
    var it = diagram.selection.iterator;
    while (it.next()) {
      CommandHandler.gatherCollection(allobjs, it.value, true, this.deletesTree ? Infinity : 0,
                                      function(p) { return p.canDelete(); });
    }
    // remove all of the deletable parts
    diagram.removeParts(allobjs, true);
    diagram.raiseDiagramEvent('SelectionDeleted', allobjs);
  } finally {
    diagram.raiseDiagramEvent('ChangedSelection');
    diagram.commitTransaction('Delete');
    diagram.currentCursor = '';
  }
};

/**
* This predicate controls whether or not the user can invoke the {@link #deleteSelection} command.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @return {boolean}
* This returns true:
* if the diagram is not {@link Diagram#isReadOnly},
* if {@link Diagram#allowDelete} is true, and
* if there are some selected {@link Part}s.
*/
CommandHandler.prototype.canDeleteSelection = function() {
  var diagram = this.diagram;
  if (diagram === null || diagram.isReadOnly || diagram.isModelReadOnly) return false;
  if (!diagram.allowDelete) return false;
  if (diagram.selection.count === 0) return false;
  return true;
};


/**
* @ignore
* Static method for collecting the member Parts of a Group,
* or the tree children of a Node, or maybe even both.
* This excludes any Adornments that might be encountered.
* This will include the initial part P in the result collection,
* unless the predicate is false for that part.
* @param {Set} coll the {@link Set} that is modified to hold the results.
* @param {Part} p the {Part} from which to start the traversal.
* @param {boolean} groupmembers whether to include member parts.
* @param {number} treechildren the number of levels of tree children to include (1 or less means just the node itself, no children).
* @param {function(Part):boolean | null=} pred a predicate to execute on each part found,
* if the predicate returns false, the part is not included in the result.
*/
CommandHandler.gatherCollection = function(coll, p, groupmembers, treechildren, pred) {
  if (coll.contains(p)) return;  // already seen
  if (pred === undefined/*notpresent*/) pred = null;
  if (pred !== null) {
    if (!pred(p)) return;  // filtered out
  }
  if (p instanceof Adornment) return;  // exclude Adornments
  coll.add(p);
  if (p instanceof Node) { // dont need to check for Part since
    var n = p;
    if (groupmembers && n instanceof Group) {
      var g = n;
      var mit = g.memberParts;
      while (mit.next()) {
        var c = mit.value;
        CommandHandler.gatherCollection(coll, c, groupmembers, treechildren, pred);
      }
    }
    var lit = n.linksConnected;
    while (lit.next()) {
      var l = lit.value;
      if (coll.contains(l)) continue;
      var from = l.fromNode;
      var to = l.toNode;
      if (from !== null && coll.contains(from) &&
          to !== null && coll.contains(to)) {
        CommandHandler.gatherCollection(coll, l, groupmembers, treechildren, pred);
      } else if (from === null || to === null) {
        CommandHandler.gatherCollection(coll, l, groupmembers, treechildren, pred);
      }
    }
    if (treechildren > 1) {
      var it = n.findTreeChildrenNodes();
      while (it.next()) {
        var c = it.value;
        CommandHandler.gatherCollection(coll, c, groupmembers, treechildren - 1, pred);
      }
    }
  } else if (p instanceof Link) {
    var l = p;
    var lit = l.labelNodes;
    while (lit.next()) {
      var lab = lit.value;
      CommandHandler.gatherCollection(coll, lab, groupmembers, treechildren, pred);
    }
  }
  // include plain Parts, without additional traversal
};


/**
* @ignore
* @expose
* This method makes a copy of a collection of {@link Part}s.
* This is not a command and thus does not perform a transaction nor does it raise a {@link DiagramEvent}.
* @this {CommandHandler}
* @param {Iterable} coll  A {@link List} or a {@link Set} of Parts.
* @param {Diagram} diagram  The destination diagram; if null, the copied parts are not added to this diagram.
* @param {boolean} check  Whether to check {@link Part#canCopy} on each part.
* @return {Map}  Map(Part, Part).
*/
CommandHandler.prototype.copyParts = function(coll, diagram, check) {
  var dict = new Map(Part, Part);
  var it = coll.iterator;
  while (it.next()) {
    var part = it.value;
    this.copyPart(part, diagram, dict, check);
  }

  if (diagram !== null) {
    var model = diagram.model;
    var discos = new Set(Link);
    var plinks = new Map(Link, Link);
    var dit = dict.iterator;
    while (dit.next()) {
      var part = dit.value;
      if (part instanceof Link) {
        var link = part;  // a copied Link
        //??? do not copy links that are partly or fully disconnected
        if (link.fromNode === null || link.toNode === null) {
          discos.add(link);
        }
      } else if (model instanceof TreeModel && part instanceof Node && part.data !== null) {
        var copiednode = part;
        // for a TreeModel, there is no link data to be copied for a Link --
        // so we have to look at the copied node data to see if we need to copy a parent Link
        var orignode = dit.key;
        var origparent = orignode.findTreeParentNode();
        if (origparent !== null) {
          var copiedparent = dict.getValue(origparent);
          // modify the copied node data to have a reference to the copied parent data
          if (copiedparent) {
            model.setParentKeyForNodeData(copiednode.data, model.getKeyForNodeData(copiedparent.data));
            // which should automatically create a parent Link in the target diagram
            // let's add the copied Link to the result Map for this copyParts method
            var copiedlink = diagram.findLinkForData(copiednode.data);
            var origlink = orignode.findTreeParentLink();
            if (origlink !== null && copiedlink !== null) plinks.add(origlink, copiedlink);
          } else {
            model.setParentKeyForNodeData(copiednode.data, undefined);
          }
        }
      }
    }
    if (discos.count > 0) {
      diagram.removeParts(discos, false);
    }
    if (plinks.count > 0) {
      // add the copied parent Links to the resulting Map
      var pit = plinks.iterator;
      while (pit.next()) dict.add(pit.key, pit.value);
    }
  }

  // update bindings in case any depend on source elements that were not available at the time
  // that the copy was added to the diagram
  var cit = dict.iterator;
  while (cit.next()) {
    var copy = cit.value;
    copy.updateTargetBindings();
  }
  return dict;
};

/**
* @ignore
* @this {CommandHandler}
* @param {Part} part
* @param {Diagram} diagram  The destination diagram; if null, the copied parts are not added to this diagram.
* @param {Map} dict  Map(Part, Part).
* @param {boolean} check
* @return {Part}  null if not copied.
*/
CommandHandler.prototype.copyPart = function(part, diagram, dict, check) {
  if (part === null) return null;
  if (check && !part.canCopy()) return null;

  // already there: just return it
  if (dict.contains(part)) {
    var p = dict.getValue(part);
    if (p instanceof Part) return p;
    return null;
  }

  // otherwise actually copy it:
  var copy = null;
  var data = part.data;
  if (data !== null && diagram !== null) {  // bound Part
    var model = diagram.model;
    if (part instanceof Link) {
      if (model instanceof GraphLinksModel) {
        var datacopy = model.copyLinkData(data);
        if (Util.isObject(datacopy)) {
          model.addLinkData(datacopy);
          copy = diagram.findLinkForData(datacopy);
        }
      }
      // if model instanceof TreeModel, Links cannot be copied independently at all;
      // instead we have to depend on a child node to be copied, and therefore implicitly any parent link
    } else {
      var datacopy = model.copyNodeData(data);
      if (Util.isObject(datacopy)) {
        model.addNodeData(datacopy);
        copy = diagram.findPartForData(datacopy);
      }
    }
  } else {  // unbound Part
    part.freezeBindings();
    copy = part.copy();
    if (diagram !== null && copy instanceof Part) {
      diagram.add(copy);
    }
  }
  if (!(copy instanceof Part)) return null;
  copy.isSelected = false;  //?? any other not-to-be-copied state
  dict.add(part, copy);
  if (part instanceof Node) { // Parts already taken care of by dict add
    var node = part;
    // fix up all connected links
    var lit = node.linksConnected;
    while (lit.next()) {
      var origlink = lit.value;
      if (origlink.fromNode === node) {
        var newlink = dict.getValue(origlink);
        if (newlink !== null) {
          newlink.fromNode = copy;
        }
      }
      if (origlink.toNode === node) {
        var newlink = dict.getValue(origlink);
        if (newlink !== null) {
          newlink.toNode = copy;
        }
      }
    }
    // if it's a Group, copy its members
    if (part instanceof Group && copy instanceof Group) {
      var group = part;
      var mit = group.memberParts;
      while (mit.next()) {
        var member = mit.value;
        // fix up container reference
        var memcopy = this.copyPart(member, diagram, dict, check);
        if (memcopy instanceof Link) {
        //  memcopy.setContainingGroup(copy);
        } else if (memcopy !== null) {
          memcopy.containingGroup = copy;
        }
      }
    }
  } else if (part instanceof Link) {
    var link = part;
    var origfrom = link.fromNode;
    if (origfrom !== null) {
      var newfrom = dict.getValue(origfrom);
      if (newfrom !== null) {
        copy.fromNode = newfrom;
      }
    }
    var origto = link.toNode;
    if (origto !== null) {
      var newto = dict.getValue(origto);
      if (newto !== null) {
        copy.toNode = newto;
      }
    }
    // if it has label nodes, copy them
    var labs = link.labelNodes;
    while (labs.next()) {
      var lab = labs.value;
      // fix up labeled Link reference
      var labcopy = this.copyPart(lab, diagram, dict, check);
      if (labcopy !== null) {
        labcopy.labeledLink = copy;
      }
    }
  }

  return copy;
};


// clipboard commands

/**
* Copy the currently selected parts, {@link Diagram#selection},
* from the {@link Diagram} into the clipboard.
* <p/>
* This makes a copy of the current selection by calling {@link #copyToClipboard}.
* This also raises the "ClipboardChanged" diagram event.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
*/
CommandHandler.prototype.copySelection = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  try {
    // collect all of the parts to copy
    var allobjs = new Set(Part);
    var it = diagram.selection.iterator;
    while (it.next()) {
      CommandHandler.gatherCollection(allobjs, it.value, true, this.copiesTree ? Infinity : 0,
                                      function(p) { return p.canCopy(); });
    }
    // copy to clipboard
    this.copyToClipboard(allobjs);
  } finally {
  }
};

/**
* This predicate controls whether or not the user can invoke the {@link #copySelection} command.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @return {boolean}
* This returns true:
* if {@link Diagram#allowCopy} is true,
* if {@link Diagram#allowClipboard} is true, and
* if there are some selected {@link Part}s.
*/
CommandHandler.prototype.canCopySelection = function() {
  var diagram = this.diagram;
  if (diagram === null || !diagram.allowCopy || !diagram.allowClipboard) return false;
  if (diagram.selection.count === 0) return false;
  return true;
};

/**
* Execute a {@link #copySelection} followed by a {@link #deleteSelection}.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
*/
CommandHandler.prototype.cutSelection = function() {
  this.copySelection();
  this.deleteSelection();
};

/**
* This predicate controls whether or not the user can invoke the {@link #cutSelection} command.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @return {boolean}
* This returns true:
* if the diagram is not {@link Diagram#isReadOnly},
* if {@link Diagram#allowCopy} is true,
* if {@link Diagram#allowDelete} is true,
* if {@link Diagram#allowClipboard} is true, and
* if there are some selected {@link Part}s.
*/
CommandHandler.prototype.canCutSelection = function() {
  var diagram = this.diagram;
  if (diagram === null || diagram.isReadOnly || diagram.isModelReadOnly) return false;
  if (!diagram.allowCopy || !diagram.allowDelete || !diagram.allowClipboard) return false;
  if (diagram.selection.count === 0) return false;
  return true;
};

/**
* This makes a copy of the given collection of {@link Part}s
* and stores it in a static variable acting as the clipboard.
* <p/>
* The clipboard is initially null.
* It can hold a collection of copied {@link Part}s.
* It also remembers the {@link Model#dataFormat} of the diagram
* from which the parts were copied.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @param {Iterable} coll A collection of {@link Part}s.
* If the value is null, the clipboard is cleared of all data.
*/
CommandHandler.prototype.copyToClipboard = function(coll) {
  var diagram = this.diagram;
  if (diagram === null) return;
  var clip = null;
  if (coll === null) {
    Util.clipboardParts = null;
    Util.clipboardFormat = '';
  } else {
    var dict = diagram.copyParts(coll, null, true);
    clip = new List(Part);
    clip.addAll(dict);
    //??? clip.sort(... by Z-order ...);
    Util.clipboardParts = clip;
    Util.clipboardFormat = diagram.model.dataFormat;
  }
  diagram.raiseDiagramEvent('ClipboardChanged', clip);
};

/**
* If the clipboard holds a collection of {@link Part}s,
* and if the {@link Model#dataFormat} matches that stored in the clipboard,
* this makes a copy of the clipboard's parts and adds the copies to this {@link Diagram}.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @return {Set} a collection of the newly pasted {@link Part}s,
* or an empty Set if there was no data in the clipboard.
*/
CommandHandler.prototype.pasteFromClipboard = function() {
  var coll = new Set(Part);
  var clip = Util.clipboardParts;
  if (clip === null) return coll;
  var diagram = this.diagram;
  if (diagram === null) return coll;
  if (Util.clipboardFormat !== diagram.model.dataFormat) return coll;
  var map = diagram.copyParts(clip, diagram, false);
  var it = map.iterator;
  while (it.next()) {
    var v = it.value;
    if (!v.location.isReal()) v.location = it.key.location;
    if (!v.position.isReal()) v.position = it.key.position;
    coll.add(v);
  }
  return coll;
};

/**
* Copy the contents of the clipboard into this diagram,
* and make those new parts the new selection.
* <p/>
* This calls {@link #pasteFromClipboard} to add copies of {@link Part}s
* into this diagram, and then selects all of the newly created parts.
* This also raises the "ClipboardPasted" diagram event.
* This method raises the "ChangingSelection" and "ChangedSelection" diagram events.
* All of the changes are performed in a transaction.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @param {Point=} pos Point at which to center the newly pasted parts; if not present the parts are not moved.
*/
CommandHandler.prototype.pasteSelection = function(pos) {
  var diagram = this.diagram;
  if (diagram === null) return;
  try {
    diagram.currentCursor = 'wait';
    diagram.startTransaction('Paste');
    diagram.raiseDiagramEvent('ChangingSelection');
    var copies = this.pasteFromClipboard();
    // now update the Diagram.selection
    if (copies.count > 0) diagram.internalClearSelection();  // don't raise ChangingSelection/Finished
    var it = copies.iterator;
    while (it.next()) {
      var part = it.value;
      part.isSelected = true;
    }
    diagram.raiseDiagramEvent('ChangedSelection');
    if (pos instanceof Point) {
      var b = diagram.computePartsBounds(diagram.selection);
      if (b) {
        var tool = diagram.toolManager.draggingTool;
        var coll = tool.computeEffectiveCollection(diagram.selection);
        tool.moveParts(coll, new Point(pos.x - b.centerX, pos.y - b.centerY), false);
      }
    }
    diagram.raiseDiagramEvent('ClipboardPasted', copies);
  } finally {
    diagram.commitTransaction('Paste');
    diagram.currentCursor = '';
  }
};

/**
* This predicate controls whether or not the user can invoke the {@link #pasteSelection} command.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @return {boolean}
* This returns true:
* if the diagram is not {@link Diagram#isReadOnly},
* if {@link Diagram#allowInsert} is true,
* if {@link Diagram#allowClipboard} is true, and
* if the clipboard has parts in it.
*/
CommandHandler.prototype.canPasteSelection = function() {
  var diagram = this.diagram;
  if (diagram === null || diagram.isReadOnly || diagram.isModelReadOnly) return false;
  if (!diagram.allowInsert || !diagram.allowClipboard) return false;
  if (Util.clipboardParts === null) return false;
  if (Util.clipboardFormat !== diagram.model.dataFormat) return false;
  return true;
};


// undo commands

/**
* Call {@link UndoManager#undo}.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
*/
CommandHandler.prototype.undo = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  diagram.undoManager.undo();
};

/**
* This predicate controls whether or not the user can invoke the {@link #undo} command.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @return {boolean}
* This returns true:
* if the diagram is not {@link Diagram#isReadOnly},
* if {@link Diagram#allowUndo} is true, and
* if the {@link UndoManager#canUndo} predicate returns true.
*/
CommandHandler.prototype.canUndo = function() {
  var diagram = this.diagram;
  if (diagram === null || diagram.isReadOnly || diagram.isModelReadOnly) return false;
  return (diagram.allowUndo && diagram.undoManager.canUndo());
};

/**
* Call {@link UndoManager#redo}.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
*/
CommandHandler.prototype.redo = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  diagram.undoManager.redo();
};

/**
* This predicate controls whether or not the user can invoke the {@link #redo} command.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @return {boolean}
* This returns true:
* if the diagram is not {@link Diagram#isReadOnly},
* if {@link Diagram#allowUndo} is true, and
* if the {@link UndoManager#canRedo} predicate returns true.
*/
CommandHandler.prototype.canRedo = function() {
  var diagram = this.diagram;
  if (diagram === null || diagram.isReadOnly || diagram.isModelReadOnly) return false;
  return (diagram.allowUndo && diagram.undoManager.canRedo());
};


// zooming commands

/**
* Decrease the {@link Diagram#scale} by a given factor.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @param {number=} factor This defaults to 1/{@link #zoomFactor}.  The value should be less than one.
*/
CommandHandler.prototype.decreaseZoom = function(factor) {
  if (factor === undefined/*notpresent*/) factor = 1 / this.zoomFactor;
  Util.checkRealNumber(factor, CommandHandler, 'decreaseZoom:factor');
  var diagram = this.diagram;
  if (diagram === null) return;
  if (diagram.autoScale !== Diagram.None) return;
  var newscale = diagram.scale * factor;
  if (newscale < diagram.minScale || newscale > diagram.maxScale) return;
  diagram.scale = newscale;
};

/**
* This predicate controls whether or not the user can invoke the {@link #decreaseZoom} command.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @param {number=} factor This defaults to 1/{@link #zoomFactor}.  The value should be less than one.
* @return {boolean}
* This returns true if {@link Diagram#allowZoom} is true
* and if the new scale is within the range of {@link Diagram#minScale} and {@link Diagram#maxScale}.
*/
CommandHandler.prototype.canDecreaseZoom = function(factor) {
  if (factor === undefined/*notpresent*/) factor = 1 / this.zoomFactor;
  Util.checkRealNumber(factor, CommandHandler, 'canDecreaseZoom:factor');
  var diagram = this.diagram;
  if (diagram === null) return false;
  if (diagram.autoScale !== Diagram.None) return false;
  var newscale = diagram.scale * factor;
  if (newscale < diagram.minScale || newscale > diagram.maxScale) return false;
  return diagram.allowZoom;
};

/**
* Increase the {@link Diagram#scale} by a given factor.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @param {number=} factor This defaults to {@link #zoomFactor}.  The value should be greater than one.
*/
CommandHandler.prototype.increaseZoom = function(factor) {
  if (factor === undefined/*notpresent*/) factor = this.zoomFactor;
  Util.checkRealNumber(factor, CommandHandler, 'increaseZoom:factor');
  var diagram = this.diagram;
  if (diagram === null) return;
  if (diagram.autoScale !== Diagram.None) return;
  var newscale = diagram.scale * factor;
  if (newscale < diagram.minScale || newscale > diagram.maxScale) return;
  diagram.scale = newscale;
};

/**
* This predicate controls whether or not the user can invoke the {@link #increaseZoom} command.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @param {number=} factor This defaults to {@link #zoomFactor}.  The value should be greater than one.
* @return {boolean}
* This returns true if {@link Diagram#allowZoom} is true
* and if the new scale is within the range of {@link Diagram#minScale} and {@link Diagram#maxScale}.
*/
CommandHandler.prototype.canIncreaseZoom = function(factor) {
  if (factor === undefined/*notpresent*/) factor = this.zoomFactor;
  Util.checkRealNumber(factor, CommandHandler, 'canIncreaseZoom:factor');
  var diagram = this.diagram;
  if (diagram === null) return false;
  if (diagram.autoScale !== Diagram.None) return false;
  var newscale = diagram.scale * factor;
  if (newscale < diagram.minScale || newscale > diagram.maxScale) return false;
  return diagram.allowZoom;
};

/**
* Set the {@link Diagram#scale} to a new scale value, by default 1.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @param {number=} newscale This defaults to 1.  The value should be greater than zero.
*/
CommandHandler.prototype.resetZoom = function(newscale) {
  if (newscale === undefined/*notpresent*/) newscale = 1;
  Util.checkRealNumber(newscale, CommandHandler, 'resetZoom:newscale');
  var diagram = this.diagram;
  if (diagram === null) return;
  if (newscale < diagram.minScale || newscale > diagram.maxScale) return;
  diagram.scale = newscale;
};

/**
* This predicate controls whether or not the user can invoke the {@link #resetZoom} command.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @param {number=} newscale This defaults to 1.  The value should be greater than zero.
* @return {boolean}
* This returns true if {@link Diagram#allowZoom} is true.
* and if the new scale is within the range of {@link Diagram#minScale} and {@link Diagram#maxScale}.
*/
CommandHandler.prototype.canResetZoom = function(newscale) {
  if (newscale === undefined/*notpresent*/) newscale = 1;
  Util.checkRealNumber(newscale, CommandHandler, 'canResetZoom:newscale');
  var diagram = this.diagram;
  if (diagram === null) return false;
  if (newscale < diagram.minScale || newscale > diagram.maxScale) return false;
  return diagram.allowZoom;
};

/**
* Change the {@link Diagram#scale} so that the {@link Diagram#documentBounds} fits within the viewport.
* If this command had been called before without any other zooming since then,
* the original Diagram scale and position are restored.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @since 1.1
*/
CommandHandler.prototype.zoomToFit = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  var scale = diagram.scale;
  var position = diagram.position;
  if (scale === this._zoomScale && !isNaN(this._lastScale)) {
    diagram.scale = this._lastScale;
    diagram.position = this._lastPosition;
  } else {
    this._lastScale = scale;
    this._lastPosition = position.copy();
    diagram.zoomToFit();
    diagram.maybeUpdate();  // force scale and position to be updated right now
    this._zoomScale = diagram.scale;
  }
};

/**
* This predicate controls whether or not the user can invoke the {@link #zoomToFit} command.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @return {boolean}
* This returns true if {@link Diagram#allowZoom} is true.
* @since 1.1
*/
CommandHandler.prototype.canZoomToFit = function() {
  var diagram = this.diagram;
  if (diagram === null) return false;
  return diagram.allowZoom;
};


/**
* Collapse all expanded selected {@link Node}s.
* This operation is performed within a "Collapse Tree" transaction.
* Just before the end of the transaction this raises the "TreeCollapsed" {@link DiagramEvent},
* with a collection of collapsed {@link Node}s as the subject.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @param {Node=} node if supplied, ignore the selection and collapse this particular Node subtree.
*/
CommandHandler.prototype.collapseTree = function(node) {
  if (node === undefined/*notpresent*/) node = null;
  var diagram = this.diagram;
  if (diagram === null) return false;
  diagram.startTransaction('Collapse Tree');
  var nodes = new List(Node);
  if (node instanceof Node && node.isTreeExpanded) {
    node.collapseTree();
    nodes.add(node);
  } else {
    var it = diagram.selection.iterator;
    while (it.next()) {
      var n = it.value;
      if (n instanceof Node && n.isTreeExpanded) {
        n.collapseTree();
        nodes.add(n);
      }
    }
    //?? also change selection
  }
  diagram.raiseDiagramEvent('TreeCollapsed', nodes);
  diagram.commitTransaction('Collapse Tree');
};

/**
* This predicate controls whether the user can collapse expanded subtrees of {@link Node}s.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @param {Node=} node if supplied, ignore the selection and consider collapsing this particular Node.
* @return {boolean}
*/
CommandHandler.prototype.canCollapseTree = function(node) {
  if (node === undefined/*notpresent*/) node = null;
  var diagram = this.diagram;
  if (diagram === null || diagram.isReadOnly) return false;
  if (node instanceof Node) {
    if (!node.isTreeExpanded) return false;  // already collapsed
    if (node.findTreeChildrenLinks().count > 0) return true;
  } else {
    var it = diagram.selection.iterator;
    while (it.next()) {
      var n = it.value;
      if (n instanceof Node) {
        if (!n.isTreeExpanded) continue;  // not this Node -- it's already collapsed
        if (n.findTreeChildrenLinks().count > 0) return true;
      }
    }
  }
  return false;
};

/**
* Expand all collapsed selected {@link Node}s.
* This operation is performed within an "Expand Tree" transaction.
* Just before the end of the transaction this raises the "TreeExpanded" {@link DiagramEvent},
* with a collection of expanded {@link Node}s as the subject.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @param {Node=} node if supplied, ignore the selection and collapse this particular Node subtree.
*/
CommandHandler.prototype.expandTree = function(node) {
  if (node === undefined/*notpresent*/) node = null;
  var diagram = this.diagram;
  if (diagram === null) return false;
  diagram.startTransaction('Expand Tree');
  var nodes = new List(Node);
  if (node instanceof Node && !node.isTreeExpanded) {
    node.expandTree();
    nodes.add(node);
  } else {
    var it = diagram.selection.iterator;
    while (it.next()) {
      var n = it.value;
      if (n instanceof Node && !n.isTreeExpanded) {
        n.expandTree();
        nodes.add(n);
      }
    }
    //?? also change selection
  }
  diagram.raiseDiagramEvent('TreeExpanded', nodes);
  diagram.commitTransaction('Expand Tree');
};

/**
* This predicate controls whether the user can expand collapsed subtrees of {@link Node}s.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @param {Node=} node if supplied, ignore the selection and consider expanding this particular Node.
* @return {boolean}
*/
CommandHandler.prototype.canExpandTree = function(node) {
  if (node === undefined/*notpresent*/) node = null;
  var diagram = this.diagram;
  if (diagram === null || diagram.isReadOnly) return false;
  if (node instanceof Node) {
    if (node.isTreeExpanded) return false;  // already expanded
    if (node.findTreeChildrenLinks().count > 0) return true;
  } else {
    var it = diagram.selection.iterator;
    while (it.next()) {
      var n = it.value;
      if (n instanceof Node) {
        if (n.isTreeExpanded) continue;  // not this Node -- it's already expanded
        if (n.findTreeChildrenLinks().count > 0) return true;
      }
    }
  }
  return false;
};


// grouping commands

/**
* Add a copy of {@link #archetypeGroupData} and add it to the diagram's model
* to create a new {@link Group} and then add the selected {@link Part}s to that new group.
* <p/>
* This creates a new {@link Group} by adding a copy of the {@link #archetypeGroupData} to the model.
* Each of the selected parts for which {@link Part#canGroup} is true
* and for which {@link #isValidMember} is true
* is made a member of that new group.
* If all of the selected groupable parts were members of a pre-existing group,
* the new group also becomes a member of that pre-existing group,
* if {@link #isValidMember} is true for that existing group with the new group.
* The new group becomes the only selected part.
* This raises the "SelectionGrouped" diagram event.
* This method also raises the "ChangingSelection" and "ChangedSelection" diagram events.
* All of the changes are performed in a "Group" transaction.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
*/
CommandHandler.prototype.groupSelection = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  var model = diagram.model;
  if (model === null || !(model instanceof GraphLinksModel)) return;
  var arch = this.archetypeGroupData;
  if (arch === null) return;
  var newgroup = null;
  try {
    diagram.currentCursor = 'wait';
    diagram.startTransaction('Group');
    diagram.raiseDiagramEvent('ChangingSelection');

    // get all of the selected parts that can be grouped
    var selparts = new List(Part);
    var it = diagram.selection.iterator;
    while (it.next()) {
      var part = it.value;
      if (part.isNodeLike() && part.canGroup()) selparts.add(part);
    }
    // keep selected parts that are not part of any other selected parts
    var parts = new List(Part);
    var sit = selparts.iterator;
    while (sit.next()) {
      var n = sit.value;
      var mem = false;
      it = selparts.iterator;
      while (it.next()) {
        var m = it.value;
        if (n.isMemberOf(m)) {
          mem = true;
          break;
        }
      }
      if (!mem) {
        parts.add(n);
      }
    }
    // find lowest common containing group for selected parts
    if (parts.count > 0) {
      it = parts.iterator;
      it.next();  // now it.value is the first groupable selected node not contained by a selected group
      var firstsg = it.value.containingGroup;
      if (firstsg !== null) {
        while (firstsg !== null) {  // stop going up containingGroup chain when at top-level
          it = parts.iterator;
          it.next();  // skip first node
          // are any NODES not a member of the group FIRSTSG?
          var notmem = false;
          while (it.next()) {
            var n = it.value;
            if (!n.isMemberOf(firstsg)) {
              notmem = true;
              break;
            }
          }
          if (notmem) {
            firstsg = firstsg.containingGroup;  // try next Group up the chain
          } else {
            break;  // done!
          }
        }
      }

      // create new group
      if (arch instanceof Group) {
        arch.freezeBindings();
        newgroup = arch.copy();
        if (newgroup instanceof Group) {
          diagram.add(newgroup);
        }
      } else if (model.isGroupForNodeData(arch)) {
        var newgroupdata = model.copyNodeData(arch);
        if (Util.isObject(newgroupdata)) {
          // add it to the model and diagram
          model.addNodeData(newgroupdata);
          // find the corresponding Group node
          newgroup = diagram.findNodeForData(newgroupdata);
        }
      }

      if (newgroup instanceof Group) {
        if (firstsg !== null && this.isValidMember(firstsg, newgroup)) {
          // make it a member of an existing group
          newgroup.containingGroup = firstsg;
        }
        // update all of the NODES to be members of the new group
        it = parts.iterator;
        while (it.next()) {
          var n = it.value;
          if (this.isValidMember(newgroup, n)) {
            n.containingGroup = newgroup;
          }
        }
        // make the new group the only selected part
        diagram.select(newgroup);
      }
    }

    diagram.raiseDiagramEvent('ChangedSelection');
    diagram.raiseDiagramEvent('SelectionGrouped', newgroup);
  } finally {
    diagram.commitTransaction('Group');
    diagram.currentCursor = '';
  }
};

/**
* This predicate controls whether or not the user can invoke the {@link #groupSelection} command.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @return {boolean}
* This returns true:
* if the {@link #archetypeGroupData} is not null,
* if the diagram is not {@link Diagram#isReadOnly},
* if {@link Diagram#allowInsert} is true,
* if {@link Diagram#allowGroup} is true,
* if {@link Diagram#model} is a {@link GraphLinksModel}, and
* if there is any selected {@link Part} that can be {@link Part#canGroup}ed.
*/
CommandHandler.prototype.canGroupSelection = function() {
  var diagram = this.diagram;
  if (diagram === null || diagram.isReadOnly || diagram.isModelReadOnly) return false;
  if (!diagram.allowInsert || !diagram.allowGroup) return false;
  var model = diagram.model;
  if (model === null || !(model instanceof GraphLinksModel)) return false;
  if (this.archetypeGroupData === null) return false;
  var it = diagram.selection.iterator;
  while (it.next()) {
    var part = it.value;
    if (part.isNodeLike() && part.canGroup()) return true;
  }
  return false;
};

/**
* @ignore
* @this {CommandHandler}
* @return {Iterable} of non-Links.
*/
CommandHandler.prototype.findUnnestedNodes = function(coll) {
  // find nodes
  var selnodes = Util.tempArray();
  var itr = coll.iterator;
  while (itr.next()) {
    var n = itr.value;
    if (n instanceof Link) continue;
    selnodes.push(n);
  }

  // filter out nodes that are members (perhaps indirectly) of other selected nodes
  //return new HashSet<Node>(selnodes.Where(n => !selnodes.Any(m => n.IsContainedBy(m))));

  var set = new Set(Part);
  var l = selnodes.length;
  for (var i = 0; i < l; i++) {
    var cur = selnodes[i];
    // filter out the "bad" nodes that are members (perhaps indirectly) of other selected nodes
    var good = true;
    for (var j = 0; j < l; j++) {
      if (cur.isMemberOf(selnodes[j])) {
        good = false;
        break;
      }
    }
    if (good) {
      set.add(cur);
    }
  }
  Util.freeArray(selnodes);
  return set;
};

/**
* This predicate is called to determine whether a Node may be added as a member of a Group.
* This always checks to make sure no group might become a member of itself, either directly or indirectly.
* If the Group has a {@link Group#memberValidation} predicate and if it returns false, this method returns false.
* If this CommandHandler has a {@link #memberValidation} predicate and if it returns false, this method returns false.
* Otherwise this will return true.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @param {Group} group this may be null if the node is being added as a top-level node.
* @param {Part} part a Part, usually a Node, possibly another Group, but not a Link or an Adornment.
* @return {boolean} true if OK to add the node to the group.
*/
CommandHandler.prototype.isValidMember = function(group, part) {
  if (part === null) return false;
  if (group === part) return false;  // can't be a member of itself!
  if (part instanceof Link) return false;
  if (group !== null) {
    if (group === part || group.isMemberOf(part)) return false;  // do not allow cycles!
    var pred = group.memberValidation;
    if (pred !== null && !pred(group, part)) return false;
    if (group.data === null && part.data !== null) return false;  // either both must be in model,
    if (group.data !== null && part.data === null) return false;  // or neither are in model
  }
  var pred = this.memberValidation;
  if (pred !== null) {
    return pred(group, part);
  } else {
    return true;
  }
};

/**
* Remove the group from the diagram without removing its members from the diagram.
* <p/>
* For the given group, or if not supplied, each selected {@link Group} that is {@link Group#ungroupable},
* change all of its member parts to be members of the group that the selected group node is in.
* (If the selected group node is a top-level node, i.e. not a member of any group node,
* its members become top-level parts too.)
* All of those selected groups are deleted.
* All of the reparented member parts are selected.
* <p/>
* This raises the "SelectionUngrouped" diagram event.
* This method also raises the "ChangingSelection" and "ChangedSelection" diagram events.
* All of the changes are performed in an "Ungroup" transaction.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @param {Group=} group if supplied, ignore the selection and consider ungrouping this particular Group.
*/
CommandHandler.prototype.ungroupSelection = function(group) {
  if (group === undefined/*notpresent*/) group = null;
  var diagram = this.diagram;
  if (diagram === null) return;
  var model = diagram.model;
  if (model === null || !(model instanceof GraphLinksModel)) return;
  try {
    diagram.currentCursor = 'wait';
    diagram.startTransaction('Ungroup');
    diagram.raiseDiagramEvent('ChangingSelection');

    // find all selected groups that are ungroupable
    var groups = new List(Group);
    if (group instanceof Group) {
      groups.add(group);
    } else {
      var it = diagram.selection.iterator;
      while (it.next()) {
        var g = it.value;
        if (g instanceof Group && g.canUngroup()) groups.add(g);
      }
    }
    if (groups.count > 0) {
      // forget selection, so we can select members as they are promoted from out of each Group
      diagram.clearSelection();
      it = groups.iterator;
      while (it.next()) {
        var groupnode = it.value;
        var groupdata = groupnode.data;
        // iterate over the member parts and reassign their group key to be SG's original
        // containing group key, if any
        var parent = groupnode.containingGroup;
        var pkey = (parent !== null && parent.data !== null ? model.getKeyForNodeData(parent.data) : undefined);
        var members = new List(Part);
        members.addAll(groupnode.memberParts);
        var mit = members.iterator;
        while (mit.next()) {
          var member = mit.value;
          if (member instanceof Link) continue;
          var memdata = member.data;
          if (memdata !== null) {
            model.setGroupKeyForNodeData(memdata, pkey);
          } else {
            member.containingGroup = parent;
          }
          member.isSelected = true;
        }
        // then delete the empty group
        if (groupdata !== null) {
          model.removeNodeData(groupdata);
        } else {
          diagram.remove(groupnode);
        }
      }
    }

    diagram.raiseDiagramEvent('ChangedSelection');
    diagram.raiseDiagramEvent('SelectionUngrouped', groups, members);
  } finally {
    diagram.commitTransaction('Ungroup');
    diagram.currentCursor = '';
  }
};

/**
* This predicate controls whether or not the user can invoke the {@link #ungroupSelection} command.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @param {Group=} group if supplied, ignore the selection and consider ungrouping this particular Group.
* @return {boolean}
* This returns true:
* if the diagram is not {@link Diagram#isReadOnly},
* if {@link Diagram#allowDelete} is true,
* if {@link Diagram#allowUngroup} is true,
* if {@link Diagram#model} is a {@link GraphLinksModel}, and
* if there are any selected {@link Group}s that are {@link Group#ungroupable}.
*/
CommandHandler.prototype.canUngroupSelection = function(group) {
  if (group === undefined/*notpresent*/) group = null;
  var diagram = this.diagram;
  if (diagram === null || diagram.isReadOnly || diagram.isModelReadOnly) return false;
  if (!diagram.allowDelete || !diagram.allowUngroup) return false;
  var model = diagram.model;
  if (model === null || !(model instanceof GraphLinksModel)) return false;
  if (group instanceof Group) {
    if (group.canUngroup()) return true;
  } else {
    var it = diagram.selection.iterator;
    while (it.next()) {
      var part = it.value;
      if (part instanceof Group && part.canUngroup()) return true;
    }
  }
  return false;
};

//?? these non-command methods really ought to be in a PartManager-like class,
// to avoid confusion with commands implemented by methods

/**
* Make sure all of the unnested {@link Part}s in the given collection
* are removed from any containing {@link Group}s.
* <p/>
* This sets {@link Part#containingGroup} to null on each Part that is
* not a member of another Part in the argument collection.
* If the check argument to this method is supplied and true,
* this will call {@link #isValidMember} on each part, passing null as the first argument.
* <p/>
* This functionality is similar to {@link #ungroupSelection},
* except that this is not a command (there is no transaction and this does not raise a {@link DiagramEvent})
* and the parts are necessarily becoming top-level parts
* (whereas ungrouping would add them to the Group containing the Group being ungrouped).
* <p/>
* This function is typically called in a {@link Diagram#mouseDrop} event handler
* in order to remove the selected Parts from whatever {@link Group} they had been in.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @param {Iterable} coll a collection of Parts.
* @param {boolean=} check whether to call {@link #isValidMember} to confirm that changing the Part to be a top-level Part is valid.
* @return {boolean} true if all non-Links were changed to be top-level Parts in this Diagram; false if some Parts or Nodes were not able to be added.
*/
CommandHandler.prototype.addTopLevelParts = function(coll, check) {
  // get all of the simple Parts and Nodes or Groups, but not Links,
  // that are not members of other parts in the given collection
  var unnested = this.findUnnestedNodes(coll);
  var ok = true;
  var it = unnested.iterator;
  while (it.next()) {
    var node = it.value;
    if (node.containingGroup !== null) {
      if (!check || this.isValidMember(null, node)) {
        node.containingGroup = null;
      } else {
        ok = false;
      }
    }
    //??this.diagram.add(node);
  }
  return ok;
};

/**
* Collapse all expanded selected {@link Group}s.
* This operation is performed within a "Collapse SubGraph" transaction.
* Just before the end of the transaction this raises the "SubGraphCollapsed" {@link DiagramEvent},
* with a collection of collapsed {@link Group}s as the subject.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @param {Group=} group if supplied, ignore the selection and collapse this particular Group.
*/
CommandHandler.prototype.collapseSubGraph = function(group) {
  if (group === undefined/*notpresent*/) group = null;
  var diagram = this.diagram;
  if (diagram === null) return false;
  diagram.startTransaction('Collapse SubGraph');
  var groups = new List(Group);
  if (group instanceof Group && group.isSubGraphExpanded) {
    group.collapseSubGraph();
    groups.add(group);
  } else {
    var it = diagram.selection.iterator;
    while (it.next()) {
      var g = it.value;
      if (g instanceof Group && g.isSubGraphExpanded) {
        g.collapseSubGraph();
        groups.add(g);
      }
    }
    //?? also change selection
  }
  diagram.raiseDiagramEvent('SubGraphCollapsed', groups);
  diagram.commitTransaction('Collapse SubGraph');
};

/**
* This predicate controls whether the user can collapse expanded {@link Group}s.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @param {Group=} group if supplied, ignore the selection and consider collapsing this particular Group.
* @return {boolean}
*/
CommandHandler.prototype.canCollapseSubGraph = function(group) {
  if (group === undefined/*notpresent*/) group = null;
  var diagram = this.diagram;
  if (diagram === null || diagram.isReadOnly) return false;
  if (group instanceof Group) {
    if (!group.isSubGraphExpanded) return false;  // already collapsed
    /*?? if (group.memberParts.count > 0) */ return true;
  } else {
    var it = diagram.selection.iterator;
    while (it.next()) {
      var g = it.value;
      if (g instanceof Group) {
        if (!g.isSubGraphExpanded) continue;  // not this Group -- it's already collapsed
        /*?? if (g.memberParts.count > 0) */ return true;
      }
    }
  }
  return false;
};


/**
* Expand all collapsed selected {@link Group}s.
* This operation is performed within an "Expand SubGraph" transaction.
* Just before the end of the transaction this raises the "SubGraphExpanded" {@link DiagramEvent},
* with a collection of expanded {@link Group}s as the subject.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @param {Group=} group if supplied, ignore the selection and expand this particular Group.
*/
CommandHandler.prototype.expandSubGraph = function(group) {
  if (group === undefined/*notpresent*/) group = null;
  var diagram = this.diagram;
  if (diagram === null) return false;
  diagram.startTransaction('Expand SubGraph');
  var groups = new List(Group);
  if (group instanceof Group && !group.isSubGraphExpanded) {
    group.expandSubGraph();
    groups.add(group);
  } else {
    var it = diagram.selection.iterator;
    while (it.next()) {
      var g = it.value;
      if (g instanceof Group && !g.isSubGraphExpanded) {
        g.expandSubGraph();
        groups.add(g);
      }
    }
    //?? also change selection
  }
  diagram.raiseDiagramEvent('SubGraphExpanded', groups);
  diagram.commitTransaction('Expand SubGraph');
};

/**
* This predicate controls whether the user can expand collapsed {@link Group}s.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @param {Group=} group if supplied, ignore the selection and consider expanding this particular Group.
* @return {boolean}
*/
CommandHandler.prototype.canExpandSubGraph = function(group) {
  if (group === undefined/*notpresent*/) group = null;
  var diagram = this.diagram;
  if (diagram === null || diagram.isReadOnly) return false;
  if (group instanceof Group) {
    if (group.isSubGraphExpanded) return false;  // already expanded
    /*?? if (group.memberParts.count > 0) */ return true;
  } else {
    var it = diagram.selection.iterator;
    while (it.next()) {
      var g = it.value;
      if (g instanceof Group) {
        if (g.isSubGraphExpanded) continue;  // not this Group -- it's already expanded
        /*?? if (g.memberParts.count > 0) */ return true;
      }
    }
  }
  return false;
};


// editing commands

/**
* Start in-place editing of a {@link TextBlock} in the selected {@link Part}.
* <p>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @param {TextBlock=} textblock the {@link TextBlock} to start editing.
*/
CommandHandler.prototype.editTextBlock = function(textblock) {
  if (textblock === undefined/*notpresent*/) textblock = null;
  var diagram = this.diagram;
  if (diagram === null) return;
  if (diagram.toolManager === null) return;
  var tool = diagram.toolManager.textEditingTool;
  if (tool === null) return;

  if (textblock === null) {  // need to find a TextBlock to edit
    // find the first eligible node
    var itr = diagram.selection.iterator;
    var firstpart = null;
    while (itr.next()) {
      var part = itr.value;
      if (part.canEdit()) {
        firstpart = part;
        break;
      }
    }
    if (firstpart === null) return;
    textblock = firstpart.findObjectByPred(function(x) { return (x instanceof TextBlock && x.editable) });
  }
  if (textblock !== null && textblock instanceof TextBlock) {
    tool.textBlock = textblock;
    diagram.currentTool = tool;
  }
};

/**
* This predicate controls whether or not the user can invoke the {@link #editTextBlock} command.
* <p>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @param {TextBlock=} textblock the {@link TextBlock} to consider editing.
* @return {boolean}
* This returns true:
* if the diagram is not {@link Diagram#isReadOnly},
* if {@link Diagram#allowTextEdit} is true,
* if there is a {@link ToolManager#textEditingTool}, and
* if there is any selected {@link Part} for which {@link Part#canEdit} is true.
*/
CommandHandler.prototype.canEditTextBlock = function(textblock) {
  if (textblock === undefined/*notpresent*/) textblock = null;
  var diagram = this.diagram;
  if (diagram === null || diagram.isReadOnly || diagram.isModelReadOnly) return false;
  if (!diagram.allowTextEdit) return false;
  if (diagram.toolManager === null || diagram.toolManager.textEditingTool === null) return false;
  if (textblock instanceof TextBlock) {
    var part = textblock.part;
    if (part !== null && part.canEdit()) return true;
  } else {
    var it = diagram.selection.iterator;
    while (it.next()) {
      var part = it.value;
      if (part.canEdit()) {
        textblock = part.findObjectByPred(function(x) { return (x instanceof TextBlock && x.editable) });
        if (textblock !== null) return true;
      }
    }
  }
  return false;
};

/**
* Open the context menu of a given GraphObject.
* <p>
* The given GraphObject must have a {@link GraphObject#contextMenu}
* defined in order to show anything.
* <p>
* This method may be overridden, but you should consider calling this
* base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @param {GraphObject|Diagram=} obj a GraphObject or Diagram with a contextMenu defined.
* If none is given, this method will use the first selected object, or else the Diagram.
*/
CommandHandler.prototype.showContextMenu = function(obj) {
  var diagram = this.diagram;
  if (diagram === null) return;
  if (diagram.toolManager === null) return;
  var tool = diagram.toolManager.contextMenuTool;
  if (tool === null) return;

  if (obj === undefined) {
    if (diagram.selection.count > 0) {
      obj = diagram.selection.first();
    } else {
      obj = diagram;
    }
  }

  var ctxObj = tool.findObjectWithContextMenu(obj);
  if (ctxObj !== null) {
    var input = new InputEvent();

    var pt = null;
    if (ctxObj instanceof GraphObject) {
      pt = ctxObj.getDocumentPoint(Spot.Center);
    } else { // Diagram
      if (!diagram._isMouseOverDiagram) {
        var vpb = diagram.viewportBounds;
        pt = new Point(vpb.x + (vpb.width / 2), vpb.y + (vpb.height / 2));
      } else {
        // mouse is still over diagram, leave lastInput as-is and show context menu there
      }
    }

    if (pt !== null) {
      input.viewPoint = diagram.transformDocToView(pt);
      input.documentPoint = pt;
      diagram._lastInput = input;
    }
    diagram.currentTool = tool;
    tool.openMenu(false, ctxObj);
  }
};

/**
* This predicate controls whether or not the user can invoke the {@link #showContextMenu} command.
* <p>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {CommandHandler}
* @param {GraphObject|Diagram=} obj a GraphObject or Diagram with a contextMenu defined.
* If none is given, this method will use the first selected object, or else the Diagram.
* @return {boolean}
*/
CommandHandler.prototype.canShowContextMenu = function(obj) {
  var diagram = this.diagram;
  if (diagram === null) return false;;
  if (diagram.toolManager === null) return false;;
  var tool = diagram.toolManager.contextMenuTool;
  if (tool === null) return false;

  if (obj === undefined) {
    if (diagram.selection.count > 0) {
      obj = diagram.selection.first();
    } else {
      obj = diagram;
    }
  }

  var contextobj = tool.findObjectWithContextMenu(obj);
  if (contextobj === null) return false;
  return true;
}

// state

/**
* Gets or sets whether {@link #copySelection} should also copy subtrees.
* The default value is false.
* Setting this property does not raise any events.
* @name CommandHandler#copiesTree
* @function.
* @return {boolean}
*/
/** @type {boolean} */
CommandHandler.prototype.copiesTree;
Util.exportProperty(CommandHandler, 'copiesTree', CommandHandler.prototype.copiesTree);
Util.defineProperty(CommandHandler, {copiesTree: 'copiesTree'},
  /** @this {CommandHandler} */
  function() { return this._copiesTree; },
  /** @this {CommandHandler} */
  function(val) { this._copiesTree = val; }
);

/**
* Gets or sets whether {@link #deleteSelection} should also delete subtrees.
* The default value is false.
* Setting this property does not raise any events.
* @name CommandHandler#deletesTree
* @function.
* @return {boolean}
*/
/** @type {boolean} */
CommandHandler.prototype.deletesTree;
Util.exportProperty(CommandHandler, 'deletesTree', CommandHandler.prototype.deletesTree);
Util.defineProperty(CommandHandler, {deletesTree: 'deletesTree'},
  /** @this {CommandHandler} */
  function() { return this._deletesTree; },
  /** @this {CommandHandler} */
  function(val) { this._deletesTree = val; }
);

/**
* Gets or sets a data object that is copied by {@link #groupSelection}
* when creating a new Group.
* <p/>
* The default value is null.
* If you set this to an Object, be sure that {@link GraphLinksModel#isGroupForNodeData} is true for that object.
* Setting this property does not raise any events.
* @name CommandHandler#archetypeGroupData
* @function.
* @return {Object}
*/
/** @type {Object} */
CommandHandler.prototype.archetypeGroupData;
Util.exportProperty(CommandHandler, 'archetypeGroupData', CommandHandler.prototype.archetypeGroupData);
Util.defineProperty(CommandHandler, {archetypeGroupData: 'archetypeGroupData'},
  /** @this {CommandHandler} */
  function() { return this._archetypeGroupData; },
  /** @this {CommandHandler} */
  function(val) {
    if (val !== null) Util.checkClass(val, Object, CommandHandler, 'archetypeGroupData');
    var diagram = this.diagram;
    if (diagram !== null) {
      var model = diagram.model;
      if (model instanceof GraphLinksModel) {
        if (!(val instanceof Group) && !model.isGroupForNodeData(val)) {
          Util.throwError('CommandHandler.archetypeGroupData must be either a Group or a data object for which GraphLinksModel.isGroupForNodeData is true: ' + val);
        }
      }
    }
    this._archetypeGroupData = val;
  }
);

/**
* Gets or sets the predicate that determines whether or not a node may become a member of a group.
* This predicate is only called if an existing {@link Group} does not have its own {@link Group#memberValidation} predicate.
* The default predicate is null, which is equivalent to simply returning true.
* The predicate may be called passing null as the first argument (the Group) --
* this asks whether it is OK to make the second argument (the Part, but not a Link) a top-level Part of the diagram.
* <p/>
* The function, if supplied, must not have any side-effects.
* @name CommandHandler#memberValidation
* @function.
* @return {function(Group, Part):boolean | null}
*/
/** @type {function(Group, Part):boolean | null} */
CommandHandler.prototype.memberValidation;
Util.exportProperty(CommandHandler, 'memberValidation', CommandHandler.prototype.memberValidation);
Util.defineProperty(CommandHandler, { memberValidation: 'memberValidation' },
  /** @this {CommandHandler} */
  function() { return this._memberValidation; },
  /** @this {CommandHandler} */
  function(val) {
    if (val !== null) Util.checkPrimitive(val, 'function', CommandHandler, 'memberValidation');
    this._memberValidation = val;
  }
);

/**
* Gets or sets the amount by which {@link #decreaseZoom} and {@link #increaseZoom} change
* the {@link Diagram#scale}.
* <p/>
* The default value is 1.05 (5%).
* The value must be a number larger than 1.0.
* Setting this property does not raise any events.
* @name CommandHandler#zoomFactor
* @function.
* @return {number}
* @since 1.1
*/
/** @type {number} */
CommandHandler.prototype.zoomFactor;
Util.exportProperty(CommandHandler, 'zoomFactor', CommandHandler.prototype.zoomFactor);
Util.defineProperty(CommandHandler, { zoomFactor: 'zoomFactor' },
  /** @this {CommandHandler} */
  function() { return this._zoomFactor; },
  /** @this {CommandHandler} */
  function(val) {
    Util.checkPrimitive(val, 'number', CommandHandler, 'zoomFactor');
    if (!(val > 1.0)) Util.throwError('zoomFactor must be larger than 1.0, not: ' + val);
    this._zoomFactor = val;
  }
);

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
Tool
*/

/**
 * Don't construct this directly -- this is an abstract class.
 * @constructor
 * @category Tool
 * @class
 * Tools handle mouse events and keyboard events.
 * The currently running tool, {@link Diagram#currentTool}, receives all input events from the {@link Diagram}.
 * <p/>
 * Most tools are "mode-less" tools that are managed by the {@link ToolManager},
 * which chooses the current tool based on the kind and position of the mouse event and the parts in the diagram.
 * The {@link ToolManager} has properties holding instances of most of the pre-defined {@link Tool} classes.
 * These classes include:
 * <ul>
 *   <li>{@link ActionTool}</li>
 *   <li>{@link RelinkingTool}</li>
 *   <li>{@link LinkReshapingTool}</li>
 *   <li>{@link ResizingTool}</li>
 *   <li>{@link RotatingTool}</li>
 *   <li>{@link LinkingTool}</li>
 *   <li>{@link DraggingTool}</li>
 *   <li>{@link DragSelectingTool}</li>
 *   <li>{@link PanningTool}</li>
 *   <li>{@link ContextMenuTool}</li>
 *   <li>{@link TextEditingTool}</li>
 *   <li>{@link ClickCreatingTool}</li>
 *   <li>{@link ClickSelectingTool}</li>
 * </ul>
 * The ToolManager chooses a tool to make current by finding in its lists of tools the first tool
 * whose {@link #canStart} method returns true.
 * <p/>
 * A tool is in the "running" state when it is the value of {@link Diagram#currentTool}.
 * The {@link Diagram#currentTool} property setter will call {@link #doStop} on the old tool
 * and then call {@link #doStart} on the new tool.
 * <p/>
 * A tool can then go into the "active" state once it decides it can actually do something.
 * This happens with a call to {@link #doActivate}, normally called by the ToolManager.
 * Later it is deactivated ({@link #doDeactivate}) and then stopped.
 * {@link #isActive} should be true when the tool is "active".
 * Often tools should ignore certain common events, such as calls to {@link #doMouseMove},
 * unless the tool is "active".
 * <p/>
 * You can prevent a "mode-less" tool (i.e. one managed by the {@link ToolManager})
 * from being started by the ToolManager by setting {@link #isEnabled} to false.
 * <p/>
 * You can go into a particular "mode" by setting {@link Diagram#currentTool} explicitly.
 * This ignores the {@link #isEnabled} property and does not call the {@link #canStart} predicate.
 * The behavior will depend on the tool -- not all of the predefined tools support operating as a "modal" tool.
 * <p/>
 * Tools cannot be shared amongst multiple Diagrams.
 * <p/>
 * If you define a Tool subclass, you may override any of the methods whose names start with "do"
 * and any other methods that are documented to be overridable, such as {@link #canStart}.
 * However you must seriously consider calling the base method in order to gets its default behavior.
 * There may be situations where not calling the base method may cause subtle bugs.
 * But that depends on the method and the tool.
 */
function Tool() {
  if (arguments.length > 0) {
    Util.throwError('Tool constructor cannot take any arguments.');
  }
  Util.uniqueHash(this);
  /** @type {Diagram} */
  this._diagram = null;
  /** @type {string} */
  this._name = '';
  /** @type {boolean} */
  this._isEnabled = true;
  /** @type {boolean} */
  this._isActive = false;

  /** @type {?string} */
  this._transactionResult = null;

  /** @type {null|number|undefined} */
  this._waitAfterTimer = -1;
}

Util.publish('Tool', Tool);

/**
* @ignore
* @this {Tool}
* @param {Diagram} val
*/
Tool.prototype.setDiagram = function(val) {
  if (Debug && val !== null) Util.checkClass(val, Diagram, Tool, 'setDiagram');
  this._diagram = val;
};

/**
* @ignore
* @this {Tool}
* @return {string}
*/
Tool.prototype.toString = function() {
  if (this.name !== '')
    return this.name + ' Tool';
  else
    return Util.getClassName(Object.getPrototypeOf(this));
};

/**
* The diagram asks each tool to update any adornments the tool might
* use for a given part.
* If the tool uses its own tool handles,
* this should display them or hide them as appropriate.
* Typically this should only show them if the part is selected.
* <p/>
* By default this method does nothing.
* This method may be overridden.
* @expose
* @this {Tool}
* @param {Part} part
*/
Tool.prototype.updateAdornments = function(part) { };


// States and state transitions

/**
* This predicate is used by the {@link ToolManager} to decide if this tool can be started mode-lessly
* by mouse and touch events.
* Implementations of this method can look at {@link Diagram#lastInput} to get the mouse
* event and input state.
* <p/>
* By default this method returns {@link #isEnabled}.
* This method may be overridden.
* @expose
* @this {Tool}
* @return {boolean} true if {@link #isEnabled} is true and
* if the {@link Diagram#toolManager} can make this tool the current one and
* then call the {@link #doStart} method.
*/
Tool.prototype.canStart = function() {
  return this.isEnabled;
};

/**
* This method is called by the diagram when this tool becomes the current tool; you should not call this method.
* Tool implementations should perform their per-use initialization here, such
* as setting up internal data structures, or capturing the mouse.
* Implementations of this method can look at {@link Diagram#lastInput} to get the mouse
* event and input state.
* <p/>
* You should not call this method -- only the {@link Diagram#currentTool} property setter should call this method.
* <p/>
* By default this method does nothing.
* This method may be overridden.
* @expose
* @this {Tool}
*/
Tool.prototype.doStart = function() { };

/**
* This method is called by the diagram after setting {@link Diagram#currentTool},
* to make the new tool active.
* This should set {@link #isActive} to true.
* Overrides of this method might call {@link #startTransaction},
* if this tool's activity involves modification of the model.
* Implementations of this method can look at {@link Diagram#lastInput} to get the mouse
* event and input state.
* <p/>
* You should call this method only after setting {@link Diagram#currentTool} to the Tool that you want to activate.
* <p/>
* By default this only sets {@link #isActive} to true.
* This method may be overridden.
* @expose
* @this {Tool}
*/
Tool.prototype.doActivate = function() {
  this.isActive = true;
};

/**
* This method is called by the diagram on the old tool when
* {@link Diagram#currentTool} is set to a new tool.
* This needs to set {@link #isActive} to false.
* Overrides of this method might call {@link #stopTransaction},
* if this tool's activity involves modification of the model.
* <p/>
* You should have no reason to call this method, because it is automatically called by the
* {@link Diagram#currentTool} property setter on the old tool.
* <p/>
* By default this only sets {@link #isActive} to false.
* This method may be overridden.
* @expose
* @this {Tool}
*/
Tool.prototype.doDeactivate = function() {
  this.isActive = false;
};

/**
* This method is called by the diagram when this tool stops being the current tool; you should not call this method.
* Tool implementations should perform their per-use cleanup here,
* such as releasing mouse capture.
* <p/>
* You should not call this method -- only the {@link Diagram#currentTool} property setter should call this method.
* If you want to stop a tool unexpectedly, you should call {@link #doCancel}.
* If your implementation of a tool wants to stop itself, you should call {@link #stopTool}.
* <p/>
* By default this method does nothing.
* This method may be overridden.
* @expose
* @this {Tool}
*/
Tool.prototype.doStop = function() { };

/**
* The diagram will call this method when the user wishes to cancel the
* current tool's operation.
* Typically this is called when the user hits the ESCAPE key.
* This should restore the original state and then call {@link #stopTool}.
* <p/>
* By default this method just calls {@link #stopTool}.
* This method may be overridden.
* @expose
* @this {Tool}
*/
Tool.prototype.doCancel = function() {
  this.stopTool();
};

/**
* If the {@link Diagram#currentTool} is this tool,
* stop this tool and start the {@link Diagram#defaultTool}
* by making it be the new current tool.
* The implementation of various tool methods can call this method to stop the current tool.
* This will call {@link #doStop} -- you should not call that method directly.
* <p/>
* If you want to stop the current tool and have it restore the original state, call {@link #doCancel}.
* @expose
* @this {Tool}
*/
Tool.prototype.stopTool = function() {
  var diagram = this.diagram;
  if (diagram !== null && diagram.currentTool === this) {
    // this will call doStop on the current tool,
    // and then make the defaultTool current and call doStart on it
    diagram.currentTool = null;  // NOT diagram.defaultTool, otherwise currentTool side-effects might not happen
    diagram.currentCursor = '';
  }
};


// Input events

/**
* The diagram will call this method upon a mouse down event.
* This is normally overridden for mouse-down tools;
* it is not called for mouse-move or mouse-up tools.
* However it may also be called when the tool is run in a modal fashion,
* when code explicitly sets the diagram's {@link Diagram#currentTool}.
* Implementations of this method can look at {@link Diagram#lastInput} to get the mouse
* event and input state.
* <p/>
* By default this method checks {@link #isActive}; if that is false it calls {@link #canStart}.
* If that in turn is true, this calls {@link #doActivate}.
* This method may be overridden.
* @expose
* @this {Tool}
*/
Tool.prototype.doMouseDown = function() {
  if (!this.isActive && this.canStart()) {
    this.doActivate();
  }
};

/**
* The diagram will call this method upon a mouse move event.
* This is normally overridden for mouse-move tools;
* it is not called for mouse-up tools.
* However it may also be called when the tool is run in a modal fashion,
* when code explicitly sets the diagram's {@link Diagram#currentTool}.
* An override of this method usually does nothing when {@link #isActive} is false.
* Implementations of this method can look at {@link Diagram#lastInput} to get the mouse
* event and input state.
* <p/>
* By default this method does nothing.
* This method may be overridden.
* @expose
* @this {Tool}
*/
Tool.prototype.doMouseMove = function() { };

/**
* The diagram will call this method upon a mouse up event.
* This is normally overridden for mouse-up tools.
* An override of this method usually does nothing when {@link #isActive} is false,
* except for calling {@link #stopTool}.
* Tools normally stop upon a mouse up, by calling {@link #stopTool}.
* If you want to handle multiple mouse down-up gestures in one tool activation,
* you will need to override this method to only stop the tool when you want.
* Implementations of this method can look at {@link Diagram#lastInput} to get the mouse
* event and input state.
* <p/>
* By default this method just calls {@link #stopTool}.
* This method may be overridden.
* @expose
* @this {Tool}
*/
Tool.prototype.doMouseUp = function() {
  this.stopTool();
};

/**
* The diagram will call this method as the mouse wheel is rotated.
* Implementations of this method can look at {@link Diagram#lastInput} to get the mouse
* event and input state.
* <p/>
* By default this method does nothing.
* This method may be overridden.
* @expose
* @this {Tool}
*/
Tool.prototype.doMouseWheel = function() { };


/**
* The diagram will call this method upon a key down event.
* By default this just calls {@link #doCancel} if the key is the ESCAPE key.
* Implementations of this method can look at {@link Diagram#lastInput} to get the key.
* <p/>
* This method may be overridden.
* @expose
* @this {Tool}
*/
Tool.prototype.doKeyDown = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  if (diagram.lastInput.key === 'Esc') {
    this.doCancel();
  }
};

/**
* The diagram will call this method upon a key up event.
* Implementations of this method can look at {@link Diagram#lastInput} to get the key.
* <p/>
* By default this method does nothing.
* This method may be overridden.
* @expose
* @this {Tool}
*/
Tool.prototype.doKeyUp = function() { };


// Transactions

Tool.prototype['startTransaction'] =
/**
* Call {@link Diagram#startTransaction} with the given transaction name.
* This always sets {@link #transactionResult} to null.
* <p/>
* This is normally called in an override of {@link #doActivate}, if the tool modifies the model,
* along with a call to {@link #stopTransaction} in an override of {@link #doDeactivate}.
* Alternatively, you can surround a block of code that sets the {@link #transactionResult}
* with calls to startTransaction and stopTransaction.
* @param {string=} tname a string describing the transaction.
* @return {boolean} the value of the call to {@link Diagram#startTransaction}.
* @this {Tool}
*/
Tool.prototype.startTransaction = function(tname) {
  this.transactionResult = null;
  var diagram = this.diagram;
  if (diagram === null) return false;
  return diagram.startTransaction(tname);
};

Tool.prototype['stopTransaction'] =
/**
* If {@link #transactionResult} is null, call {@link Diagram#rollbackTransaction},
* otherwise call {@link Diagram#commitTransaction}.
* <p/>
* This is normally called in an override of {@link #doDeactivate},
* if {@link #startTransaction} was called in {@link #doActivate}.
* Alternatively, you can surround a block of code that sets the {@link #transactionResult}
* with calls to startTransaction and stopTransaction.
* @return {boolean} the result of the call to rollback or commit the transaction.
* @this {Tool}
*/
Tool.prototype.stopTransaction = function() {
  var diagram = this.diagram;
  if (diagram === null) return false;
  if (this.transactionResult === null)
    return diagram.rollbackTransaction();
  else
    return diagram.commitTransaction(this.transactionResult);
};


// Useful methods

/**
* Implement the standard behavior for selecting parts with the mouse,
* depending on the control and shift modifier keys.
* <p/>
* Control-clicking on a part will select it if it wasn't already,
* and will deselect if it had been selected.
* Shift-clicking on a part will add it to the selection (if it wasn't already).
* Otherwise, clicking on a part will select it (if it wasn't already).
* <p/>
* Note that there are restrictions on selection.
* For example, a part cannot be selected in this manner if {@link GraphObject#selectable} is false,
* or if {@link Diagram#maxSelectionCount} would be exceeded.
* <p/>
* A left click in the background of the diagram with no modifier keys clears the selection.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {Tool}
*/
Tool.prototype.standardMouseSelect = function() {
  var diagram = this.diagram;
  if (diagram === null || !diagram.allowSelect) return;
  var e = diagram.lastInput;
  var curobj = diagram.findPartAt(e.documentPoint, false);  // to select containing Group if Part.canSelect() is false
  if (curobj !== null) {
    if (e.control) {  // toggle the part's selection
      diagram.raiseDiagramEvent('ChangingSelection');
      var part = curobj;
      while (part !== null && !part.canSelect()) part = part.containingGroup;
      part.isSelected = !part.isSelected;
      diagram.raiseDiagramEvent('ChangedSelection');
    } else if (e.shift) {  // add the part to the selection
      if (!curobj.isSelected) {
        diagram.raiseDiagramEvent('ChangingSelection');
        var part = curobj;
        while (part !== null && !part.canSelect()) part = part.containingGroup;
        part.isSelected = true;
        diagram.raiseDiagramEvent('ChangedSelection');
      }
    } else {
      if (!curobj.isSelected) {
        var part = curobj;
        while (part !== null && !part.canSelect()) part = part.containingGroup;
        diagram.select(part);  // also raises ChangingSelection/Finished
      }
    }
  } else if (e.left && !e.control && !e.shift) {
    // left click on background with no modifier: clear selection
    diagram.clearSelection();  // also raises ChangingSelection/Finished
  }
};

/**
* Implement the standard behavior for mouse clicks,
* searching for and calling click handler functions on {@link GraphObject}s
* or on {@link Diagram},
* and raising the corresponding {@link DiagramEvent}.
* <p/>
* A click on a {@link GraphObject} of the diagram will raise one of the following {@link DiagramEvent}s:
* "ObjectSingleClicked", "ObjectDoubleClicked", or "ObjectContextClicked".
* This will also look at the corresponding click property:
* {@link GraphObject#click}, {@link GraphObject#doubleClick}, or {@link GraphObject#contextClick}.
* If the value is a function, this will call it, passing the current {@link InputEvent}
* and the GraphObject.
* If the value is null, it tries looking at the parent {@link GraphObject#panel},
* and so on, walking up the visual tree until it finds the appropriate function to call.
* After calling the click function, if the value of {@link InputEvent#handled} is false,
* this method will continue walking up the visual tree looking for more click functions
* to call.
* Once it has looked at the top-level object (a {@link Part})
* for a click function, this method stops.
* <p/>
* A click in the background of the diagram will raise one of the following {@link DiagramEvent}s:
* "BackgroundSingleClicked", "BackgroundDoubleClicked", or "BackgroundContextClicked".
* This will also look at the corresponding click property:
* {@link Diagram#click}, {@link Diagram#doubleClick}, or {@link Diagram#contextClick}.
* If the value is a function, this will call it, passing the current {@link InputEvent}.
* <p/>
* This method is not responsible for selecting or deselecting any parts.
* Call {@link #standardMouseSelect} for that functionality.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {Tool}
* @param {function(GraphObject):GraphObject | null=} navig An optional custom navigation
* function to find target objects.
* @param {function(GraphObject):boolean | null=} pred An optional custom predicate
* function to find target objects. No value means that only objects in layers holding permanent objects.
*/
Tool.prototype.standardMouseClick = function(navig, pred) {
  if (navig === undefined/*notpresent*/) navig = null;
  if (pred === undefined/*notpresent*/) pred = function(x) { return !x.layer.isTemporary; };
  var diagram = this.diagram;
  if (diagram === null) return;

  var e = diagram.lastInput;
  var curobj = diagram.findObjectAt(e.documentPoint, navig, pred);
  e.targetObject = curobj;

  this._standardClick(curobj, e, diagram);
};

/**
* @ignore
* @this {Tool}
*/
Tool.prototype._standardClick = function(curobj, e, diagram) {
  // decide whether single-click, double-click, or context-click
  var kind = 0;
  if (e.left) {
    if (e.clickCount === 1) {
      kind = 1;
    } else if (e.clickCount === 2) {
      kind = 2;
    } else { // assume more than a double-click is just a rapid single click
      kind = 1;
    }
  } else if (e.right) {
    if (e.clickCount === 1) {
      kind = 3;
    }
  }

  // raise DiagramEvent
  var eventkind = '';
  if (curobj !== null) {
    switch (kind) {
      case 1: eventkind = 'ObjectSingleClicked'; break;
      case 2: eventkind = 'ObjectDoubleClicked'; break;
      case 3: eventkind = 'ObjectContextClicked'; break;
    }
    if (kind !== 0) diagram.raiseDiagramEvent(eventkind, curobj);
  } else {
    switch (kind) {
      case 1: eventkind = 'BackgroundSingleClicked'; break;
      case 2: eventkind = 'BackgroundDoubleClicked'; break;
      case 3: eventkind = 'BackgroundContextClicked'; break;
    }
    if (kind !== 0) diagram.raiseDiagramEvent(eventkind);
  }

  // call any event handlers, bubbling up the chain of GraphObjects
  if (curobj !== null) {
    while (curobj !== null) {
      var func = null;
      switch (kind) {
        case 1: func = curobj.click; break;
        case 2: func = curobj.doubleClick ? curobj.doubleClick : curobj.click; break;
        case 3: func = curobj.contextClick; break;
      }
      if (func !== null) {
        func(e, curobj);  // pass the InputEvent and the bubbled GraphObject
        // (the original GraphObject getting the event is in InputEvent.targetObject)
        if (e.handled) break;
      }
      curobj = curobj.panel;
    }
  } else {
    var func = null;
    switch (kind) {
      case 1: func = diagram.click; break;
      case 2: func = diagram.doubleClick ? diagram.doubleClick : diagram.click; break;
      case 3: func = diagram.contextClick; break;
    }
    if (func !== null) {
      func(e);  // pass the InputEvent; there's no current object or e.targetObject
    }
  }
};

/**
* Implement the standard behavior for mouse enter, over, and leave events,
* where the mouse is moving but no button is pressed.
* This should be called by mouse move event handlers when wanting to
* detect and invoke mouse enter/over/leave event handlers.
* <p/>
* The {@link GraphObject#mouseEnter} property provides a function to call
* when the mouse first enters an object or any of its contained objects
* (if the object is actually a {@link Panel}).
* <p/>
* The {@link GraphObject#mouseLeave} property provides a function to call
* when the mouse leaves an object and all of its contained objects
* (if the object is actually a {@link Panel}).
* <p/>
* The {@link GraphObject#mouseOver} property and {@link Diagram#mouseOver}
* properties provide functions to call when the mouse moves but stays
* within the same {@link GraphObject} or when the mouse moves in the
* background of the {@link Diagram}.
* <p/>
* This method is also responsible for updating the {@link Diagram#currentCursor}
* according to the value of {@link GraphObject#cursor} and {@link Diagram#defaultCursor}.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {Tool}
*/
Tool.prototype.standardMouseOver = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  var e = diagram.lastInput;
  if (e.diagram === null) return;
  var currobj = diagram.findObjectAt(e.documentPoint, null, null);
  e.targetObject = currobj;

  var oldskip = diagram.skipsUndoManager;
  diagram.skipsUndoManager = true;
  var anyfunc = false;

  // if we've changed current objects, call mouseLeave and mouseEnter handlers
  if (currobj !== diagram.currentEnterLeaveObject) {
    // save old and new objects
    var prevobj = diagram.currentEnterLeaveObject;
    diagram.previousEnterLeaveObject = prevobj;
    diagram.currentEnterLeaveObject = currobj;

    // needed to cleanup tooltips:
    this.doCurrentObjectChanged(prevobj, currobj);

    // look for mouseLeave event handler for objects that we left
    while (prevobj !== null) {
      var func = prevobj.mouseLeave;
      if (func !== null) {
        // if the new/current object is inside the previous Panel,
        // we haven't left that Panel
        if (currobj === prevobj) break;
        if (currobj !== null && currobj.isContainedBy(prevobj)) break;
        func(e, prevobj, currobj);
        anyfunc = true;
        if (e.handled) break;
      }
      prevobj = prevobj.panel;
    }
    prevobj = diagram.previousEnterLeaveObject;

    // look for mouseEnter event handler for objects that we entered
    //??? should this call event handler in reverse order: from outside in?
    while (currobj !== null) {
      var func = currobj.mouseEnter;
      if (func !== null) {
        // if the old/previous object is inside the current Panel,
        // we haven't entered this Panel
        if (prevobj === currobj) break;
        if (prevobj !== null && prevobj.isContainedBy(currobj)) break;
        func(e, currobj, prevobj);
        anyfunc = true;
        if (e.handled) break;
      }
      currobj = currobj.panel;
    }
    currobj = diagram.currentEnterLeaveObject;
  }

  if (currobj !== null) {  // now inside some GraphObject
    // look for a cursor -- anything that isn't an empty string
    var obj = currobj;
    var curs = '';  // but default to an empty string
    while (obj !== null) {
      curs = obj.cursor;
      if (curs !== '') break;
      obj = obj.panel;
    }
    diagram.currentCursor = curs;

    // look for mouseOver event handler for current object that we're over
    obj = currobj;
    while (obj !== null) {
      var func = obj.mouseOver;
      if (func !== null) {
        func(e, obj);
        anyfunc = true;
        if (e.handled) break;
      }
      obj = obj.panel;
    }
  } else {  // not now in any GraphObject
    diagram.currentCursor = '';  // use Diagram.defaultCursor
    // maybe execute a mouseOver event handler
    var func = diagram.mouseOver;
    if (func !== null) {
      func(e);
      anyfunc = true;
    }
  }

  if (anyfunc) diagram.requestUpdate();
  diagram.skipsUndoManager = oldskip;
};

/**
* @ignore
* This is called by {@link #standardMouseOver} when the current object changes.
* By default this does nothing.
* @expose
* @this {Tool}
* @param {GraphObject} prev
* @param {GraphObject} curr
*/
Tool.prototype.doCurrentObjectChanged = function(prev, curr) {
};

/**
* Implement the standard behavior for mouse wheel events.
* <p/>
* Turning the mouse wheel if {@link Diagram#allowVerticalScroll} is true
* causes the diagram to scroll up or down.
* If {@link InputEvent#shift} and {@link Diagram#allowHorizontalScroll} are true,
* the diagram scrolls left or right.
* <p/>
* If {@link InputEvent#control} and {@link Diagram#allowZoom} are true,
* turning the mouse wheel changes the diagram's scale,
* zooming in or out while trying to keep the point in the model
* at the same point as the mouse.
* <p/>
* The value of {@link ToolManager#mouseWheelBehavior} affects what operations might occur
* upon mouse wheel events.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {Tool}
*/
Tool.prototype.standardMouseWheel = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  var e = diagram.lastInput;
  var delta = e.delta;
  if (delta === 0) return;
  var wheelBehavior = diagram.toolManager.mouseWheelBehavior;
  if (diagram.allowZoom &&
      ((wheelBehavior === ToolManager.WheelZoom && !e.shift) ||
       (wheelBehavior === ToolManager.WheelScroll && e.control))) {
    // zoom in or out at current mouse point
    var oldzoom = diagram.zoomPoint;
    diagram.zoomPoint = e.viewPoint;
    var cmd = diagram.commandHandler;
    if (cmd !== null) {
      if (delta > 0)
        cmd.increaseZoom();
      else
        cmd.decreaseZoom();
    } else {
      if (delta > 0)
        diagram.scale *= 1.05;
      else
        diagram.scale /= 1.05;
    }
    diagram.zoomPoint = oldzoom;
    e.bubbles = false;
  } else if ((wheelBehavior === ToolManager.WheelZoom && e.shift) ||
             (wheelBehavior === ToolManager.WheelScroll && !e.control)) {
    var oldpos = diagram.position.copy();
    if (!e.shift && diagram.allowVerticalScroll) {
      // scroll up or down
      if (delta > 0) diagram.scroll('line', 'up', 3);
      else diagram.scroll('line', 'down', 3);
    } else if (e.shift && diagram.allowHorizontalScroll) {
      // scroll left or right
      if (delta > 0) diagram.scroll('line', 'left', 3);
      else diagram.scroll('line', 'right', 3);
    }
    if (!diagram.position.equals(oldpos)) {
      e.bubbles = false;
    }
  }
};


/**
* This is called to start a new timer to call {@link #doWaitAfter} after a given delay.
* It first cancels any previously running "WaitAfter" timer, by calling {@link #cancelWaitAfter}.
* <p/>
* This is normally used to implement mouse hover and mouse hold events.
* If the mouse has moved, it must not have moved beyond the distance as determined by
* {@link Tool#isBeyondDragSize} for it be considered "stationary".
* So the regular {@link ToolManager#doMouseMove} implementation only calls
* this method when the mouse has moved beyond the drag size.
* @expose
* @this {Tool}
* @param {number} delay
*/
Tool.prototype.standardWaitAfter = function(delay) {
  Util.checkPrimitive(delay, 'number', Tool, 'standardWaitAfter:delay');
  this.cancelWaitAfter();
  var tool = this;  // closure needed as arg to setTimeout
  this._waitAfterTimer = window.setTimeout(function() { tool.doWaitAfter(); }, delay);
};

/**
* This is called to cancel any running "WaitAfter" timer.
* <p/>
* This is called when a tool is stopped.
* @expose
* @this {Tool}
*/
Tool.prototype.cancelWaitAfter = function() {
  if (this._waitAfterTimer !== -1) {
    window.clearTimeout(this._waitAfterTimer);
  }
  this._waitAfterTimer = -1;
};

/**
* This is called a certain delay after a call to {@link #standardWaitAfter} if there
* has not been any call to {@link #cancelWaitAfter}.
* <p/>
* By default this does nothing.
* This method may be overridden.
* @expose
* @this {Tool}
*/
Tool.prototype.doWaitAfter = function() {
};


/**
* This convenience function finds the front-most {@link GraphObject}
* that is at a given point and that is part of an {@link Adornment}
* that is of a given category.
* <p/>
* This method may be overridden.
* @expose
* @this {Tool}
* @param {Point} p a Point in document coordinates.
* @param {string} category the required {@link Part#category} of the {@link Adornment}.
* @return {GraphObject}
*/
Tool.prototype.findToolHandleAt = function(p, category) {
  var diagram = this.diagram;
  if (diagram === null) return null;
  var element = diagram.findObjectAt(p, null,
        function(x) {
          var gp = x.part;
          if (gp === null) return false;
          return gp.adornedObject !== null;
        });
  if (element === null) return null;
  var top = element.part;
  if (top === null || top.category !== category) return null;
  return element;
};

/**
* Return true when the last mouse point is far enough away from the first mouse down point
* to constitute a drag operation instead of just a potential click.
* <p/>
* This uses the value of {@link ToolManager#dragSize}.
* On touch devices the value is automatically increased to accommodate the unavoidable movement of fingers.
* This method may be overridden.
* @expose
* @this {Tool}
* @param {Point=} first Point in view coordinates, defaults to {@link Diagram#firstInput}'s {@link InputEvent#viewPoint}.
* @param {Point=} last Point in view coordinates, defaults to {@link Diagram#lastInput}'s {@link InputEvent#viewPoint}.
* @return {boolean}
*/
Tool.prototype.isBeyondDragSize = function(first, last) {
  var diagram = this.diagram;
  if (diagram === null) return false;
  // Get both of the points in screen/view coordinates
  if (first === undefined/*notpresent*/) first = diagram.firstInput.viewPoint;
  if (last === undefined/*notpresent*/) last = diagram.lastInput.viewPoint;
  var dsize = diagram.toolManager.dragSize;
  var dw = dsize.width;
  var dh = dsize.height;
  if (Util.supportsTouch) {
    dw += 6;
    dh += 6;
  }
  return (Math.abs(last.x - first.x) > dw ||
          Math.abs(last.y - first.y) > dh);
};


/**
* Gets the {@link Diagram} that owns this tool and
* for which this tool is handling input events.
* @name Tool#diagram
* @function.
* @return {Diagram}
*/
/** @type {Diagram} */
Tool.prototype.diagram;
Util.defineReadOnlyProperty(Tool, {diagram: 'diagram'},
  /** @this {Tool} */
  function() { return this._diagram; }
);

/**
* Gets or sets the name of this tool.
* The initial name is an empty string.
* <p/>
* This name is sometimes used by tools that use {@link Adornment}s as the {@link Part#category} for their Adornments.
* It is also sometimes used by tools that conduct transactions as the transaction name.
* @name Tool#name
* @function.
* @return {string}
*/
/** @type {string} */
Tool.prototype.name;
Util.exportProperty(Tool, 'name', Tool.prototype.name);
Util.defineProperty(Tool, {name: 'name'},
  /** @this {Tool} */
  function() { return this._name; },
  /** @this {Tool} */
  function(val) { this._name = val; }
);

/**
* Gets or sets whether this tool can be started by a mouse event.
* <p/>
* Set this to false to prevent {@link #canStart} from returning true.
* Setting this property to false should prevent this tool from being used in a mode-less fashion
* by the {@link ToolManager} with a mouse down/move/up event.
* However, even when this property is false, this tool can still be used in a modal fashion:
* it can still be started by explicitly setting the
* {@link Diagram#currentTool} property to this tool.
* <p/>
* The default value is true.
* @name Tool#isEnabled
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Tool.prototype.isEnabled;
Util.exportProperty(Tool, 'isEnabled', Tool.prototype.isEnabled);
Util.defineProperty(Tool, {isEnabled: 'isEnabled'},
  /** @this {Tool} */
  function() { return this._isEnabled; },
  /** @this {Tool} */
  function(val) { this._isEnabled = val; }
);

/**
* Gets or sets whether this tool is started and is actively doing something.
* <p/>
* You can set this to true after your tool is started (i.e. when it is the
* {@link Diagram#currentTool} and {@link #doStart}
* had been called), but when it is not yet in a state
* that it is actually "doing" something, because it is waiting for the right
* circumstances.  This is typically only important when the tool is used in
* a modal fashion.
* <p/>
* The default value is false.
* @name Tool#isActive
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Tool.prototype.isActive;
Util.exportProperty(Tool, 'isActive', Tool.prototype.isActive);
Util.defineProperty(Tool, {isActive: 'isActive'},
  /** @this {Tool} */
  function() { return this._isActive; },
  /** @this {Tool} */
  function(val) { this._isActive = val; }
);

/**
* Gets or sets the name of the transaction to be committed by {@link #stopTransaction};
* if null, the transaction will be rolled back.
* <p/>
* If this is non-null at the time of a call to {@link #stopTransaction},
* it calls {@link Diagram#commitTransaction} with this transaction name;
* if this is null at that time, it calls {@link Diagram#rollbackTransaction}.
* <p/>
* The default value is null; {@link #startTransaction} will also set this to null.
* @name Tool#transactionResult
* @function.
* @return {?string}
*/
/** @type {?string} */
Tool.prototype.transactionResult;
Util.exportProperty(Tool, 'transactionResult', Tool.prototype.transactionResult);
Util.defineProperty(Tool, {transactionResult: 'transactionResult'},
  /** @this {Tool} */
  function() { return this._transactionResult; },
  /** @this {Tool} */
  function(val) { this._transactionResult = val; }
);

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
DraggingTool
*/

/**
 * You do not normally need to create an instance of this tool
 * because one already exists as the {@link ToolManager#draggingTool}, which you can modify.
 * @constructor
 * @extends Tool
 * @category Tool
 * @class
 * The DraggingTool is used to move or copy selected parts with the mouse.
 * <p/>
 * Dragging the selection moves parts for which {@link Part#canMove} is true.
 * If the user holds down the Control key, this tool will make a copy of the parts being dragged,
 * for those parts for which {@link Part#canCopy} is true.
 * <p/>
 * When the drag starts it calls {@link #computeEffectiveCollection} to find the actual collection
 * of {@link Part}s to be dragged.
 * Normally this collection includes not only the {@link Diagram#selection}, but also parts that belong
 * to those selected parts, such as members of groups.
 * If {@link #dragsTree} is true, the effective collection also includes all of the nodes and links that
 * constitute the subtree starting from selected nodes.
 * The result of {@link #computeEffectiveCollection} is not a {@link Set} but a {@link Map}
 * which remembers the original {@link Part#location} for all of the dragged parts.
 * This map is saved as the value of {@link #draggedParts}.
 * <p/>
 * During the drag if the user holds down the Control key this tool makes a copy of the {@link #draggedParts}
 * and proceeds to drag it around.
 * (It only copies the {@link Diagram#selection}, not the whole effective collection,
 * if {@link #copiesEffectiveCollection} is false.)
 * The collection of copied parts is held by {@link #copiedParts}.
 * It too is a {@link Map} remembering the original locations of the parts.
 * {@link #copiedParts} will be null when this tool is moving (not copying) at the moment.
 * <p/>
 * If you set {@link #isGridSnapEnabled} to true, dragged or copied parts will be snapped to points on a grid.
 * The snapping occurs continuously during a drag unless you set {@link #isGridSnapRealtime} to false.
 * Normally the grid points come from the {@link Diagram#grid}, even if that grid is not {@link GraphObject#visible}.
 * However you can override those grid's properties for the snapping grid cell size and offset
 * by setting the properties here: {@link #gridSnapCellSize} and {@link #gridSnapOrigin}.
 * This computes the point to snap to for each dragged part.
 * The resulting point is used as the new {@link Part#location}.
 * <p/>
 * This tool does not utilize any {@link Adornment}s or tool handles.
 * If the drag is successful, it raises the "SelectionMoved" or "SelectionCopied" {@link DiagramEvent}
 * and produces a "Move" or a "Copy" transaction.
 */
function DraggingTool() {
  if (arguments.length > 0) {
    Util.throwError('DraggingTool constructor cannot take any arguments.');
  }
  Tool.call(this);
  this.name = 'Dragging';
  /** @type {boolean} */
  this._copiesEffectiveCollection = true;
  /** @type {boolean} */
  this._dragsTree = false;

  // Grid properties
  /** @type {boolean} */
  this._isGridSnapEnabled = false;
  /** @type {boolean} */
  this._isGridSnapRealtime = true;
  /** @type {Size} */
  this._gridSnapCellSize = new Size(NaN, NaN).freeze();
  /** @type {Spot} */
  this._gridSnapCellSpot = Spot.TopLeft;
  /** @type {Point} */
  this._gridSnapOrigin = new Point(NaN, NaN).freeze();

  /** @type {boolean} */
  this._dragsLinks = false;

  // @type {Part} */
  this._currentPart = null;
  // @type {Map} */
  this._draggedParts = null;
  // @type {Map} */
  this._copiedParts = null;
  /** @type {Link} */
  this._draggedLink = null;
  /** @type {boolean} */
  this._isDragOutStarted = false;
  /** @type {boolean} */
  this._dropped = false;
  /** @type {Point} */
  this._startPanelPoint = new Point(NaN, NaN);
  // the mouse point from which parts start to move.
  // @type {Point} */
  this._startPoint = new Point();

  /** @type {boolean} */
  this._suspendedRouting = false;
  // we want to skip the last dragOver event
  /** @type {boolean} */
  this._skipUndo = true;

  /** @type {number} */
  this._delay = 100;


  /** @type {GraphObject} */
  this._previousDragEnterLeaveObject = null;
  /** @type {GraphObject} */
  this._currentDragEnterLeaveObject = null;
}

Util.publish('DraggingTool', DraggingTool);

Util.inherit(DraggingTool, Tool);

/**
* Gets or sets whether for a copying operation the extended selection
* is copied or only the selected parts.
* The default value is true.
* Setting this property does not raise any events.
* @name DraggingTool#copiesEffectiveCollection
* @function.
* @return {boolean}
*/
/** @type {boolean} */
DraggingTool.prototype.copiesEffectiveCollection;
Util.exportProperty(DraggingTool, 'copiesEffectiveCollection', DraggingTool.prototype.copiesEffectiveCollection);
Util.defineProperty(DraggingTool, {copiesEffectiveCollection: 'copiesEffectiveCollection'},
  /** @this {DraggingTool} */
  function() { return this._copiesEffectiveCollection; },
  /** @this {DraggingTool} */
  function(val) { this._copiesEffectiveCollection = val; }
);

/**
* Gets or sets whether moving or copying a node also includes all of the
* node's tree children and their descendants, along with the links to those additional nodes.
* The default value is false.
* Setting this property does not raise any events.
* @name DraggingTool#dragsTree
* @function.
* @return {boolean}
*/
/** @type {boolean} */
DraggingTool.prototype.dragsTree;
Util.exportProperty(DraggingTool, 'dragsTree', DraggingTool.prototype.dragsTree);
Util.defineProperty(DraggingTool, {dragsTree: 'dragsTree'},
  /** @this {DraggingTool} */
  function() { return this._dragsTree; },
  /** @this {DraggingTool} */
  function(val) { this._dragsTree = val; }
);


/**
* Gets or sets whether the {@link DraggingTool} snaps objects to grid points.
* Whether the snapping movement of the dragged parts occurs during the drag or only upon a drop
* is determined by the value of {@link #isGridSnapRealtime}.
* By default this property is false.
* Setting this property does not raise any events.
* @name DraggingTool#isGridSnapEnabled
* @function.
* @return {boolean}
*/
/** @type {boolean} */
DraggingTool.prototype.isGridSnapEnabled;
Util.exportProperty(DraggingTool, 'isGridSnapEnabled', DraggingTool.prototype.isGridSnapEnabled);
Util.defineProperty(DraggingTool, { isGridSnapEnabled: 'isGridSnapEnabled' },
  /** @this {DraggingTool} */
  function() { return this._isGridSnapEnabled; },
  /** @this {DraggingTool} */
  function(val) {
    var old = this._isGridSnapEnabled;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', DraggingTool, 'isGridSnapEnabled');
      this._isGridSnapEnabled = val;
    }
  }
);

/**
* Gets or sets whether the {@link DraggingTool} snaps objects to grid points during the drag.
* This property is ignored unless {@link #isGridSnapEnabled} is true.
* By default this property is true; when false parts are only snapped to grid locations upon the drop (i.e. mouse-up).
* Setting this property does not raise any events.
* @name DraggingTool#isGridSnapRealtime
* @function.
* @return {boolean}
* @since 1.1
*/
/** @type {boolean} */
DraggingTool.prototype.isGridSnapRealtime;
Util.exportProperty(DraggingTool, 'isGridSnapRealtime', DraggingTool.prototype.isGridSnapRealtime);
Util.defineProperty(DraggingTool, { isGridSnapRealtime: 'isGridSnapRealtime' },
  /** @this {DraggingTool} */
  function() { return this._isGridSnapRealtime; },
  /** @this {DraggingTool} */
  function(val) {
    var old = this._isGridSnapRealtime;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', DraggingTool, 'isGridSnapRealtime');
      this._isGridSnapRealtime = val;
    }
  }
);

/**
* Gets or sets the size of the grid cell used when snapping during a drag
* if the value of {@link #isGridSnapEnabled} is true.
* By default this property is the Size(NaN, NaN), which causes this tool to use the {@link Panel#gridCellSize} value of the {@link Diagram#grid}.
* Setting this property does not raise any events.
* @name DraggingTool#gridSnapCellSize
* @function.
* @return {Size}
*/
/** @type {Size} */
DraggingTool.prototype.gridSnapCellSize;
Util.exportProperty(DraggingTool, 'gridSnapCellSize', DraggingTool.prototype.gridSnapCellSize);
Util.defineProperty(DraggingTool, { gridSnapCellSize: 'gridSnapCellSize' },
  /** @this {DraggingTool} */
  function() { return this._gridSnapCellSize; },
  /** @this {DraggingTool} */
  function(val) {
    var old = this._gridSnapCellSize;
    if (!old.equals(val)) {
      Util.checkClass(val, Size, DraggingTool, 'gridSnapCellSize');
      val = val.copyFrozen();
      this._gridSnapCellSize = val;
    }
  }
);

/**
* Gets or sets the {@link Spot} that specifies what point in the grid cell dragged parts snap to,
* if the value of {@link #isGridSnapEnabled} is true.
* By default this property is {@link Spot#TopLeft}:
* node locations will snap exactly to the grid point.
* Setting this property does not raise any events.
* @name DraggingTool#gridSnapCellSpot
* @function.
* @return {Spot}
*/
/** @type {Spot} */
DraggingTool.prototype.gridSnapCellSpot;
Util.exportProperty(DraggingTool, 'gridSnapCellSpot', DraggingTool.prototype.gridSnapCellSpot);
Util.defineProperty(DraggingTool, { gridSnapCellSpot: 'gridSnapCellSpot' },
  /** @this {DraggingTool} */
  function() { return this._gridSnapCellSpot; },
  /** @this {DraggingTool} */
  function(val) {
    var old = this._gridSnapCellSpot;
    if (!old.equals(val)) {
      Util.checkClass(val, Spot, DraggingTool, 'gridSnapCellSpot');
      val = val.copyFrozen();
      this._gridSnapCellSpot = val;
    }
  }
);

/**
* Gets or sets the snapping grid's origin point, in document coordinates,
* if the value of {@link #isGridSnapEnabled} is true.
* By default this property is the Point(NaN, NaN), which causes this tool to use the {@link Panel#gridOrigin} value from the {@link Diagram#grid}.
* Setting this property does not raise any events.
* @name DraggingTool#gridSnapOrigin
* @function.
* @return {Point}
*/
/** @type {Point} */
DraggingTool.prototype.gridSnapOrigin;
Util.exportProperty(DraggingTool, 'gridSnapOrigin', DraggingTool.prototype.gridSnapOrigin);
Util.defineProperty(DraggingTool, { gridSnapOrigin: 'gridSnapOrigin' },
  /** @this {DraggingTool} */
  function() { return this._gridSnapOrigin; },
  /** @this {DraggingTool} */
  function(val) {
    var old = this._gridSnapOrigin;
    if (!old.equals(val)) {
      Util.checkClass(val, Point, DraggingTool, 'gridSnapOrigin');
      val = val.copyFrozen();
      this._gridSnapOrigin = val;
    }
  }
);


/**
* @ignore
* Gets or sets whether the user can drag a single {@link Link},
* disconnecting it from its connected nodes and possibly connecting it
* to valid ports when the link is dropped.
* <p/>
* The default value is false.
* Setting this property does not raise any events.
* @name DraggingTool#dragsLinks
* @function.
* @return {boolean}
*/
/** @type {boolean} */
DraggingTool.prototype.dragsLinks;
Util.exportProperty(DraggingTool, 'dragsLinks', DraggingTool.prototype.dragsLinks);
Util.defineProperty(DraggingTool, {dragsLinks: 'dragsLinks'},
  /** @this {DraggingTool} */
  function() { return this._dragsLinks; },
  /** @this {DraggingTool} */
  function(val) { this._dragsLinks = val; }
);

/**
* Gets the {@link Part} found at the mouse point.
* @name DraggingTool#currentPart
* @function.
* @return {Part}
*/
/** @type {Part} */
DraggingTool.prototype.currentPart;
Util.exportProperty(DraggingTool, 'currentPart', DraggingTool.prototype.currentPart);
Util.defineProperty(DraggingTool, {currentPart: 'currentPart'},
  /** @this {DraggingTool} */
  function() { return this._currentPart; },
  /** @this {DraggingTool} */
  function(val) { this._currentPart = val; }
);


/**
* Gets the collection of {@link Part}s that this tool has copied.
* The value is a {@link Map} mapping {@link Part}s to JavaScript Objects that have a "point" property remembering the original location of that Part
* The value is null when moving instead of copying.
* @name DraggingTool#copiedParts
* @function.
* @return {Map}
*/
/** @type {Map} */
DraggingTool.prototype.copiedParts;
Util.exportProperty(DraggingTool, 'copiedParts', DraggingTool.prototype.copiedParts);
Util.defineProperty(DraggingTool, { copiedParts: 'copiedParts' },
  /** @this {DraggingTool} */
  function() { return this._copiedParts; },
  /** @this {DraggingTool} */
  function(val) { this._copiedParts = val; }
);

/**
* Gets the collection of {@link Part}s being dragged.
* The value is a {@link Map} mapping {@link Part}s to JavaScript Objects that have a "point" property remembering the original location of that Part
* @name DraggingTool#draggedParts
* @function.
* @return {Map}
*/
/** @type {Map} */
DraggingTool.prototype.draggedParts;
Util.exportProperty(DraggingTool, 'draggedParts', DraggingTool.prototype.draggedParts);
Util.defineProperty(DraggingTool, {draggedParts: 'draggedParts'},
  /** @this {DraggingTool} */
  function() { return this._draggedParts; },
  /** @this {DraggingTool} */
  function(val) { this._draggedParts = val; }
);

/**
* @ignore
* Gets or sets the {@link Link} that may be dragged and reconnected
* when {@link DraggingTool#dragsLinks} is true.
* <p/>
* This property is set during {@link DraggingTool#doActivate}.
* The default value is null.
* Setting this property does not raise any events.
* @name DraggingTool#draggedLink
* @function.
* @return {Link}
*/
/** @type {Link} */
DraggingTool.prototype.draggedLink;
Util.exportProperty(DraggingTool, 'draggedLink', DraggingTool.prototype.draggedLink);
Util.defineProperty(DraggingTool, {draggedLink: 'draggedLink'},
  /** @this {DraggingTool} */
  function() { return this._draggedLink; },
  /** @this {DraggingTool} */
  function(val) { this._draggedLink = val; }
);

/**
* @ignore
* Gets or sets whether a potentially external drag-and-drop has been started by this tool.
* <p/>
* This property is set to true when starting a drag-and-drop in {@link DraggintTool#doDragOut}.
* <p/>
* The default value is false.
* Setting this property does not raise any events.
* @name DraggingTool#isDragOutStarted
* @function.
* @return {boolean}
*/
/** @type {boolean} */
DraggingTool.prototype.isDragOutStarted;
Util.exportProperty(DraggingTool, 'isDragOutStarted', DraggingTool.prototype.isDragOutStarted);
Util.defineProperty(DraggingTool, {isDragOutStarted: 'isDragOutStarted'},
  /** @this {DraggingTool} */
  function() { return this._isDragOutStarted; },
  /** @this {DraggingTool} */
  function(val) { this._isDragOutStarted = val; }
);

/**
* On touch gestures only, this property gets or sets the time in milliseconds
* for which the mouse must be stationary before this tool can be started.
* The default value is 100 milliseconds.
* Setting this property does not raise any events.
* @name DraggingTool#delay
* @function.
* @return {number}
*/
/** @type {number} */
DraggingTool.prototype.delay;
Util.exportProperty(DraggingTool, 'delay', DraggingTool.prototype.delay);
Util.defineProperty(DraggingTool, {delay: 'delay'},
  /** @this {DraggingTool} */
  function() { return this._delay; },
  /** @this {DraggingTool} */
  function(val) { this._delay = val; }
);


/**
* This tool can run if the diagram allows selection and moves/copies/dragging-out,
* if the mouse has moved far enough away to be a drag and not a click,
* and if {@link #findDraggablePart} has found a selectable part at the mouse-down point.
* <p/>
* This method may be overridden.
* @this {DraggingTool}
* @return {boolean}
*/
DraggingTool.prototype.canStart = function() {
  if (!this.isEnabled) return false;

  var diagram = this.diagram;
  if (diagram === null) return false;
  if (!diagram.allowMove && !diagram.allowCopy && !diagram.allowDragOut) return false;
  if (!diagram.allowSelect) return false;

  // require left button & that it has moved far enough away from the mouse down point,
  // so it isn't a click
  var e = diagram.lastInput;
  if (!e.left) return false;
  // don't include the following check when this tool is running modally
  if (diagram.currentTool !== this) {
    if (!this.isBeyondDragSize()) return false;
    if (e.isTouchEvent) {
      // must wait for "delay" milliseconds before that tool can run
      if (e.timestamp - diagram.firstInput.timestamp < this._delay) return false;
    }
  }

  // need to be over a part that is movable or copyable
  var part = this.findDraggablePart();
  return (part !== null);
};

/**
* Return the selectable and movable/copyable {@link Part} at the mouse-down point.
* This is called by {@link #canStart} to decide if this tool is ready to run.
* <p/>
* This method may be overridden.
* @expose
* @this {DraggingTool}
* @return {Part}
*/
DraggingTool.prototype.findDraggablePart = function() {
  var diagram = this.diagram;
  if (diagram === null) return null;
  // to select containing Group if Part.canSelect() is false, allow nonselectable
  var part = diagram.findPartAt(diagram.firstInput.documentPoint, false);
  if (part === null) return null;
  while (part !== null && !part.canSelect()) part = part.containingGroup;
  if (part !== null && (part.canMove() || part.canCopy())) return part;
  return null;
};

/**
* This override prevents the Control modifier unselecting an already selected part.
* This also remembers the selectable {@link #currentPart} at the current mouse point.
* <p/>
* This method may be overridden.
* @this {DraggingTool}
*/
DraggingTool.prototype.standardMouseSelect = function() {
  var diagram = this.diagram;
  if (diagram === null || !diagram.allowSelect) return;
  // to select containing Group if Part.canSelect() is false, allow nonselectable
  var part = diagram.findPartAt(diagram.firstInput.documentPoint, false);
  if (part === null) return;
  while (part !== null && !part.canSelect()) part = part.containingGroup;
  this.currentPart = part;

  // change behavior of StandardMouseSelect because we don't want the Control modifier
  // to unselect an already selected object.
  if (!this.currentPart.isSelected) {
    diagram.raiseDiagramEvent('ChangingSelection');
    var e = diagram.lastInput;
    if (!e.control && !e.shift) {
      diagram.internalClearSelection();  // don't raise ChangingSelection/Finished
    }
    this.currentPart.isSelected = true;
    diagram.raiseDiagramEvent('ChangedSelection');
  }
};

/**
* Start the dragging operation.
* This calls {@link #computeEffectiveCollection} and saves the result as {@link #draggedParts}.
* <p/>
* This starts a "Drag" transaction.
* Depending on what happens, the transaction may be finished as a "Move" or a "Copy"
* transaction, or it may be rolled-back if the tool is cancelled.
* @this {DraggingTool}
*/
DraggingTool.prototype.doActivate = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  this.standardMouseSelect();
  var mainnode = this.currentPart;
  if (mainnode === null || (!mainnode.canMove() && !mainnode.canCopy())) return;

  this.isActive = true;
  this._startPanelPoint.set(diagram.position);
  this._checkForDraggedLink(diagram.selection);
  this._previousDragEnterLeaveObject = null;
  this._currentDragEnterLeaveObject = null;
  var coll = this.computeEffectiveCollection(diagram.selection);
  this.draggedParts = coll;

  diagram.skipBoundsUpdates(true);

  this._suspendRouting(this.draggedParts);
  this.startTransaction('Drag');
  this._startPoint.set(diagram.firstInput.documentPoint);
  diagram.isMouseCaptured = true;
  if (diagram.allowDragOut) {
    this.doDragOut();
  }
};

/**
* @ignore
* @this {DraggingTool}
* @param {Iterable} parts
*/
DraggingTool.prototype._checkForDraggedLink = function(parts) {
  if (this.dragsLinks) {
    var diagram = this.diagram;
    if (diagram === null || !diagram.allowRelink) return;
    if (parts.count === 1) {
      var it = parts.iterator;
      it.next();
      this.draggedLink = it.value;
      if (this.draggedLink !== null &&
          this.draggedLink.canRelinkFrom() && this.draggedLink.canRelinkTo()) {
        this.draggedLink.clearAdornments();
      }
    } else {
      this.draggedLink = null;
    }
  }
};

/**
* Find the actual collection of nodes and links to be moved or copied,
* given an initial collection.
* This includes links that connected at both ends to nodes being moved or copied,
* members of {@link Group}s, and if {@link #dragsTree} is true,
* this includes nodes and links that are "tree" descendants from selected nodes.
* <p/>
* Note that this does not return a simple collection of {@link Part}s,
* but a {@link Map} associating a chosen {@link Part}
* with an Object holding its original location Points as the value of the "point" property.
* <p/>
* This method may be overridden.
* @expose
* @this {DraggingTool}
* @param {Iterable} parts A {@link Set} or {@link List} of {@link Parts}.
* @return {Map}  a Map mapping {@link Part}s to JavaScript Objects that have a "point" property remembering the original location of that Part.
*/
DraggingTool.prototype.computeEffectiveCollection = function(parts) {
  var dragging = (this.diagram !== null && this.diagram.currentTool === this);
  var map = new Map(Part, Object);
  if (parts === null) return map;
  var it = parts.iterator;
  while (it.next()) {
    var p = it.value;
    this.gatherMembers(map, p, dragging);
  }
  if (this.draggedLink !== null && this.dragsLinks) return map;
  // ignore any links that are connected to nodes not in the effective collection
  it = parts.iterator;
  while (it.next()) {
    var p = it.value;
    if (p instanceof Link) {
      var l = p;
      var from = l.fromNode;
      if (from !== null && !map.contains(from)) {
        map.remove(l);
      } else {
        var to = l.toNode;
        if (to !== null && !map.contains(to)) {
          map.remove(l);
        }
      }
    }
  }
  return map;
};

/**
* @ignore
* @this {DraggingTool}
* @param {Point=} p
* @return {Object}
*/
DraggingTool.prototype._newDraggingInfo = function(p) {
  if (p === undefined/*notpresent*/) return { 'point': Geo.Origin, _shifted: Geo.Origin };
  return { 'point': p.copy(), _shifted: Geo.Origin };
};

/**
* @ignore
* @this {DraggingTool}
* @param {Map} map  a Map(Part, Object).
* @param {Part} p
* @param {boolean} dragging
*/
DraggingTool.prototype.gatherMembers = function(map, p, dragging) {
  if (map.contains(p)) return;
  // only check canMove or canCopy when dragging interactively, because this is the Diagram.currentTool
  if (dragging && !p.canMove() && !p.canCopy()) return;
  if (p instanceof Node) {
    var n = p;
    map.add(n, this._newDraggingInfo(n.location));
    if (n instanceof Group) {
      var g = n;
      var mit = g.memberParts;
      while (mit.next()) {
        var c = mit.value;
        this.gatherMembers(map, c, dragging);
      }
    }
    var lit = n.linksConnected;
    while (lit.next()) {
      var l = lit.value;
      if (map.contains(l)) continue;
      var from = l.fromNode;
      var to = l.toNode;
      if (from !== null && map.contains(from) &&
          to !== null && map.contains(to)) {
        this.gatherMembers(map, l, dragging);
      }
    }
    if (this.dragsTree) {
      var it = n.findTreeChildrenNodes();
      while (it.next()) {
        var c = it.value;
        this.gatherMembers(map, c, dragging);
      }
    }
  } else if (p instanceof Link) {
    var l = p;
    map.add(l, this._newDraggingInfo());
    var lit = l.labelNodes;
    while (lit.next()) {
      var lab = lit.value;
      this.gatherMembers(map, lab, dragging);
    }
  } else if (!(p instanceof Adornment)) {
    map.add(p, this._newDraggingInfo(p.location));
  }
};

/**
* Stop the dragging operation by stopping the transaction and cleaning up any temporary state.
* @this {DraggingTool}
*/
DraggingTool.prototype.doDeactivate = function() {
  this.isActive = false;
  var diagram = this.diagram;
  if (diagram !== null) diagram.stopAutoScroll();
  this._stopEnterLeave();
  this._resumeRouting(this.draggedParts);
  this.draggedParts = null;
  this.isDragOutStarted = false;
  this._dropped = false;
  DraggingTool.cleanUpDraggingTool();
  this._cleanUpDraggedLink();
  this._startPanelPoint.setTo(NaN, NaN);
  /** @ignore */
  DraggingTool.currentDiagram = null;
  /** @ignore */
  DraggingTool.source = null;
  this.removeCopies();
  diagram.isMouseCaptured = false;

  diagram.skipBoundsUpdates(false);
  this.stopTransaction();
};

/**
* @ignore
* Stop the dragging operation by stopping the transaction and cleaning up any temporary state.
* @this {DraggingTool}
*/
DraggingTool.prototype.localDeactivate = function() {

  this.removeCopies();
  this._restoreOriginalLocations();
  var diagram = this.diagram;
  if (diagram !== null && this._startPanelPoint.isReal()) {
    diagram.position = this._startPanelPoint;
  }

  if (diagram !== null) diagram.stopAutoScroll();
};

/**
* @ignore
* @this {DraggingTool}
*/
DraggingTool.prototype._stopEnterLeave = function() {
  var diagram = this.diagram;
  if (diagram !== null) {
    var oldskip = diagram.skipsUndoManager;
    diagram.skipsUndoManager = true;
    var e = diagram.lastInput;
    var prevobj = this._currentDragEnterLeaveObject;
    while (prevobj !== null) {
      var func = prevobj.mouseDragLeave;
      if (func !== null) {
        func(e, prevobj, null);
        if (e.handled) break;
      }
      prevobj = prevobj.panel;
    }
    diagram.skipsUndoManager = oldskip;
  }
  this._previousDragEnterLeaveObject = null;
  this._currentDragEnterLeaveObject = null;
};

/**
* Abort any dragging operation.
* @this {DraggingTool}
*/
DraggingTool.prototype.doCancel = function() {
  this.removeCopies();
  this._restoreOriginalLocations();
  var diagram = this.diagram;
  if (diagram !== null && this._startPanelPoint.isReal()) {
    diagram.position = this._startPanelPoint;
  }
  this.stopTool();
};

/**
* @ignore
* @this {DraggingTool}
* @param {Iterable} parts
*/
DraggingTool.prototype._suspendRouting = function(parts) {
  if (parts === null) return;
  this._suspendedRouting = true;
  var it = parts.iterator;
  while (it.next()) {
    var link = it.key;
    if (link instanceof Link) {
       link.suspendsRouting = true;
    }
  }
};

/**
* @ignore
* @this {DraggingTool}
* @param {Iterable} parts
*/
DraggingTool.prototype._resumeRouting = function(parts) {
  if (parts === null) return;
  if (!this._suspendedRouting) return;
  var it = parts.iterator;
  while (it.next()) {
    var link = it.key;
    if (link instanceof Link) {
      link.suspendsRouting = false;
      // only need to re-route if the routing style is AvoidsNodes
      if (link.routing === Link.AvoidsNodes) {
        link.invalidateRoute();
      } else {
        link.invalidateMeasure(); // ?? needed or no?
      }
    }
  }
  this._suspendedRouting = false;
};


// DURING A DRAG, either moving or copying:

/**
* Handle switching between copying and moving modes as the Control key is pressed or released.
* @this {DraggingTool}
*/
DraggingTool.prototype.doKeyDown = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  var e = diagram.lastInput;
  if (e === null) return;
  if (!this.isActive) return;
  if (e.key === 'Esc') {
    this.doCancel();
  } else {
    this.doMouseMove();
  }
};

/**
* Handle switching between copying and moving modes as the Control key is pressed or released.
* @this {DraggingTool}
*/
DraggingTool.prototype.doKeyUp = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  var e = diagram.lastInput;
  if (e === null) return;
  if (!this.isActive) return;
  this.doMouseMove();
};


// DURING A DRAG: copying parts

/**
* @ignore
* used in DraggingTool
* @this {Diagram}
* @param {Set|Map} nodes
* @param {Rect} result
* @return {Rect}
*/
DraggingTool.prototype.computeLocations = function(nodes, result) {
  var minx = Infinity;
  var miny = Infinity;
  var maxx = -Infinity;
  var maxy = -Infinity;
  var itr = nodes.iterator;
  while (itr.next()) {
    var n = itr.value;
    if (!n.isNodeLike()) continue; // only nodes
    var l = n.location;
    var x = l.x;
    var y = l.y;
    if (isNaN(x) || isNaN(y)) continue;
    if (x < minx) minx = x;
    if (y < miny) miny = y;
    if (x > maxx) maxx = x;
    if (y > maxy) maxy = y;
  }
  if (minx === Infinity)
    result._set(0, 0, 0, 0);
  else
    result._set(minx, miny, maxx - minx, maxy - miny);
  return result;
};

/**
* @ignore
* @this {DraggingTool}
* @param {boolean} undoable
*/
DraggingTool.prototype.addCopies = function(undoable) {
  if (this.copiedParts !== null) return;
  var diagram = this.diagram;
  if (diagram === null || diagram.isReadOnly || diagram.isModelReadOnly) return;
  if (this.draggedParts === null) return;
  this._restoreOriginalLocations();
  diagram.skipsUndoManager = !undoable;
  diagram.addsToTemporaryLayer = !undoable;

  this._startPoint.set(diagram.firstInput.documentPoint);
  var copieddata;
  if (this.copiesEffectiveCollection) {
    copieddata = diagram.copyParts(this.draggedParts.toKeySet(), diagram, true);
  } else {
    copieddata = diagram.copyParts(diagram.selection, diagram, true);
  }

  // Copy the locations over separately, in case they are not in the data
  var it = copieddata.iterator;
  while (it.next()) {
    var v = it.value;
    v.location = it.key.location;
  }

  var bounds = Util.tempRect();
  this.computeLocations(copieddata, bounds);
  var midx = bounds.x + bounds.width / 2;
  var midy = bounds.y + bounds.height / 2;
  Util.freeRect(bounds);
  var loc = this._startPoint;

  var copiedparts = new Map(Part, Object);
  var nit = this.draggedParts.iterator;
  while (nit.next()) {
    var n = nit.key;
    if (n.isNodeLike() && n.canCopy()) {
      var c = copieddata.getValue(n);
      if (c === null) continue;
      // someday we will want to be more careful than just duplicating the location
      // this causes the copied node's location to exist at the mouse point:
      //var l = n.location;
      //c.location = new Point(loc.x - (midx - l.x), loc.y - (midy - l.y));
      c.ensureBounds();
      copiedparts.add(c, this._newDraggingInfo(c.location));
    }
  }
  var lit = copieddata.iterator;
  while (lit.next()) {
    var l = lit.value;
    if (l instanceof Link && l.canCopy()) {
      copiedparts.add(l, this._newDraggingInfo());
    }
  }
  this.copiedParts = copiedparts;

  this._checkForDraggedLink(copiedparts.toKeySet());
  if (this.draggedLink !== null) {
    var route = this.draggedLink;
    var b = route._getRouteBounds();
    route.movePoints(this._startPoint.x - (b.x + b.width / 2),
                      this._startPoint.y - (b.y + b.height / 2));
  }
};

/**
* @ignore
* @this {DraggingTool}
*/
DraggingTool.prototype.removeCopies = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  if (this.copiedParts !== null) {
    diagram.removeParts(this.copiedParts.toKeySet(), false);
    this.copiedParts = null;
  }
  diagram.skipsUndoManager = false;
  diagram.addsToTemporaryLayer = false;
  this._startPoint.set(diagram.firstInput.documentPoint);
};

/**
* @ignore
* @this {DraggingTool}
*/
DraggingTool.prototype._cleanUpDraggedLink = function() {
  if (this.draggedLink !== null) {
    if (this.dragsLinks) {
      var tool = this.diagram.toolManager.relinkingTool;
      //??? if (tool !== null) tool.stopDraggingMouseMove();
    }
    this.draggedLink = null;
  }
};


// DURING A DRAG: moving parts (perhaps copied parts)

/**
* @ignore
* @this {DraggingTool}
* @param {Map} parts
* @param {boolean} check
*/
DraggingTool.prototype.moveCollection = function(parts, check) {
  var diagram = this.diagram;
  if (diagram === null) return;
  var oldpos = this._startPoint;
  var newpos = Util.tempPoint();
  newpos.assign(diagram.lastInput.documentPoint);
  this.moveParts(parts, newpos.subtract(oldpos), check);
  Util.freePoint(newpos);
};

/**
* Move a collection of {@link Part}s by a given offset.
* <p/>
* This respects the {@link Part#canMove} predicate for {@link Node}s or simple {@link Part}s
* when this is the {@link Diagram#currentTool}.
* It also respects {@link #isGridSnapEnabled} in order to try to automatically snap part locations to a grid.
* And it also uses the {@link Part#dragComputation} function, if any, to determine the new location for each part.
* @expose
* @this {DraggingTool}
* @param {Map} parts  a Map mapping {@link Part}s to JavaScript Objects that have a "point" property remembering the original location of that Part.
* @param {Point} offset
* @param {boolean} check  Whether to check {@link Part#canMove} on each part.
* @since 1.1
*/
DraggingTool.prototype.moveParts = function(parts, offset, check) {
  if (parts === null || parts.count === 0) return;
  var temp = Util.tempPoint();
  var off = Util.tempPoint();
  off.assign(offset);
  if (isNaN(off.x)) off.x = 0;
  if (isNaN(off.y)) off.y = 0;
  // can't optimize a zero offset move, due to possible need to snap the nodes
  //if (off.x === 0 && off.y === 0) return;

  var wassuspended = this._suspendedRouting;
  if (!wassuspended) this._suspendRouting(parts);

  var nestednodes = new List();  // ad-hoc NodeInfoPair with properties: Node, Info, GroupInfo
  var linkkvps = new List(KeyValuePair);
  var it = parts.iterator;
  while (it.next()) {
    var n = it.key;
    if (n.isNodeLike()) {
      var ginfo = this._findContainingInfo(n, parts);
      if (ginfo !== null) {
        nestednodes.add({ node: n, info: it.value, groupInfo: ginfo });  //?? anonymous class
      } else if (!check || n.canMove()) {  // only check canMove() if the user is dragging
        var oldloc = it.value['point'];
        temp.assign(oldloc);
        var newloc = this.computeMove(n, temp.add(off), parts);  // returns a new Point
        n.location = newloc;
        it.value._shifted = newloc.subtract(oldloc);
      }
    } else {
      var l = it.key;
      if (l instanceof Link) {
        linkkvps.add(it._kvp);
      }
    }
  }

  var nnit = nestednodes.iterator;
  while (nnit.next()) {
    var nip = nnit.value;
    var oldloc = nip.info['point'];
    temp.assign(oldloc);
    nip.node.location = temp.add(nip.groupInfo._shifted);
  }

  var fromoff = Util.tempPoint();
  var tooff = Util.tempPoint();
  var kvpit = linkkvps.iterator;
  while (kvpit.next()) {
    var kvp = kvpit.value;
    var link = kvp.key;
    if (!(link instanceof Link)) continue;
    if (link.suspendsRouting) {  // need to move the route explicitly
      var from = link.fromNode;
      var to = link.toNode;
      if (this.draggedLink !== null && this.dragsLinks) {
        var oldlinkoff = kvp.value['point'];
        parts.add(link, this._newDraggingInfo(off));
        var dx = offset.x - oldlinkoff.x;
        var dy = offset.y - oldlinkoff.y;
        link.movePoints(dx, dy);
      } else {
        if (from !== null) {
          fromoff.assign(from.location);
          var info = parts.getValue(from);
          if (info !== null) {
            fromoff.subtract(info['point']);
          }
        }
        if (to !== null) {
          tooff.assign(to.location);
          var info = parts.getValue(to);
          if (info !== null) {
            tooff.subtract(info['point']);
          }
        }
        if (from !== null && to !== null) {  // connected on both ends
          // if both ends moved the same amount, can keep the original route
          if (fromoff.equalsAbout(tooff)) {
            var oldlinkoff = kvp.value['point'];
            var linkoff = temp;
            linkoff.assign(fromoff);
            linkoff.subtract(oldlinkoff);
            parts.add(link, this._newDraggingInfo(fromoff));
            link.movePoints(linkoff.x, linkoff.y);
          } else {  // don't try to maintain shape of path
            link.suspendsRouting = false;
            link.invalidateRoute();
          }
        } else {  // only one or neither end is connected
          var oldlinkoff = kvp.value['point'];
          var o;
          if (from !== null) o = fromoff;
          else if (to !== null) o = tooff;
          else o = offset;
          parts.add(link, this._newDraggingInfo(o));
          var dx = off.x - oldlinkoff.x;
          var dy = off.y - oldlinkoff.y;
          link.movePoints(dx, dy);
        }
      }
    } else {  // move explicitly if partly or fully disconnected
      if (link.fromNode === null || link.toNode === null) {
        var oldlinkoff = kvp.value['point'];
        parts.add(link, this._newDraggingInfo(offset));
        var dx = off.x - oldlinkoff.x;
        var dy = off.y - oldlinkoff.y;
        link.movePoints(dx, dy);
      }
    }
  }
  Util.freePoint(temp);
  Util.freePoint(off);
  Util.freePoint(fromoff);
  Util.freePoint(tooff);
  if (!wassuspended) this._resumeRouting(parts);
};

/**
* @ignore
* @this {DraggingTool}
* @param {Part} n
* @param {Map} parts
* @return
*/
DraggingTool.prototype._findContainingInfo = function(n, parts) {
  var g = n.containingGroup;
  if (g !== null) {
    var info = this._findContainingInfo(g, parts);
    if (info !== null) return info;
    info = parts.getValue(g);
    if (info !== null) return info;
  }
  return null;
};

// move everything back to their original locations, respecting no rerouting of links in DraggedParts
/**
* @ignore
* @this {DraggingTool}
*/
DraggingTool.prototype._restoreOriginalLocations = function() {
  if (this.draggedParts === null) return;
  var diagram = this.diagram;
  var kvpit = this.draggedParts.iterator;
  while (kvpit.next()) {
    var n = kvpit.key;
    if (n.isNodeLike()) {
      n.location = kvpit.value['point'];
    }
  }
  kvpit = this.draggedParts.iterator;
  while (kvpit.next()) {
    var l = kvpit.key;
    if (l instanceof Link && l.suspendsRouting) {
      var oldlinkoff = kvpit.value['point'];
      this.draggedParts.add(l, this._newDraggingInfo());
      l.movePoints(-oldlinkoff.x, -oldlinkoff.y);
    }
  }
  diagram.invalidateDocumentBounds();
};


// DURING A DRAG: while moving parts, snapping to either nodes or the diagram's grid

/**
* @ignore
* @this {DraggingTool}
* @param {Part} moving
* @param {Point} pt
* @param {Part} snapper ???
* @param {Map} draggedparts
* @param {Point} result
* @return {Point}
*/
DraggingTool.prototype.snapTo = function(moving, pt, snapper, draggedparts, result) {
  result.assign(pt);
  if (moving === null) return result;
  if (draggedparts === undefined/*not present*/) draggedparts = null;
  var diagram = this.diagram;
  if (diagram === null) return result;
  var grid = diagram.grid;
  var cell = this.gridSnapCellSize;
  var cellw = cell.width;
  var cellh = cell.height;
  var origin = this.gridSnapOrigin;
  var origx = origin.x;
  var origy = origin.y;
  var spot = this.gridSnapCellSpot;
  if (grid !== null) {
    var gcell = grid.gridCellSize;
    if (isNaN(cellw)) cellw = gcell.width;
    if (isNaN(cellh)) cellh = gcell.height;
    var gorigin = grid.gridOrigin;
    if (isNaN(origx)) origx = gorigin.x;
    if (isNaN(origy)) origy = gorigin.y;
  }
  var gridpt = Util.tempPointAt(0, 0);
  gridpt.setSpot(0, 0, cellw, cellh, spot);
  Geo.findNearestInfiniteGridPoint(pt.x, pt.y, origx + gridpt.x, origy + gridpt.y, cellw, cellh, result);
  Util.freePoint(gridpt);
  return result;
};

/**
* This method computes the new location for a {@link Node} or simple {@link Part},
* given a new desired location and an optional Map of dragged parts,
* taking any grid-snapping into consideration,
* any {@link Part#dragComputation} function,
* and any {@link Part#minLocation} and {@link Part#maxLocation}.
* @expose
* @this {DraggingTool}
* @param {Part} n
* @param {Point} newloc
* @param {Map=} draggedparts  an optional Map mapping {@link Part}s to JavaScript Objects that have a "point" property remembering the original location of that Part.
* @param {Point=} result  an optional Point that is modified and returned
* @return {Point}
* @since 1.1
*/
DraggingTool.prototype.computeMove = function(n, newloc, draggedparts, result) {
  if (result === undefined/*notpresent*/) result = new Point();
  result.assign(newloc);
  if (n === null) return result;
  if (draggedparts === undefined/*not present*/) draggedparts = null;

  var snappt = newloc;
  // only consider diagram snapping if this.isGridSnapEnabled
  // and either the snapping is realtime or when a mouse-up occurs
  if (this.isGridSnapEnabled &&
      (this.isGridSnapRealtime || draggedparts === null || this.diagram.lastInput.up)) {
    snappt = Util.tempPoint();
    this.snapTo(n, newloc, null, draggedparts, snappt);
  }

  // consider if the part has a special drag computation method defined
  var pt;
  if (n.dragComputation !== null) {
    pt = n.dragComputation(n, newloc, snappt);
  } else {
    pt = snappt;
  }

  // interpret NaN in minLocation or maxLocation to continue using the old location X or Y
  var min = n.minLocation;
  var minx = min.x;
  if (isNaN(minx)) minx = n.location.x;
  var miny = min.y;
  if (isNaN(miny)) miny = n.location.y;
  var max = n.maxLocation;
  var maxx = max.x;
  if (isNaN(maxx)) maxx = n.location.x;
  var maxy = max.y;
  if (isNaN(maxy)) maxy = n.location.y;
  result._set(Math.max(minx, Math.min(pt.x, maxx)), Math.max(miny, Math.min(pt.y, maxy)));
  if (snappt !== newloc) Util.freePoint(snappt);
  return result;
};


// DURING A DRAG: affecting stationary parts

/**
* @ignore
* @this {DraggingTool}
* @return {boolean}
*/
DraggingTool.prototype._isDraggedObject = function(obj) {
  if (obj === null) return true;
  var part = obj.part;
  if (part === null) return true;
  if (part.isSelected) return true;
  if (part instanceof Adornment) return true;
  if (part.layer.isTemporary) return true;
  if (this.draggedParts && this.draggedParts.contains(part)) return true;
  if (this.copiedParts && this.copiedParts.contains(part)) return true;
  return false;
};

/**
 * @ignore
 * Affect some stationary unselected parts that are under a given point, and consider auto-scrolling.
 * <p/>
 * Look for a {@link GraphObject} at the given point.
 * If it is a different object, this calls {@link GraphObject#mouseDragLeave} (if it is a function) on the previous object
 * and {@link GraphObject#mouseDragEnter} (if it is a function) on the new object.
 * If there is no object at the given point, this calls {@link Diagram#mouseDragOver} if that property is a function.
 * <p/>
 * This method also performs auto-scrolling, if {@link Diagram#allowScroll} is true.
 * @this {DraggingTool}
 * @param {Point} pt a Point in document coordinates.
 * @param {boolean} moving true if just moving the selection.
 * @param {boolean} copying true if copying the selection.
 */
DraggingTool.prototype.internalDragOver = function(pt, moving, copying) {
  var diagram = this.diagram;
  if (diagram === null) return;

  if (this.dragsLinks) {
    // disconnect the link from any ports
    if (this.draggedLink !== null) {
      var lmodel = this.diagram.model; //draggedLink.model
      if (lmodel instanceof GraphLinksModel) {
        if (this.draggedLink.fromNode !== null) lmodel.setFromPortIdForLinkData(this.draggedLink.data, ''); //lmodel.SetLinkFromPort(this.DraggedLink.data, null, null);
        if (this.draggedLink.toNode !== null) lmodel.setToPortIdForLinkData(this.draggedLink.data, ''); //lmodel.SetLinkToPort(this.DraggedLink.data, null, null);
      }
    }
    // then see if either or both ends are over any valid ports
    this._updateDraggedLinkOverPorts(false);
  }
  var oldskip = false;
  if (this._skipUndo === false) { // we only do this on the last drag
    oldskip = diagram.skipsUndoManager;
    diagram.skipsUndoManager = true;
  }
  var anyfunc = false;

  /** @ignore @type {DraggingTool} */
  var tool = this;
  var currobj = diagram.findObjectAtNoTemp(pt, null,
                                     function(o) { return !tool._isDraggedObject(o); });
  var e = diagram.lastInput;
  e.targetObject = currobj;

  var oldskip2 = diagram.skipsUndoManager;
  diagram.skipsUndoManager = true;

  // if we've changed current objects, call mouseDragLeave and mouseDragEnter handlers
  if (currobj !== this._currentDragEnterLeaveObject) {
    // save old and new objects
    var prevobj = this._currentDragEnterLeaveObject;
    this._previousDragEnterLeaveObject = prevobj;
    this._currentDragEnterLeaveObject = currobj;

    // look for mouseDragLeave event handler for objects that we left
    while (prevobj !== null) {
      var func = prevobj.mouseDragLeave;
      if (func !== null) {
        // if the new/current object is inside the previous Panel,
        // we haven't left that Panel
        if (currobj === prevobj) break;
        if (currobj !== null && currobj.isContainedBy(prevobj)) break;
        func(e, prevobj, currobj);
        anyfunc = true;
        if (e.handled) break;
      }
      prevobj = prevobj.panel;
    }
    prevobj = this._previousDragEnterLeaveObject;

    // look for mouseDragEnter event handler for objects that we entered
    //??? should this call event handler in reverse order: from outside in?
    while (currobj !== null) {
      var func = currobj.mouseDragEnter;
      if (func !== null) {
        // if the old/previous object is inside the current Panel,
        // we haven't entered this Panel
        if (prevobj === currobj) break;
        if (prevobj !== null && prevobj.isContainedBy(currobj)) break;
        func(e, currobj, prevobj);
        anyfunc = true;
        if (e.handled) break;
      }
      currobj = currobj.panel;
    }
    currobj = this._currentDragEnterLeaveObject;
  }

  // not now in any GraphObject
  if (currobj === null) {
    var func = diagram.mouseDragOver;
    if (func !== null) {
      func(e);
      anyfunc = true;
    }
  }

  this.doDragOver(pt, currobj);

  diagram.skipsUndoManager = oldskip2;

  if (anyfunc) diagram.maybeUpdate();
  if (this._skipUndo === false) {
    diagram.skipsUndoManager = oldskip;
  }

  if ((diagram.allowHorizontalScroll || diagram.allowVerticalScroll) &&
      (moving || copying)) {
    diagram.doAutoScroll(pt);
  }
};


/**
 * @ignore
 * @this {DraggingTool}
 * @param {boolean} commit
 */
DraggingTool.prototype._updateDraggedLinkOverPorts = function(commit) {
  var link = this.draggedLink;
  if (link !== null) {
    var diagram = this.diagram;
    //??? NYI
  }
};

/**
* Perform any additional side-effects during a drag, whether an internal move or copy or an external drag,
* that may affect the existing non-moved object(s).
* @expose
* @this {DraggingTool}
* @param {Point} pt a Point in document coordinates.
* @param {GraphObject} obj the {@link GraphObject} at the point,
* excluding what is being dragged or temporary objects;
* the argument may be null if the drag is occurring in the background of the diagram.
* Use {@link GraphObject#part} to get the {@link Node} or {@link Part} at the root of
* the visual tree of the stationary object.
* @since 1.1
*/
DraggingTool.prototype.doDragOver = function(pt, obj) {
};


// UPON A DROP:

/**
* @ignore
* Perform any additional side-effects after a drop.
* <p/>
* This looks for a {@link GraphObject} at the given point.
* If it finds one, this calls its {@link GraphObject#mouseDrop} value if it is a function.
* Otherwise this calls the {@link Diagram#mouseDrop} value if it is a function.
* <p/>
* This also reroutes "AvoidsNodes" links that intersect with the area(s) where the selection is dropped.
* @this {DraggingTool}
* @param {Point} pt a Point in document coordinates.
*/
DraggingTool.prototype.internalDropOnto = function(pt) {
  var diagram = this.diagram;
  if (diagram === null) return;
  var model = diagram.model;
  if (model === null) return;

  if (this.dragsLinks) this._updateDraggedLinkOverPorts(true);

  // pretend the mouse has moved out of the current object, to clean up any side-effects
  this._stopEnterLeave();

  /** @ignore @type {DraggingTool} */
  var tool = this;
  var currobj = diagram.findObjectAtNoTemp(pt, null,
                                     function(o) { return !tool._isDraggedObject(o); });
  var e = diagram.lastInput;
  e.targetObject = currobj;

  if (currobj !== null) {
    var obj = currobj;
    // look for mouseDrop event handlers up chain of panels
    while (obj !== null) {
      var func = obj.mouseDrop;
      if (func !== null) {
        func(e, obj);
        if (e.handled) break;
      }
      obj = obj.panel;
    }
  } else {
    // maybe execute a mouseDrop event handler for the Diagram background
    var func = diagram.mouseDrop;
    if (func !== null) {
      func(e);
    }
  }

  this.doDropOnto(pt, currobj);

  // after dropping a Node, see if it overlaps with any AvoidsNodes link that might need to be re-routed
  var itr = diagram.selection.iterator;
  while (itr.next()) {
    var node = itr.value;
    if (!(node instanceof Node)) continue;
    diagram.invalidateAvoidsNodesLinks(node.actualBounds);
  }
};

/**
* Perform any additional side-effects after a drop, whether an internal move or copy or an external drop,
* that may affect the existing non-moved object(s).
* @expose
* @this {DraggingTool}
* @param {Point} pt a Point in document coordinates.
* @param {GraphObject} obj the {@link GraphObject} where the drop occurred,
* excluding what was dropped or temporary objects;
* the argument may be null if the drop occurred in the background of the diagram.
* Use {@link GraphObject#part} to get the {@link Node} or {@link Part} at the root of
* the visual tree of the stationary object.
* @since 1.1
*/
DraggingTool.prototype.doDropOnto = function(pt, obj) {
};


// Internal mouse drag and drop

/**
* Move the {@link #draggedParts} (or if copying, the {@link #copiedParts}) to follow the current mouse point.
* <p/>
* This calls {@link #doDragOver} for any side-effects on stationary parts.
* @this {DraggingTool}
*/
DraggingTool.prototype.doMouseMove = function() {
  if (!this.isActive) return;
  var diagram = this.diagram;
  if (diagram === null) return;
  var mainnode = this.currentPart;

  if (mainnode !== null && this.draggedParts !== null) {
    var copying = false;
    var moving = false;

    // handle copying by making copy immediately, and dragging it
    if (this.mayCopy()) {
      copying = true;
      this.addCopies(false);  // false means it doesn't get recorded in UndoManager
      this.moveCollection(this.copiedParts, true);
    } else if (this.mayMove()) {
      moving = true;
      this.removeCopies();  // get rid of any copies, in case COPYING had been true before
      this.moveCollection(this.draggedParts, true);
    } else {
      this.removeCopies();
    }

    this.internalDragOver(diagram.lastInput.documentPoint, moving, copying);
    diagram.requestUpdate();
  }
};

/**
* On a mouse-up finish moving or copying the effective selection.
* <p/>
* This calls {@link #doDropOnto} for any side-effects on stationary parts.
* <p/>
* This also updates the diagram's bounds,
* raises a "SelectionCopied" or "SelectionMoved" DiagramEvent, and stops this tool.
* @this {DraggingTool}
*/
DraggingTool.prototype.doMouseUp = function() {
  if (!this.isActive) return;
  this._dropped = true;
  var diagram = this.diagram;
  if (diagram === null) return;

  var maybeUpdateGroups = false;

  var copying = this.mayCopy();
  if (copying && this.copiedParts !== null) {
    this._restoreOriginalLocations();
    this.removeCopies();
    this.addCopies(true);
    this.moveCollection(this.copiedParts, true);
    if (this.copiedParts !== null) diagram.selectCollection(this.copiedParts.toKeySet());
  } else {
    maybeUpdateGroups = true;
    this.removeCopies();  // get rid of any copies, in case COPYING had been true before
    // one last dragOver event, this time not skipping the undo manager
    if (this.mayMove()) {
      this.moveCollection(this.draggedParts, true);
      this._skipUndo = false;
      this.internalDragOver(diagram.lastInput.documentPoint, true, false);
      this._skipUndo = true;
    }
  }
  // consider side-effects on the "target" object, if any
  this.internalDropOnto(diagram.lastInput.documentPoint);
  if (this.isActive) {
    this.copiedParts = null;
    if (maybeUpdateGroups) this._maybeUpdateContainingGroups();

    diagram.invalidateDocumentBounds();
    this._resumeRouting(this.draggedParts);
    // set the EditResult before raising event, in case it changes the result or cancels the tool
    this.transactionResult = (copying ? 'Copy' : 'Move');
    diagram.raiseDiagramEvent(copying ? 'SelectionCopied' : 'SelectionMoved', diagram.selection);
  }
  this.stopTool();
};

/**
* @ignore
* @this {DraggingTool}
*/
DraggingTool.prototype._maybeUpdateContainingGroups = function() {
  if (this.draggedParts === null) return;
  var it = this.draggedParts.iterator;
  while (it.next()) {
    var part = it.key;
    if (part instanceof Node) {
      var n = part;
      var sg = n.containingGroup;
      if (sg !== null && sg.placeholder !== null && !this.draggedParts.contains(sg)) {
         if (sg.computesBoundsAfterDrag) {
          sg.invalidateMeasure();
        }
      }
    }
  }
};

/**
* This predicate is true when the diagram allows objects to be copied and inserted,
* and some object in the selection is copyable,
* and the user is holding down the Control key.
* <p/>
* This method may be overridden, although in most cases it is easiest to set {@link Part#copyable}.
* @expose
* @this {DraggingTool}
* @return {boolean}
*/
DraggingTool.prototype.mayCopy = function() {
  var diagram = this.diagram;
  if (diagram === null || diagram.isReadOnly || diagram.isModelReadOnly || !diagram.allowInsert || !diagram.allowCopy) return false;
  if (!diagram.lastInput.control) return false;
  var it = diagram.selection.iterator;
  while (it.next()) {
    var part = it.value;
    if (part.isNodeLike()) {
      var n = part;
      if (n.canCopy()) {
        return true;
      }
    }
  }
  if (this.draggedLink !== null && this.dragsLinks && this.draggedLink.canCopy()) return true;
  return false;
};

/**
* This predicate is true when the diagram allows objects to be moved,
* and some object in the selection is movable.
* <p/>
* This method may be overridden, although in most cases it is easiest to set {@link Part#movable}.
* @expose
* @this {DraggingTool}
* @return {boolean}
*/
DraggingTool.prototype.mayMove = function() {
  var diagram = this.diagram;
  if (diagram === null || diagram.isReadOnly || !diagram.allowMove) return false; // isModelReadOnly does not stop the diagram from moving an object
  var it = diagram.selection.iterator;
  while (it.next()) {
    var part = it.value;
    if (part.isNodeLike()) {
      var n = part;
      if (n.canMove()) {
        return true;
      }
    }
  }
  if (this.draggedLink !== null && this.dragsLinks && this.draggedLink.canMove()) return true;
  return false;
};



// Static
/** @ignore */
DraggingTool._draggedOverTools = new List(DraggingTool);

/**
 * @ignore
 * @this {DraggingTool}
 */
DraggingTool.prototype.rememberDraggingTool = function() {
  if (!DraggingTool._draggedOverTools.contains(this)) {
    DraggingTool._draggedOverTools.add(this);
  }
};

/**
 * @ignore
 * @this {DraggingTool}
 */
DraggingTool.cleanUpDraggingTool = function() {
  // hack to clean up temporary nodes created by DragOver in other Diagrams
  if (DraggingTool._draggedOverTools.count > 0) {
    var tools = DraggingTool._draggedOverTools;
    var l = tools.length;
    for (var i = 0; i < l; i++) {
      var tool = tools._arr[i];
      tool._cleanUpDraggedLink();
      tool.removeCopies();
      tool._stopEnterLeave();
      if (tool.diagram !== null) {
        tool.diagram.stopAutoScroll();  // make sure there isn't any timer going
      }
    }
    tools.clear();
  }
  // don't set DraggingTool.source = null
};

// Simulated drag-and-drop

//??? support moving between diagrams
//??? drop effects: e.g. Copy Allowed

//the DraggingTool that is the source of a simulated drag-and-drop
/** @ignore @type {DraggingTool} */
DraggingTool.source = null;
/** @ignore @type {Diagram} */
DraggingTool.currentDiagram = null;


// in the target DraggingTool:

/**
 * @ignore
 * @expose
 * @return {boolean}
 */
DraggingTool.prototype.mayCopyExternal = function() {
  var diagram = this.diagram;  // this diagram must allow insert
  if (diagram === null || !diagram.allowDrop || diagram.isReadOnly || diagram.isModelReadOnly || !diagram.allowInsert) return false;
  var model = diagram.model;  // this model must support the data
  if (model === null) return false;
  return true;
};

/**
 * @ignore
 * @expose
 * @this {DraggingTool}
 */
DraggingTool.prototype.doSimulatedDragEnter = function() {
  if (!this.mayCopyExternal()) return;
  var draggingTool = DraggingTool.source;
  if (draggingTool !== null) draggingTool.localDeactivate();
  this.rememberDraggingTool();
};

/**
 * @ignore
 * @expose
 * @this {DraggingTool}
 */
DraggingTool.prototype.doSimulatedDragLeave = function() {

  var draggingTool = DraggingTool.source;
  draggingTool.isDragOutStarted = false;

  this.doCancel();
};

/**
 * @ignore
 * @expose
 * @this {DraggingTool}
 */
DraggingTool.prototype.doSimulatedDragOver = function() {
  if (!this.mayCopyExternal()) return;
  var diagram = this.diagram;
  if (diagram === null) return;
  var src = DraggingTool.source;
  if (src !== null && src.draggedParts !== null) {
    this.addCopiesSim(src.draggedParts.toKeySet(), false);
    this.moveCollection(this.copiedParts, false);

    this.internalDragOver(diagram.lastInput.documentPoint, false, true);
    diagram.requestUpdate();
  }
};

/**
 * @ignore
 * @expose
 * @this {DraggingTool}
 */
DraggingTool.prototype.doSimulatedDrop = function() {
  var src = DraggingTool.source;
  if (src !== null) {
    // always tell source Diagram/DraggingTool that the drop happened, even if disallowed
    src._dropped = true;

    // get rid of any temporary objects before turning on any UndoManager
    this.removeCopies();

    if (!this.mayCopyExternal()) return;

    var diagram = this.diagram;
    if (diagram === null) return;
    this.startTransaction('Drop');
    this.addCopiesSim(src.draggedParts.toKeySet(), true);
    this.moveCollection(this.copiedParts, true);
    if (this.copiedParts !== null) diagram.selectCollection(this.copiedParts.toKeySet());
    this.transactionResult = 'ExternalCopy';
    // consider side-effects on the "target" object, if any
    this.internalDropOnto(diagram.lastInput.documentPoint);

    // cleanup
    this.copiedParts = null;

    diagram.raiseDiagramEvent('ExternalObjectsDropped', diagram.selection);
    this.stopTransaction();

    diagram.invalidateDocumentBounds();
  }
};

/**
 * @ignore
 * Nearly identical to addCopies, it is
 * @this {DraggingTool}
 * @param {Set} originals
 * @param {boolean} undoable
 */
DraggingTool.prototype.addCopiesSim = function(originals, undoable) {
  if (this.copiedParts !== null) return;
  var diagram = this.diagram;
  if (diagram === null || diagram.isReadOnly || diagram.isModelReadOnly) return;
  var model = diagram.model;
  if (model === null) return;
  diagram.skipsUndoManager = !undoable;
  diagram.addsToTemporaryLayer = !undoable;

  this._startPoint.set(diagram.lastInput.documentPoint);
  var copieddata = diagram.copyParts(originals, diagram, true); // might be right

  var bounds = Util.tempRect();
  this.computeLocations(originals, bounds);
  var midx = bounds.x + bounds.width / 2;
  var midy = bounds.y + bounds.height / 2;
  Util.freeRect(bounds);
  var loc = this._startPoint;

  var copiedparts = new Map(Part, Object);
  var temp = Util.tempPoint();
  var nit = originals.iterator;
  while (nit.next()) {
    var n = nit.value;
    if (n.isNodeLike() && n.canCopy()) {
      var nloc = n.location;
      var c = copieddata.getValue(n);
      temp._set(loc.x - (midx - nloc.x), loc.y - (midy - nloc.y));
      c.location = temp
      c.ensureBounds();
      copiedparts.add(c, this._newDraggingInfo(temp));
    }
  }
  Util.freePoint(temp);
  var lit = copieddata.iterator;
  while (lit.next()) {
    var l = lit.value;
    if (l instanceof Link && l.canCopy()) {
      copiedparts.add(l, this._newDraggingInfo());
    }
  }

  this.copiedParts = copiedparts;

  this._checkForDraggedLink(copiedparts.toKeySet());
  if (this.draggedLink !== null) {
    var route = this.draggedLink;
    var b = route._getRouteBounds();
    route.movePoints(this._startPoint.x - (b.x + b.width / 2),
                      this._startPoint.y - (b.y + b.height / 2));
  }
};


// simulated drag-and-drop

// in the source DraggingTool:
/**
 * @ignore
 * @this {DraggingTool}
 */
DraggingTool.prototype.doDragOut = function() {
  this.isDragOutStarted = true;
  this._dropped = false;
  DraggingTool.source = this;
  DraggingTool.currentDiagram = this.diagram; // ???
};

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
LinkingBaseTool
LinkingTool
RelinkingTool
*/

/**
* Don't construct this directly -- this is an abstract class.
* @constructor
* @extends Tool
* @category Tool
* @class
* This abstract class is the base class for the {@link LinkingTool} and {@link RelinkingTool} classes.
* <p/>
* This class includes properties for defining and accessing any temporary nodes and temporary link
* that are used during any linking operation, as well as access to the existing diagram's nodes and link
* (if any) that are involved with the linking operation.
*/
function LinkingBaseTool() {
  if (arguments.length > 0) {
    Util.throwError('LinkingBaseTool constructor cannot take any arguments.');
  }
  Tool.call(this);
  /** @type {number} */
  this._portGravity = 100.0;
  /** @type {boolean} */
  this._isUnconnectedLinkValid = false;

  var link = new Link();
  link.selectionObjectName = 'PATH';
  var path = new Shape();
  path.isPanelMain = true;
  path.name = 'PATH';
  path.stroke = 'blue';
  link.add(path);
  var arrow = new Shape();
  arrow.toArrow = 'Standard';
  arrow.fill = 'blue';
  link.add(arrow);
  link.layerName = 'Tool';
  /** @type {Link} */
  this._temporaryLink = link;

  var fromNode = new Node();
  var fromPort = new Shape();
  fromPort.portId = '';
  fromPort.figure = 'Rectangle';
  fromPort.fill = null;
  fromPort.stroke = 'magenta';
  fromPort.strokeWidth = 2;
  fromPort.desiredSize = Geo.OneSize;
  fromNode.add(fromPort);
  fromNode.selectable = false;
  fromNode.layerName = 'Tool';
  /** @type {Node} */
  this._temporaryFromNode = fromNode;
  /** @type {GraphObject} */
  this._temporaryFromPort = fromPort;

  var toNode = new Node();
  var toPort = new Shape();
  toPort.portId = '';
  toPort.figure = 'Rectangle';
  toPort.fill = null;
  toPort.stroke = 'magenta';
  toPort.strokeWidth = 2;
  toPort.desiredSize = Geo.OneSize;
  toNode.add(toPort);
  toNode.selectable = false;
  toNode.layerName = 'Tool';
  /** @type {Node} */
  this._temporaryToNode = toNode;
  /** @type {GraphObject} */
  this._temporaryToPort = toPort;

  // transient state
  /** @type {Link} */
  this._originalLink = null;
  /** @type {Node} */
  this._originalFromNode = null;
  /** @type {GraphObject} */
  this._originalFromPort = null;
  /** @type {Node} */
  this._originalToNode = null;
  /** @type {GraphObject} */
  this._originalToPort = null;

  /** @type {boolean} */
  this._isForwards = true;
  /** @type {Map} */
  this._validPortsCache = new Map(GraphObject, 'boolean');
  /** @type {GraphObject} */
  this._targetPort = null;
  /** @type {function(Node, GraphObject, Node, GraphObject, Link):boolean | null} */
  this._linkValidation = null;
  /** @type {function(Node, GraphObject, Node, GraphObject, boolean) | null} */
  this._portTargeted = null;
}

Util.publish('LinkingBaseTool', LinkingBaseTool);

Util.inherit(LinkingBaseTool, Tool);

/**
* @ignore
* Clear out any temporary state.
* @this {LinkingBaseTool}
*/
LinkingBaseTool.prototype.doStop = function() {
  var diagram = this.diagram;
  if (diagram !== null) diagram.stopAutoScroll();
  this.originalLink = null;
  this.originalFromNode = null;
  this.originalFromPort = null;
  this.originalToNode = null;
  this.originalToPort = null;
  this.validPortsCache.clear();
  this.targetPort = null;
};


/**
* Gets or sets the distance at which link snapping occurs.
* The default value is 100.0.
* The value must be non-negative.
* Setting this property does not raise any events.
* @name LinkingBaseTool#portGravity
* @function.
* @return {number}
*/
/** @type {number} */
LinkingBaseTool.prototype.portGravity;
Util.exportProperty(LinkingBaseTool, 'portGravity', LinkingBaseTool.prototype.portGravity);
Util.defineProperty(LinkingBaseTool, {portGravity: 'portGravity'},
  /** @this {LinkingBaseTool} */
  function() { return this._portGravity; },
  /** @this {LinkingBaseTool} */
  function(val) {
    var old = this._portGravity;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'number', LinkingBaseTool, 'portGravity');
      this._portGravity = val;
    }
  }
);

/**
* @ignore
* Gets or sets whether it is valid to have partly or completely unconnected links.
* Setting this property does not raise any events.
* @name LinkingBaseTool#isUnconnectedLinkValid
* @function.
* @return {boolean}
*/
/** @type {boolean} */
LinkingBaseTool.prototype.isUnconnectedLinkValid;
Util.exportProperty(LinkingBaseTool, 'isUnconnectedLinkValid', LinkingBaseTool.prototype.isUnconnectedLinkValid);
Util.defineProperty(LinkingBaseTool, {isUnconnectedLinkValid: 'isUnconnectedLinkValid'},
  /** @this {LinkingBaseTool} */
  function() { return this._isUnconnectedLinkValid; },
  /** @this {LinkingBaseTool} */
  function(val) {
    var old = this._isUnconnectedLinkValid;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', LinkingBaseTool, 'isUnconnectedLinkValid');
      this._isUnconnectedLinkValid = val;
    }
  }
);


/**
* Gets or sets the temporary {@link Link} that is shown while the user is drawing or reconnecting a link.
* Setting this property does not raise any events.
* @name LinkingBaseTool#temporaryLink
* @function.
* @return {Link}
*/
/** @type {Link} */
LinkingBaseTool.prototype.temporaryLink;
Util.exportProperty(LinkingBaseTool, 'temporaryLink', LinkingBaseTool.prototype.temporaryLink);
Util.defineProperty(LinkingBaseTool, {temporaryLink: 'temporaryLink'},
  /** @this {LinkingBaseTool} */
  function() { return this._temporaryLink; },
  /** @this {LinkingBaseTool} */
  function(val) {
    var old = this._temporaryLink;
    if (old !== val) {
      if (Debug) Util.checkClass(val, Link, LinkingBaseTool, 'temporaryLink');
      this._temporaryLink = val;
    }
  }
);

/**
* Gets or sets the temporary {@link Node} at the "from" end of the {@link #temporaryLink}
* while the user is drawing or reconnecting a link.
* Setting this property does not raise any events.
* @name LinkingBaseTool#temporaryFromNode
* @function.
* @return {Node}
*/
/** @type {Node} */
LinkingBaseTool.prototype.temporaryFromNode;
Util.exportProperty(LinkingBaseTool, 'temporaryFromNode', LinkingBaseTool.prototype.temporaryFromNode);
Util.defineProperty(LinkingBaseTool, {temporaryFromNode: 'temporaryFromNode'},
  /** @this {LinkingBaseTool} */
  function() { return this._temporaryFromNode; },
  /** @this {LinkingBaseTool} */
  function(val) {
    var old = this._temporaryFromNode;
    if (old !== val) {
      if (Debug) Util.checkClass(val, Node, LinkingBaseTool, 'temporaryFromNode');
      this._temporaryFromNode = val;
    }
  }
);

/**
* Gets or sets the {@link GraphObject} that is the port at the "from" end of the {@link #temporaryLink}
* while the user is drawing or reconnecting a link.
* Setting this property does not raise any events.
* @name LinkingBaseTool#temporaryFromPort
* @function.
* @return {GraphObject}
*/
/** @type {GraphObject} */
LinkingBaseTool.prototype.temporaryFromPort;
Util.exportProperty(LinkingBaseTool, 'temporaryFromPort', LinkingBaseTool.prototype.temporaryFromPort);
Util.defineProperty(LinkingBaseTool, {temporaryFromPort: 'temporaryFromPort'},
  /** @this {LinkingBaseTool} */
  function() { return this._temporaryFromPort; },
  /** @this {LinkingBaseTool} */
  function(val) {
    var old = this._temporaryFromPort;
    if (old !== val) {
      if (Debug) Util.checkClass(val, GraphObject, LinkingBaseTool, 'temporaryFromPort');
      this._temporaryFromPort = val;
    }
  }
);

/**
* Gets or sets the temporary {@link Node} at the "to" end of the {@link #temporaryLink}
* while the user is drawing or reconnecting a link.
* Setting this property does not raise any events.
* @name LinkingBaseTool#temporaryToNode
* @function.
* @return {Node}
*/
/** @type {Node} */
LinkingBaseTool.prototype.temporaryToNode;
Util.exportProperty(LinkingBaseTool, 'temporaryToNode', LinkingBaseTool.prototype.temporaryToNode);
Util.defineProperty(LinkingBaseTool, {temporaryToNode: 'temporaryToNode'},
  /** @this {LinkingBaseTool} */
  function() { return this._temporaryToNode; },
  /** @this {LinkingBaseTool} */
  function(val) {
    var old = this._temporaryToNode;
    if (old !== val) {
      if (Debug) Util.checkClass(val, Node, LinkingBaseTool, 'temporaryToNode');
      this._temporaryToNode = val;
    }
  }
);

/**
* Gets or sets the {@link GraphObject} that is the port at the "to" end of the {@link #temporaryLink}
* while the user is drawing or reconnecting a link.
* Setting this property does not raise any events.
* @name LinkingBaseTool#temporaryToPort
* @function.
* @return {GraphObject}
*/
/** @type {GraphObject} */
LinkingBaseTool.prototype.temporaryToPort;
Util.exportProperty(LinkingBaseTool, 'temporaryToPort', LinkingBaseTool.prototype.temporaryToPort);
Util.defineProperty(LinkingBaseTool, {temporaryToPort: 'temporaryToPort'},
  /** @this {LinkingBaseTool} */
  function() { return this._temporaryToPort; },
  /** @this {LinkingBaseTool} */
  function(val) {
    var old = this._temporaryToPort;
    if (old !== val) {
      if (Debug) Util.checkClass(val, GraphObject, LinkingBaseTool, 'temporaryToPort');
      this._temporaryToPort = val;
    }
  }
);


/**
* Gets or sets the original {@link Link} being reconnected by the {@link RelinkingTool}.
* Setting this property does not raise any events.
* @name LinkingBaseTool#originalLink
* @function.
* @return {Link}
*/
/** @type {Link} */
LinkingBaseTool.prototype.originalLink;
Util.exportProperty(LinkingBaseTool, 'originalLink', LinkingBaseTool.prototype.originalLink);
Util.defineProperty(LinkingBaseTool, {originalLink: 'originalLink'},
  /** @this {LinkingBaseTool} */
  function() { return this._originalLink; },
  /** @this {LinkingBaseTool} */
  function(val) {
    var old = this._originalLink;
    if (old !== val) {
      if (Debug && val !== null) Util.checkClass(val, Link, LinkingBaseTool, 'originalLink');
      this._originalLink = val;
    }
  }
);

/**
* Gets or sets the original {@link Node} from which the new link is being drawn
* or from which the {@link #originalLink} was connected when being relinked.
* Setting this property does not raise any events.
* @name LinkingBaseTool#originalFromNode
* @function.
* @return {Node}
*/
/** @type {Node} */
LinkingBaseTool.prototype.originalFromNode;
Util.exportProperty(LinkingBaseTool, 'originalFromNode', LinkingBaseTool.prototype.originalFromNode);
Util.defineProperty(LinkingBaseTool, {originalFromNode: 'originalFromNode'},
  /** @this {LinkingBaseTool} */
  function() { return this._originalFromNode; },
  /** @this {LinkingBaseTool} */
  function(val) {
    var old = this._originalFromNode;
    if (old !== val) {
      if (Debug && val !== null) Util.checkClass(val, Node, LinkingBaseTool, 'originalFromNode');
      this._originalFromNode = val;
    }
  }
);

/**
* Gets or sets the {@link GraphObject} that is the port in the {@link #originalFromNode}.
* Setting this property does not raise any events.
* @name LinkingBaseTool#originalFromPort
* @function.
* @return {GraphObject}
*/
/** @type {GraphObject} */
LinkingBaseTool.prototype.originalFromPort;
Util.exportProperty(LinkingBaseTool, 'originalFromPort', LinkingBaseTool.prototype.originalFromPort);
Util.defineProperty(LinkingBaseTool, {originalFromPort: 'originalFromPort'},
  /** @this {LinkingBaseTool} */
  function() { return this._originalFromPort; },
  /** @this {LinkingBaseTool} */
  function(val) {
    var old = this._originalFromPort;
    if (old !== val) {
      if (Debug && val !== null) Util.checkClass(val, GraphObject, LinkingBaseTool, 'originalFromPort');
      this._originalFromPort = val;
    }
  }
);

/**
* Gets or sets the original {@link Node} to which the new link is being drawn
* or to which the {@link #originalLink} was connected when being relinked.
* Setting this property does not raise any events.
* @name LinkingBaseTool#originalToNode
* @function.
* @return {Node}
*/
/** @type {Node} */
LinkingBaseTool.prototype.originalToNode;
Util.exportProperty(LinkingBaseTool, 'originalToNode', LinkingBaseTool.prototype.originalToNode);
Util.defineProperty(LinkingBaseTool, {originalToNode: 'originalToNode'},
  /** @this {LinkingBaseTool} */
  function() { return this._originalToNode; },
  /** @this {LinkingBaseTool} */
  function(val) {
    var old = this._originalToNode;
    if (old !== val) {
      if (Debug && val !== null) Util.checkClass(val, Node, LinkingBaseTool, 'originalToNode');
      this._originalToNode = val;
    }
  }
);

/**
* Gets or sets the {@link GraphObject} that is the port in the {@link #originalToNode}.
* Setting this property does not raise any events.
* @name LinkingBaseTool#originalToPort
* @function.
* @return {GraphObject}
*/
/** @type {GraphObject} */
LinkingBaseTool.prototype.originalToPort;
Util.exportProperty(LinkingBaseTool, 'originalToPort', LinkingBaseTool.prototype.originalToPort);
Util.defineProperty(LinkingBaseTool, {originalToPort: 'originalToPort'},
  /** @this {LinkingBaseTool} */
  function() { return this._originalToPort; },
  /** @this {LinkingBaseTool} */
  function(val) {
    var old = this._originalToPort;
    if (old !== val) {
      if (Debug && val !== null) Util.checkClass(val, GraphObject, LinkingBaseTool, 'originalToPort');
      this._originalToPort = val;
    }
  }
);


/**
* Gets whether the linking operation is in the forwards direction,
* connecting from the "From" port to the "To" port.
* @name LinkingBaseTool#isForwards
* @function.
* @return {boolean}
*/
/** @type {boolean} */
LinkingBaseTool.prototype.isForwards;
Util.defineProperty(LinkingBaseTool, {isForwards: 'isForwards'},
  /** @this {LinkingBaseTool} */
  function() { return this._isForwards; },
  /** @this {LinkingBaseTool} */
  function(val) { this._isForwards = val; }
);

/**
* @ignore
* Gets the map used to keep track of ports for which a link may be valid.
* This remembers the results of calls to {@link #isValidLink}.
* @name LinkingBaseTool#validPortsCache
* @function.
* @return {Map}
*/
/** @type {Map} */
LinkingBaseTool.prototype.validPortsCache;
Util.defineReadOnlyProperty(LinkingBaseTool, {validPortsCache: 'validPortsCache'},
  /** @this {LinkingBaseTool} */
  function() { return this._validPortsCache; }
);

/**
* Gets or sets a proposed {@link GraphObject} port for connecting a link.
* Whether this is a "to" port or a "from" port depends on the direction
* ({@link #isForwards}) in which the link is being drawn or reconnected.
* <p/>
* This is set when the mouse is being dragged and when a mouse-up event occurs
* with the result of a call to {@link #findTargetPort}.
* Setting this property does not raise any events.
* @name LinkingBaseTool#targetPort
* @function.
* @return {GraphObject}
*/
/** @type {GraphObject} */
LinkingBaseTool.prototype.targetPort;
Util.exportProperty(LinkingBaseTool, 'targetPort', LinkingBaseTool.prototype.targetPort);
Util.defineProperty(LinkingBaseTool, {targetPort: 'targetPort'},
  /** @this {LinkingBaseTool} */
  function() { return this._targetPort; },
  /** @this {LinkingBaseTool} */
  function(val) {
    var old = this._targetPort;
    if (old !== val) {
      if (Debug && val !== null) Util.checkClass(val, GraphObject, LinkingBaseTool, 'targetPort');
      this._targetPort = val;
    }
  }
);


/**
* Make a temporary port look and act like a real one.
* <p/>
* This is called by {@link #doMouseMove} as the tool finds new valid target ports.
* If {@link #findTargetPort} returns null, it calls {@link #setNoTargetPortProperties} instead.
* <p/>
* If the {@link #portTargeted} property is a function, that function is called.
* It is easier to customize the behavior by setting that functional property than it is to override
* this method and the {@link #setNoTargetPortProperties} method.
* But you may want to call this method to get the standard behavior for dynamically adapting
* the temporary node/port to "act like" the target port.
* @expose
* @this {LinkingBaseTool}
* @param {Node} realnode
* @param {GraphObject} realport
* @param {Node} tempnode
* @param {GraphObject} tempport
* @param {boolean} toend
* @since 1.2
*/
LinkingBaseTool.prototype.copyPortProperties = function(realnode, realport, tempnode, tempport, toend) {
  if (realnode === null || realport === null || tempnode === null || tempport === null) return;
  tempport.desiredSize = realport.actualBounds.size;  //??? not always correct
  if (toend) {
    tempport.toSpot = realport.toSpot;
    tempport.toEndSegmentLength = realport.toEndSegmentLength;
  } else {
    tempport.fromSpot = realport.fromSpot;
    tempport.fromEndSegmentLength = realport.fromEndSegmentLength;
  }
  tempnode.locationSpot = Spot.Center;
  var temploc = Util.tempPoint();
  tempnode.location = realport.getDocumentPoint(Spot.Center, temploc);
  Util.freePoint(temploc);
  tempport.angle = realport.getDocumentAngle();
  if (this.portTargeted !== null) {
    this.portTargeted(realnode, realport, tempnode, tempport, toend);
  }
};

/**
* Reset a temporary port's properties to neutral values when there is no target port.
* <p/>
* This is called by {@link #doMouseMove} when the tool finds no new valid target port.
* If {@link #findTargetPort} returns non-null, it calls {@link #copyPortProperties} instead.
* <p/>
* If the {@link #portTargeted} property is a function, that function is called with null values as the first two arguments.
* It is easier to customize the behavior by setting that functional property than it is to override
* this method and the {@link #copyPortProperties} method.
* But you may want to call this method to get the standard behavior for dynamically adapting
* the temporary node/port to "act like" it is not connecting with any target port.
* @expose
* @this {LinkingBaseTool}
* @param {Node} tempnode
* @param {GraphObject} tempport
* @param {boolean} toend
* @since 1.2
*/
LinkingBaseTool.prototype.setNoTargetPortProperties = function(tempnode, tempport, toend) {
  if (tempport !== null) {
    tempport.desiredSize = Geo.OneSize;
    tempport.fromSpot = Spot.None;
    tempport.toSpot = Spot.None;
  }
  if (tempnode !== null) {
    tempnode.location = this.diagram.lastInput.documentPoint;
  }
  if (this.portTargeted !== null) {
    this.portTargeted(null, null, tempnode, tempport, toend);
  }
};

/**
* @ignore
* Call {@link #doMouseMove} in order to update any temporary nodes.
* @this {LinkingBaseTool}
*/
LinkingBaseTool.prototype.doMouseDown = function() {
  if (this.isActive) {
    this.doMouseMove();
  }
};

/**
* Mouse movement results in a temporary node moving to where a valid target port is located,
* or to where the mouse is if there is no valid target port nearby.
* <p/>
* This calls {@link #findTargetPort} to update the {@link #targetPort}
* given the new mouse point.
* If a valid target port is found this moves the temporary node/port and
* makes them appear like the target node/port by calling {@link #copyPortProperties}.
* If no valid target port is found, this moves the temporary node to
* where the mouse currently is and removes any node/port appearance,
* by calling {@link #setNoTargetPortProperties}.
* <p/>
* This method may be overridden, but we recommend that you call this base method.
* @this {LinkingBaseTool}
*/
LinkingBaseTool.prototype.doMouseMove = function() {
  if (this.isActive) {
    var diagram = this.diagram;
    if (diagram === null) return;
    this.targetPort = this.findTargetPort(this.isForwards);
    if (this.targetPort !== null) {
      var targetnode = this.targetPort.part;
      if (targetnode instanceof Node) {
        if (this.isForwards) {
          this.copyPortProperties(targetnode, this.targetPort, this.temporaryToNode, this.temporaryToPort, true);
        } else {
          this.copyPortProperties(targetnode, this.targetPort, this.temporaryFromNode, this.temporaryFromPort, false);
        }
        diagram.requestUpdate();
        return;
      }
    }
    // found no potential port
    if (this.isForwards) {
      this.setNoTargetPortProperties(this.temporaryToNode, this.temporaryToPort, true);
    } else {
      this.setNoTargetPortProperties(this.temporaryFromNode, this.temporaryFromPort, false);
    }
    diagram.requestUpdate();

    if (diagram.allowHorizontalScroll || diagram.allowVerticalScroll) {
      diagram.doAutoScroll(diagram.lastInput.documentPoint);
    }
  }
};


/**
* @ignore
* @expose
* @this {LinkingBaseTool}
* @param {GraphObject} obj
* @param {boolean} toend
* @return {GraphObject}
*/
LinkingBaseTool.prototype.findValidLinkablePort = function(obj, toend) {
  if (obj === null) return null;
  var node = obj.part;
  if (!(node instanceof Node)) return null;
  while (obj !== null) {
    var allow = (toend ? obj.toLinkable : obj.fromLinkable);
    if (allow === true && (obj.portId !== null || obj instanceof Node) &&
        (toend ? this.isValidTo(node, obj) : this.isValidFrom(node, obj))) return obj;
    if (allow === false) return null;
    // if ALLOW is null, continue searching up the parent chain
    obj = obj.panel;
  }
  return null;
};

/**
* Find a port with which the user could complete a valid link.
* <p/>
* This finds objects near to the current mouse point for which a valid link connection is possible.
* <p/>
* For each port element found, this calls {@link #isValidLink} to find out if a link between
* the original node/port and the found node/port would be valid.
* The result is saved in a cache for faster decisions later during operation of this tool.
* The closest valid port is returned.
* <p/>
* This method may be overridden, but we recommend that you call this base method.
* @expose
* @this {LinkingBaseTool}
* @param {boolean} toend true if looking for a "to" port.
* @return {GraphObject} a valid port, or null if no such port is near the current mouse point
* within the {@link #portGravity} distance.
*/
LinkingBaseTool.prototype.findTargetPort = function(toend) {
  var diagram = this.diagram;
  var p = diagram.lastInput.documentPoint;
  var gravity = this.portGravity;
  if (gravity <= 0) gravity = 0.1;
  var tool = this;
  var nearports = diagram.findObjectsNear(p, gravity,
      function(x) { return tool.findValidLinkablePort(x, toend); },
      null, true); // ??? temporarily true?
  var bestDist = Infinity;
  var bestPort = null;
  var it = nearports.iterator;
  while (it.next()) {
    var port = it.value;
    var node = port.part;
    if (!(node instanceof Node)) continue;
    var toPoint = port.getDocumentPoint(Spot.Center, Util.tempPoint());  //?? assumes center point of port
    var dx = p.x - toPoint.x;
    var dy = p.y - toPoint.y;
    Util.freePoint(toPoint);
    var dist = dx * dx + dy * dy;  // don't bother taking sqrt
    if (dist < bestDist) {  // closest so far
      // check cache of isValidLink calls
      var valid = this.validPortsCache.getValue(port);
      if (valid !== null) {
        // known to be either valid or invalid
        if (valid) {  // known to be a valid port for a link
          bestPort = port;
          bestDist = dist;
        } // else known not valid: don't need to call isValidLink again
      } else {  // but not if cached, try isValidLink in the appropriate direction
        if ((toend && this.isValidLink(this.originalFromNode, this.originalFromPort, node, port)) ||
            (!toend && this.isValidLink(node, port, this.originalToNode, this.originalToPort))) {
          // now known valid, remember in cache
          this.validPortsCache.add(port, true);
          bestPort = port;
          bestDist = dist;
        } else {
          // now known not valid, remember in cache
          this.validPortsCache.add(port, false);
        }
      }
    }
  }
  if (bestPort !== null) {
    var targetnode = bestPort.part;
    if (targetnode instanceof Node &&
        (targetnode.layer === null || targetnode.layer.allowLink)) {
      return bestPort;
    }
  }
  return null;
};

/**
* This predicate is true if it is permissible to connect a link from a given node/port.
* <p/>
* This method may be overridden, but we recommend that you call this base method.
* @expose
* @this {LinkingBaseTool}
* @param {Node} fromnode
* @param {GraphObject} fromport
* @return {boolean}
* False if the node is in a {@link Layer} that does not {@link Layer#allowLink}.
* False if the port's {@link GraphObject#fromLinkable} is either false or null.
* False if the number of links connected to the port would exceed the port's {@link GraphObject#fromMaxLinks}.
* Otherwise true.
*/
LinkingBaseTool.prototype.isValidFrom = function(fromnode, fromport) {
  if (fromnode === null || fromport === null) {
    return this.isUnconnectedLinkValid;
  }
  if (this.diagram.currentTool === this) {
    if (fromnode.layer !== null && !fromnode.layer.allowLink) return false;
    if (fromport.fromLinkable !== true) return false;  // false or null value means not linkable
  }
  var maxlinks = fromport.fromMaxLinks;
  if (maxlinks < Infinity) {
    //?? wrong number, because RelinkingTool doesn't temporarily disconnect?
    if (this.originalLink !== null && fromnode === this.originalFromNode && fromport === this.originalFromPort) return true;
    var fromportid = fromport.portId;
    if (fromportid === null) fromportid = '';
    if (fromnode.findLinksOutOf(fromportid).count >= maxlinks) return false;
  }
  return true;
};

/**
* This predicate is true if it is permissible to connect a link to a given node/port.
* <p/>
* This method may be overridden, but we recommend that you call this base method.
* @expose
* @this {LinkingBaseTool}
* @param {Node} tonode
* @param {GraphObject} toport
* @return {boolean}
* False if the node is in a {@link Layer} that does not {@link Layer#allowLink}.
* False if the port's {@link GraphObject#toLinkable} is either false or null.
* False if the number of links connected from the port would exceed the port's {@link GraphObject#toMaxLinks}.
* Otherwise true.
*/
LinkingBaseTool.prototype.isValidTo = function(tonode, toport) {
  if (tonode === null || toport === null) {
    return this.isUnconnectedLinkValid;
  }
  if (this.diagram.currentTool === this) {
    if (tonode.layer !== null && !tonode.layer.allowLink) return false;
    if (toport.toLinkable !== true) return false;  // false or null value means not linkable
  }
  var maxlinks = toport.toMaxLinks;
  if (maxlinks < Infinity) {
    //?? wrong number, because RelinkingTool doesn't temporarily disconnect?
    if (this.originalLink !== null && tonode === this.originalToNode && toport === this.originalToPort) return true;
    var toportid = toport.portId;
    if (toportid === null) toportid = '';
    if (tonode.findLinksInto(toportid).count >= maxlinks) return false;
  }
  return true;
};

/**
* This predicate is true if both argument ports are in the same {@link Node}.
* @expose
* @this {LinkingBaseTool}
* @param {GraphObject} fromport
* @param {GraphObject} toport
* @return {boolean}
*/
LinkingBaseTool.prototype.isInSameNode = function(fromport, toport) {
  if (fromport === null || toport === null) return false;
  if (fromport === toport) return true;
  var fromnode = fromport.part;
  var tonode = toport.part;
  return (fromnode !== null && fromnode === tonode);
};

/**
* This predicate is true if there is a link in the diagram going from the given port to the given port.
* @expose
* @this {LinkingBaseTool}
* @param {GraphObject} fromport
* @param {GraphObject} toport
* @return {boolean}
*/
LinkingBaseTool.prototype.isLinked = function(fromport, toport) {
  if (fromport === null || toport === null) return false;
  var fromnode = fromport.part;
  if (!(fromnode instanceof Node)) return false;
  var fromportid = fromport.portId;
  if (fromportid === null) fromportid = '';
  var tonode = toport.part;
  if (!(tonode instanceof Node)) return false;
  var toportid = toport.portId;
  if (toportid === null) toportid = '';
  var it = tonode.findLinksInto(toportid);
  while (it.next()) {
    var link = it.value;
    if (link.fromNode === fromnode && link.fromPortId === fromportid) return true;
  }
  return false;
};

/**
* This predicate should be true when it is logically valid to connect a new link from
* one node/port to another node/port.
* When this is called by the {@link RelinkingTool}, that tool sets {@link #originalLink}
* to be the {@link Link} being reconnected.
* <p/>
* This method may be overridden, although it is usually much easier to just set {@link #linkValidation}
* in order to add some application-specific link validation.
* @expose
* @this {LinkingBaseTool}
* @param {Node} fromnode the "from" {@link Node}.
* @param {GraphObject} fromport the "from" {@link GraphObject} port.
* @param {Node} tonode the "to" {@link Node}.
* @param {GraphObject} toport the "to" {@link GraphObject} port.
* @return {boolean}
* False if {@link #isValidFrom} is false for the "from" node/port.
* False if {@link #isValidTo} is false for the "to" node/port.
* False if {@link #isInSameNode} is true unless {@link GraphObject#fromLinkableSelfNode}
* and {@link GraphObject#toLinkableSelfNode} are true for the two ports.
* False if {@link #isLinked} is true unless {@link GraphObject#fromLinkableDuplicates}
* and {@link GraphObject#toLinkableDuplicates} are true for the two ports.
* False if trying to link to the link's own label node(s).
* If {@link #linkValidation} is a predicate and if it returns false, this predicate returns false.
* Otherwise this predicate is true.
*/
LinkingBaseTool.prototype.isValidLink = function(fromnode, fromport, tonode, toport) {
  // allow partly connected or unconnected links
  if (!this.isValidFrom(fromnode, fromport)) return false;
  if (!this.isValidTo(tonode, toport)) return false;

  if (fromport !== null && toport !== null) {
    if (!(fromport.fromLinkableSelfNode && toport.toLinkableSelfNode) &&
        this.isInSameNode(fromport, toport)) return false;
    if (!(fromport.fromLinkableDuplicates && toport.toLinkableDuplicates) &&
        this.isLinked(fromport, toport)) return false;
  }

  // disallow linking to the link's own label(s)
  if (this.originalLink !== null) {
    if (fromnode !== null && this.isLabelDependentOnLink(fromnode, this.originalLink)) return false;
    if (tonode !== null && this.isLabelDependentOnLink(tonode, this.originalLink)) return false;
  }

  // either both nodes are in model or neither are
  if (fromnode !== null && tonode !== null) {
    if (fromnode.data === null && tonode.data !== null) return false;
    if (fromnode.data !== null && tonode.data === null) return false;
  }

  // check Diagram.validCycle
  if (!this.checkValidCycle(fromnode, tonode, this.originalLink)) return false;

  if (this.linkValidation !== null) {
    return this.linkValidation(fromnode, fromport, tonode, toport, this.originalLink);
  } else {
    return true;
  }
};

/**
* @ignore
* False if the node is not a link label node.
* True if the node is a label on the link (i.e. if the link owns the node).
* Otherwise true if the label node is on a link whose from or to node is dependent on the link.
* @this {LinkingBaseTool}
* @param {Node} node
* @param {Link} link
* @return {boolean}
**/
LinkingBaseTool.prototype.isLabelDependentOnLink = function(node, link) {
  if (node === null) return false;
  var l = node.labeledLink;
  if (l === null) return false;
  if (l === link) return true;
  var labelnodes = new Set(Node);
  labelnodes.add(node);
  return this._isLinkDependent(l, link, labelnodes);
};

/**
* @ignore
* False if the node is not a link label node.
* True if the node is a label on the link (i.e. if the link owns the node).
* Otherwise true if the label node is on a link whose from or to node is dependent on the link.
* @this {LinkingBaseTool}
* @param {Link} l
* @param {Link} link
* @param {Set} labelnodes
* @return {boolean}
**/
LinkingBaseTool.prototype._isLinkDependent = function(l, link, labelnodes) {
  if (l === link) return true;
  var from = l.fromNode;
  if (from !== null && from.isLinkLabel) {
    labelnodes.add(from);
    if (this._isLinkDependent(from.labeledLink, link, labelnodes)) return true;
  }
  var to = l.toNode;
  if (to !== null && to.isLinkLabel) {
    labelnodes.add(to);
    if (this._isLinkDependent(to.labeledLink, link, labelnodes)) return true;
  }
  return false;
};

/**
* @ignore
* @this {LinkingBaseTool}
* @param {Node} from
* @param {Node} to
* @param {Link} ignore
* @return {boolean}
*/
LinkingBaseTool.prototype.checkValidCycle = function(from, to, ignore) {
  //??? this.diagram.isUnconnectedLinkValid
  if (from === null || to === null) return false;

  var vc = this.diagram.validCycle;
  if (vc === Diagram.CycleAll) return true;
  else if (vc === Diagram.CycleDestinationTree) {
    if (ignore !== null && !ignore.isTreeLink) return true;
    var lit = to.linksConnected;
    while (lit.next()) {
      var l = lit.value;
      if (l === ignore) continue;
      if (!l.isTreeLink) continue;
      if (l.toNode === to) return false;
    }
    return !this._MakesDirectedCycleFast(from, to, ignore, true);
  } else if (vc === Diagram.CycleSourceTree) {
    if (ignore !== null && !ignore.isTreeLink) return true;
    var lit = from.linksConnected;
    while (lit.next()) {
      var l = lit.value;
      if (l === ignore) continue;
      if (!l.isTreeLink) continue;
      if (l.fromNode === from) return false;
    }
    return !this._MakesDirectedCycleFast(from, to, ignore, true);
  } else if (vc === Diagram.CycleNotDirected) {
    return !this._MakesDirectedCycle(from, to, ignore);
  } else if (vc === Diagram.CycleNotDirectedFast) {
    return !this._MakesDirectedCycleFast(from, to, ignore, false);
  } else if (vc === Diagram.CycleNotUndirected) {
    return !this._MakesUndirectedCycle(from, to, ignore);
  }
  return true;
};

/**
* @ignore
* @this {LinkingBaseTool}
* @param {Node} a
* @param {Node} b
* @param {Link} ignore
* @param {boolean} tree
* @return {boolean}
*/
LinkingBaseTool.prototype._MakesDirectedCycleFast = function(a, b, ignore, tree) {
  if (a === b) return true;
  if (a === null) return false;
  if (b === null) return false;
  var lit = a.linksConnected;
  while (lit.next()) {
    var l = lit.value;
    if (l === ignore) continue;
    if (tree && !l.isTreeLink) continue;
    if (l.toNode !== a) continue;
    var n = l.fromNode;
    if (n === a) continue;
    if (this._MakesDirectedCycleFast(n, b, ignore, tree)) {
      return true;
    }
  }
  return false;
};


/**
* @ignore
* @this {LinkingBaseTool}
* @param {Node} a
* @param {Node} b
* @param {Link} ignore
* @return {boolean}
*/
LinkingBaseTool.prototype._MakesDirectedCycle = function(a, b, ignore) {
  if (a === b) return true;
  var seen = new Set(Node);
  seen.add(b);
  return this._MakesDirectedCycle1(seen, a, b, ignore);
};

/**
* @ignore
* @this {LinkingBaseTool}
* @param {Set} seen
* @param {Node} a
* @param {Node} b
* @param {Link} ignore
* @return {boolean}
*/
LinkingBaseTool.prototype._MakesDirectedCycle1 = function(seen, a, b, ignore) {
  if (a === b) return true;
  if (a === null) return false;
  if (b === null) return false;
  if (seen.contains(a)) return false;
  seen.add(a);
  var lit = a.linksConnected;
  while (lit.next()) {
    var l = lit.value;
    if (l === ignore) continue;
    if (l.toNode !== a) continue;
    var n = l.fromNode;
    if (n === a) continue;
    if (this._MakesDirectedCycle1(seen, n, b, ignore)) {
      return true;
    }
  }
  return false;
};


/**
* @ignore
* @this {LinkingBaseTool}
* @param {Node} a
* @param {Node} b
* @param {Link} ignore
* @return {boolean}
*/
LinkingBaseTool.prototype._MakesUndirectedCycle = function(a, b, ignore) {
  if (a === b) return true;
  var seen = new Set(Node);
  seen.add(b);
  return this._MakesUndirectedCycle1(seen, a, b, ignore);
};

/**
* @ignore
* @this {LinkingBaseTool}
* @param {Set} seen
* @param {Node} a
* @param {Node} b
* @param {Link} ignore
* @return {boolean}
*/
LinkingBaseTool.prototype._MakesUndirectedCycle1 = function(seen, a, b, ignore) {
  if (a === b) return true;
  if (a === null) return false;
  if (b === null) return false;
  if (seen.contains(a)) return false;
  seen.add(a);
  var lit = a.linksConnected;
  while (lit.next()) {
    var l = lit.value;
    if (l === ignore) continue;
    var from = l.fromNode;
    var to = l.toNode;
    var n = (from === a ? to : from);
    if (n === a) continue;
    if (this._MakesUndirectedCycle1(seen, n, b, ignore)) {
      return true;
    }
  }
  return false;
};

/**
* Gets or sets a predicate that determines whether or not a new link between two ports would be valid.
* This predicate is called in addition to the normal link checking performed by {@link #isValidLink}.
* When relinking, the {@link Link} being considered for reconnection is passed as the fifth argument.
* The default predicate is null, which is equivalent to simply returning true.
* <p/>
* The function, if supplied, must not have any side-effects.
* @name LinkingBaseTool#linkValidation
* @function.
* @return {function(Node, GraphObject, Node, GraphObject, Link):boolean | null}
*/
/** @type {function(Node, GraphObject, Node, GraphObject, Link):boolean | null} */
LinkingBaseTool.prototype.linkValidation;
Util.exportProperty(LinkingBaseTool, 'linkValidation', LinkingBaseTool.prototype.linkValidation);
Util.defineProperty(LinkingBaseTool, { linkValidation: 'linkValidation' },
  /** @this {LinkingBaseTool} */
  function() { return this._linkValidation; },
  /** @this {LinkingBaseTool} */
  function(val) {
    if (val !== null) Util.checkPrimitive(val, 'function', LinkingBaseTool, 'linkValidation');
    this._linkValidation = val;
  }
);

/**
* Gets or sets a function that is called as the tool targets the nearest valid port.
* The first two arguments specify the port by providing the {@link Node} that it is in
* and the {@link GraphObject} that is the actual port object.
* The next two arguments are the temporary port that has been moved and styled to be like the valid port.
* These values will be either the {@link #temporaryToNode} and {@link #temporaryToPort}
* or the {@link #temporaryFromNode} and {@link #temporaryFromPort}, depending on
* which end of the temporary link is being updated.
* The fifth argument is true if the target port represents a potential "to" end of a link;
* it is false if it is for the "from" end of a link.
* <p/>
* When there is no valid port within the {@link #portGravity}, the first two arguments are null.
* <p/>
* The function, if supplied, must not add or remove any links or nodes or port objects,
* nor may it change the validity of any potential link connection.
* @name LinkingBaseTool#portTargeted
* @function.
* @return {function(Node, GraphObject, Node, GraphObject, boolean) | null}
* @since 1.2
*/
/** @type {function(Node, GraphObject, Node, GraphObject, boolean) | null} */
LinkingBaseTool.prototype.portTargeted;
Util.exportProperty(LinkingBaseTool, 'portTargeted', LinkingBaseTool.prototype.portTargeted);
Util.defineProperty(LinkingBaseTool, { portTargeted: 'portTargeted' },
  /** @this {LinkingBaseTool} */
  function() { return this._portTargeted; },
  /** @this {LinkingBaseTool} */
  function(val) {
    if (val !== null) Util.checkPrimitive(val, 'function', LinkingBaseTool, 'portTargeted');
    this._portTargeted = val;
  }
);



/**
* You do not normally need to create an instance of this tool
* because one already exists as the {@link ToolManager#linkingTool}, which you can modify.
* @constructor
* @extends LinkingBaseTool
* @category Tool
* @class
* The LinkingTool lets a user draw a new {@link Link} between two ports,
* using a mouse-drag operation.
* <p/>
* By default an instance of this tool is installed as a mouse-move tool in the
* {@link Diagram#toolManager} as the {@link ToolManager#linkingTool}.
* <p/>
* {@link #canStart} calls {@link #findLinkablePort} to find a valid "port" element
* from which (or to which) the user may interactively draw a new link.
* {@link #doActivate} sets up a temporary link and two temporary nodes,
* one at the start port and one following the mouse.
* <p/>
* This tool does not utilize any {@link Adornment}s or tool handles.
* <p/>
* This tool conducts a transaction while the tool is active.
* A successful linking will result in a "LinkDrawn" {@link DiagramEvent} and a "Linking" transaction.
* <p/>
* If you want to programmatically start a new user mouse-gesture to draw a new link
* from a given {@link GraphObject} that may be a "port" or may be within
* the visual tree of a "port", set the {@link #startObject} property
* to let {@link #findLinkablePort} find the real "port" element.
* Then start and activate this tool:
* <pre>
*   var tool = myDiagram.toolManager.linkingTool;
*   tool.startObject = ...;
*   myDiagram.currentTool = tool;
*   tool.doActivate();
* </pre>
*/
function LinkingTool() {
  if (arguments.length > 0) {
    Util.throwError('LinkingTool constructor cannot take any arguments.');
  }
  LinkingBaseTool.call(this);
  this.name = 'Linking';
  /** @type {Object} */
  this._archetypeLinkData = {};
  /** @type {Object} */
  this._archetypeLabelNodeData = null;
  /** @type {EnumValue} */
  this._direction = LinkingTool.Either;
  /** @type {GraphObject} */
  this._startObject = null;

  // transient state
  /** @type {GraphObject} */
  this._startPort = null;
}

Util.publish('LinkingTool', LinkingTool);

Util.inherit(LinkingTool, LinkingBaseTool);

/**
* This value for {@link LinkingTool#direction} indicates that users may draw new links in either direction.
* @name LinkingTool#Either
* @constant
* @static
* @return {EnumValue}
*/
LinkingTool['Either'] = LinkingTool.Either = Util.defineEnumValue(LinkingTool, 'Either', 0);

/**
* This value for {@link LinkingTool#direction} indicates that users may draw new links forwards only
* (i.e. from "from" node to "to" node).
* @name LinkingTool#ForwardsOnly
* @constant
* @static
* @return {EnumValue}
*/
LinkingTool['ForwardsOnly'] = LinkingTool.ForwardsOnly = Util.defineEnumValue(LinkingTool, 'ForwardsOnly', 0);

/**
* This value for {@link LinkingTool#direction} indicates that users may draw new links backwards only
* (i.e. from "to" node to "from" node).
* @name LinkingTool#BackwardsOnly
* @constant
* @static
* @return {EnumValue}
*/
LinkingTool['BackwardsOnly'] = LinkingTool.BackwardsOnly = Util.defineEnumValue(LinkingTool, 'BackwardsOnly', 0);


/**
* Gets or sets a data object that is copied by {@link #insertLink}
* and added to the {@link GraphLinksModel} when creating a new {@link Link}.
* The default value is an empty Object, which will be copied.
* The value must be an Object for the linking operation to succeed.
* <p/>
* The copied link data's {@link GraphLinksModel#linkFromKeyProperty}
* and {@link GraphLinksModel#linkToKeyProperty} properties are set to
* the corresponding node's data's key values.
* If the ports have {@link GraphObject#portId} values that are not null,
* the link data's {@link GraphLinksModel#linkFromPortIdProperty}
* and {@link GraphLinksModel#linkToPortIdProperty} properties are also set.
* <p/>
* Setting this property does not raise any events.
* @name LinkingTool#archetypeLinkData
* @function.
* @return {Object}
*/
/** @type {Object} */
LinkingTool.prototype.archetypeLinkData;
Util.exportProperty(LinkingTool, 'archetypeLinkData', LinkingTool.prototype.archetypeLinkData);
Util.defineProperty(LinkingTool, {archetypeLinkData: 'archetypeLinkData'},
  /** @this {LinkingTool} */
  function() { return this._archetypeLinkData; },
  /** @this {LinkingTool} */
  function(val) {
    var old = this._archetypeLinkData;
    if (old !== val) {
      if (val !== null) Util.checkClass(val, Object, LinkingTool, 'archetypeLinkData');
      this._archetypeLinkData = val;
    }
  }
);

/**
* Gets or sets an optional node data object representing a link label, that is copied by {@link #insertLink}
* and added to the {@link GraphLinksModel} when creating a new {@link Link}.
* <p/>
* The default value is null, which causes no such label node data to be added to the model
* along with the new link data.
* If you set this to an Object, be sure that {@link GraphLinksModel#isLinkLabelForNodeData} is true for that object.
* <p/>
* {@link #insertLink} calls {@link GraphLinksModel#addLabelKeyForLinkData}
* to associate the label node data with the link data.
* <p/>
* Setting this property does not raise any events.
* @name LinkingTool#archetypeLabelNodeData
* @function.
* @return {Object}
*/
/** @type {Object} */
LinkingTool.prototype.archetypeLabelNodeData;
Util.exportProperty(LinkingTool, 'archetypeLabelNodeData', LinkingTool.prototype.archetypeLabelNodeData);
Util.defineProperty(LinkingTool, { archetypeLabelNodeData: 'archetypeLabelNodeData' },
  /** @this {LinkingTool} */
  function() { return this._archetypeLabelNodeData; },
  /** @this {LinkingTool} */
  function(val) {
    var old = this._archetypeLabelNodeData;
    if (old !== val) {
      if (val !== null) Util.checkClass(val, Object, LinkingTool, 'archetypeLabelNodeData');
      var diagram = this.diagram;
      if (diagram !== null) {
        var model = diagram.model;
        if (model instanceof GraphLinksModel) {
          if (!(val instanceof Node) && !model.isLinkLabelForNodeData(val)) {
            Util.throwError('CommandHandler.archetypeLabelNodeData must be either a Node or a data object for which GraphLinksModel.isLinkLabelForNodeData is true: ' + val);
          }
        }
      }
      this._archetypeLabelNodeData = val;
    }
  }
);

/**
* Gets or sets the direction in which new links may be drawn.
* Possible values are {@link LinkingTool#ForwardsOnly}, {@link LinkingTool#BackwardsOnly}, or {@link LinkingTool#Either}.
* This defaults to {@link LinkingTool#Either}.
* Setting this property does not raise any events.
* @name LinkingTool#direction
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
LinkingTool.prototype.direction;
Util.exportProperty(LinkingTool, 'direction', LinkingTool.prototype.direction);
Util.defineProperty(LinkingTool, {direction: 'direction'},
  /** @this {LinkingTool} */
  function() { return this._direction; },
  /** @this {LinkingTool} */
  function(val) {
    var old = this._direction;
    if (old !== val) {
      if (Debug) Util.checkEnumValue(val, LinkingTool, LinkingTool, 'direction');
      this._direction = val;
    }
  }
);

/**
* Gets or sets the {@link GraphObject} at which {@link #findLinkablePort} should start its search.
* The default value is null.
* Setting this property does not raise any events.
* <p/>
* If you want to explicitly start a new user mouse-gesture to draw a new link
* from a given {@link GraphObject} that may be a "port" object or may be within
* the visual tree of a "port" object, set this property to that object
* to left {@link #findLinkablePort} find the real "port" object.
* Then start and activate this tool:
* <pre>
*   var tool = myDiagram.toolManager.linkingTool;
*   tool.startObject = ...;
*   myDiagram.currentTool = tool;
*   tool.doActivate();
* </pre>
* @name LinkingTool#startObject
* @function.
* @return {GraphObject}
*/
/** @type {GraphObject} */
LinkingTool.prototype.startObject;
Util.exportProperty(LinkingTool, 'startObject', LinkingTool.prototype.startObject);
Util.defineProperty(LinkingTool, {startObject: 'startObject'},
  /** @this {LinkingTool} */
  function() { return this._startObject; },
  /** @this {LinkingTool} */
  function(val) {
    var old = this._startObject;
    if (old !== val) {
      if (Debug && val !== null) Util.checkClass(val, GraphObject, LinkingTool, 'startObject');
      this._startObject = val;
    }
  }
);

/**
* @ignore
* Gets the port {@link GraphObject} at which the linking operation started.
* The default value is null.
* This is automatically set when activated.
* @name LinkingTool#startPort
* @function.
* @return {GraphObject}
*/
/** @type {GraphObject} */
LinkingTool.prototype.startPort;
Util.defineReadOnlyProperty(LinkingTool, {startPort: 'startPort'},
  /** @this {LinkingTool} */
  function() { return this._startPort; }
);


/**
* This tool can run when the diagram allows linking, the model is modifiable,
* the left-button mouse drag has moved far enough away to not be a click, and
* when {@link #findLinkablePort} has returned a valid port.
* <p/>
* This method may be overridden, but we recommend that you call this base method.
* @this {LinkingTool}
* @return {boolean}
*/
LinkingTool.prototype.canStart = function() {
  if (!this.isEnabled) return false;
  var diagram = this.diagram;
  if (diagram === null || diagram.isReadOnly || diagram.isModelReadOnly) return false;
  if (!diagram.allowLink) return false;
  var model = diagram.model;
  if (model === null) return false;
  if (!(model instanceof GraphLinksModel) && !(model instanceof TreeModel)) return false;
  // require left button & that it has moved far enough away from the mouse down point, so it isn't a click
  if (!diagram.lastInput.left) return false;
  // don't include the following check when this tool is running modally
  if (diagram.currentTool !== this) {
    if (!this.isBeyondDragSize()) return false;
  }
  var port = this.findLinkablePort();
  return (port !== null);
};

/**
* Return the {@link GraphObject} at the mouse-down point,
* if it is part of a node and if it is valid to link with it.
* <p/>
* This method may be overridden, but we recommend that you call this base method.
* @expose
* @this {LinkingTool}
* @return {GraphObject}
* If the {@link #direction} is {@link #Either} or {@link #ForwardsOnly},
* this checks the element and its parent {@link Node} by calling {@link LinkingBaseTool#isValidFrom}.
* If the {@link #direction} is {@link #Either} or {@link #BackwardsOnly},
* this checks the element and its parent {@link Node} by calling {@link LinkingBaseTool#isValidTo}.
* In either case finding a matching port will return that port and set {@link LinkingBaseTool#isForwards} appropriately.
* Otherwise this will return null.
*/
LinkingTool.prototype.findLinkablePort = function() {
  var diagram = this.diagram;
  if (diagram === null) return null;
  var obj = this.startObject;
  if (obj === null) {
    obj = diagram.findObjectAt(diagram.firstInput.documentPoint, null, null);
  }
  if (obj === null) return null;
  var node = obj.part;
  if (!(node instanceof Node)) return null;
  // don't search for valid ports "underneath" the object at the current mouse point;
  // only search up the parent tree of elements for one that isValidFrom
  var port;
  var dir = this.direction;
  if (dir === LinkingTool.Either || dir === LinkingTool.ForwardsOnly) {
    port = this.findValidLinkablePort(obj, false);
    if (port !== null) {
      this._isForwards = true;
      return port;
    }
  }
  if (dir === LinkingTool.Either || dir === LinkingTool.BackwardsOnly) {
    port = this.findValidLinkablePort(obj, true);
    if (port !== null) {
      this._isForwards = false;
      return port;
    }
  }
  return null;
};

/**
* Start the linking operation.
* <p/>
* If the {@link #startObject} is already set, it uses that object to find the starting port.
* If it is not set, this calls {@link #findLinkablePort} and remembers it as the starting port.
* <p/>
* It then start a transaction, captures the mouse, and changes the cursor.
* Next it initializes and adds the {@link LinkingBaseTool#temporaryFromNode},
* {@link LinkingBaseTool#temporaryToNode}, and {@link LinkingBaseTool#temporaryLink} to the diagram.
* The temporary nodes that are positioned and sized to be like the real {@link LinkingBaseTool#originalFromPort}
* and {@link LinkingBaseTool#originalToPort} ports.
* The temporary link connects the two temporary ports, of course.
* <p/>
* This method may be overridden, but we recommend that you call this base method.
* @this {LinkingTool}
*/
LinkingTool.prototype.doActivate = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  if (this.startPort === null) this._startPort = this.findLinkablePort();
  if (this.startPort === null) return;

  this.startTransaction(this.name);

  diagram.isMouseCaptured = true;
  diagram.currentCursor = 'pointer';

  if (this.isForwards) {
    this.originalFromPort = this.startPort;
    var node = this.originalFromPort.part;
    if (node instanceof Node) this.originalFromNode = node;
    this.copyPortProperties(this.originalFromNode, this.originalFromPort, this.temporaryFromNode, this.temporaryFromPort, false);
  } else {
    this.originalToPort = this.startPort;
    var node = this.originalToPort.part;
    if (node instanceof Node) this.originalToNode = node;
    this.copyPortProperties(this.originalToNode, this.originalToPort, this.temporaryToNode, this.temporaryToPort, true);
  }

  diagram.add(this.temporaryFromNode);
  diagram.add(this.temporaryToNode);

  if (this.temporaryLink !== null) {
    if (this.temporaryFromNode !== null) {
      this.temporaryLink.fromNode = this.temporaryFromNode;
    }
    if (this.temporaryToNode !== null) {
      this.temporaryLink.toNode = this.temporaryToNode;
    }
    this.temporaryLink.invalidateRoute();
    diagram.add(this.temporaryLink);
  }

  this.isActive = true;
};

/**
* Finishing the linking operation stops the transaction, releases the mouse, and resets the cursor.
* <p/>
* This method may be overridden, but we recommend that you call this base method.
* @this {LinkingTool}
*/
LinkingTool.prototype.doDeactivate = function() {
  this.isActive = false;
  var diagram = this.diagram;
  if (diagram === null) return;
  diagram.remove(this.temporaryLink);
  diagram.remove(this.temporaryFromNode);
  diagram.remove(this.temporaryToNode);
  diagram.isMouseCaptured = false;
  diagram.currentCursor = '';
  this.stopTransaction();
};

/**
* @ignore
* Clean up tool state.
* @this {LinkingTool}
*/
LinkingTool.prototype.doStop = function() {
  LinkingBaseTool.prototype.doStop.call(this);
  this._startPort = null;
  this.startObject = null;
};

/**
* A mouse-up ends the linking operation; if there is a valid {@link #targetPort} nearby,
* this adds a new {@link Link} by calling {@link #insertLink}.
* <p/>
* If there is a new link, it is selected and the "LinkDrawn" {@link DiagramEvent} is raised.
* In any case this stops the tool.
* <p/>
* This method may be overridden, but we recommend that you call this base method.
* It is usually easier to override {@link #insertLink} or just set {@link #archetypeLinkData}.
* It is also common to implement a "LinkDrawn" {@link DiagramEvent} listener on the {@link Diagram}.
* @this {LinkingTool}
*/
LinkingTool.prototype.doMouseUp = function() {
  if (this.isActive) {
    var diagram = this.diagram;
    if (diagram === null) return;
    this.transactionResult = null;

    var fromnode = null;
    var fromport = null;
    var tonode = null;
    var toport = null;

    this.targetPort = this.findTargetPort(this.isForwards);
    var targetport = this.targetPort;
    var targetnode = null;
    if (targetport !== null) {
      targetnode = targetport.part;
      if (targetnode instanceof Node) {
        if (this.isForwards) {
          if (this.originalFromNode !== null) {
            fromnode = this.originalFromNode;
            fromport = this.originalFromPort;
          }
          tonode = targetnode;
          toport = targetport;
        } else {
          fromnode = targetnode;
          fromport = targetport;
          if (this.originalToNode !== null) {
            tonode = this.originalToNode;
            toport = this.originalToPort;
          }
        }
      }
    } else {  // not connecting to a port; set FROMNODE or TONODE, but not both
      if (this.isForwards) {
        if (this.originalFromNode !== null && this.isUnconnectedLinkValid) {
          fromnode = this.originalFromNode;
          fromport = this.originalFromPort;
        }
      } else {
        if (this.originalToNode !== null && this.isUnconnectedLinkValid) {
          tonode = this.originalToNode;
          toport = this.originalToPort;
        }
      }
    }
    if (fromnode !== null || tonode !== null) {
      var link = this.insertLink(fromnode, fromport, tonode, toport);
      if (link !== null) {
        if (targetport === null) {
          // need to tell Link that it ought to end at Diagram.lastInput.documentPoint
          if (this.isForwards) {
            link.defaultToPoint = diagram.lastInput.documentPoint;
          } else {
            link.defaultFromPoint = diagram.lastInput.documentPoint;
          }
        }
        if (diagram.allowSelect) {
          diagram.select(link);
        }
        // set the TransactionResult before raising event, in case it changes the result or cancels the tool
        this.transactionResult = this.name;
        diagram.raiseDiagramEvent('LinkDrawn', link);
      } else {
        diagram.model.clearUnresolvedReferences();
      }
    }
  }
  this.stopTool();
};

/**
* Make a copy of the {@link #archetypeLinkData}, set its node and port properties, and add it to the model.
* <p/>
* If {@link #archetypeLabelNodeData} is non-null, this method also adds that node data as an initial label node
* for the new link data.
* <p/>
* This method may be overridden, but we recommend that you call this base method.
* Usually though it is easiest to just set {@link #archetypeLinkData}.
* @expose
* @this {LinkingTool}
* @param {Node} fromnode
* @param {GraphObject} fromport
* @param {Node} tonode
* @param {GraphObject} toport
* @return {Link} the newly created Link, or null if it failed.
*/
LinkingTool.prototype.insertLink = function(fromnode, fromport, tonode, toport) {
  var diagram = this.diagram;
  if (diagram === null) return null;
  var model = diagram.model;
  if (model === null) return null;
  if (model instanceof TreeModel) {
    var parentnode = fromnode;
    var childnode = tonode;
    if (!diagram.isTreePathToChildren) {
      parentnode = tonode;
      childnode = fromnode;
    }
    if (parentnode !== null && childnode !== null) {
      var parentdata = parentnode.data;
      var childdata = childnode.data;
      model.setParentKeyForNodeData(childdata, model.getKeyForNodeData(parentdata));
      return childnode.findTreeParentLink();
    }
    return null;
  } else if (model instanceof GraphLinksModel) {
    if (fromport === null) fromport = fromnode;
    var fromportid = fromport.portId;
    if (fromportid === null) fromportid = '';
    if (toport === null) toport = tonode;
    var toportid = toport.portId;
    if (toportid === null) toportid = '';

    var arch = this.archetypeLinkData;
    if (arch instanceof Link) {
      arch.freezeBindings();
      var link = arch.copy();
      if (link instanceof Link) {
        link.fromNode = fromnode;
        link.fromPortId = fromportid;
        link.toNode = tonode;
        link.toPortId = toportid;
        diagram.add(link);
        return link;
      }
    } else if (arch !== null) {
      var data = model.copyLinkData(arch);
      if (Util.isObject(data)) {
        model.setFromKeyForLinkData(data, model.getKeyForNodeData(fromnode.data));
        model.setFromPortIdForLinkData(data, fromportid);
        model.setToKeyForLinkData(data, model.getKeyForNodeData(tonode.data));
        model.setToPortIdForLinkData(data, toportid);
        model.addLinkData(data);

        // maybe add a label node data for this new link data
        var archlab = this.archetypeLabelNodeData;
        if (archlab !== null && model.isLinkLabelForNodeData(archlab)) {
          var labdata = model.copyNodeData(archlab);
          if (Util.isObject(labdata)) {
            model.addNodeData(labdata);
            var labkey = model.getKeyForNodeData(labdata);
            if (labkey !== undefined) {
              model.addLabelKeyForLinkData(data, labkey);
            }
          }
        }

        var link = diagram.findLinkForData(data);
        return link;
      }
    }
  }
  return null;
};



/**
* You do not normally need to create an instance of this tool
* because one already exists as the {@link ToolManager#relinkingTool}, which you can modify.
* @constructor
* @extends LinkingBaseTool
* @category Tool
* @class
* The RelinkingTool allows the user to reconnect an existing {@link Link}
* if the {@link Link#relinkableTo} and/or {@link Link#relinkableFrom} properties are true.
* <p/>
* By default an instance of this tool is installed as a mouse-down tool in the
* {@link Diagram#toolManager} as the {@link ToolManager#relinkingTool}.
* <p/>
* This tool makes use of two {@link Adornment}s,
* each including a relink handle (potentially one for each end of the link),
* shown when a link is selected.
* <p/>
* This tool conducts a transaction while the tool is active.
* A successful relinking will result in a "LinkRelinked" {@link DiagramEvent} and a "Relinking" transaction.
*/
function RelinkingTool() {
  if (arguments.length > 0) {
    Util.throwError('RelinkingTool constructor cannot take any arguments.');
  }
  LinkingBaseTool.call(this);
  this.name = 'Relinking';

  var h = new Shape();
  h.figure = 'Diamond';
  h.desiredSize = Geo.EightSize;
  h.fill = 'cyan';
  h.cursor = 'pointer';
  h.segmentIndex = 0;
  /** @type {GraphObject} */
  this._fromHandleArchetype = h;

  h = new Shape();
  h.figure = 'Diamond';
  h.desiredSize = Geo.EightSize;
  h.fill = 'cyan';
  h.cursor = 'pointer';
  h.segmentIndex = -1;
  /** @type {GraphObject} */
  this._toHandleArchetype = h;

  // transient state
  /** @type {GraphObject} */
  this._handle = null;
  /** @type {Rect} */
  this._originalLinkBounds = new Rect();
}

Util.publish('RelinkingTool', RelinkingTool);

Util.inherit(RelinkingTool, LinkingBaseTool);


/**
* Show an {@link Adornment} for each end of the {@link Link} that the user may reconnect.
* The Adornment may have a copy of {@link #fromHandleArchetype} and/or {@link #toHandleArchetype}.
* <p/>
* This method may be overridden.
* @this {RelinkingTool}
* @param {Part} part
*/
RelinkingTool.prototype.updateAdornments = function(part) {
  if (!(part instanceof Link)) return;  // this tool only applies to Links

  // show handles if link is selected, remove them if no longer selected
  var adornment = null;
  var category = 'RelinkFrom';
  if (part.isSelected) {
    var selelt = part.selectionObject;
    if (part.actualBounds.isReal() && selelt !== null && part.isVisible() && part.canRelinkFrom() && selelt.isVisibleObject() && selelt.actualBounds.isReal()) {
      adornment = part.findAdornment(category);
      if (adornment === null) {
        adornment = this.makeAdornment(selelt, false);
        adornment.category = category;
      }
      if (adornment !== null) {
        // don't set the location, measureLink does that
        adornment.invalidateMeasure();
      }
    }
    part.addAdornment(category, adornment);
  } else {
    part.removeAdornment(category);
  }

  adornment = null;
  category = 'RelinkTo';
  if (part.isSelected) {
    var selelt = part.selectionObject;
    if (part.actualBounds.isReal() && selelt !== null && part.isVisible() && part.canRelinkTo() && selelt.isVisibleObject() && selelt.actualBounds.isReal()) {
      adornment = part.findAdornment(category);
      if (adornment === null) {
        adornment = this.makeAdornment(selelt, true);
        adornment.category = category;
        adornment.isStandard = true;
      }
      if (adornment !== null) {
        // don't set the location, measureLink does that
        adornment.invalidateMeasure();
      }
    }
    part.addAdornment(category, adornment);
  } else {
    part.removeAdornment(category);
  }
};

/**
* @ignore
* Create and return an {@link Adornment} that lets the user grab a handle to reconnect one end of the selected link.
* @expose
* @this {RelinkingTool}
* @param {GraphObject} selelt the {@link GraphObject} of the {@link Link} being relinked.
* @param {boolean} toend
* @return {Adornment}
*/
RelinkingTool.prototype.makeAdornment = function(selelt, toend) {
  var adornment = new Adornment();
  adornment.type = Panel.Link;
  var h = (toend ? this.toHandleArchetype : this.fromHandleArchetype);
  if (h !== null) {
    // add a single handle for relinking at one end
    adornment.add(h.copy());
  }
  adornment.adornedObject = selelt;
  return adornment;
};

/**
* Gets or sets a small GraphObject that is copied as a relinking handle for the selected link path
* at the "from" end of the link.
* By default this is a {@link Shape} that is a small cyan diamond.
* Setting this property does not raise any events.
* <p/>
* Here is an example of changing the default handle to be larger green triangles:
* <code><br/>
* myDiagram.toolManager.relinkingTool.toHandleArchetype =<br/>
* &nbsp;&nbsp;$(go.Shape, "Triangle",<br/>
* &nbsp;&nbsp;&nbsp;&nbsp;{ width: 10, height: 10, fill: "limegreen", segmentIndex: 0 });<br/>
* </code>
* @name RelinkingTool#fromHandleArchetype
* @function.
* @return {GraphObject}
* @see #toHandleArchetype
*/
/** @type {GraphObject} */
RelinkingTool.prototype.fromHandleArchetype;
Util.defineProperty(RelinkingTool, { fromHandleArchetype: 'fromHandleArchetype' },
  /** @this {RelinkingTool} */
  function() { return this._fromHandleArchetype; },
  /** @this {RelinkingTool} */
  function(val) {
    if (val) Util.checkClass(val, GraphObject, RelinkingTool, 'fromHandleArchetype');
    this._fromHandleArchetype = val;
  }
);

/**
* Gets or sets a small GraphObject that is copied as a relinking handle for the selected link path
* at the "to" end of the link.
* By default this is a {@link Shape} that is a small cyan diamond.
* Setting this property does not raise any events.
* <p/>
* Here is an example of changing the default handle to be larger orange triangles:
* <code><br/>
* &nbsp;&nbsp;myDiagram.toolManager.relinkingTool.toHandleArchetype =<br/>
* &nbsp;&nbsp;$(go.Shape, "Triangle",<br/>
* &nbsp;&nbsp;&nbsp;&nbsp;{ width: 10, height: 10, fill: "orange", segmentIndex: -1 });<br/>
* </code>
* @name RelinkingTool#toHandleArchetype
* @function.
* @return {GraphObject}
* @see #fromHandleArchetype
*/
/** @type {GraphObject} */
RelinkingTool.prototype.toHandleArchetype;
Util.defineProperty(RelinkingTool, { toHandleArchetype: 'toHandleArchetype' },
  /** @this {RelinkingTool} */
  function() { return this._toHandleArchetype; },
  /** @this {RelinkingTool} */
  function(val) {
    if (val) Util.checkClass(val, GraphObject, RelinkingTool, 'toHandleArchetype');
    this._toHandleArchetype = val;
  }
);


/**
* Gets the {@link GraphObject} that is the tool handle being dragged by the user.
* This will be contained by an {@link Adornment} whose category is "RelinkFrom" or "RelinkTo".
* Its {@link Adornment#adornedPart} is the same as the {@link #originalLink}.
* @name RelinkingTool#handle
* @function.
* @return {GraphObject}
*/
/** @type {GraphObject} */
RelinkingTool.prototype.handle;
Util.defineReadOnlyProperty(RelinkingTool, { handle: 'handle' },
/** @this {RelinkingTool} */
  function() { return this._handle; }
);


/**
* This tool can run when the diagram allows relinking, the model is modifiable,
* and there is a relink handle at the mouse-down point.
* <p/>
* This method may be overridden, but we recommend that you call this base method.
* @this {RelinkingTool}
* @return {boolean}
*/
RelinkingTool.prototype.canStart = function() {
  if (!this.isEnabled) return false;
  var diagram = this.diagram;
  if (diagram === null || diagram.isReadOnly || diagram.isModelReadOnly) return false;
  if (!diagram.allowRelink) return false;
  var model = diagram.model;
  if (model === null) return false;
  if (!(model instanceof GraphLinksModel) && !(model instanceof TreeModel)) return false;
  if (!diagram.lastInput.left) return false;
  var h = this.findToolHandleAt(diagram.firstInput.documentPoint, 'RelinkFrom');
  if (h === null) h = this.findToolHandleAt(diagram.firstInput.documentPoint, 'RelinkTo');
  return (h !== null);
};

/**
* Start the relinking operation.
* <p/>
* Find the relink handle by calling {@link Tool#findToolHandleAt}
* looking for either the "RelinkFrom" adornment or the "RelinkTo" adornment,
* saving the result in {@link #handle}.
* <p/>
* This starts a transaction, captures the mouse, and sets the cursor.
* <p/>
* The value of {@link #isForwards} is set depending on the category of the relink handle found.
* The {@link LinkingBaseTool#originalLink} property and various
* "Original..." port and node properties are set too.
* The temporary nodes and temporary link are also initialized.
* <p/>
* This method may be overridden, but we recommend that you call this base method.
* @this {RelinkingTool}
*/
RelinkingTool.prototype.doActivate = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  if (this.originalLink === null) {
    var h = this.findToolHandleAt(diagram.firstInput.documentPoint, 'RelinkFrom');
    if (h === null) h = this.findToolHandleAt(diagram.firstInput.documentPoint, 'RelinkTo');
    if (h === null) return;

    var ad = h.part;
    if (!(ad instanceof Adornment)) return;
    if (!(ad.adornedPart instanceof Link)) return;
    this._handle = h;

    // "forwards" means the user started dragging the RelinkHandle at the "To" end of the link
    this._isForwards = (ad === null || ad.category === 'RelinkTo');

    this.originalLink = ad.adornedPart;
  }

  this.startTransaction(this.name);

  diagram.isMouseCaptured = true;
  diagram.currentCursor = 'pointer';
  this.originalFromPort = this.originalLink.fromPort;
  this.originalFromNode = this.originalLink.fromNode;
  this.originalToPort = this.originalLink.toPort;
  this.originalToNode = this.originalLink.toNode;
  this._originalLinkBounds.set(this.originalLink.actualBounds);

  // in case either end is not connected to a node/port, initialize the temporary node/port
  if (this.originalLink !== null && this.originalLink.pointsCount > 0) {
    if (this.originalLink.fromNode === null) {
      if (this.temporaryFromPort !== null) {
        this.temporaryFromPort.desiredSize = Geo.ZeroSize;
      }
      if (this.temporaryFromNode !== null) {
        this.temporaryFromNode.location = this.originalLink.getPoint(0);
      }
    }
    if (this.originalLink.toNode === null) {
      if (this.temporaryToPort !== null) {
        this.temporaryToPort.desiredSize = Geo.ZeroSize;
      }
      if (this.temporaryToNode !== null) {
        this.temporaryToNode.location = this.originalLink.getPoint(this.originalLink.pointsCount - 1);
      }
    }
  }

  // initialize temporary nodes/ports
  this.copyPortProperties(this.originalFromNode, this.originalFromPort, this.temporaryFromNode, this.temporaryFromPort, false);
  this.copyPortProperties(this.originalToNode, this.originalToPort, this.temporaryToNode, this.temporaryToPort, true);

  diagram.add(this.temporaryFromNode);
  diagram.add(this.temporaryToNode);

  if (this.temporaryLink !== null) {
    if (this.temporaryFromNode !== null) {
      this.temporaryLink.fromNode = this.temporaryFromNode;
    }
    if (this.temporaryToNode !== null) {
      this.temporaryLink.toNode = this.temporaryToNode;
    }
    this.temporaryLink.invalidateRoute();
    diagram.add(this.temporaryLink);
  }

  this.isActive = true;
};

/**
* Finishing the linking operation stops the transaction, releases the mouse, and resets the cursor.
* <p/>
* This method may be overridden, but we recommend that you call this base method.
* @this {RelinkingTool}
*/
RelinkingTool.prototype.doDeactivate = function() {
  this.isActive = false;
  var diagram = this.diagram;
  if (diagram === null) return;
  diagram.remove(this.temporaryLink);
  diagram.remove(this.temporaryFromNode);
  diagram.remove(this.temporaryToNode);
  diagram.isMouseCaptured = false;
  diagram.currentCursor = '';
  this.stopTransaction();
};

/**
* @ignore
* Clean up tool state.
* @this {RelinkingTool}
*/
RelinkingTool.prototype.doStop = function() {
  LinkingBaseTool.prototype.doStop.call(this);
  this._handle = null;
};

/**
* A mouse-up ends the relinking operation; if there is a valid {@link #targetPort} nearby,
* this modifies the old link to connect with the target port.
* <p/>
* A successful relinking calls {@link #reconnectLink} to actually change the link.
* The "LinkRelinked" {@link DiagramEvent} is raised.
* <p/>
* A failure to find a valid target port results in no changes and no DiagramEvent.
* <p/>
* This method may be overridden, but we recommend that you call this base method.
* You might find it easier to override {@link #reconnectLink}.
* It is actually most common to implement a "LinkRelinked" {@link DiagramEvent} listener on the {@link Diagram}.
* @this {RelinkingTool}
*/
RelinkingTool.prototype.doMouseUp = function() {
  if (this.isActive) {
    var diagram = this.diagram;
    if (diagram === null) return;
    this.transactionResult = null;

    var newfromnode = this.originalFromNode;
    var newfromport = this.originalFromPort;
    var newtonode = this.originalToNode;
    var newtoport = this.originalToPort;

    var origlink = this.originalLink;
    this.targetPort = this.findTargetPort(this.isForwards);
    if (this.targetPort !== null) {
      var targetnode = this.targetPort.part;
      if (targetnode instanceof Node) {
        if (this.isForwards) {
          newtonode = targetnode;
          newtoport = this.targetPort;
        } else {
          newfromnode = targetnode;
          newfromport = this.targetPort;
        }
      }
    } else { // no target port found, disconnect if allowed
      if (this.isUnconnectedLinkValid) {
        if (this.isForwards) {
          newtonode = null;
          newtoport = null;
        } else {
          newfromnode = null;
          newfromport = null;
        }
      } else {
        origlink = null;
        // don't set transactionResult and let any changes be rolled back
      }
    }

    if (origlink !== null) {
      this.reconnectLink(origlink, (this.isForwards ? newtonode : newfromnode),
                                      (this.isForwards ? newtoport : newfromport), this.isForwards);

      if (this.targetPort === null) {
        // need to tell Link that it ought to end at last mouse point
        if (this.isForwards) {
          origlink.defaultToPoint = diagram.lastInput.documentPoint;
        } else {
          origlink.defaultFromPoint = diagram.lastInput.documentPoint;
        }
        origlink.invalidateRoute();
      }
      // select the link
      if (diagram.allowSelect) origlink.isSelected = true;
      // set the TransactionResult before raising event, in case it changes the result or cancels
      this.transactionResult = this.name;
      diagram.raiseDiagramEvent('LinkRelinked', origlink, (this.isForwards ? this.originalToPort : this.originalFromPort));
    }

    // fix any jump-overs
    this.originalLink.invalidateOtherJumpOvers(this._originalLinkBounds);
  }
  this.stopTool();
};

/**
* Modify an existing {@link Link} to connect to a new node and port.
* <p/>
* This method may be overridden, but we recommend that you call this base method.
* @expose
* @this {RelinkingTool}
* @param {Link} existinglink
* @param {Node} newnode the {@link Node} to connect to or from.
* @param {GraphObject} newport the {@link GraphObject} port to connect to or from.
* @param {boolean} toend If true, this modifies the link's "to" node and port; otherwise it modifies the "from" node and port.
* @return {boolean} true if successful.
*/
RelinkingTool.prototype.reconnectLink = function(existinglink, newnode, newport, toend) {
  var diagram = this.diagram;
  if (diagram === null) return false;

  //??? this model changing code looks unnecessary because Link property setters should be changing the model
  var newnodedata = (newnode !== null ? newnode.data : null);
  var newnodekey = (newnodedata !== null ? diagram.model.getKeyForNodeData(newnodedata) : undefined);
  var newportid = (newport.portId !== null ? newport.portId : '');
  var oldlinkdata = existinglink.data;
  if (oldlinkdata !== null && newnodekey !== undefined) {  // modify the model
    var model = diagram.model;
    if (model instanceof TreeModel) {
      var tochildren = diagram.isTreePathToChildren;
      var oldparentnode = existinglink.fromNode;
      var oldchildnode = existinglink.toNode;
      if (!tochildren) {
        oldparentnode = existinglink.toNode;
        oldchildnode = existinglink.fromNode;
      }
      var newparentnode = oldparentnode;
      var newchildnode = oldchildnode;
      if ((toend && tochildren) ||
          (!toend && !tochildren)) {
        newchildnode = newnode;
        model.setParentKeyForNodeData(oldchildnode.data, undefined);
        model.setParentKeyForNodeData(newchildnode.data, model.getKeyForNodeData(newparentnode.data));
      } else {
        newparentnode = newnode;
        model.setParentKeyForNodeData(oldchildnode.data, model.getKeyForNodeData(newparentnode.data));
      }
    } else if (model instanceof GraphLinksModel) {
      if (toend) {
        model.setToKeyForLinkData(oldlinkdata, newnodekey);
        model.setToPortIdForLinkData(oldlinkdata, newportid);
      } else {
        model.setFromKeyForLinkData(oldlinkdata, newnodekey);
        model.setFromPortIdForLinkData(oldlinkdata, newportid);
      }
    } else {
      return false;
    }
  } else {  // just modify the Link directly
    if (toend) {
      this.originalLink.toNode = newnode;
      this.originalLink.toPortId = newportid;
    } else {
      this.originalLink.fromNode = newnode;
      this.originalLink.fromPortId = newportid;
    }
  }
  return true;
};

/**
* @ignore
* @this {RelinkingTool}
* @param {Node} fromnode
* @param {GraphObject} fromport
* @param {Node} tonode
* @param {GraphObject} toport
*/
RelinkingTool.prototype.doDraggingMouseMove = function(fromnode, fromport, tonode, toport) {
  //???
};

/**
* @ignore
* @this {RelinkingTool}
*/
RelinkingTool.prototype.stopDraggingMouseMove = function() {
  //???
};

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
PartReshapingTool
LinkReshapingTool
*/

///**
// * @constructor
// * @extends Tool
// * @category Tool
// * @class
// */
//function PartReshapingTool() {
//  Tool.call(this);
//  this.name = 'PartReshaping';
//}

//Util.publish('PartReshapingTool', PartReshapingTool);

//Util.inherit(PartReshapingTool, Tool);




/**
* You do not normally need to create an instance of this tool
* because one already exists as the {@link ToolManager#linkReshapingTool}, which you can modify.
* @constructor
* @extends Tool
* @category Tool
* @class
* The LinkReshapingTool is used to interactively change the route of a {@link Link}.
* <p/>
* This tool makes use of an {@link Adornment}, shown when the adorned {@link Link} is selected,
* that includes some number of reshape handles.
* This tool conducts a transaction while the tool is active.
* A successful reshaping will result in a "LinkReshaped" {@link DiagramEvent} and a "LinkReshaping" transaction.
*/
function LinkReshapingTool() {
  if (arguments.length > 0) {
    Util.throwError('LinkReshapingTool constructor cannot take any arguments.');
  }
  Tool.call(this);
  this.name = 'LinkReshaping';

  var h = new Shape();
  h.figure = 'Rectangle';
  h.desiredSize = Geo.SixSize;
  h.fill = 'cyan';
  /** @type {GraphObject} */
  this._handleArchetype = h;

  h = new Shape();
  h.figure = 'Diamond';
  h.desiredSize = Geo.SixSize;
  h.fill = 'cyan';
  /** @type {GraphObject} */
  this._midHandleArchetype = h;

  /** @type {number} */
  this._resegmentingDistance = 3;

  // internal state
  /** @type {GraphObject} */
  this._handle = null;
  /** @type {Link} */
  this._adornedLink = null;

  /** @type {Point} */
  this._originalPoint = new Point();
  /** @type {List} */
  this._originalPoints = null;
}

Util.publish('LinkReshapingTool', LinkReshapingTool);

Util.inherit(LinkReshapingTool, Tool);

/**
* Disallow dragging.
* @name LinkReshapingTool#None
* @constant
* @static
* @return {EnumValue}
*/
LinkReshapingTool['None'] = LinkReshapingTool.None = Util.defineEnumValue(LinkReshapingTool, 'None', 0);

/**
* Allow only horizontal (left-and-right) dragging.
* @name LinkReshapingTool#Horizontal
* @constant
* @static
* @return {EnumValue}
*/
LinkReshapingTool['Horizontal'] = LinkReshapingTool.Horizontal = Util.defineEnumValue(LinkReshapingTool, 'Horizontal', 1);

/**
* Allow only vertical (up-and-down) dragging.
* @name LinkReshapingTool#Vertical
* @constant
* @static
* @return {EnumValue}
*/
LinkReshapingTool['Vertical'] = LinkReshapingTool.Vertical = Util.defineEnumValue(LinkReshapingTool, 'Vertical', 2);

/**
* Allow dragging in any direction.
* @name LinkReshapingTool#All
* @constant
* @static
* @return {EnumValue}
*/
LinkReshapingTool['All'] = LinkReshapingTool.All = Util.defineEnumValue(LinkReshapingTool, 'All', 3);


/**
* Show an {@link Adornment} with reshape handles at each of the interesting points of the link's route,
* if the link is selected and visible and if {@link Part#canReshape} is true.
* <p/>
* This method may be overridden.
* @this {LinkReshapingTool}
* @param {Part} part
*/
LinkReshapingTool.prototype.updateAdornments = function(part) {
  if (!(part instanceof Link)) return;  // this tool only applies to Links
  var adornment = null;
  if (part.isSelected) {
    var selelt = part.path;
    if (part.actualBounds.isReal() && selelt !== null && part.isVisible() && part.canReshape() && selelt.isVisibleObject() && selelt.actualBounds.isReal()) {
      adornment = part.findAdornment(this.name);
      if (adornment === null) {
        adornment = this.makeAdornment(selelt);
        adornment.category = this.name;
        adornment.isStandard = true;
      }
      if (adornment !== null) {
        adornment.location = part.position;
        adornment.invalidateMeasure();
      }
    }
    part.addAdornment(this.name, adornment);
  } else {
    part.removeAdornment(this.name);
  }
}; // end updateAdornments

/**
* @ignore
* @expose
* @this {LinkReshapingTool}
* @param {GraphObject} selelt
* @return {Adornment}
*/
LinkReshapingTool.prototype.makeAdornment = function(selelt) {
  var adornment = new Adornment();
  adornment.type = Panel.Link;

  var link = selelt.part;
  var pts = link.points;
  var numpts = link.pointsCount;
  var ortho = link.isOrthogonal;
  if (pts !== null && numpts > 1) {
    var firstindex = link.firstPickIndex;
    var lastindex = link.lastPickIndex;
    var orthadjust = (ortho ? 1 : 0);
    if (link.resegmentable && link.curve !== Link.Bezier) {
      for (var i = firstindex + orthadjust; i < lastindex - orthadjust; i++) {
        var h = this.makeResegmentHandle(selelt, i);
        // needs to be a GraphObject so we can set its Cursor
        if (h !== null) {
          // identify this particular handle within the LinkPanel
          h.segmentIndex = i;
          h.segmentFraction = 0.5;
          adornment.add(h);
        }
      }
    }
    // don't bother creating handles for firstindex or lastindex
    for (var i = firstindex + 1; i < lastindex; i++) {
      var h = this.makeHandle(selelt, i);
      // needs to be a GraphObject so we can set its Cursor
      if (h !== null) {
        // identify this particular handle within the LinkPanel
        h.segmentIndex = i;
        // now determines its reshape behavior and cursor, depending on whether Orthogonal et al.
        if (i === firstindex) {
          // default ReshapeBehavior.None
        } else if (i === firstindex + 1 && ortho) {
          var a = link.getPoint(firstindex);
          var b = link.getPoint(firstindex + 1);
          if (Geo.isApprox(a.x, b.x) && Geo.isApprox(a.y, b.y)) {
            b = link.getPoint(firstindex - 1);
            if (Geo.isApprox(a.x, b.x)) {
              h.reshapeBehavior = LinkReshapingTool.Vertical;
              h.cursor = 'n-resize';
            } else if (Geo.isApprox(a.y, b.y)) {
              h.reshapeBehavior = LinkReshapingTool.Horizontal;
              h.cursor = 'w-resize';
            }
          } else if (Geo.isApprox(a.x, b.x)) {
            h.reshapeBehavior = LinkReshapingTool.Vertical;
            h.cursor = 'n-resize';
          } else if (Geo.isApprox(a.y, b.y)) {
            h.reshapeBehavior = LinkReshapingTool.Horizontal;
            h.cursor = 'w-resize';
          }
        } else if (i === lastindex - 1 && ortho) {
          var a = link.getPoint(lastindex - 1);
          var b = link.getPoint(lastindex);
          if (Geo.isApprox(a.x, b.x) && Geo.isApprox(a.y, b.y)) {
            a = link.getPoint(lastindex + 1);
            if (Geo.isApprox(a.x, b.x)) {
              h.reshapeBehavior = LinkReshapingTool.Vertical;
              h.cursor = 'n-resize';
            } else if (Geo.isApprox(a.y, b.y)) {
              h.reshapeBehavior = LinkReshapingTool.Horizontal;
              h.cursor = 'w-resize';
            }
          } else if (Geo.isApprox(a.x, b.x)) {
            h.reshapeBehavior = LinkReshapingTool.Vertical;
            h.cursor = 'n-resize';
          } else if (Geo.isApprox(a.y, b.y)) {
            h.reshapeBehavior = LinkReshapingTool.Horizontal;
            h.cursor = 'w-resize';
          }
        } else if (i === lastindex) {
          // default ReshapeBehavior.None
        } else {
          h.reshapeBehavior = LinkReshapingTool.All;
          h.cursor = 'move';
        }
        adornment.add(h);
      }
    }
    adornment.adornedObject = selelt;
  }

  return adornment;
};

/**
* @ignore
* Create and return a {@link GraphObject} that the user can "grab" to relink the selected Link.
* By default this returns a copy of {@link #handleArchetype}, a {@link Shape} that is a small cyan rectangle.
* @expose
* @this {LinkReshapingTool}
* @param {GraphObject} selelt the {@link GraphObject} path of the link being reshaped.
* @param {number} idx the index of the route point to be moved.
* @return {GraphObject}
*/
LinkReshapingTool.prototype.makeHandle = function(selelt, idx) {
  var h = this.handleArchetype;
  if (h === null) return null;
  return h.copy();
};

/**
* Gets or sets a small GraphObject that is copied as a reshape handle at each movable point in the selected link's route.
* By default this is a {@link Shape} that is a small cyan rectangle.
* Setting this property does not raise any events.
* <p/>
* Here is an example of changing the default handles to be larger yellow circles:
* <code><br/>
* &nbsp;&nbsp;myDiagram.toolManager.linkReshapingTool.handleArchetype =<br/>
* &nbsp;&nbsp;&nbsp;&nbsp;$(go.Shape, "Circle",<br/>
* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ width: 10, height: 10, fill: "yellow" });<br/>
* </code>
* @name LinkReshapingTool#handleArchetype
* @function.
* @return {GraphObject}
* @see #midHandleArchetype
*/
/** @type {GraphObject} */
LinkReshapingTool.prototype.handleArchetype;
Util.defineProperty(LinkReshapingTool, { handleArchetype: 'handleArchetype' },
  /** @this {LinkReshapingTool} */
  function() { return this._handleArchetype; },
  /** @this {LinkReshapingTool} */
  function(val) {
    if (val) Util.checkClass(val, GraphObject, LinkReshapingTool, 'handleArchetype');
    this._handleArchetype = val;
  }
);

/**
* @ignore
* Create and return a {@link GraphObject} that the user can "grab" to add a segment to the selected Link.
* By default this returns a copy of {@link #midHandleArchetype}, a {@link Shape} that is a small cyan diamond.
* @expose
* @this {LinkReshapingTool}
* @param {GraphObject} selelt the {@link GraphObject} path of the link being reshaped.
* @param {number} idx the index of the route point to be moved.
* @return {GraphObject}
*/
LinkReshapingTool.prototype.makeResegmentHandle = function(selelt, idx) {
  var h = this.midHandleArchetype;
  if (h === null) return null;
  return h.copy();
};

/**
* Gets or sets a small GraphObject that is copied as a resegment handle at each mid-point in the selected Link's route.
* By default this is a {@link Shape} that is a small cyan diamond.
* Setting this property does not raise any events.
* <p/>
* Here is an example of changing the default handle to be larger cyan triangles:
* <code><br/>
* &nbsp;&nbsp;myDiagram.toolManager.linkReshapingTool.midHandleArchetype =<br/>
* &nbsp;&nbsp;&nbsp;&nbsp;$(go.Shape, "Diamond", { width: 10, height: 10, fill: "cyan" });<br/>
* </code>
* @name LinkReshapingTool#midHandleArchetype
* @function.
* @return {GraphObject}
* @see #handleArchetype
* @since 1.2
*/
/** @type {GraphObject} */
LinkReshapingTool.prototype.midHandleArchetype;
Util.defineProperty(LinkReshapingTool, { midHandleArchetype: 'midHandleArchetype' },
  /** @this {LinkReshapingTool} */
  function() { return this._midHandleArchetype; },
  /** @this {LinkReshapingTool} */
  function(val) {
    if (val) Util.checkClass(val, GraphObject, LinkReshapingTool, 'midHandleArchetype');
    this._midHandleArchetype = val;
  }
);

/**
* Gets the {@link GraphObject} that is the tool handle being dragged by the user.
* This will be contained by an {@link Adornment} whose category is "LinkReshaping".
* Its {@link Adornment#adornedPart} is the same as the {@link #adornedLink}.
* @name LinkReshapingTool#handle
* @function.
* @return {GraphObject}
*/
/** @type {GraphObject} */
LinkReshapingTool.prototype.handle;
Util.defineReadOnlyProperty(LinkReshapingTool, {handle: 'handle'},
  /** @this {LinkReshapingTool} */
  function() { return this._handle; }
);

/**
* Gets the {@link Link} that is being routed manually.
* @name LinkReshapingTool#adornedLink
* @function.
* @return {Link}
*/
/** @type {Link} */
LinkReshapingTool.prototype.adornedLink;
Util.defineReadOnlyProperty(LinkReshapingTool, { adornedLink: 'adornedLink' },
  /** @this {LinkReshapingTool} */
  function() { return this._adornedLink; }
);


/**
* This tool may run when there is a mouse-down event on a reshape handle.
* <p/>
* This method may be overridden.
* @this {LinkReshapingTool}
* @return {boolean}
*/
LinkReshapingTool.prototype.canStart = function() {
  if (!this.isEnabled) return false;

  var diagram = this.diagram;
  if (diagram === null || diagram.isReadOnly) return false;
  if (!diagram.allowReshape) return false;
  //if (!IsLeftButtonDown()) return false; ???
  var h = this.findToolHandleAt(diagram.firstInput.documentPoint, this.name);
  return (h !== null);
};


/**
* Start reshaping, if {@link #findToolHandleAt} finds a reshape handle at the mouse down point.
* <p/>
* If successful this sets {@link #handle} to be the reshape handle that it finds
* and {@link #adornedLink} to be the {@link Link} being routed.
* It also remembers the original link route (a list of Points) in case this tool is cancelled.
* And it starts a transaction.
* @this {LinkReshapingTool}
*/
LinkReshapingTool.prototype.doActivate = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  this._handle = this.findToolHandleAt(diagram.firstInput.documentPoint, this.name);
  if (this._handle === null) return;
  var link = this._handle.part.adornedPart;
  if (!(link instanceof Link)) return;
  this._adornedLink = link;
  diagram.isMouseCaptured = true;

  this.startTransaction(this.name);

  if (link.resegmentable && this._handle.segmentFraction === 0.5) {
    var pts = link.points.copy();
    var hpt = this._handle.getDocumentPoint(Spot.Center);
    pts.insertAt(this._handle.segmentIndex + 1, hpt);
    if (link.isOrthogonal) {
      pts.insertAt(this._handle.segmentIndex + 1, hpt);
    }
    link.points = pts;
    link.clearAdornments();
    link.updateAdornments();
    this._handle = this.findToolHandleAt(diagram.firstInput.documentPoint, this.name);
  }

  this._originalPoint = link.getPoint(this._handle.segmentIndex);
  this._originalPoints = link.points.copy();
  this.isActive = true;
};

/**
* This stops the current reshaping operation with the link route shaped the way it is.
* @this {LinkReshapingTool}
*/
LinkReshapingTool.prototype.doDeactivate = function() {
  this.stopTransaction();

  this._handle = null;
  this._adornedLink = null;
  var diagram = this.diagram;
  if (diagram !== null) diagram.isMouseCaptured = false;
  this.isActive = false;
};

/**
* Restore the link route to be the original points and stop this tool.
* @this {LinkReshapingTool}
*/
LinkReshapingTool.prototype.doCancel = function() {
  var link = this.adornedLink;
  if (link !== null) {
    link.points = this._originalPoints;
  }
  this.stopTool();
};

/**
* Call {@link #reshape} with a new point determined by the mouse
* to change the route of the {@link #adornedLink}.
* @this {LinkReshapingTool}
*/
LinkReshapingTool.prototype.doMouseMove = function() {
  var diagram = this.diagram;
  if (this.isActive && diagram !== null) {
    var newpt = this.computeReshape(diagram.lastInput.documentPoint);
    this.reshape(newpt);
  }
};

/**
* Reshape the route with a point based on the most recent mouse point by calling {@link #reshape},
* and then raise a "LinkReshaped" {@link DiagramEvent} before stopping this tool.
* @this {LinkReshapingTool}
*/
LinkReshapingTool.prototype.doMouseUp = function() {
  var diagram = this.diagram;
  if (this.isActive && diagram !== null) {
    var newpt = this.computeReshape(diagram.lastInput.documentPoint);
    this.reshape(newpt);

    var link = this.adornedLink;
    if (link !== null && link.resegmentable) {
      var idx = this.handle.segmentIndex;
      var a = link.getPoint(idx - 1);
      var b = link.getPoint(idx);
      var c = link.getPoint(idx + 1);
      // see if we should delete a segment because both adjacent segments are co-linear
      if (link.isOrthogonal) {
        if (idx > link.firstPickIndex + 1 && idx < link.lastPickIndex - 1) {
          var q = link.getPoint(idx - 2);
          if (this.isWithinResegmentingDistance(a, b) &&
              (this.isInLineOrtho(q, a, b, c, true) || this.isInLineOrtho(q, a, b, c, false))) {
            var pts = link.points.copy();
            // re-align remaining two points Q and C to maintain orthogonality
            if (this.isInLineOrtho(q, a, b, c, true)) {
              pts.setElt(idx - 2, new Point(q.x, (c.y + q.y) / 2));
              pts.setElt(idx + 1, new Point(c.x, (c.y + q.y) / 2));
            } else {
              pts.setElt(idx - 2, new Point((c.x + q.x) / 2, q.y));
              pts.setElt(idx + 1, new Point((c.x + q.x) / 2, c.y));
            }
            // remove points A and B
            pts.removeAt(idx);  // order matters!
            pts.removeAt(idx - 1);
            link.points = pts;
            link.clearAdornments();
            link.updateAdornments();
          } else {
            q = link.getPoint(idx + 2);
            if (this.isWithinResegmentingDistance(b, c) &&
                (this.isInLineOrtho(a, b, c, q, true) || this.isInLineOrtho(a, b, c, q, false))) {
              var pts = link.points.copy();
              // re-align remaining two points A and Q to maintain orthogonality
              if (this.isInLineOrtho(a, b, c, q, true)) {
                pts.setElt(idx - 1, new Point(a.x, (a.y + q.y) / 2));
                pts.setElt(idx + 2, new Point(q.x, (a.y + q.y) / 2));
              } else {
                pts.setElt(idx - 1, new Point((a.x + q.x) / 2, a.y));
                pts.setElt(idx + 2, new Point((a.x + q.x) / 2, q.y));
              }
              // remove points B and C
              pts.removeAt(idx + 1);  // order matters!
              pts.removeAt(idx);
              link.points = pts;
              link.clearAdornments();
              link.updateAdornments();
            }
          }
        }
      } else {
        var q = Util.tempPoint();  // the closest point to B on the line between A and C
        if (Geo.nearestPointOnLine(a.x, a.y, c.x, c.y, b.x, b.y, q)) {
          // if B is within 3 units of the line from A to C, and if Q is between A and C,
          // remove that point from the route
          if (q.distanceSquaredPoint(b) < 3 * 3) {
            var pts = link.points.copy();
            pts.removeAt(idx);
            link.points = pts;
            link.clearAdornments();
            link.updateAdornments();
          }
        }
        Util.freePoint(q);
      }
    }

    diagram.invalidateDocumentBounds();
    // set the EditResult before raising event, in case it changes the result or cancels the tool
    this.transactionResult = this.name;
    diagram.raiseDiagramEvent('LinkReshaped', this.adornedLink);
  }
  this.stopTool();
};

/**
* @ignore
* @this {LinkReshapingTool}
* @param {Point} p1
* @param {Point} p2
* @return {boolean}
*/
LinkReshapingTool.prototype.isWithinResegmentingDistance = function(p1, p2) {
  return Math.abs(p1.x - p2.x) < this.resegmentingDistance && Math.abs(p1.y - p2.y) < this.resegmentingDistance;
};

/**
* @ignore
* @this {LinkReshapingTool}
* @param {Point} a
* @param {Point} b
* @param {Point} c
* @param {Point} d
* @param {boolean} horiz
* @return {boolean}
*/
LinkReshapingTool.prototype.isInLineOrtho = function(a, b, c, d, horiz) {
  if (horiz) {
    return (Math.abs(a.y - b.y) < this.resegmentingDistance &&
            Math.abs(b.y - c.y) < this.resegmentingDistance &&
            Math.abs(c.y - d.y) < this.resegmentingDistance);
  } else {
    return (Math.abs(a.x - b.x) < this.resegmentingDistance &&
            Math.abs(b.x - c.x) < this.resegmentingDistance &&
            Math.abs(c.x - d.x) < this.resegmentingDistance);
  }
};

/**
* @ignore
* Gets or sets the distance from a straight line that controls whether a
* {@link Link#resegmentable} Link segment is kept as a separate segment or
* removed to form a straight segment of the adjacent points.
* <p/>
* The default value is 3.
* @name Tool#resegmentingDistance
* @function.
* @return {number}
*/
/** @type {number} */
Tool.prototype.resegmentingDistance;
Util.exportProperty(Tool, 'resegmentingDistance', Tool.prototype.resegmentingDistance);
Util.defineProperty(Tool, { resegmentingDistance: 'resegmentingDistance' },
/** @this {Tool} */
  function() { return this._resegmentingDistance; },
/** @this {Tool} */
  function(val) { this._resegmentingDistance = val; }
);

/**
* Change the route of the {@link #adornedLink} by moving the point corresponding to the current
* {@link #handle} to be at the given {@link Point}.
* This is called by {@link #doMouseMove} and {@link #doMouseUp} with the result of calling
* {@link #computeReshape} to constrain the input point.
* <p/>
* This method respects the orthogonality of the link, if necessary limiting movement along only one axis.
* To maintain orthogonality it may need to modify more than one point in the route.
* <p/>
* This method may be overridden.
* @expose
* @this {LinkReshapingTool}
* @param {Point} newPoint the value of the call to {@link #computeReshape}.
*/
LinkReshapingTool.prototype.reshape = function(newPoint) {
  var link = this.adornedLink;
  link.startRoute();
  var index = this.handle.segmentIndex;
  var behavior = this.handle.reshapeBehavior;
  if (link.isOrthogonal) {  // need to adjust adjacent points as well
    if (index === link.firstPickIndex + 1) {
      var midfirst = link.firstPickIndex + 1;
      if (behavior === LinkReshapingTool.Vertical) {
        // move segment vertically
        link.setPointAt(midfirst, link.getPoint(midfirst - 1).x, newPoint.y);
        link.setPointAt(midfirst + 1, link.getPoint(midfirst + 2).x, newPoint.y);
      } else if (behavior === LinkReshapingTool.Horizontal) {
        // move segment horizontally
        link.setPointAt(midfirst, newPoint.x, link.getPoint(midfirst - 1).y);
        link.setPointAt(midfirst + 1, newPoint.x, link.getPoint(midfirst + 2).y);
      }
    } else if (index === link.lastPickIndex - 1) {
      var midlast = link.lastPickIndex - 1;
      if (behavior === LinkReshapingTool.Vertical) {
        // move segment vertically
        link.setPointAt(midlast - 1, link.getPoint(midlast - 2).x, newPoint.y);
        link.setPointAt(midlast, link.getPoint(midlast + 1).x, newPoint.y);
      } else if (behavior === LinkReshapingTool.Horizontal) {
        // move segment horizontally
        link.setPointAt(midlast - 1, newPoint.x, link.getPoint(midlast - 2).y);
        link.setPointAt(midlast, newPoint.x, link.getPoint(midlast + 1).y);
      }
    } else {
      // can move anywhere, but need to keep adjacent segments orthogonal
      var i = index;
      var oldpt = link.getPoint(i);
      var before = link.getPoint(i - 1);
      var after = link.getPoint(i + 1);
      if (Geo.isApprox(before.x, oldpt.x) && Geo.isApprox(oldpt.y, after.y)) {
        if (Geo.isApprox(before.x, link.getPoint(i - 2).x) && !Geo.isApprox(before.y, link.getPoint(i - 2).y)) {
          link.insertPointAt(i, newPoint.x, before.y);
          index++;
          i++;
        } else link.setPointAt(i - 1, newPoint.x, before.y);
        if (Geo.isApprox(after.y, link.getPoint(i + 2).y) && !Geo.isApprox(after.x, link.getPoint(i + 2).x)) {
          link.insertPointAt(i + 1, after.x, newPoint.y);
        } else link.setPointAt(i + 1, after.x, newPoint.y);
      } else if (Geo.isApprox(before.y, oldpt.y) && Geo.isApprox(oldpt.x, after.x)) {
        if (Geo.isApprox(before.y, link.getPoint(i - 2).y) && !Geo.isApprox(before.x, link.getPoint(i - 2).x)) {
          link.insertPointAt(i, before.x, newPoint.y);
          index++;
          i++;
        } else link.setPointAt(i - 1, before.x, newPoint.y);
        if (Geo.isApprox(after.x, link.getPoint(i + 2).x) && !Geo.isApprox(after.y, link.getPoint(i + 2).y)) {
          link.insertPointAt(i + 1, newPoint.x, after.y);
        } else link.setPointAt(i + 1, newPoint.x, after.y);
      } else if (Geo.isApprox(before.x, oldpt.x) && Geo.isApprox(oldpt.x, after.x)) {
        if (Geo.isApprox(before.x, link.getPoint(i - 2).x) && !Geo.isApprox(before.y, link.getPoint(i - 2).y)) {
          link.insertPointAt(i, newPoint.x, before.y);
          index++;
          i++;
        } else link.setPointAt(i - 1, newPoint.x, before.y);
        if (Geo.isApprox(after.x, link.getPoint(i + 2).x) && !Geo.isApprox(after.y, link.getPoint(i + 2).y)) {
          link.insertPointAt(i + 1, newPoint.x, after.y);
        } else link.setPointAt(i + 1, newPoint.x, after.y);
      } else if (Geo.isApprox(before.y, oldpt.y) && Geo.isApprox(oldpt.y, after.y)) {
        if (Geo.isApprox(before.y, link.getPoint(i - 2).y) && !Geo.isApprox(before.x, link.getPoint(i - 2).x)) {
          link.insertPointAt(i, before.x, newPoint.y);
          index++;
          i++;
        } else link.setPointAt(i - 1, before.x, newPoint.y);
        if (Geo.isApprox(after.y, link.getPoint(i + 2).y) && !Geo.isApprox(after.x, link.getPoint(i + 2).x)) {
          link.insertPointAt(i + 1, after.x, newPoint.y);
        } else link.setPointAt(i + 1, after.x, newPoint.y);
      }
      link.setPointAt(index, newPoint.x, newPoint.y);
    }
  } else {  // no Orthogonal constraints, just set the new point
    link.setPointAt(index, newPoint.x, newPoint.y);
    // also adjust the end point if there is no spot for the port
    if (index === 1 && link.computeSpot(true).isNoSpot()) {
      var fromNode = link.fromNode;
      var fromPort = link.fromPort;
      var ctr = fromPort.getDocumentPoint(Spot.Center, Util.tempPoint());
      var result = Util.tempPoint();
      var endpt = link.getLinkPointFromPoint(fromNode, fromPort, ctr, newPoint, true, result);
      link.setPointAt(0, endpt.x, endpt.y);
      Util.freePoint(ctr);
      Util.freePoint(result);
    }
    if (index === link.pointsCount - 2 && link.computeSpot(false).isNoSpot()) {
      var toNode = link.toNode;
      var toPort = link.toPort;
      var ctr = toPort.getDocumentPoint(Spot.Center, Util.tempPoint());
      var result = Util.tempPoint();
      var endpt = link.getLinkPointFromPoint(toNode, toPort, ctr, newPoint, false, result);
      link.setPointAt(link.pointsCount - 1, endpt.x, endpt.y);
      Util.freePoint(ctr);
      Util.freePoint(result);
    }
  }
  link.commitRoute();
};


/**
* This is called by {@link #doMouseMove} and {@link #doMouseUp} to limit the input point
* before calling {@link #reshape}.
* <p/>
* This method may be overridden.
* @expose
* @this {LinkReshapingTool}
* @param {Point} p the point where the handle is being dragged.
* @return {Point} Either the same Point p or one constrained by the reshape behavior to be moved
* only vertically or only horizontally.
*/
LinkReshapingTool.prototype.computeReshape = function(p) {
  var link = this.adornedLink;
  var index = this.handle.segmentIndex;
  switch (this.handle.reshapeBehavior) {
    case LinkReshapingTool.All:
      return p;  // no constraints
    case LinkReshapingTool.Vertical: {
        var oldpt = link.getPoint(index);
        return new Point(oldpt.x, p.y);
      }
    case LinkReshapingTool.Horizontal: {
        var oldpt = link.getPoint(index);
        return new Point(p.x, oldpt.y);
      }
    default:
    case LinkReshapingTool.None:
      return link.getPoint(index);  // can't move -- return old point
  }
};

/**
* Gets the {@link Point} that was the original location of the handle that is being dragged to reshape the Link.
* @name LinkReshapingTool#originalPoint
* @function.
* @return {Point}
* @since 1.1
*/
/** @type {Point} */
LinkReshapingTool.prototype.originalPoint;
Util.exportProperty(LinkReshapingTool, 'originalPoint', LinkReshapingTool.prototype.originalPoint);
Util.defineReadOnlyProperty(LinkReshapingTool, { originalPoint: 'originalPoint' },
  /** @this {LinkReshapingTool} */
  function() { return this._originalPoint; }
);

/**
* Gets the {@link List} of {@link Point}s that was the original route of the Link that is being reshaped.
* This List should not be modified; its value is indeterminate until a reshaping has been activated.
* @name LinkReshapingTool#originalPoints
* @function.
* @return {List}
* @since 1.1
*/
/** @type {List} */
LinkReshapingTool.prototype.originalPoints;
Util.exportProperty(LinkReshapingTool, 'originalPoints', LinkReshapingTool.prototype.originalPoints);
Util.defineReadOnlyProperty(LinkReshapingTool, { originalPoints: 'originalPoints' },
  /** @this {LinkReshapingTool} */
  function() { return this._originalPoints; }
);

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
ResizingTool
*/

/**
* You do not normally need to create an instance of this tool
* because one already exists as the {@link ToolManager#resizingTool}, which you can modify.
* @constructor
* @extends Tool
* @category Tool
* @class
* The ResizingTool is used to interactively change the size of a {@link GraphObject}
* in the selected {@link Part} or {@link Node}.
* This tool does not operate on {@link Link}s.
* <p/>
* You can limit the permitted minimum and maximum dimensions by setting
* {@link #minSize} and {@link #maxSize}.
* The resizing will also respect the {@link GraphObject#minSize} and
* {@link GraphObject#maxSize} properties.
* Width or height values that are NaN do not constrain the resizing.
* <p/>
* You can also limit the width and/or height to be multiples of a particular size by
* setting {@link Part#resizeCellSize}.
* If either or both of these values are NaN, as they are by default,
* it will get the values from this tool's {@link #cellSize}.
* <p/>
* If either or both of the width and height are still NaN,
* and if {@link DraggingTool#isGridSnapEnabled} is true,
* it will use the {@link DraggingTool#gridSnapCellSize}.
* Finally it will consider the {@link Diagram#grid}'s {@link Panel#gridCellSize}
* if {@link #isGridSnapEnabled} is true.
* <p/>
* This tool makes use of an {@link Adornment}, shown when the {@link Part} or {@link Node} is selected,
* that includes some number of resize handles.
* The resize handles are normally copies of {@link ResizingTool#handleArchetype},
* unless you specify a custom resize Adornment by setting {@link Part#resizeAdornmentTemplate}.
* <p/>
* This tool conducts a transaction while the tool is active.
* A successful resizing will result in a "PartResized" {@link DiagramEvent} and a "Resizing" transaction.
*/
function ResizingTool() {
  if (arguments.length > 0) {
    Util.throwError('ResizingTool constructor cannot take any arguments.');
  }
  Tool.call(this);
  // external properties
  this.name = 'Resizing';
  /** @type {Size} */
  this._minSize = new Size(1, 1).freeze();
  /** @type {Size} */
  this._maxSize = new Size(9999, 9999).freeze();
  /** @type {Size} */
  this._cellSize = new Size(NaN, NaN).freeze();
  /** @type {boolean} */
  this._isGridSnapEnabled = false;

  // internal state
  /** @type {GraphObject} */
  this._adornedObject = null;

  var h = new Shape();
  h.alignmentFocus = Spot.Center;
  h.figure = 'Rectangle';
  h.desiredSize = Geo.SixSize;
  h.fill = 'cyan';
  h.stroke = 'black';
  h.strokeWidth = 1;
  h.cursor = 'pointer';
  /** @type {GraphObject} */
  this._handleArchetype = h;

  /** @type {GraphObject} */
  this._handle = null;
  /** @type {number} */
  this._originalAngle = 0;
  /** @type {Rect} */
  this._originalBounds = new Rect();
  /** @type {Size} */
  this._originalDesiredSize = new Size();
  /** @type {Point} */
  this._originalLocation = new Point();
  /** @type {Size} */
  this._effectiveMinSize = new Size(0, 0);
  /** @type {Size} */
  this._effectiveMaxSize = new Size(Infinity, Infinity);
  /** @type {Size} */
  this._effectiveCellSize = new Size(1, 1);
}

Util.publish('ResizingTool', ResizingTool);

Util.inherit(ResizingTool, Tool);

/**
* Show an {@link Adornment} with the resize handles at points along the edge of the bounds of the
* selected {@link Part}'s {@link Part#resizeObject}.
* <p/>
* First this finds the object in the visual tree of the Part that should
* get the resize adornment and that the user will be able to resize interactively.
* It finds the object that has the {@link Part#resizeObjectName} property of the Part.
* If the {@link Part#resizeObjectName} property is an empty string, as it is by default,
* it uses the whole part.
* <p/>
* It then builds the adornment, associating it with the chosen resize object.
* The adornment gets eight handles, four at the corners and four at the middle of each side.
* <p/>
* This method may be overridden.
* @this {ResizingTool}
* @param {Part} part
*/
ResizingTool.prototype.updateAdornments = function(part) {
  if (part === null || part instanceof Link) return;  // can't resize links
  var adornment = null;
  if (part.isSelected) {
    var selelt = part.resizeObject;
    if (part.canResize() && selelt !== null && part.actualBounds.isReal() && part.isVisible() && selelt.isVisibleObject() && selelt.actualBounds.isReal()) {
      adornment = part.findAdornment(this.name);
      if (adornment === null) {
        adornment = this.makeAdornment(selelt);
        adornment.isStandard = true;
        adornment.locationSpot = Spot.Center;
      }
      if (adornment !== null) {
        var angle = selelt.getDocumentAngle();
        adornment.angle = angle;
        var loc = selelt.getDocumentPoint(Spot.Center, Util.tempPoint());
        var sc = selelt.getDocumentScale();
        adornment.location = loc;
        Util.freePoint(loc);

        var place = adornment.placeholder;
        if (place !== null) {
          var ns = selelt.naturalBounds;
          var sw = (selelt.strokeWidth);
          var dessz = Util.tempSize();
          dessz._set((ns.width) * sc, (ns.height) * sc);
          place.desiredSize = dessz;
          Util.freeSize(dessz);
        }
        this.updateResizeHandles(adornment, angle);  // fix up any cursors to point the right way
      }
    }
    part.addAdornment(this.name, adornment);
  } else {
    part.removeAdornment(this.name);
  }
};

/**
* @ignore
* Create and return an {@link Adornment} that lets the user grab a handle to resize the selected part.
* @expose
* @this {ResizingTool}
* @param {GraphObject} selelt the {@link GraphObject} being resized.
* @return {Adornment}
*/
ResizingTool.prototype.makeAdornment = function(selelt) {
  var adornment = null;
  var template = selelt.part.resizeAdornmentTemplate;
  if (template === null) {
    adornment = new Adornment();
    adornment.type = Panel.Spot;

    var surrogate = new Placeholder();
    surrogate.isPanelMain = true;
    adornment.add(surrogate);

    // add the standard eight handles: four at the corners
    adornment.add(this.makeHandle(selelt, Spot.TopLeft));
    adornment.add(this.makeHandle(selelt, Spot.TopRight));
    adornment.add(this.makeHandle(selelt, Spot.BottomRight));
    adornment.add(this.makeHandle(selelt, Spot.BottomLeft));
    // and four at the middle of each side
    adornment.add(this.makeHandle(selelt, Spot.MiddleTop));
    adornment.add(this.makeHandle(selelt, Spot.MiddleRight));
    adornment.add(this.makeHandle(selelt, Spot.MiddleBottom));
    adornment.add(this.makeHandle(selelt, Spot.MiddleLeft));
  } else {
    template.freezeBindings();
    adornment = template.copy();
    if (!(adornment instanceof Adornment)) return null;
  }
  adornment.category = this.name;
  adornment.adornedObject = selelt;
  return adornment;
};

/**
* @ignore
* Create and return a {@link GraphObject} that the user can "grab" to resize the selected part.
* By default this returns a {@link Shape} that is a small cyan rectangle.
* @expose
* @this {ResizingTool}
* @param {GraphObject} selelt the {@link GraphObject} to be resized, which may be the same as the whole Part.
* @param {Spot} spot
* @return {GraphObject}
*/
ResizingTool.prototype.makeHandle = function(selelt, spot) {
  var h = this.handleArchetype;
  if (h === null) return null;
  var c = h.copy();
  c.alignment = spot;
  return c;
};

/**
* @ignore
* @this {ResizingTool}
* @param {GraphObject} elt
* @param {number} angle
*/
ResizingTool.prototype.updateResizeHandles = function(elt, angle) {
  if (elt === null) return;
  if (!elt.alignment.isDefault() && elt.cursor !== '') {
    this.setResizeCursor(elt, angle);
  } else if (elt instanceof Panel) {
    var it = elt.elements;
    while (it.next()) {
      this.updateResizeHandles(it.value, angle);
    }
  }
};

/**
* @ignore
*/
ResizingTool.prototype.setResizeCursor = function(h, angle) {
  var spot = h.alignment;
  if (spot.isNoSpot()) spot = Spot.Center;
  var a = angle;
  if (spot.x <= 0) {  // left
    if (spot.y <= 0) {  // top-left
      a += 225;
    } else if (spot.y >= 1) {  // bottom-left
      a += 135;
    } else {  // middle-left
      a += 180;
    }
  } else if (spot.x >= 1) {  // right
    if (spot.y <= 0) {  // top-right
      a += 315;
    } else if (spot.y >= 1) {  // bottom-right
      a += 45;
    } else {  // middle-right
      // a += 0;
    }
  } else {  // middle-X
    if (spot.y <= 0) {  // top-middle
      a += 270;
    } else if (spot.y >= 1) {  // bottom-middle
      a += 90;
    } else {
      // handle is in the middle-middle -- don't do anything
      return;
    }
  }
  if (a < 0) a += 360;
  else if (a >= 360) a -= 360;
  if (a < 22.5)
    h.cursor = 'e-resize';
  else if (a < 67.5)
    h.cursor = 'se-resize';
  else if (a < 112.5)
    h.cursor = 's-resize';
  else if (a < 157.5)
    h.cursor = 'sw-resize';
  else if (a < 202.5)
    h.cursor = 'w-resize';
  else if (a < 247.5)
    h.cursor = 'nw-resize';
  else if (a < 292.5)
    h.cursor = 'n-resize';
  else if (a < 337.5)
    h.cursor = 'ne-resize';
  else
    h.cursor = 'e-resize';
};

/**
* Gets or sets a small GraphObject that is copied as a resizing handle for the selected part.
* By default this is a {@link Shape} that is a small cyan rectangle.
* Setting this property does not raise any events.
* <p/>
* Here is an example of changing the default handle to be larger yellow circles:
* <code><br/>
* &nbsp;&nbsp;myDiagram.toolManager.resizingTool.handleArchetype =<br/>
* &nbsp;&nbsp;&nbsp;&nbsp;$(go.Shape, "Circle",<br/>
* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ width: 10, height: 10, fill: "yellow" });<br/>
* </code>
* <p/>
* This property is ignored when a custom resizing Adornment is specified as the {@link Part#resizeAdornmentTemplate}.
* @name ResizingTool#handleArchetype
* @function.
* @return {GraphObject}
*/
/** @type {GraphObject} */
ResizingTool.prototype.handleArchetype;
Util.defineProperty(ResizingTool, { handleArchetype: 'handleArchetype' },
  /** @this {ResizingTool} */
  function() { return this._handleArchetype; },
  /** @this {ResizingTool} */
  function(val) {
    if (val) Util.checkClass(val, GraphObject, ResizingTool, 'handleArchetype');
    this._handleArchetype = val;
  }
);

/**
* Gets the {@link GraphObject} that is the tool handle being dragged by the user.
* This will be contained by an {@link Adornment} whose category is "ResizingTool".
* Its {@link Adornment#adornedObject} is the same as the {@link #adornedObject}.
* @name ResizingTool#handle
* @function.
* @return {GraphObject}
*/
/** @type {GraphObject} */
ResizingTool.prototype.handle;
Util.defineReadOnlyProperty(ResizingTool, {handle: 'handle'},
  /** @this {ResizingTool} */
  function() { return this._handle; }
);

/**
* Gets the {@link GraphObject} that is being resized.
* This may be the same object as the selected {@link Part} or it may be contained within that Part.
* <p>
* This property is also settable, but should only be set when overriding functions
* in ResizingTool, and not during normal operation.
* @name ResizingTool#adornedObject
* @function.
* @return {GraphObject}
*/
/** @type {GraphObject} */
ResizingTool.prototype.adornedObject;
Util.defineProperty(ResizingTool, {adornedObject: 'adornedObject'},
  /** @this {ResizingTool} */
  function() { return this._adornedObject; },
  /** @this {ResizingTool} */
  function(val) {
    if (val) Util.checkClass(val, GraphObject, ResizingTool, 'adornedObject');
    this._adornedObject = val;
  }
);

/**
* This tool may run when there is a mouse-down event on a resize handle,
* the diagram is not read-only and it allows resizing,
* the left mouse button is being used,
* and this tool's adornment's resize handle is at the current mouse point.
* <p/>
* This method may be overridden.
* @this {ResizingTool}
* @return {boolean}
*/
ResizingTool.prototype.canStart = function() {
  if (!this.isEnabled) return false;
  var diagram = this.diagram;
  if (diagram === null || diagram.isReadOnly) return false;
  if (!diagram.allowResize) return false;
  if (!diagram.lastInput.left) return false;

  var h = this.findToolHandleAt(diagram.firstInput.documentPoint, this.name);
  if (h !== null) return true; else return false;
};

/**
* Capture the mouse, remember the object's original bounds,
* and start a transaction.
* @this {ResizingTool}
*/
ResizingTool.prototype.doActivate = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  this._handle = this.findToolHandleAt(diagram.firstInput.documentPoint, this.name);
  if (this._handle === null) return;

  this._adornedObject = this._handle.part.adornedObject;
  this._originalAngle = this._adornedObject.angle;
  // this has to be (unrotated) natural size and not actualBounds
  this._originalBounds.set(this._adornedObject.naturalBounds);
  this._originalLocation.set(this._adornedObject.part.location);
  this._originalDesiredSize.set(this._adornedObject.desiredSize);
  this._effectiveCellSize = this.computeCellSize();
  this._effectiveMinSize = this.computeMinSize();
  this._effectiveMaxSize = this.computeMaxSize();
  diagram.isMouseCaptured = true;
  this.startTransaction(this.name);
  this.isActive = true;
};

/**
* Stop the current transaction and release the mouse.
* @this {ResizingTool}
*/
ResizingTool.prototype.doDeactivate = function() {
  var diagram = this.diagram;
  if (diagram === null) return;

  this.stopTransaction();
  this._handle = null;
  this._adornedObject = null;
  diagram.isMouseCaptured = false;
  this.isActive = false;
};

/**
* Restore the original {@link GraphObject}'s size.
* @this {ResizingTool}
*/
ResizingTool.prototype.doCancel = function() {
  this._adornedObject.desiredSize = this._originalDesiredSize;
  this._adornedObject.part.location = this._originalLocation;
  this.stopTool();
};

/**
* Call {@link #resize} with a new size determined by the current mouse point.
* This determines the new bounds by calling {@link #computeResize}.
* @this {ResizingTool}
*/
ResizingTool.prototype.doMouseMove = function() {
  var diagram = this.diagram;
  if (!this.isActive || diagram === null) return;
  var minsz = this._effectiveMinSize;
  var maxsz = this._effectiveMaxSize;
  var cellsz = this._effectiveCellSize;
  var docpt = diagram.lastInput.documentPoint;
  var locpt = this._adornedObject.getLocalPoint(docpt, Util.tempPoint());
  var stretch = this._adornedObject.geometryStretch;
  if (stretch === GraphObject.Default)
    stretch = this._adornedObject._geometry._defaultStretch;
  var reshape = !(stretch === GraphObject.Uniform || stretch === GraphObject.UniformToFill || diagram.lastInput.shift);
  var newr = this.computeResize(locpt, this._handle.alignment, minsz, maxsz, cellsz, reshape);
  //Debug.trace(docpt.toString() + ' --> ' + locpt.toString() + ' : ' + newr.toString());
  this.resize(newr);
  // do it immediately
  diagram.maybeUpdate();
  Util.freePoint(locpt);
};

/**
* Call {@link #resize} with the final bounds based on the most recent mouse point,
* commit the transaction, and raise the "PartResized" {@link DiagramEvent}.
* @this {ResizingTool}
*/
ResizingTool.prototype.doMouseUp = function() {
  var diagram = this.diagram;
  if (this.isActive && diagram !== null) {
    var minsz = this._effectiveMinSize;
    var maxsz = this._effectiveMaxSize;
    var cellsz = this._effectiveCellSize;
    var locpt = this._adornedObject.getLocalPoint(diagram.lastInput.documentPoint, Util.tempPoint());
    var stretch = this._adornedObject.geometryStretch;
    if (stretch === GraphObject.Default)
      stretch = this._adornedObject._geometry._defaultStretch;
    var reshape = !(stretch === GraphObject.Uniform || stretch === GraphObject.UniformToFill || diagram.lastInput.shift);
    var newr = this.computeResize(locpt, this._handle.alignment, minsz, maxsz, cellsz, reshape);
    this.resize(newr);
    Util.freePoint(locpt);

    diagram.invalidateDocumentBounds();
    // set the TransactionResult before raising event, in case it changes the result or cancels the tool
    this.transactionResult = this.name;
    diagram.raiseDiagramEvent('PartResized', this._adornedObject, this._originalDesiredSize);
  }
  this.stopTool();
};

/**
* Change the size of the selected part's {@link Part#resizeObject} to have the given bounds.
* This modifies its {@link GraphObject#desiredSize} and maybe its {@link Part#location}.
* <p/>
* This method may be overridden.
* @expose
* @this {ResizingTool}
* @param {Rect} newr
*/
ResizingTool.prototype.resize = function(newr) {
  //Debug.trace(newr.toString());
  var diagram = this.diagram;
  if (diagram === null) return;
  // calculate new location
  var part = this._adornedObject.part;
  var spot = part.locationSpot;
  var pos = part.position.copy();

  var ob = this._adornedObject.naturalBounds.copy();
  var angle = this._adornedObject.getDocumentAngle();
  var sc = this._adornedObject.getDocumentScale();

  if (angle >= 360) angle -= 360;
  else if (angle < 0) angle += 360;

  var radAngle = Math.PI * angle / 180;
  var angleCos = Math.cos(radAngle);
  var angleSin = Math.sin(radAngle);

  var deltaWidth = newr.width - ob.width;
  var deltaHeight = newr.height - ob.height;

  var angleRight = (angle > 270 || angle < 90) ? 1 : 0;
  var angleBottom = (angle > 0 && angle < 180) ? 1 : 0;
  var angleLeft = (angle > 90 && angle < 270) ? 1 : 0;
  var angleTop = (angle > 180 && angle < 360) ? 1 : 0;

  pos.x += sc * ((newr.x + deltaWidth * angleLeft) * angleCos - (newr.y + deltaHeight * angleBottom) * angleSin);
  pos.y += sc * ((newr.x + deltaWidth * angleTop) * angleSin + (newr.y + deltaHeight * angleLeft) * angleCos);


  this._adornedObject.desiredSize = newr.size;
  part.ensureBounds();
  part.move(pos);

  diagram.requestUpdate();
};

/**
* Given a {@link Spot} in the original bounds of the object being resized and a new {@link Point},
* compute the new {@link Rect}.
* <p/>
* This method may be overridden.
* @expose
* @this {ResizingTool}
* @param {Point} newPoint a Point in local coordinates.
* @param {Spot} spot the alignment spot of the handle being dragged.
* @param {Size} min the result of the call to {@link #computeMinSize}.
* @param {Size} max the result of the call to {@link #computeMaxSize}.
* @param {Size} cell the result of the call to {@link #computeCellSize}.
* @param {boolean} reshape true if the new size may change the aspect ratio from that of the natural bounds of the {@link #adornedObject}.
* @return {Rect}
*/
ResizingTool.prototype.computeResize = function(newPoint, spot, min, max, cell, reshape) {
  if (spot.isNoSpot()) spot = Spot.Center;

  var origRect = this._adornedObject.naturalBounds;
  var left = origRect.x;
  var top = origRect.y;
  var right = origRect.x + origRect.width;
  var bottom = origRect.y + origRect.height;

  var oldratio = 1;
  if (!reshape) {
    var oldw = origRect.width;
    var oldh = origRect.height;
    if (oldw <= 0) oldw = 1;
    if (oldh <= 0) oldh = 1;
    oldratio = oldh / oldw;
  }

  var gridpt = Util.tempPoint();
  Geo.findNearestInfiniteGridPoint(newPoint.x, newPoint.y, left, top, cell.width, cell.height, gridpt);

  var newRect = origRect.copy();
  if (spot.x <= 0) {  // left
    if (spot.y <= 0) {  // top-left
      newRect.x = Math.max(gridpt.x, right - max.width);
      newRect.x = Math.min(newRect.x, right - min.width);
      newRect.width = Math.max(right - newRect.x, min.width);

      newRect.y = Math.max(gridpt.y, bottom - max.height);
      newRect.y = Math.min(newRect.y, bottom - min.height);
      newRect.height = Math.max(bottom - newRect.y, min.height);

      if (!reshape) {
        var newratio = newRect.height / newRect.width;
        if (oldratio < newratio) {
          newRect.height = oldratio * newRect.width;
          newRect.y = bottom - newRect.height;
        } else {
          newRect.width = newRect.height / oldratio;
          newRect.x = right - newRect.width;
        }
      }
    } else if (spot.y >= 1) {  // bottom-left
      newRect.x = Math.max(gridpt.x, right - max.width);
      newRect.x = Math.min(newRect.x, right - min.width);
      newRect.width = Math.max(right - newRect.x, min.width);

      newRect.height = Math.max(Math.min(gridpt.y - top, max.height), min.height);

      if (!reshape) {
        var newratio = newRect.height / newRect.width;
        if (oldratio < newratio) {
          newRect.height = oldratio * newRect.width;
        } else {
          newRect.width = newRect.height / oldratio;
          newRect.x = right - newRect.width;
        }
      }
    } else {  // middle-left
      newRect.x = Math.max(gridpt.x, right - max.width);
      newRect.x = Math.min(newRect.x, right - min.width);
      newRect.width = right - newRect.x;

      if (!reshape) {
        var newratio = newRect.height / newRect.width;
        newRect.height = oldratio * newRect.width;
        newRect.y = top + 0.5 * ((bottom - top) - newRect.height);
      }
    }
  } else if (spot.x >= 1) {  // right
    if (spot.y <= 0) {  // top-right
      newRect.width = Math.max(Math.min(gridpt.x - left, max.width), min.width);

      newRect.y = Math.max(gridpt.y, bottom - max.height);
      newRect.y = Math.min(newRect.y, bottom - min.height);
      newRect.height = Math.max(bottom - newRect.y, min.height);

      if (!reshape) {
        var newratio = newRect.height / newRect.width;
        if (oldratio < newratio) {
          newRect.height = oldratio * newRect.width;
          newRect.y = bottom - newRect.height;
        } else {
          newRect.width = newRect.height / oldratio;
        }
      }
    } else if (spot.y >= 1) {  // bottom-right
      newRect.width = Math.max(Math.min(gridpt.x - left, max.width), min.width);
      newRect.height = Math.max(Math.min(gridpt.y - top, max.height), min.height);

      if (!reshape) {
        var newratio = newRect.height / newRect.width;
        if (oldratio < newratio) {
          newRect.height = oldratio * newRect.width;
        } else {
          newRect.width = newRect.height / oldratio;
        }
      }
    } else {  // middle-right
      newRect.width = Math.max(Math.min(gridpt.x - left, max.width), min.width);

      if (!reshape) {
        var newratio = newRect.height / newRect.width;
        newRect.height = oldratio * newRect.width;
        newRect.y = top + 0.5 * ((bottom - top) - newRect.height);
      }
    }
  } else {  // middle-X
    if (spot.y <= 0) {  // top-middle
      newRect.y = Math.max(gridpt.y, bottom - max.height);
      newRect.y = Math.min(newRect.y, bottom - min.height);
      newRect.height = bottom - newRect.y;

      if (!reshape) {
        var newratio = newRect.height / newRect.width;
        newRect.width = newRect.height / oldratio;
        newRect.x = left + 0.5 * ((right - left) - newRect.width);
      }
    } else if (spot.y >= 1) {  // bottom-middle
      newRect.height = Math.max(Math.min(gridpt.y - top, max.height), min.height);

      if (!reshape) {
        var newratio = newRect.height / newRect.width;
        newRect.width = newRect.height / oldratio;
        newRect.x = left + 0.5 * ((right - left) - newRect.width);
      }
    } else {
      // handle is in the middle-middle -- don't do anything
    }
  }
  Util.freePoint(gridpt);
  return newRect;
};

/**
* The effective minimum resizing size is the maximum of {@link #minSize} and the
* {@link #adornedObject}'s {@link GraphObject#minSize}.
* <p/>
* This method may be overridden.
* This is called once when the tool is activated.
* @expose
* @this {ResizingTool}
* @return {Size}
*/
ResizingTool.prototype.computeMinSize = function() {
  var msz = this._adornedObject.minSize.copy();
  var sz = this.minSize;
  if (!isNaN(sz.width) && sz.width > msz.width) msz.width = sz.width;
  if (!isNaN(sz.height) && sz.height > msz.height) msz.height = sz.height;
  return msz;
};

/**
* The effective maximum resizing size is the minimum of the {@link #maxSize} and the
* {@link #adornedObject}'s {@link GraphObject#maxSize}.
* <p/>
* This method may be overridden.
* This is called once when the tool is activated.
* @expose
* @this {ResizingTool}
* @return {Size}
*/
ResizingTool.prototype.computeMaxSize = function() {
  var msz = this._adornedObject.maxSize.copy();
  var sz = this.maxSize;
  if (!isNaN(sz.width) && sz.width < msz.width) msz.width = sz.width;
  if (!isNaN(sz.height) && sz.height < msz.height) msz.height = sz.height;
  return msz;
};

/**
* The size should be a multiple of the value returned by this method.
* <p/>
* This method may be overridden.
* This is called once when the tool is activated.
* @expose
* @this {ResizingTool}
* @return {Size}
*/
ResizingTool.prototype.computeCellSize = function() {
  var csz = new Size(NaN, NaN);
  var part = this._adornedObject.part;
  if (part) {  // any information on the Part takes precedence
    var sz = part.resizeCellSize;
    if (!isNaN(sz.width) && sz.width > 0) csz.width = sz.width;
    if (!isNaN(sz.height) && sz.height > 0) csz.height = sz.height;
  }

  //??? skip looking for snappers

  var sz = this.cellSize; // look at this ResizingTool's cell property
  if (isNaN(csz.width) && !isNaN(sz.width) && sz.width > 0) csz.width = sz.width;
  if (isNaN(csz.height) && !isNaN(sz.height) && sz.height > 0) csz.height = sz.height;

  // maybe need to look at the draggingTool's cell property or the diagram's background grid
  var diagram = this.diagram;
  if ((isNaN(csz.width) || isNaN(csz.height)) && diagram) {
    var tool = diagram.toolManager.draggingTool;
    if (tool !== null && tool.isGridSnapEnabled) {
      sz = tool.gridSnapCellSize;
      if (isNaN(csz.width) && !isNaN(sz.width) && sz.width > 0) csz.width = sz.width;
      if (isNaN(csz.height) && !isNaN(sz.height) && sz.height > 0) csz.height = sz.height;
    }

    var backgrid = diagram.grid;
    if (backgrid !== null && backgrid.visible && this.isGridSnapEnabled) {
      sz = backgrid.gridCellSize;
      if (isNaN(csz.width) && !isNaN(sz.width) && sz.width > 0) csz.width = sz.width;
      if (isNaN(csz.height) && !isNaN(sz.height) && sz.height > 0) csz.height = sz.height;
    }
  }

  // finally, disallow zero and default to 1
  if (isNaN(csz.width) || csz.width === 0 || csz.width === Infinity) csz.width = 1;
  if (isNaN(csz.height) || csz.height === 0 || csz.height === Infinity) csz.height = 1;
  return csz;
};


/**
* Gets or sets the minimum size to which the user can resize.
* The effective minimum size is the maximum of this value and the {@link GraphObject#minSize},
* independently in each direction.
* <p/>
* The default value is 1 x 1.
* Any new value must be of type Size; the width and height must not be NaN.
* Setting this property does not raise any events.
* @name ResizingTool#minSize
* @function.
* @return {Size}
*/
/** @type {Size} */
ResizingTool.prototype.minSize;
Util.exportProperty(ResizingTool, 'minSize', ResizingTool.prototype.minSize);
Util.defineProperty(ResizingTool, {minSize: 'minSize'},
  /** @this {ResizingTool} */
  function() { return this._minSize; },
  /** @this {ResizingTool} */
  function(val) {
    var old = this._minSize;
    if (!old.equals(val)) {
      if (Debug) Util.checkClass(val, Size, ResizingTool, 'minSize');
      if (isNaN(val.width)) val.width = 0;
      if (isNaN(val.height)) val.height = 0;
      this._minSize.assign(val);
    }
  }
);

/**
* Gets or sets the maximum size to which the user can resize.
* The effective maximum size is the minimum of this value and the {@link GraphObject#maxSize},
* independently in each direction.
* <p/>
* The default value is 9999 x 9999.
* Any new value must be of type Size; the width and height must not be NaN.
* Setting this property does not raise any events.
* @name ResizingTool#maxSize
* @function.
* @return {Size}
*/
/** @type {Size} */
ResizingTool.prototype.maxSize;
Util.exportProperty(ResizingTool, 'maxSize', ResizingTool.prototype.maxSize);
Util.defineProperty(ResizingTool, {maxSize: 'maxSize'},
  /** @this {ResizingTool} */
  function() { return this._maxSize; },
  /** @this {ResizingTool} */
  function(val) {
    var old = this._maxSize;
    if (!old.equals(val)) {
      if (Debug) Util.checkClass(val, Size, ResizingTool, 'maxSize');
      if (isNaN(val.width)) val.width = Infinity;
      if (isNaN(val.height)) val.height = Infinity;
      this._maxSize.assign(val);
    }
  }
);

/**
* Gets or sets the width and height multiples with which the user must resize.
* The effective cell size is computed by first looking at the {@link AdornedPart}'s {@link Part#resizeCellSize}.
* If either or both of its width and height are NaN, it will use this property, <code>cellSize</code>.
* If either or both of this property's width and height are NaN, it will
* consider the {@link DraggingTool#gridSnapCellSize} and the {@link Diagram#grid}'s {@link Panel#gridCellSize}.
* <p/>
* The default value is NaN x NaN.
* Setting this property does not raise any events.
* @name ResizingTool#cellSize
* @function.
* @return {Size}
*/
/** @type {Size} */
ResizingTool.prototype.cellSize;
Util.exportProperty(ResizingTool, 'cellSize', ResizingTool.prototype.cellSize);
Util.defineProperty(ResizingTool, {cellSize: 'cellSize'},
  /** @this {ResizingTool} */
  function() { return this._cellSize; },
  /** @this {ResizingTool} */
  function(val) {
    var old = this._cellSize;
    if (!old.equals(val)) {
      if (Debug) Util.checkClass(val, Size, ResizingTool, 'cellSize');
      this._cellSize.assign(val);
    }
  }
);

/**
* Gets or sets whether the {@link ResizingTool} snaps object sizes to the diagram's background grid during the resize.
* By default this property is false.
* Setting this property does not raise any events.
* @name ResizingTool#isGridSnapEnabled
* @function.
* @return {boolean}
*/
/** @type {boolean} */
ResizingTool.prototype.isGridSnapEnabled;
Util.exportProperty(ResizingTool, 'isGridSnapEnabled', ResizingTool.prototype.isGridSnapEnabled);
Util.defineProperty(ResizingTool, { isGridSnapEnabled: 'isGridSnapEnabled' },
  /** @this {ResizingTool} */
  function() { return this._isGridSnapEnabled; },
  /** @this {ResizingTool} */
  function(val) {
    var old = this._isGridSnapEnabled;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', ResizingTool, 'isGridSnapEnabled');
      this._isGridSnapEnabled = val;
    }
  }
);

/**
* Gets the {@link Size} that was the original value of the {@link GraphObject#desiredSize}
* of the element that is being resized.
* @name ResizingTool#originalDesiredSize
* @function.
* @return {Size}
* @since 1.1
*/
/** @type {Size} */
ResizingTool.prototype.originalDesiredSize;
Util.exportProperty(ResizingTool, 'originalDesiredSize', ResizingTool.prototype.originalDesiredSize);
Util.defineReadOnlyProperty(ResizingTool, { originalDesiredSize: 'originalDesiredSize' },
  /** @this {ResizingTool} */
  function() { return this._originalDesiredSize; }
);

/**
* Gets the {@link Point} that was the original value of the {@link Part#location}
* of the Part that is being resized.
* @name ResizingTool#originalLocation
* @function.
* @return {Point}
* @since 1.1
*/
/** @type {Point} */
ResizingTool.prototype.originalLocation;
Util.exportProperty(ResizingTool, 'originalLocation', ResizingTool.prototype.originalLocation);
Util.defineReadOnlyProperty(ResizingTool, { originalLocation: 'originalLocation' },
  /** @this {ResizingTool} */
  function() { return this._originalLocation; }
);

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
RotatingTool
*/

/**
* You do not normally need to create an instance of this tool
* because one already exists as the {@link ToolManager#rotatingTool}, which you can modify.
* @constructor
* @extends Tool
* @category Tool
* @class
* The RotatingTool is used to interactively change the {@link GraphObject#angle} of a {@link GraphObject}.
* <p/>
* This tool allows the user to rotate the {@link Part#rotateObject} of the selected {@link Part}.
* Normally this works with {@link Part}s or {@link Node}s; it does not make sense for {@link Link}s.
* The {@link Part} must be {@link Part#rotatable}, which is false by default.
* <p/>
* You can limit the permitted angles by setting {@link #snapAngleMultiple} and {@link #snapAngleEpsilon}.
* For example, if you want to permit only angles that are multiples of 90 degrees,
* set {@link #snapAngleMultiple} to 90 and {@link #snapAngleEpsilon} to 45.
* <p/>
* This tool makes use of an {@link Adornment} that includes a rotation handle.
* It is shown when the selected {@link Part} is {@link Part#rotatable}.
* The rotate handle is normally a copy of {@link RotatingTool#handleArchetype}.
* unless you specify a custom rotate Adornment by setting {@link Part#rotateAdornmentTemplate}.
* <p/>
* This tool conducts a transaction while the tool is active.
* A successful rotation will result in a "PartRotated" {@link DiagramEvent} and a "Rotating" transaction.
*/
function RotatingTool() {
  if (arguments.length > 0) {
    Util.throwError('RotatingTool constructor cannot take any arguments.');
  }
  Tool.call(this);
  // external properties
  this.name = 'Rotating';
  /** @type {number} */
  this._snapAngleMultiple = 45;
  /** @type {number} */
  this._snapAngleEpsilon = 2;

  // internal state
  /** @type {GraphObject} */
  this._adornedObject = null;

  var h = new Shape();
  h.figure = 'Ellipse';
  h.desiredSize = Geo.SixSize;
  h.fill = 'yellow';
  h.stroke = 'black';
  h.strokeWidth = 1;
  h.cursor = 'pointer';
  /** @type {GraphObject} */
  this._handleArchetype = h;

  /** @type {GraphObject} */
  this._handle = null;
  /** @type {number} */
  this._originalAngle = 0;
  /** @type {Point} */
  this._rotationPoint = new Point();
}

Util.publish('RotatingTool', RotatingTool);

Util.inherit(RotatingTool, Tool);

/**
* Show an {@link Adornment} with a rotate handle at a point to the side of the adorned object
* if the part is selected and visible and if {@link Part#canRotate}() is true.
* <p/>
* This method may be overridden.
* @this {RotatingTool}
* @param {Part} part the part.
*/
RotatingTool.prototype.updateAdornments = function(part) {
  if (part === null || part instanceof Link) return;  // this tool never applies to Links
  var adornment = null;
  if (part.isSelected) {
    var selelt = part.rotateObject;
    if (part.canRotate() && selelt !== null && part.actualBounds.isReal() && part.isVisible() && selelt.isVisibleObject() && selelt.actualBounds.isReal()) {
      adornment = part.findAdornment(this.name);
      if (adornment === null) {
        adornment = this.makeAdornment(selelt);
        adornment.isStandard = true;
      }
      if (adornment !== null) {
        adornment.angle = selelt.getDocumentAngle();

        var elem = null;
        var rotateSpot = null;
        if (selelt === part || selelt === part.locationObject) {
          elem = part.locationObject;
          rotateSpot = part.locationSpot;
        } else {
          elem = selelt;
          rotateSpot = Spot.Center;
        }

        // Get the point being rotated about in coordinates of the locationObject
        var ns = elem.naturalBounds;
        var rotatePoint = Util.tempPointAt(ns.width * rotateSpot.x + rotateSpot.offsetX, ns.height * rotateSpot.y + rotateSpot.offsetY);

        // Transform the rotation point to coordinates of the rotationObject
        var parent = elem;
        while (parent !== null && parent !== selelt) {
          parent.transform.transformPoint(rotatePoint);
          parent = parent.panel;
        }

        // place the handle 50 pixels to the right
        // of the node (or the location point, whichever is furthest to the right) and
        // at the same vertical position as the spot being rotated about
        var verticalOffset = rotatePoint.y;
        var horizontalOffset = Math.max(rotatePoint.x - selelt.naturalBounds.width, 0);

        adornment.locationSpot = Spot.Center;
        var temploc = Util.tempPoint();
        adornment.location = selelt.getDocumentPoint(new Spot(1, 0, 50 + horizontalOffset, verticalOffset), temploc);
        Util.freePoint(temploc);

        Util.freePoint(rotatePoint);
      }
    }
    part.addAdornment(this.name, adornment);
  } else {
    part.removeAdornment(this.name);
  }
};

/**
* @ignore
* Create and return an {@link Adornment} that lets the user grab a handle to rotate the selected part.
* @expose
* @this {RotatingTool}
* @param {GraphObject} selelt the {@link GraphObject} being rotated.
* @return {Adornment}
*/
RotatingTool.prototype.makeAdornment = function(selelt) {
  var adornment = null;
  var template = selelt.part.rotateAdornmentTemplate;
  if (template === null) {
    adornment = new Adornment();
    adornment.type = Panel.Position;
    var h = this.handleArchetype;
    if (h !== null) {
      // add a single handle for rotation
      adornment.add(h.copy());
    }
  } else {
    template.freezeBindings();
    adornment = template.copy();
    if (!(adornment instanceof Adornment)) return null;
  }
  adornment.category = this.name;
  adornment.adornedObject = selelt;
  return adornment;
};

/**
* Gets or sets a small GraphObject that is copied as a rotation handle for the selected part.
* By default this is a {@link Shape} that is a small yellow circle.
* Setting this property does not raise any events.
* <p/>
* Here is an example of changing the default handle to be green "X":
* <code><br/>
* &nbsp;&nbsp;myDiagram.toolManager.rotatingTool.handleArchetype =<br/>
* &nbsp;&nbsp;&nbsp;&nbsp;$(go.Shape, "XLine",<br/>
* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ width: 8, height: 8, stroke: "green", fill: "transparent" });<br/>
* </code>
* <p/>
* This property is ignored when a custom rotating Adornment is specified as the {@link Part#rotateAdornmentTemplate}.
* @name RotatingTool#handleArchetype
* @function.
* @return {GraphObject}
*/
/** @type {GraphObject} */
RotatingTool.prototype.handleArchetype;
Util.defineProperty(RotatingTool, { handleArchetype: 'handleArchetype' },
  /** @this {RotatingTool} */
  function() { return this._handleArchetype; },
  /** @this {RotatingTool} */
  function(val) {
    if (val) Util.checkClass(val, GraphObject, RotatingTool, 'handleArchetype');
    this._handleArchetype = val;
  }
);

/**
* Gets the {@link GraphObject} that is the tool handle being dragged by the user.
* This will be contained by an {@link Adornment} whose category is "RotatingTool".
* Its {@link Adornment#adornedObject} is the same as the {@link #adornedObject}.
* @name RotatingTool#handle
* @function.
* @return {GraphObject}
*/
/** @type {GraphObject} */
RotatingTool.prototype.handle;
Util.defineReadOnlyProperty(RotatingTool, {handle: 'handle'},
  /** @this {RotatingTool} */
  function() { return this._handle; }
);

/**
* Gets the {@link GraphObject} that is being rotated.
* This may be the same object as the selected {@link Part} or it may be contained within that Part.
* <p>
* This property is also settable, but should only be set when overriding functions
* in RotatingTool, and not during normal operation.
* @name RotatingTool#adornedObject
* @function.
* @return {GraphObject}
*/
/** @type {GraphObject} */
RotatingTool.prototype.adornedObject;
Util.defineProperty(RotatingTool, {adornedObject: 'adornedObject'},
  /** @this {RotatingTool} */
  function() { return this._adornedObject; },
  /** @this {RotatingTool} */
  function(val) {
    if (val) Util.checkClass(val, GraphObject, RotatingTool, 'adornedObject');
    this._adornedObject = val;
  }
);

/**
* This tool may run when there is a mouse-down event on a rotate handle,
* the diagram is not read-only and it allows rotation,
* the left mouse button is being used,
* and this tool's adornment's rotate handle is at the current mouse point.
* <p/>
* This method may be overridden.
* @this {RotatingTool}
* @return {boolean}
*/
RotatingTool.prototype.canStart = function() {
  if (!this.isEnabled) return false;
  var diagram = this.diagram;
  if (diagram === null || diagram.isReadOnly) return false;
  if (!diagram.allowRotate) return false;
  if (!diagram.lastInput.left) return false;

  var h = this.findToolHandleAt(diagram.firstInput.documentPoint, this.name);
  if (h !== null) return true; else return false;
};

/**
* Capture the mouse, remember the original {@link GraphObject#angle},
* and start a transaction.
* @this {RotatingTool}
*/
RotatingTool.prototype.doActivate = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  this._handle = this.findToolHandleAt(diagram.firstInput.documentPoint, this.name);
  if (this._handle === null) return;

  this._adornedObject = this._handle.part.adornedObject;
  var part = this._adornedObject.part;
  var locationObject = part.locationObject;
  if (this._adornedObject === part || this._adornedObject === locationObject) {
    this._rotationPoint = locationObject.getDocumentPoint(part.locationSpot);
  } else {
    this._rotationPoint = this._adornedObject.getDocumentPoint(Spot.Center);
  }
  this._originalAngle = this._adornedObject.angle;
  diagram.isMouseCaptured = true;
  this.startTransaction(this.name);
  this.isActive = true;
};

/**
* Stop the current transaction and release the mouse.
* @this {RotatingTool}
*/
RotatingTool.prototype.doDeactivate = function() {
  var diagram = this.diagram;
  if (diagram === null) return;

  this.stopTransaction();
  this._handle = null;
  this._adornedObject = null;
  diagram.isMouseCaptured = false;
  this.isActive = false;
};

/**
* Restore the original {@link GraphObject#angle} of the adorned object.
* @this {RotatingTool}
*/
RotatingTool.prototype.doCancel = function() {
  this.rotate(this._originalAngle);
  this.stopTool();
};

/**
* Call {@link #rotate} with a new angle determined by the current mouse point.
* This determines the new angle by calling {@link #computeRotate}.
* @this {RotatingTool}
*/
RotatingTool.prototype.doMouseMove = function() {
  var diagram = this.diagram;
  if (this.isActive && diagram !== null) {
    var newangle = this.computeRotate(diagram.lastInput.documentPoint);
    this.rotate(newangle);
  }
};

/**
* Call {@link #rotate} with an angle based on the most recent mouse point,
* commit the transaction, and raise the "PartRotated" {@link DiagramEvent}.
* @this {RotatingTool}
*/
RotatingTool.prototype.doMouseUp = function() {
  var diagram = this.diagram;
  if (this.isActive && diagram !== null) {
    var newangle = this.computeRotate(diagram.lastInput.documentPoint);
    this.rotate(newangle);

    diagram.invalidateDocumentBounds();
    // set the TransactionResult before raising event, in case it changes the result or cancels the tool
    this.transactionResult = this.name;
    diagram.raiseDiagramEvent('PartRotated', this._adornedObject, this._originalAngle);
  }
  this.stopTool();
};

/**
* Change the angle of the selected part's {@link Part#rotateObject}.
* This modifies its {@link GraphObject#angle}.
* <p/>
* This method may be overridden.
* @expose
* @this {RotatingTool}
* @param {number} newangle in degrees.
*/
RotatingTool.prototype.rotate = function(newangle) {
  Util.checkRealNumber(newangle, RotatingTool, 'rotate:newangle');
  if (this._adornedObject !== null) {
    this._adornedObject.angle = newangle;
    this.diagram.requestUpdate();
  }
};

/**
* Compute the new angle given a point.
* <p/>
* If the angle is close (by {@link #snapAngleEpsilon} degrees)
* to a multiple of {@link #snapAngleMultiple} degrees,
* make it exactly that multiple.
* <p/>
* This method may be overridden.
* @expose
* @this {RotatingTool}
* @param {Point} newPoint in document coordinates.
* @return {number} the new angle, in degrees.
*/
RotatingTool.prototype.computeRotate = function(newPoint) {
  // the apparent angle from RotationPoint to newPoint
  var a = this._rotationPoint.directionPoint(newPoint);

  // account for the angle of the rotateObject's panel, if it exists
  var parent = this._adornedObject.panel;
  if (parent) {
    a -= parent.getDocumentAngle();
    if (a >= 360) a -= 360;
    else if (a < 0) a += 360;
  }

  var interval = Math.min(Math.abs(this.snapAngleMultiple), 180);
  var epsilon = Math.min(Math.abs(this.snapAngleEpsilon), interval / 2);
  // if it's close to a multiple of INTERVAL degrees, make it exactly so
  if (!this.diagram.lastInput.shift && interval > 0 && epsilon > 0) {
    if (a % interval < epsilon) {
      a = Math.floor(a / interval) * interval;
    } else if (a % interval > interval - epsilon) {
      a = (Math.floor(a / interval) + 1) * interval;
    }
  }

  var ang = a;
  if (ang >= 360) ang -= 360;
  else if (ang < 0) ang += 360;
  return ang;
};

/**
* Gets or sets the preferred angles for the selected object.
* <p/>
* The default value is 45 degrees, meaning that angles that are multiples
* of 45 degrees are automatically preferred, if the actual angle is
* close to that multiple.
* The closeness is determined by the {@link #snapAngleEpsilon} property.
* A value of zero for {@link #snapAngleMultiple} results in no snapping at all.
* Setting this property does not raise any events.
* @name RotatingTool#snapAngleMultiple
* @function.
* @return {number}
*/
/** @type {number} */
RotatingTool.prototype.snapAngleMultiple;
Util.exportProperty(RotatingTool, 'snapAngleMultiple', RotatingTool.prototype.snapAngleMultiple);
Util.defineProperty(RotatingTool, {snapAngleMultiple: 'snapAngleMultiple'},
  /** @this {RotatingTool} */
  function() { return this._snapAngleMultiple; },
  /** @this {RotatingTool} */
  function(val) {
    var old = this._snapAngleMultiple;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'number', RotatingTool, 'snapAngleMultiple');
      this._snapAngleMultiple = val;
    }
  }
);

/**
* Gets or sets the the closeness to a desired angle at which the angle is "snapped to".
* <p/>
* The default value is 2 degrees, meaning that any angle within 2 degrees
* of a multiple of the {@link #snapAngleMultiple} automatically
* snaps to that multiple.
* Values are limited to half of the {@link #snapAngleMultiple};
* such values restrict user selected angles only to exact multiples of
* {@link #snapAngleMultiple} -- no other angles between them.
* Setting this property does not raise any events.
* @name RotatingTool#snapAngleEpsilon
* @function.
* @return {number}
*/
/** @type {number} */
RotatingTool.prototype.snapAngleEpsilon;
Util.exportProperty(RotatingTool, 'snapAngleEpsilon', RotatingTool.prototype.snapAngleEpsilon);
Util.defineProperty(RotatingTool, {snapAngleEpsilon: 'snapAngleEpsilon'},
  /** @this {RotatingTool} */
  function() { return this._snapAngleEpsilon; },
  /** @this {RotatingTool} */
  function(val) {
    var old = this._snapAngleEpsilon;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'number', RotatingTool, 'snapAngleEpsilon');
      this._snapAngleEpsilon = val;
    }
  }
);

/**
* Gets the angle that was the original value of the {@link GraphObject#angle}
* of the GraphObject that is being rotated.
* @name RotatingTool#originalAngle
* @function.
* @return {number}
* @since 1.1
*/
/** @type {number} */
RotatingTool.prototype.originalAngle;
Util.exportProperty(RotatingTool, 'originalAngle', RotatingTool.prototype.originalAngle);
Util.defineReadOnlyProperty(RotatingTool, { originalAngle: 'originalAngle' },
  /** @this {RotatingTool} */
  function() { return this._originalAngle; }
);

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
ClickSelectingTool
ActionTool
ClickCreatingTool
ContextMenuTool
DragSelectingTool
PanningTool
*/

/**
* You do not normally need to create an instance of this tool
* because one already exists as the {@link ToolManager#clickSelectingTool}.
* @constructor
* @extends Tool
* @category Tool
* @class
* The ClickSelectingTool selects and deselects {@link Part}s when there is a click.
* It does this by calling {@link Tool#standardMouseSelect}.
* It is also responsible for handling and dispatching click events on {@link GraphObject}s
* by calling {@link Tool#standardMouseClick}.
* <p/>
* This tool is a standard mouse-up tool, the {@link ToolManager#clickSelectingTool}.
* <p/>
* This tool does not utilize any {@link Adornment}s or tool handles.
* This tool does not modify the model or conduct any transaction.
*/
function ClickSelectingTool() {
  if (arguments.length > 0) {
    Util.throwError('ClickSelectingTool constructor cannot take any arguments.');
  }
  Tool.call(this);
  this.name = 'ClickSelecting';
}

Util.publish('ClickSelectingTool', ClickSelectingTool);

Util.inherit(ClickSelectingTool, Tool);

/**
* This tool can run whenever a click occurs.
* <p/>
* This method may be overridden.
* @this {ClickSelectingTool}
* @return {boolean}
*/
ClickSelectingTool.prototype.canStart = function() {
  if (!this.isEnabled) return false;
  var diagram = this.diagram;
  if (diagram === null) return false;
  // don't check for  !diagram.allowSelect  any more,
  // to always support click events on GraphObjects
  if (this.isBeyondDragSize()) return false;
  return true;
};

/**
* Upon a click, this calls {@link Tool#standardMouseSelect} to change the {@link Diagram#selection} collection,
* then calls {@link Tool#standardMouseClick} to perform the normal click behaviors,
* and then stops this tool.
* @this {ClickSelectingTool}
*/
ClickSelectingTool.prototype.doMouseUp = function() {
  if (this.isActive) {
    this.standardMouseSelect();
    this.standardMouseClick();
  }
  this.stopTool();
};


/**
* You do not normally need to create an instance of this tool
* because one already exists as the {@link ToolManager#actionTool}.
* @constructor
* @extends Tool
* @category Tool
* @class
* The ActionTool is responsible for handling and dispatching mouse events on {@link GraphObject}s
* that have {@link GraphObject#isActionable} set to true.
* This is how one implements "controls", such as buttons or sliders or knobs, as {@link GraphObject}s
* that can be inside {@link Part}s without interfering with the standard tool behaviors.
* <p/>
* This tool allows individual GraphObjects (usually Panels) to handle mouse-down-move-up events without
* having to define new {@link Tool}s.
* It does this by calling {@link GraphObject#actionDown}, {@link GraphObject#actionMove}, {@link GraphObject#actionUp},
* and {@link GraphObject#actionCancel} on objects that have {@link GraphObject#isActionable} set to true.
* <p/>
* This tool is a standard mouse-down tool, the {@link ToolManager#actionTool}.
* <p/>
* This tool does not utilize any {@link Adornment}s or tool handles.
* This tool does not modify the model or conduct any transaction, although the actions that this invokes may do so.
*/
function ActionTool() {
  if (arguments.length > 0) {
    Util.throwError('ActionTool constructor cannot take any arguments.');
  }
  Tool.call(this);
  this.name = 'Action';
  /** @type {GraphObject} */
  this._actObj = null;
}

Util.publish('ActionTool', ActionTool);

Util.inherit(ActionTool, Tool);

/**
* This tool can run when there is a mouse-down on an object with {@link GraphObject#isActionable} true
* or if the object is within a {@link Panel} that "isActionable".
* <p/>
* This method may be overridden.
* @this {ActionTool}
* @return {boolean}
*/
ActionTool.prototype.canStart = function() {
  if (!this.isEnabled) return false;
  var diagram = this.diagram;
  if (diagram === null) return false;
  // don't check for !diagram.allowSelect
  var e = diagram.lastInput;
  var curobj = diagram.findObjectAt(e.documentPoint,
    function(x) {
      while (x.panel !== null) {
        if (x.isActionable) return x;
        x = x.panel;
      }
      return x;
    }, function(x) { return x.isActionable; });
  if (curobj !== null) {
    this._actObj = curobj;
    // ActionTool still needs the plain currentObject in addition
    diagram.currentEnterLeaveObject = diagram.findObjectAt(e.documentPoint, null, null);
    return true;
  }
  return false;
};

/**
* If there is a {@link GraphObject} found with {@link GraphObject#isActionable} set to true,
* call that object's {@link GraphObject#actionDown} event, if it exists.
* @this {ActionTool}
*/
ActionTool.prototype.doMouseDown = function() {
  if (!this.isActive) {
    if (this.canStart()) {
      this.doActivate();
    }
  } else {
    var diagram = this.diagram;
    var e = diagram.lastInput;
    var curobj = this._actObj;
    if (curobj === null) return;
    e.targetObject = curobj;
    if (curobj.actionDown !== null)
      curobj.actionDown(e, curobj);
  }
};

/**
* If this tool is active call {@link GraphObject#actionMove}, if it exists, on the active object.
* @this {ActionTool}
*/
ActionTool.prototype.doMouseMove = function() {
  if (this.isActive) {
    var diagram = this.diagram;
    var e = diagram.lastInput;
    var curobj = this._actObj;
    if (curobj === null) return;
    e.targetObject = curobj;
    if (curobj.actionMove !== null)
      curobj.actionMove(e, curobj);
  }
};

/**
* Calls the {@link GraphObject#actionUp} event if defined, then effectively calls
* {@link Tool#standardMouseClick} to perform the normal click behaviors,
* and then stops this tool.
* @this {ActionTool}
*/
ActionTool.prototype.doMouseUp = function() {
  if (this.isActive) {
    var diagram = this.diagram;
    var e = diagram.lastInput;
    var curobj = this._actObj;
    if (curobj === null) return;
    e.targetObject = curobj;
    if (curobj.actionUp !== null)
      curobj.actionUp(e, curobj);
    // Do a "click" too, if one is defined
    if (!this.isBeyondDragSize()) {
      this._standardClick(curobj, e, diagram);
    }
  }
  this.stopTool();
};

/**
* Call the {@link GraphObject#actionCancel} event if defined on the current object.
* @this {ActionTool}
*/
ActionTool.prototype.doCancel = function() {
  var diagram = this.diagram;
  if (diagram !== null) {
    var e = diagram.lastInput;
    var curobj = this._actObj;
    if (curobj === null) return;
    e.targetObject = curobj;
    if (curobj.actionCancel !== null)
      curobj.actionCancel(e, curobj);
  }
  this.stopTool();
};

/**
* @ignore
* @this {ActionTool}
*/
ActionTool.prototype.doStop = function() {
  this._actObj = null;
};


/**
* You do not normally need to create an instance of this tool
* because one already exists as the {@link ToolManager#clickCreatingTool}, which you can modify.
* @constructor
* @extends Tool
* @category Tool
* @class
* The ClickCreatingTool lets the user create a node by clicking where they want the new node to be.
* By default a double-click is required to start this tool;
* set {@link #isDoubleClick} to false if you want a single-click to create a node.
* <p/>
* This tool is a standard mouse-up tool, the {@link ToolManager#clickCreatingTool}.
* However, it will not be able to start running unless you have set the
* {@link #archetypeNodeData} property to an object that can be copied and added to the diagram's model.
* <p/>
* This tool does not utilize any {@link Adornment}s or tool handles.
* This tool does conduct a transaction when inserting the new node.
*/
function ClickCreatingTool() {
  if (arguments.length > 0) {
    Util.throwError('ClickCreatingTool constructor cannot take any arguments.');
  }
  Tool.call(this);
  this.name = 'ClickCreating';
  /** @type {Object} */
  this._archetypeNodeData = null;
  /** @type {boolean} */
  this._isDoubleClick = true;
  /** @type {Point} */
  this._firstPoint = new Point(0, 0);
}

Util.publish('ClickCreatingTool', ClickCreatingTool);

Util.inherit(ClickCreatingTool, Tool);

/**
* This tool can run when the diagram is not read-only and supports creating new nodes,
* and when there has been a click (or double-click if {@link #isDoubleClick} is true)
* in the background of the diagram (not on a {@link Part}),
* and {@link #archetypeNodeData} is an object that can be copied and added to the model.
* <p/>
* This method may be overridden.
* @this {ClickCreatingTool}
* @return {boolean}
*/
ClickCreatingTool.prototype.canStart = function() {
  if (!this.isEnabled) return false;

  // gotta have some node data that can be copied
  if (this.archetypeNodeData === null) return false;

  var diagram = this.diagram;

  // heed IsReadOnly & AllowInsert
  if (diagram === null || diagram.isReadOnly || diagram.isModelReadOnly) return false;
  if (!diagram.allowInsert) return false;

  // only works with the left button
  if (!diagram.lastInput.left) return false;

  // the mouse down point needs to be near the mouse up point
  if (this.isBeyondDragSize()) return false;

  // maybe requires double-click; otherwise avoid accidental double-create
  if (this.isDoubleClick) {
    if (diagram.lastInput.clickCount === 1) this._firstPoint = diagram.lastInput.viewPoint.copy();
    if (diagram.lastInput.clickCount !== 2) return false;
    if (this.isBeyondDragSize(this._firstPoint)) return false;
  } else {
    if (diagram.lastInput.clickCount !== 1) return false;
  }

  // don't include the following check when this tool is running modally
  if (diagram.currentTool !== this) {
    // only operates in the background, not on some Part
    var part = diagram.findPartAt(diagram.lastInput.documentPoint, true);
    if (part !== null) return false;
  }

  return true;
};

/**
* Upon a click, call {@link #insertPart} and stop this tool.
* @this {ClickCreatingTool}
*/
ClickCreatingTool.prototype.doMouseUp = function() {
  var diagram = this.diagram;
  if (this.isActive && diagram !== null) {
    this.insertPart(diagram.lastInput.documentPoint);
  }
  this.stopTool();
};

/**
* Create a node by adding a copy of the {@link #archetypeNodeData} object
* to the diagram's model, assign its {@link Part#location}
* to be the given point, and select the new part.
* <p/>
* This starts and commits a transaction and also raises the "PartCreated" {@link DiagramEvent}.
* The actual part that is added to the diagram may be a {@link Part}, a {@link Node},
* or even a {@link Group}, depending on the properties of the {@link #archetypeNodeData}
* and the type of the template that is copied to create the part.
* <p/>
* This method may be overridden, although it is usually much easier to just set {@link #archetypeNodeData}.
* @expose
* @this {ClickCreatingTool}
* @param {Point} loc a Point in document coordinates.
* @return {Part} the newly created Part, or null if it failed.
*/
ClickCreatingTool.prototype.insertPart = function(loc) {
  var diagram = this.diagram;
  if (diagram === null) return null;
  var arch = this.archetypeNodeData;
  if (arch === null) return null;

  this.startTransaction(this.name);
  var part = null;
  if (arch instanceof Part) {
    if (arch.isNodeLike()) {
      arch.freezeBindings();
      part = arch.copy();
      if (part instanceof Part) {
        diagram.add(part);
      }
    }
  } else if (arch !== null) {
    var data = diagram.model.copyNodeData(arch);
    if (Util.isObject(data)) {
      diagram.model.addNodeData(data);
      part = diagram.findPartForData(data);
    }
  }
  if (part instanceof Part) {
    part.location = loc;
    if (diagram.allowSelect) {
      diagram.select(part);  // raises ChangingSelection/Finished
    }
  }

  diagram.invalidateDocumentBounds();
  // set the TransactionResult before raising event, in case it changes the result or cancels the tool
  this.transactionResult = this.name;
  diagram.raiseDiagramEvent('PartCreated', part);
  this.stopTransaction();
  if (part instanceof Part) return part;  // check is need for Closure compiler
  return null;
};

/**
* Gets or sets a data object that will be copied and added to the diagram's model each time this tool executes.
* The default value is null.
* The value must be non-null for this tool to be able to run.
* Setting this property does not raise any events.
* @name ClickCreatingTool#archetypeNodeData
* @function.
* @return {Object}
*/
/** @type {Object} */
ClickCreatingTool.prototype.archetypeNodeData;
Util.exportProperty(ClickCreatingTool, 'archetypeNodeData', ClickCreatingTool.prototype.archetypeNodeData);
Util.defineProperty(ClickCreatingTool, {archetypeNodeData: 'archetypeNodeData'},
  /** @this {ClickCreatingTool} */
  function() { return this._archetypeNodeData; },
  /** @this {ClickCreatingTool} */
  function(val) {
    var old = this._archetypeNodeData;
    if (old !== val) {
      if (val !== null) Util.checkClass(val, Object, ClickCreatingTool, 'archetypeNodeData');
      this._archetypeNodeData = val;
    }
  }
);

/**
* Gets or sets whether a double click rather than a single-click is required
* to insert a new {@link Part} at the mouse-up point.
* The default value is true -- only a double-click will cause a node to be created.
* Setting this property does not raise any events.
* @name ClickCreatingTool#isDoubleClick
* @function.
* @return {boolean}
*/
/** @type {boolean} */
ClickCreatingTool.prototype.isDoubleClick;
Util.exportProperty(ClickCreatingTool, 'isDoubleClick', ClickCreatingTool.prototype.isDoubleClick);
Util.defineProperty(ClickCreatingTool, {isDoubleClick: 'isDoubleClick'},
  /** @this {ClickCreatingTool} */
  function() { return this._isDoubleClick; },
  /** @this {ClickCreatingTool} */
  function(val) {
    var old = this._isDoubleClick;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', ClickCreatingTool, 'isDoubleClick');
      this._isDoubleClick = val;
    }
  }
);


/**
* You do not normally need to create an instance of this tool
* because one already exists as the {@link ToolManager#contextMenuTool}, which you can modify.
* @constructor
* @extends Tool
* @category Tool
* @class
* The ContextMenuTool is used to create and show a context menu.
* It automatically disables any browser context menu.
* <p/>
* Define context menus on individual {@link GraphObject}s by setting {@link GraphObject#contextMenu}.
* Define a context menu for the diagram background by setting {@link Diagram#contextMenu}.
* <p/>
* This tool is a standard mouse-down tool, the {@link ToolManager#contextMenuTool}.
* <p/>
* This tool does not utilize any tool handles.
* This tool does not modify the model or conduct any transaction,
* although any code invoked by context menu commands might do so.
*/
function ContextMenuTool() {
  if (arguments.length > 0) {
    Util.throwError('ContextMenuTool constructor cannot take any arguments.');
  }
  Tool.call(this);
  this.name = 'ContextMenu';
  /** @type {Adornment} */
  this._currentContextMenu = null;

  /** @type {Point} */
  this._mouseDownPoint = new Point();

  // HTML state for the default touch context menu

  /** @type {?Adornment} */
  this._defaultTouchContextMenu = null;
  if (Util.supportsTouch !== true) return;
  this._defaultTouchContextMenu = new Adornment(); // maybe a boolean instead?
  this._defaultButtons = null;
  var tool = this;
  this._toolStopper = function() { tool.stopTool(); };

  if (Util.defaultContextMenuSetup !== false) return;
  var cmLight = document.createElement('div');
  var cmDark = document.createElement('div');

  cmLight.style.cssText =
    'top: 0px;' +
    'z-index:300;' +
    'position: fixed;' +
    'display: none;' +
    'text-align: center;' +
    'left: 25%;' +
    'width: 50%;' +
    'background-color: #F5F5F5;' +
    'padding: 16px;' +
    'border: 16px solid #444;' +
    'border-radius: 10px;' +
    'margin-top: 10px';

  cmDark.style.cssText =
    'z-index:299;' +
    'position: fixed;' +
    'display: none;' +
    'top: 0;' +
    'left: 0;' +
    'width: 100%;' +
    'height: 100%;' +
    'background-color: black;' +
    '-moz-opacity: 0.8;' +
    'opacity:.80;' +
    'filter: alpha(opacity=80);';

  var ns = document.createElement('style');
  document.getElementsByTagName('head')[0].appendChild(ns);

  ns.sheet.insertRule('.defaultCXul { list-style: none; }', 0);
  ns.sheet.insertRule('.defaultCXli {' +
    'font:700 1.5em Helvetica, Arial, sans-serif;' +
    'position: relative;' +
    'min-width: 60px; }', 0);
  ns.sheet.insertRule('.defaultCXa {' +
    'color: #444;' +
    'display: inline-block;' +
    'padding: 4px;' +
    'text-decoration: none;' +
    'margin: 2px;' +
    'border: 1px solid gray;' +
    'border-radius: 10px; }', 0);

  // We don't want the div acting as a context menu to have a (browser) context menu!
  cmLight.addEventListener('contextmenu', function(e) { e.preventDefault(); return false; }, false);
  cmLight.addEventListener('selectstart', function(e) { e.preventDefault(); return false; }, false);
  cmDark.addEventListener('contextmenu', function(e) { e.preventDefault(); return false; }, false);

  if (document.body) {
    document.body.appendChild(cmLight);
    document.body.appendChild(cmDark);
  }

  Util.cmLight = cmLight;
  Util.cmDark = cmDark;
  Util.defaultContextMenuSetup = true;
}

Util.publish('ContextMenuTool', ContextMenuTool);

Util.inherit(ContextMenuTool, Tool);

/**
* Return true if it's a mouse right click that hasn't moved {@link Tool#isBeyondDragSize}
* and that is on a {@link GraphObject} with a {@link GraphObject#contextMenu}.
* This is also true if the mouse right click is in the diagram background
* and the diagram's {@link Diagram#contextMenu} is non-null.
* <p>
* On touch devices, a special default context menu will appear even if no object with a context menu is found.
* <p>
* This method may be overridden.
* @this {ContextMenuTool}
* @return {boolean}
*/
ContextMenuTool.prototype.canStart = function() {
  if (!this.isEnabled) return false;
  var diagram = this.diagram;
  if (diagram === null) return false;
  if (this.isBeyondDragSize()) return false;
  if (!diagram.lastInput.right) return false;
  if (this._defaultTouchContextMenu !== null || this.findObjectWithContextMenu() !== null) return true;
  return false;
};

/**
* @ignore
* @this {ContextMenuTool}
*/
ContextMenuTool.prototype.doStart = function() {
  var diagram = this.diagram;
  if (diagram !== null) this._mouseDownPoint.set(diagram.firstInput.documentPoint);
};

/**
* @ignore
* Make sure any context menu has been removed.
* @this {ContextMenuTool}
*/
ContextMenuTool.prototype.doStop = function() {
  this.hideDefaultContextMenu();
  this.hideContextMenu();
};

/**
* Find a {@link GraphObject} at the current mouse point with a {@link GraphObject#contextMenu},
* or return the {@link Diagram} if there is a {@link Diagram#contextMenu}.
* <p/>
* This method may be overridden.
* @expose
* @this {ContextMenuTool}
* @param {GraphObject=} obj Optional GraphObject with which to start searching for a context menu.
* If null, the Diagram will be used. If no argument is specified, this method will look for an object at the current mouse point.
* @return {GraphObject|Diagram} something with a <code>contextMenu</code>,
* or null if nothing can be found with a context menu at the current mouse point.
*/
ContextMenuTool.prototype.findObjectWithContextMenu = function(obj) {
  var diagram = this.diagram;
  if (diagram === null) return null;
  var e = diagram.lastInput;
  var currobj = null;
  if (obj !== undefined) {
    currobj = obj;
  } else {
    currobj = diagram.findObjectAt(e.documentPoint, null,
                                     function(x) { return !x.layer.isTemporary; });
  }

  if (currobj !== null) {  // now inside some GraphObject
    var nextobj = currobj;
    while (nextobj !== null) {
      var cm = nextobj.contextMenu;
      if (cm !== null) return nextobj;
      nextobj = nextobj.panel;
    }
    // No context menu found, return the part in case the default menu wants it
    if (this._defaultTouchContextMenu !== null) return currobj.part;
  } else {  // not now in any GraphObject
    var cm = diagram.contextMenu;
    if (cm !== null) return diagram;
  }
  return null;
};

/**
* Do nothing, activation is special and relies on doMouseUp
* @this {ContextMenuTool}
*/
ContextMenuTool.prototype.doActivate = function() {
};

/**
* @ignore
* This mouse-down happens after the context menu has been shown -- it should cause a click on a button acting as a menu item.
* @this {ContextMenuTool}
*/
ContextMenuTool.prototype.doMouseDown = function() {
  if (!this.isActive) return; // don't activate on mouse down
  var diagram = this.diagram;
  if (diagram === null) return;
  if (this.currentContextMenu === null) return;
  var currobj = diagram.findObjectAt(diagram.lastInput.documentPoint, null, null);
  if (currobj !== null && currobj.isContainedBy(this.currentContextMenu)) {
    // click on a context menu button
    this.standardMouseClick(null, null);
    this.stopTool();
  } else {
    this.stopTool();
    diagram.currentTool.doMouseDown();
  }
};

/**
* If there is something found by {@link #findObjectWithContextMenu},
* call {@link #showContextMenu} with that object's {@link GraphObject#contextMenu}
* or {@link Diagram#contextMenu}.
* Once a context menu is being shown,
* if a click occurs on a part of the context menu, call {@link Tool#standardMouseClick}.
* Otherwise if the click occurs elsewhere, just stop this tool.
* Unlike some tools, a mouse-up should not stop this tool.
* @this {ContextMenuTool}
*/
ContextMenuTool.prototype.doMouseUp = function() {
  if (!this.isActive) {
    if (this.canStart()) {
      this.openMenu(true);
    }
  }
};

/**
* Called by mouseUp
* @ignore
* @this {ContextMenuTool}
* @param {boolean} mouseUp wether or not this was called by a real mouse(up) event
* @param {Diagram|GraphObject=} cmo
*/
ContextMenuTool.prototype.openMenu = function(mouseUp, cmo) {
  // defacto doActivate
  this.isActive = true;

  // like ClickSelectingTool:
  if (mouseUp) this.standardMouseSelect();
  this.standardMouseClick();

  if (cmo === undefined) cmo = this.findObjectWithContextMenu();
  if (cmo !== null) {  // might be a GraphObject or the Diagram
    var cm = cmo.contextMenu;
    if (cm !== null) {
      this.showContextMenu(cm, (cmo instanceof GraphObject ? cmo : null));
    } else {
      this.showDefaultContextMenu();
    }
    // now _currentContextMenu ought to be non-null
  } else {
    // no object found, is the default touch context menu enabled?
    this.showDefaultContextMenu();
  }
}

/**
* Handle mouse-enter, mouse-over, and mouse-leave events.
* @this {ContextMenuTool}
*/
ContextMenuTool.prototype.doMouseMove = function() {
  if (this.isActive) {
    var diagram = this.diagram;
    this.standardMouseOver();
  }
};

/**
* Show an {@link Adornment} as a context menu.
* <p/>
* If the object's containing {@link Part} is data-bound,
* set the contextmenu's <code>Part.data</code> to the same value.
* The {@link Adornment#adornedObject} property is set to the {@link GraphObject} for which the menu is being shown.
* This method sets the {@link #currentContextMenu}.
* <p/>
* This method may be overridden.
* @expose
* @this {ContextMenuTool}
* @param {Adornment} contextmenu
* @param {GraphObject} obj the {@link GraphObject} for which the context menu is being shown;
*   this is null if the contextmenu is being shown for the diagram background.
*/
ContextMenuTool.prototype.showContextMenu = function(contextmenu, obj) {
  Util.checkClass(contextmenu, Adornment, ContextMenuTool, 'showContextMenu:contextmenu');
  if (obj !== null) Util.checkClass(obj, GraphObject, ContextMenuTool, 'showContextMenu:obj');
  var diagram = this.diagram;
  if (diagram === null) return;

  // hide any other existing context menu
  if (contextmenu !== this.currentContextMenu) {
    this.hideContextMenu();
  }

  // always use Tool layer
  contextmenu.layerName = 'Tool';
  contextmenu.selectable = false;
  contextmenu.scale = 1 / diagram.scale;
  contextmenu.category = this.name;

  // show
  diagram.add(contextmenu);

  // maybe data-bind
  if (obj !== null) {
    var data = null;
    var panel = obj.findTemplateBinder();
    if (panel !== null) data = panel.data;
    contextmenu.adornedObject = obj;
    contextmenu.data = data;
  } else {  // for diagram background, bind to model
    contextmenu.data = diagram.model;
  }

  // position inside the viewport
  contextmenu.ensureBounds();
  this.positionContextMenu(contextmenu, obj);

  // remember
  this.currentContextMenu = contextmenu;

  diagram.requestUpdate();// not needed???
};

/**
* This is called by {@link #showContextMenu} to position the context menu within the viewport.
* It normally goes just below the cursor.
* But if the mouse is too close to the right edge or the bottom edge of the viewport,
* it is positioned left and/or above the cursor.
* <p/>
* The context menu Adornment has already been measured but not arranged,
* so you can use its {@link GraphObject#measuredBounds} width and height
* but not its {@link GraphObject#actualBounds}.
* <p/>
* This method may be overridden.
* @expose
* @this {ContextMenuTool}
* @param {Adornment} contextmenu
* @param {GraphObject} obj The {@link GraphObject} getting the context menu,
* or null if the context menu is for the diagram background.
*/
ContextMenuTool.prototype.positionContextMenu = function(contextmenu, obj) {
  var diagram = this.diagram;
  if (diagram === null) return;

  var p = diagram.lastInput.documentPoint.copy();
  var ttb = contextmenu.measuredBounds;
  var viewb = diagram.viewportBounds;
  // when touch event -- shift towards the left, so it's not obscured by the finger
  if (diagram.lastInput.isTouchEvent) {
    p.x -= ttb.width;
  }
  // if extends too far to the right -- shift left
  if (p.x + ttb.width > viewb.right) {
    p.x -= ttb.width + 5;
  }
  // but don't go beyond the left edge of the viewport
  if (p.x < viewb.x) {
    p.x = viewb.x;
  }
  // if extends too far down -- shift up
  if (p.y + ttb.height > viewb.bottom) {
    p.y -= ttb.height + 5;
  }
  // but don't go beyond the top edge of the viewport
  if (p.y < viewb.y) {
    p.y = viewb.y;
  }
  contextmenu.position = p;
};

/**
* Hide any context menu.
* <p/>
* This method may be overridden.
* @expose
* @this {ContextMenuTool}
*/
ContextMenuTool.prototype.hideContextMenu = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  if (this.currentContextMenu === null) return;
  this.currentContextMenu.data = null;
  this.currentContextMenu.adornedObject = null;
  diagram.remove(this.currentContextMenu);
  this.currentContextMenu = null;
  this.standardMouseOver();
  diagram.requestUpdate();
};

/**
* @ignore
* @expose
* @this {ContextMenuTool}
* @return {List} of objects describing button functionality,
* each with the properties "text", "command", and "visible".
*/
ContextMenuTool.prototype.initializeDefaultButtons = function() {
  if (this.diagram === null) return null;
  var buttons = new List();

  var cm = this.diagram.commandHandler;

  buttons.add({ text: 'Copy',
    command: function(diagram) { cm.copySelection(); },
    visible: function() { return cm.canCopySelection(); } });
  buttons.add({ text: 'Cut',
    command: function(diagram) { cm.cutSelection(); },
    visible: function() { return cm.canCutSelection(); } });
  buttons.add({ text: 'Delete',
    command: function(diagram) { cm.deleteSelection(); },
    visible: function() { return cm.canDeleteSelection(); } });
  buttons.add({ text: 'Paste',
    command: function(diagram) { cm.pasteSelection(diagram.lastInput.documentPoint); },
    visible: function() { return cm.canPasteSelection(); } });
  buttons.add({ text: 'Select All',
    command: function(diagram) { cm.selectAll(); },
    visible: function() { return cm.canSelectAll(); } });

  buttons.add({ text: 'Undo',
    command: function(diagram) { cm.undo(); },
    visible: function() { return cm.canUndo(); } });
  buttons.add({ text: 'Redo',
    command: function(diagram) { cm.redo(); },
    visible: function() { return cm.canRedo(); } });

  buttons.add({ text: 'Zoom Out',
    command: function(diagram) { cm.decreaseZoom(); },
    visible: function() { return cm.canDecreaseZoom(); } });
  buttons.add({ text: 'Zoom In',
    command: function(diagram) { cm.increaseZoom(); },
    visible: function() { return cm.canIncreaseZoom(); } });
  buttons.add({ text: 'Zoom To Fit',
    command: function(diagram) { cm.zoomToFit(); },
    visible: function() { return cm.canZoomToFit(); } });
  buttons.add({ text: 'Reset Zoom',
    command: function(diagram) { cm.resetZoom(); },
    visible: function() { return cm.canResetZoom(); } });
  buttons.add({ text: 'Group Selection',
    command: function(diagram) { cm.groupSelection(); },
    visible: function() { return cm.canGroupSelection(); } });
  buttons.add({ text: 'Ungroup Selection',
    command: function(diagram) { cm.ungroupSelection(); },
    visible: function() { return cm.canUngroupSelection(); } });
  buttons.add({ text: 'Edit Text',
    command: function(diagram) { cm.editTextBlock(); },
    visible: function() { return cm.canEditTextBlock(); } });

  return buttons;
};

/**
* Show a series of HTML elements acting as a context menu.
* <p>
* If the object's containing {@link Part} is data-bound,
* set the contextmenu's <code>Part.data</code> to the same value.
* The {@link Adornment#adornedObject} property is set to the {@link GraphObject}
* for which the menu is being shown.
* This method sets the {@link #currentContextMenu}.
* <p>
* On touch devices, a special default context menu will appear even there is no context menu defined.
* <p>
* This method may be overridden.
* @expose
* @this {ContextMenuTool}
*/
ContextMenuTool.prototype.showDefaultContextMenu = function() {
  var diagram = this.diagram;
  if (diagram === null) return;

  if (diagram.lastInput.event instanceof MouseEvent) return;

  if (this._defaultButtons === null) {
    this._defaultButtons = this.initializeDefaultButtons();
  }

  // hide any other existing context menu
  if (this._defaultTouchContextMenu !== this.currentContextMenu) {
    this.hideContextMenu();
  }

  // Show only the relevant buttons
  Util.cmLight.innerHTML = ''; // empty?

  Util.cmDark.addEventListener('click', this._toolStopper, false);

  var tool = this;
  var ul = document.createElement('ul');
  ul.className = 'defaultCXul';
  Util.cmLight.appendChild(ul);
  ul.innerHTML = '';

  var itr = this._defaultButtons.iterator;
  while (itr.next()) {
    var button = itr.value;
    var text = button.text;
    var command = button.command;
    var visible = button.visible;

    if (typeof visible === 'function' && !visible()) continue;
    var li = document.createElement('li');
    li.className = 'defaultCXli';
    var ahref = document.createElement('a');
    ahref.className = 'defaultCXa';
    ahref.href = '#';
    ahref._command = button.command;
    ahref.addEventListener('click', function(e) {
      this._command(diagram);
      tool.stopTool();
      e.preventDefault();
      return false;
    }, false);
    ahref.textContent = text;
    li.appendChild(ahref);
    ul.appendChild(li);
  }

  Util.cmLight.style.display = 'block';
  Util.cmDark.style.display = 'block';

  // Remember
  this.currentContextMenu = this._defaultTouchContextMenu;
};


/**
* Hide the default context menu.
* <p/>
* This method may be overridden.
* @expose
* @this {ContextMenuTool}
*/
ContextMenuTool.prototype.hideDefaultContextMenu = function() {
  if (this.currentContextMenu === null) return;
  if (this.currentContextMenu !== this._defaultTouchContextMenu) return;
  Util.cmLight.style.display = 'none';
  Util.cmDark.style.display = 'none';
  var tool = this;
  Util.cmDark.removeEventListener('click', this._toolStopper, false);
  this.currentContextMenu = null;
};

/**
* Gets the currently showing context menu, or null if there is none.
* This is typically only set in {@link #showContextMenu} and not by the user.
* It is also typically set to null in {@link #hideContextMenu}.
* Setting this property does not raise any events.
* @name ContextMenuTool#currentContextMenu
* @function.
* @return {Adornment}
*/
/** @type {Adornment} */
ContextMenuTool.prototype.currentContextMenu;
Util.exportProperty(ContextMenuTool, 'currentContextMenu', ContextMenuTool.prototype.currentContextMenu);
Util.defineProperty(ContextMenuTool, {currentContextMenu: 'currentContextMenu'},
  /** @this {ContextMenuTool} */
  function() { return this._currentContextMenu; },
  /** @this {ContextMenuTool} */
  function(val) { this._currentContextMenu = val; }
);

/**
* Gets the original mouse-down point in document coordinates.
* @name ContextMenuTool#mouseDownPoint
* @function.
* @return {Point}
*/
/** @type {Point} */
ContextMenuTool.prototype.mouseDownPoint;
Util.defineReadOnlyProperty(ContextMenuTool, { mouseDownPoint: 'mouseDownPoint' },
  /** @this {ContextMenuTool} */
  function() { return this._mouseDownPoint; }
);


/**
* You do not normally need to create an instance of this tool
* because one already exists as the {@link ToolManager#dragSelectingTool}, which you can modify.
* @constructor
* @extends Tool
* @category Tool
* @class
* The DragSelectingTool lets the user select multiple parts with a rectangular area.
* There is a temporary part, the {@link #box},
* that shows the current area encompassed between the mouse-down
* point and the current mouse point.
* The default drag selection box is a magenta rectangle.
* You can change the {@link #box} to customize its appearance -- see its documentation for an example.
* <p/>
* This tool is a standard mouse-move tool, the {@link ToolManager#dragSelectingTool}.
* However this cannot start running unless there has been a motionless delay
* after the mouse-down event of at least {@link #delay} milliseconds.
* <p/>
* This tool does not utilize any {@link Adornment}s or tool handles,
* but it does temporarily add the {@link #box} part to the diagram.
* This tool does not modify the model or conduct any transaction.
* <p/>
* Selection occurs on a mouse-up when it calls {@link #selectInRect}
* with the value of {@link #computeBoxBounds}.
* Selectable parts are selected when their bounds fall entirely within the rectangle,
* unless {@link #isPartialInclusion} is set to true.
*/
function DragSelectingTool() {
  if (arguments.length > 0) {
    Util.throwError('DragSelectingTool constructor cannot take any arguments.');
  }
  Tool.call(this);
  this.name = 'DragSelecting';
  /** @type {number} */
  this._delay = 175;
  /** @type {boolean} */
  this._isPartialInclusion = false;

  var b = new Part();
  b.layerName = 'Tool';
  b.selectable = false;
  var r = new Shape();
  r.name = 'SHAPE';
  r.figure = 'Rectangle';
  r.fill = null;
  r.stroke = 'magenta';
  b.add(r);
  /** @type {Part} */
  this._box = b;
}

Util.publish('DragSelectingTool', DragSelectingTool);

Util.inherit(DragSelectingTool, Tool);

/**
* This tool can run when the diagram allows selection,
* there has been delay of at least {@link #delay} milliseconds
* after the mouse-down before a mouse-move,
* there has been a mouse-drag far enough away not to be a click,
* and there is no selectable part at the mouse-down point.
* <p/>
* The delay required to start this tool enables both this tool and
* the {@link ToolManager#panningTool} to co-exist as mode-less mouse-move tools.
* <p/>
* This method may be overridden.
* @this {DragSelectingTool}
* @return {boolean}
*/
DragSelectingTool.prototype.canStart = function() {
  if (!this.isEnabled) return false;
  var diagram = this.diagram;
  if (diagram === null || !diagram.allowSelect) return false;
  var e = diagram.lastInput;
  // require left button & that it has moved far enough away from the mouse down point, so it isn't a click
  if (!e.left) return false;
  // don't include the following checks when this tool is running modally
  if (diagram.currentTool !== this) {
    if (!this.isBeyondDragSize()) return false;
    // must wait for "delay" milliseconds before that tool can run
    if (e.timestamp - diagram.firstInput.timestamp < this.delay) return false;
    // don't start if we're over a selectable part
    if (diagram.findPartAt(e.documentPoint, true) !== null) return false;
  }
  return true;
};

/**
* Capture the mouse and show the {@link #box}.
* @this {DragSelectingTool}
*/
DragSelectingTool.prototype.doActivate = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  this.isActive = true;
  diagram.isMouseCaptured = true;
  diagram.skipsUndoManager = true;
  diagram.add(this.box);
  this.doMouseMove();
};

/**
* Release the mouse and remove any {@link #box}.
* @this {DragSelectingTool}
*/
DragSelectingTool.prototype.doDeactivate = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  diagram.remove(this.box);
  diagram.skipsUndoManager = false;
  diagram.isMouseCaptured = false;
  this.isActive = false;
  diagram.requestUpdate();
};

/**
* Update the {@link #box}'s position and size according to the value
* of {@link #computeBoxBounds}.
* @this {DragSelectingTool}
*/
DragSelectingTool.prototype.doMouseMove = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  if (this.isActive && this.box !== null) {
    var r = this.computeBoxBounds();
    var shape = this.box.findObject('SHAPE');
    if (shape === null) shape = this.box.findMainElement();
    shape.desiredSize = r.size;
    this.box.position = r.position;
    diagram.requestUpdate();
  }
};

/**
* Call {@link #selectInRect} with the value of a call to {@link #computeBoxBounds}.
* @this {DragSelectingTool}
*/
DragSelectingTool.prototype.doMouseUp = function() {
  if (this.isActive) {
    var diagram = this.diagram;
    diagram.remove(this.box);
    try {
      diagram.currentCursor = 'wait';
      this.selectInRect(this.computeBoxBounds());
    } finally {
      diagram.currentCursor = '';
    }
  }
  this.stopTool();
};

/**
* This just returns a {@link Rect} stretching from the mouse-down point to the current mouse point.
* <p/>
* This method may be overridden.
* @expose
* @this {DragSelectingTool}
* @return {Rect} a {@link Rect} in document coordinates.
*/
DragSelectingTool.prototype.computeBoxBounds = function() {
  var diagram = this.diagram;
  if (diagram === null) return new Rect(0, 0, 0, 0);
  return new Rect(diagram.firstInput.documentPoint, diagram.lastInput.documentPoint);
};

/**
* This method is called to select some parts within the area of a given rectangle.
* <p/>
* The normal behavior is to set the diagram's selection collection to only those parts
* in the given rectangle according to the {@link #isPartialInclusion} policy.
* However, if the Shift key modifier is used, no parts are deselected --
* this adds to the selection the parts in the rectangle not already selected.
* If the Control key modifier is used, this toggles the selectedness of the parts in the rectangle.
* If the Control key and Shift key modifiers are both used, this deselects the parts in the rectangle.
* <p/>
* This method may be overridden.
* @expose
* @this {DragSelectingTool}
* @param {Rect} r a rectangular bounds in document coordinates.
*/
DragSelectingTool.prototype.selectInRect = function(r) {
  var diagram = this.diagram;
  if (diagram === null) return;
  var e = diagram.lastInput;
  diagram.raiseDiagramEvent('ChangingSelection');
  var parts = diagram.findObjectsIn(r, null,
                                       function(p) { return p instanceof Part && p.canSelect(); },
                                       this.isPartialInclusion);
  if (e.control) {  // toggle or deselect
    if (e.shift) {  // deselect only
      var it = parts.iterator;
      while (it.next()) {
        var p = it.value;
        if (p.isSelected) p.isSelected = false;
      }
    } else {  // toggle selectedness of parts
      var it = parts.iterator;
      while (it.next()) {
        var p = it.value;
        p.isSelected = !p.isSelected;
      }
    }
  } else if (e.shift) {  // extend selection only
    var it = parts.iterator;
    while (it.next()) {
      var p = it.value;
      if (!p.isSelected) p.isSelected = true;
    }
  } else {  // select parts, and unselect all other previously selected parts
    // this tries to avoid deselecting and then reselecting any Part
    var tounselect = new List(Part);
    var sit = diagram.selection.iterator;
    while (sit.next()) {
      var p = sit.value;
      if (!parts.contains(p)) tounselect.add(p);
    }
    var uit = tounselect.iterator;
    while (uit.next()) {
      var p = uit.value;
      p.isSelected = false;
    }
    var it = parts.iterator;
    while (it.next()) {
      var p = it.value;
      if (!p.isSelected) p.isSelected = true;
    }
  }
  diagram.raiseDiagramEvent('ChangedSelection');
};

/**
* Gets or sets the time in milliseconds for which the mouse must be stationary
* before this tool can be started.
* The default value is 175 milliseconds.
* Setting this property does not raise any events.
* @name DragSelectingTool#delay
* @function.
* @return {number}
*/
/** @type {number} */
DragSelectingTool.prototype.delay;
Util.exportProperty(DragSelectingTool, 'delay', DragSelectingTool.prototype.delay);
Util.defineProperty(DragSelectingTool, {delay: 'delay'},
  /** @this {DragSelectingTool} */
  function() { return this._delay; },
  /** @this {DragSelectingTool} */
  function(val) { this._delay = val; }
);

/**
* Gets or sets whether a selectable {@link Part} may be only partly
* or must be completely enclosed by the rectangle given to {@link #selectInRect}.
* The default value is false: parts must be completely inside the rectangle.
* Setting this property does not raise any events.
* @name DragSelectingTool#isPartialInclusion
* @function.
* @return {boolean}
*/
/** @type {boolean} */
DragSelectingTool.prototype.isPartialInclusion;
Util.exportProperty(DragSelectingTool, 'isPartialInclusion', DragSelectingTool.prototype.isPartialInclusion);
Util.defineProperty(DragSelectingTool, { isPartialInclusion: 'isPartialInclusion' },
  /** @this {DragSelectingTool} */
  function() { return this._isPartialInclusion; },
  /** @this {DragSelectingTool} */
  function(val) { this._isPartialInclusion = val; }
);

/**
* Gets or sets the {@link Part} used as the "rubber-band selection box"
* that is stretched to follow the mouse, as feedback for what area will
* be passed to {@link #selectInRect} upon a mouse-up.
* <p/>
* Initially this is a {@link Part} containing only a simple magenta rectangular {@link Shape}.
* The object to be resized during dragging should be named "SHAPE".
* Setting this property does not raise any events.
* <p/>
* Here is an example of changing the selection box to be a thicker bright green rectangle:
* <code><br/>
* &nbsp;&nbsp;myDiagram.toolManager.dragSelectingTool.box =<br/>
* &nbsp;&nbsp;&nbsp;&nbsp;$(go.Part,<br/>
* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ layerName: "Tool" },<br/>
* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(go.Shape,<br/>
* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ name: "SHAPE", fill: null, stroke: "chartreuse", strokeWidth: 3 }));<br/>
* </code>
* Note that the Part should be put into a {@link Layer} that {@link Layer#isTemporary}.
* <p/>
* Modifying this property while this tool {@link Tool#isActive} might have no effect.
* @name DragSelectingTool#box
* @function.
* @return {Part}
*/
/** @type {Part} */
DragSelectingTool.prototype.box;
Util.exportProperty(DragSelectingTool, 'box', DragSelectingTool.prototype.box);
Util.defineProperty(DragSelectingTool, {box: 'box'},
  /** @this {DragSelectingTool} */
  function() { return this._box; },
  /** @this {DragSelectingTool} */
  function(val) { this._box = val; }
);


/**
* You do not normally need to create an instance of this tool
* because one already exists as the {@link ToolManager#panningTool}.
* @constructor
* @extends Tool
* @category Tool
* @class
* The PanningTool supports manual panning, where the user can shift the
* {@link Diagram#position} by dragging the mouse.
* <p/>
* This tool is a standard mouse-move tool, the {@link ToolManager#panningTool}.
* Although the {@link ToolManager#dragSelectingTool} takes precedence over this tool,
* the {@link DragSelectingTool} only starts if there is a delay after a mouse-down event.
* If it does not start, then this PanningTool gets a chance to start.
* <p/>
* This tool does not utilize any {@link Adornment}s or tool handles.
* This tool does not modify the model or conduct any transaction.
*/
function PanningTool() {
  if (arguments.length > 0) {
    Util.throwError('PanningTool constructor cannot take any arguments.');
  }
  Tool.call(this);
  this.name = 'Panning';
  /** @type {Point} */
  this._originalPosition = new Point();

  /** @type {boolean} */
  this._bubbles = false;
  var tool = this;
  /** @ignore */
  this._stopToolOnPan = function() {
    document.removeEventListener('scroll', tool._stopToolOnPan, false);
    tool.stopTool();
  };
}

Util.publish('PanningTool', PanningTool);

Util.inherit(PanningTool, Tool);

/**
* This tool can run when the diagram allows scrolling and
* the mouse has been dragged with the left button far enough away
* from the mouse-down point to avoid being a click.
* <p/>
* This method may be overridden.
* @this {PanningTool}
* @return {boolean}
*/
PanningTool.prototype.canStart = function() {
  if (!this.isEnabled) return false;
  var diagram = this.diagram;
  if (diagram === null) return false;
  if (!diagram.allowHorizontalScroll && !diagram.allowVerticalScroll) return false;
  // require left button & that it has moved far enough away from the mouse down point, so it isn't a click
  if (!diagram.lastInput.left) return false;
  // don't include the following check when this tool is running modally
  if (diagram.currentTool !== this) {
    // mouse needs to have moved from the mouse-down point
    if (!this.isBeyondDragSize()) return false;
  }
  return true;
};

/**
* Capture the mouse, change the diagram cursor, and remember the {@link Diagram#position}.
* @this {PanningTool}
*/
PanningTool.prototype.doActivate = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  if (this._bubbles) {
    diagram.lastInput.bubbles = true;
    // attach event to window
    document.addEventListener('scroll', this._stopToolOnPan, false);
  } else {
    diagram.currentCursor = 'move';
    diagram.isMouseCaptured = true;
    this._originalPosition = diagram.position.copy();
  }
  this.isActive = true;
};

/**
* Release the mouse and restore the default diagram cursor.
* @this {PanningTool}
*/
PanningTool.prototype.doDeactivate = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  diagram.currentCursor = '';
  diagram.isMouseCaptured = false;
  this.isActive = false;

  diagram.invalidateDraw(); // full redraw
};

/**
* Restore the {@link Diagram#position} to what it was when this tool activated.
* @this {PanningTool}
*/
PanningTool.prototype.doCancel = function() {
  var diagram = this.diagram;
  if (diagram !== null) {
    diagram.position = this._originalPosition;
    diagram.isMouseCaptured = false;
  }
  this.stopTool();
};

/**
* Modify the {@link Diagram#position} according to how much the mouse has moved.
* @this {PanningTool}
*/
PanningTool.prototype.doMouseMove = function() {
  this.move();
};

/**
* Modify the {@link Diagram#position} according to how much the mouse has moved.
* @this {PanningTool}
*/
PanningTool.prototype.doMouseUp = function() {
  this.move();
  this.stopTool();
};

/**
* @ignore
* @this {PanningTool}
*/
PanningTool.prototype.move = function() {
  var diagram = this.diagram;
  if (this.isActive && diagram) {
    if (this._bubbles) {
      diagram.lastInput.bubbles = true;
      return;
    }
    var pos = diagram.position;
    var first = diagram.firstInput.documentPoint;
    var last = diagram.lastInput.documentPoint;
    var x = pos.x + first.x - last.x;
    var y = pos.y + first.y - last.y;
    if (!diagram.allowHorizontalScroll) x = pos.x;
    if (!diagram.allowVerticalScroll) y = pos.y;
    diagram.position = new Point(x, y);
    // no maybeUpdate necessary, is called by invalidateViewport from position setter
  }
};


/**
* Gets or sets whether panning actions will allow
* events to bubble <strong>instead</strong> of panning in the diagram.
* <p/>
* Set this to true to allow mobile devices to scroll the page with panning gestures on the diagram.
* Otherwise, the panning events will be captured and used to pan inside of the diagram.
* <p/>
* The default value is false.
* @name PanningTool#bubbles
* @function.
* @return {boolean}
*/
/** @type {boolean} */
PanningTool.prototype.bubbles;
Util.exportProperty(PanningTool, 'bubbles', PanningTool.prototype.bubbles);
Util.defineProperty(PanningTool, {bubbles: 'bubbles'},
  /** @this {PanningTool} */
  function() { return this._bubbles; },
  /** @this {PanningTool} */
  function(val) { this._bubbles = val; }
);

/**
* Gets the {@link Point} that was the original value of {@link Diagram#position} when the panning operation started.
* @name PanningTool#originalPosition
* @function.
* @return {Point}
* @since 1.1
*/
/** @type {Point} */
PanningTool.prototype.originalPosition;
Util.exportProperty(PanningTool, 'originalPosition', PanningTool.prototype.originalPosition);
Util.defineReadOnlyProperty(PanningTool, { originalPosition: 'originalPosition' },
  /** @this {PanningTool} */
  function() { return this._originalPosition; }
);

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
TextEditingTool
*/

/**
* You do not normally need to create an instance of this tool
* because one already exists as the {@link ToolManager#textEditingTool}, which you can modify.
* @constructor
* @extends Tool
* @category Tool
* @class
* The TextEditingTool is used to let the user interactively edit text in place.
* You do not normally need to create an instance of this tool
* because one already exists as the {@link ToolManager#clickSelectingTool}.
* <p/>
* Typically this is used by setting the {@link TextBlock#editable} property to true
* on a particular <c>TextBlock</c> in a part.
* When the part is selected and the user clicks on the {@link TextBlock}
* or invokes the {@link CommandHandler#editTextBlock} command,
* this tool is started and it uses an HTMLTextArea to perform in-place text editing.
* (For more details see the description for {@link TextEditingTool#doActivate}.)
* <p/>
* The {@link TextBlock} is accessible as the {@link TextEditingTool#textBlock} property.
* The text editor is accessible as the {@link TextEditingTool#currentTextEditor} property.
* From the text editor control one can access the <c>TextBlock</c> being edited via the
* attached property HTMLElement.TextEditingTool to get to this tool, from which one can use
* the {@link TextEditingTool#textBlock} property.
* <p/>
* You can disable mouse clicking from starting this text editing tool
* by setting {@link Tool#isEnabled} to false.
* You can disable the F2 key from starting this text editing tool
* by making sure {@link Part#canEdit} returns false,
* by either setting {@link Diagram#allowTextEdit} to false
* or by setting {@link Part#textEditable} to false.
*/
function TextEditingTool() {
  if (arguments.length > 0) {
    Util.throwError('TextEditingTool constructor cannot take any arguments.');
  }
  Tool.call(this);
  this.name = 'TextEditing';
  /** @type {GraphObject} */
  this._tempText = null;
  /** @type {TextBlock} */
  this._textBlock = null;
  // this is an HTML Input
  /** @type {Element} */
  this._currentTextEditor = null;
  /** @type {Element} */
  this._defaultTextEditor = null;
  /** @type {EnumValue} */
  this._starting = TextEditingTool.SingleClickSelected;

  /** @type {function(TextBlock, string, string):boolean | null} */
  this._textValidation = null;

  // internal no-property holder of TextEditingState
  /** @type {EnumValue} */
  this._state = TextEditingTool.StateNone;
  /** @type {?string} */
  this._oldBorder = null;
}

Util.publish('TextEditingTool', TextEditingTool);

Util.inherit(TextEditingTool, Tool);

/**
* The text editing control has lost focus. Used as the reason for calling {@link TextEditingTool#acceptText}.
* @name TextEditingTool#LostFocus
* @constant
* @static
* @return {EnumValue}
*/
TextEditingTool['LostFocus'] = TextEditingTool.LostFocus = Util.defineEnumValue(TextEditingTool, 'LostFocus', 0);

/**
* The user has clicked somewhere else in the diagram. Used as the reason for calling {@link TextEditingTool#acceptText}.
* @name TextEditingTool#MouseDown
* @constant
* @static
* @return {EnumValue}
*/
TextEditingTool['MouseDown'] = TextEditingTool.MouseDown = Util.defineEnumValue(TextEditingTool, 'MouseDown', 1);

/**
* The user has typed TAB. Used as the reason for calling {@link TextEditingTool#acceptText}.
* @name TextEditingTool#Tab
* @constant
* @static
* @return {EnumValue}
*/
TextEditingTool['Tab'] = TextEditingTool.Tab = Util.defineEnumValue(TextEditingTool, 'Tab', 2);

/**
* The user has typed ENTER. Used as the reason for calling {@link TextEditingTool#acceptText}.
* @name TextEditingTool#Enter
* @constant
* @static
* @return {EnumValue}
*/
TextEditingTool['Enter'] = TextEditingTool.Enter = Util.defineEnumValue(TextEditingTool, 'Enter', 3);


/**
* A single click on a {@link TextBlock} with {@link TextBlock#editable} property set to true
* will start in-place editing.
* @name TextEditingTool#SingleClick
* @constant
* @static
* @return {EnumValue}
*/
TextEditingTool['SingleClick'] = TextEditingTool.SingleClick = Util.defineEnumValue(TextEditingTool, 'SingleClick', 0);

/**
* A single click on a {@link TextBlock} with {@link TextBlock#editable} property set to true
* will start in-place editing, but only if the {@link Part} that the {@link TextBlock} is in is already selected.
* @name TextEditingTool#SingleClickSelected
* @constant
* @static
* @return {EnumValue}
*/
TextEditingTool['SingleClickSelected'] = TextEditingTool.SingleClickSelected = Util.defineEnumValue(TextEditingTool, 'SingleClickSelected', 1);

/**
* @ignore
* @constant
* @static
*/
TextEditingTool.StateNone = Util.defineEnumValue(TextEditingTool, 'StateNone', 0);
/**
* @ignore
* @constant
* @static
*/
TextEditingTool.StateActive = Util.defineEnumValue(TextEditingTool, 'StateActive', 1);
/**
* @ignore
* @constant
* @static
*/
TextEditingTool.StateEditing = Util.defineEnumValue(TextEditingTool, 'StateEditing', 2);
/**
* @ignore
* @constant
* @static
*/
TextEditingTool.StateEditing2 = Util.defineEnumValue(TextEditingTool, 'StateEditing2', 3);
/**
* @ignore
* @constant
* @static
*/
TextEditingTool.StateValidating = Util.defineEnumValue(TextEditingTool, 'StateValidating', 4);
/**
* @ignore
* @constant
* @static
*/
TextEditingTool.StateValidated = Util.defineEnumValue(TextEditingTool, 'StateValidated', 5);

/**
* Gets or sets the {@link TextBlock} that is being edited.
* This property is initially null and is set in {@link TextEditingTool#doActivate}
* as the {@link TextBlock} at the mouse click point.
* However, if you set this property beforehand, {@link TextEditingTool#doActivate}
* will not set it, and this tool will edit the given {@link TextBlock}.
* @name TextEditingTool#textBlock
* @function.
* @return {TextBlock}
*/
/** @type {TextBlock} */
TextEditingTool.prototype.textBlock;
Util.exportProperty(TextEditingTool, 'textBlock', TextEditingTool.prototype.textBlock);
Util.defineProperty(TextEditingTool, {textBlock: 'textBlock'},
  /** @this {TextEditingTool} */
  function() { return this._textBlock; },
  /** @this {TextEditingTool} */
  function(val) { this._textBlock = val; }
);

/**
* Gets or sets the HTML element that edits the text.
* @name TextEditingTool#currentTextEditor
* @function.
* @return {Element}
*/
/** @type {Element} */
TextEditingTool.prototype.currentTextEditor;
Util.exportProperty(TextEditingTool, 'currentTextEditor', TextEditingTool.prototype.currentTextEditor);
Util.defineProperty(TextEditingTool, {currentTextEditor: 'currentTextEditor'},
  /** @this {TextEditingTool} */
  function() { return this._currentTextEditor; },
  /** @this {TextEditingTool} */
  function(val) { this._currentTextEditor = val; }
);

/**
* Gets or sets the HTML element that edits the text.
* This is set by {@link TextEditingTool#doActivate} but can be set manually.
* If manually set, the HTML element will be added and removed automatically, and
* should have a way of calling {@link TextEditingTool#acceptText}.
* @name TextEditingTool#defaultTextEditor
* @function.
* @return {Element}
*/
/** @type {Element} */
TextEditingTool.prototype.defaultTextEditor;
Util.exportProperty(TextEditingTool, 'defaultTextEditor', TextEditingTool.prototype.defaultTextEditor);
Util.defineProperty(TextEditingTool, {defaultTextEditor: 'defaultTextEditor'},
  /** @this {TextEditingTool} */
  function() { return this._defaultTextEditor; },
  /** @this {TextEditingTool} */
  function(val) { this._defaultTextEditor = val; }
);

/**
* Gets or sets how user gestures can start in-place editing of text.
* The default is {@link TextEditingTool#SingleClickSelected}
* @name TextEditingTool#starting
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
TextEditingTool.prototype.starting;
Util.exportProperty(TextEditingTool, 'starting', TextEditingTool.prototype.starting);
Util.defineProperty(TextEditingTool, { starting: 'starting' },
  /** @this {EnumValue} */
  function() { return this._starting; },
  /** @this {EnumValue} */
  function(val) {
    var old = this._starting;
    if (old !== val) {
      if (Debug) Util.checkEnumValue(val, TextEditingTool, TextEditingTool, 'starting');
      this._starting = val;
    }
  }
);


/**
* This may run when there is a mouse-click on a {@link TextBlock} for which the
* {@link TextBlock#editable} property is true in a {@link Part}
* that {@link Part#isSelected}.
* <p/>
* This method may be overridden.
* @this {TextEditingTool}
* @return {boolean}
*/
TextEditingTool.prototype.canStart = function() {
  if (!this.isEnabled) return false;
  var diagram = this.diagram;
  if (diagram === null || diagram.isReadOnly) return false;
  // only works with the left button
  if (!diagram.lastInput.left) return false;

  // the mouse down point needs to be near the mouse up point
  if (this.isBeyondDragSize()) return false;

  var p = diagram.lastInput.documentPoint;
  var tb = diagram.findObjectAt(p, null, function(x) { return (x instanceof TextBlock); });
  if (!(tb instanceof TextBlock)) return false;
  if (!tb.editable) return false;

  var part = tb.part;
  if (part === null) return false;
  if (this.starting === TextEditingTool.SingleClickSelected && !part.isSelected) return false;

  return true;
};

/**
 * This calls {@link TextEditingTool#doActivate} if there is a
 * {@link TextBlock} supplied.
 * @this {TextEditingTool}
 */
TextEditingTool.prototype.doStart = function() {
  if (!this.isActive && this.textBlock !== null) {
    this.doActivate();
  }
};

/**
* Start editing the text for a {@link TextBlock}.
* <p/>
* If {@link TextEditingTool#textBlock} is not already specified, this looks for one at the current
* mouse point. If none is found, this method does nothing.
* <p/>
* Then this method need an HTMLElement to manage the editing. If {@link TextBlock#textEditor}
* is defined on the <c>TextBlock</c> it will use that. If one is supplied for {@link #defaultTextEditor}
* it uses that. Finally, by default it creates and uses an HTMLTextArea.
* <p/>
* This also calls {@link Diagram#startTransaction}
* and sets {@link Tool#isActive} to true.
* Custom text editors should call {@link TextEditingTool#acceptText} to finish the edit
* by modifying the {@link TextBlock} and committing the edit transaction.
* Or call {@link TextEditingTool#doCancel} to abort the edit.
* @this {TextEditingTool}
*/
TextEditingTool.prototype.doActivate = function() {
  if (this.isActive) return;
  var diagram = this.diagram;
  if (diagram === null) return;
  var textblock = this.textBlock;

  // there should be a TextBlock; find it if not given
  if (textblock === null) {
    var result = diagram.findObjectAt(diagram.lastInput.documentPoint,
      function(x) { if (x instanceof TextBlock) return x; return null; });
    textblock = (result instanceof TextBlock) ? result : null;
  }
  if (textblock === null) {
    return;
  }
  this.textBlock = textblock;
  // not needed if activated the normal way because the tool checks beforehand ?
  //if (!textblock.editable) return;  //?? able to operate on all TextBlocks
  var part = textblock.part;
  if (part === null) return;  //?? don't check for IsSelected here, just in CanStart?

  // start editing
  this.isActive = true;
  this._state = TextEditingTool.StateActive;
  this.startTransaction(this.name);

  // make sure there's a TextEditor
  var input = this.defaultTextEditor;
  var custom = false;
  if (textblock.textEditor !== null) input = textblock.textEditor;
  if (input !== null && !input.__default) custom = true;

  // used to update the size of the textarea
  this._tempText = this.textBlock.copy();

  if (input === null) {
    input = document.createElement('textarea');
    input.__default = true; // the default editor
    this._defaultTextEditor = input;

    input.addEventListener('input', function(e) {
      var tool = this['textEditingTool'];
      var tempText = tool._tempText;
      tempText.text = this.value;
      tempText.measure(Infinity, Infinity);  //??? maintain aspect ratio
      var scale = this.textScale;
      this.style.width = 20 + tempText.measuredBounds.width * scale + 'px';
      //this.style.height = 10+tempText.measuredBounds.height * scale + "px";
      this.rows = tempText.lineCount;
    }, false);

    input.addEventListener('keydown', function(e) {
      var keynum = e.which;
      var tool = this['textEditingTool'];
      if (tool === null) return;
      if (keynum === 13) { // Enter
        tool.acceptText(TextEditingTool.Enter);
        return;
      } else if (keynum === 9) { // Tab
        tool.acceptText(TextEditingTool.Tab);
        e.preventDefault();
        return false;
      } else if (keynum === 27) { // Esc
        tool.doCancel();
        if (tool.diagram) tool.diagram.focus();
      }
    }, false);

    input.addEventListener('focus', function(e) {
      var tool = this['textEditingTool'];
      tool.handleFocus();
    }, false);
  }

  // Additional setup done every time for the default editor only
  if (input.__default) {
    var loc = textblock.getDocumentPoint(Spot.Center);
    var pos = diagram.position;
    var sc = diagram.scale;
    var textscale = textblock.getDocumentScale() * sc;
    var textwidth = textblock.naturalBounds.width * textscale;
    var textheight = textblock.getStringHeight() * textscale;
    var left = (loc.x - pos.x) * sc;
    var top = (loc.y - pos.y) * sc;

    input.value = textblock.text;
    // ??? Stupid HTML rule:
    // the only way you can mix font and fontSize is if the font inherits and the fontSize overrides
    // ??? in the future maybe have input contained in its own div
    diagram.div.style.font = textblock.font;
    input.style.font = 'inherit';
    input.style.fontSize = (textscale * 100) + '%';
    input.style.lineHeight = 'normal';
    var scrollWidth = 20 + textwidth;
    input.style.width = scrollWidth + 'px';
    input.style.height = ''; // reset, let columns and rows take care of it
    input.rows = textblock.lineCount;
    diagram.div.appendChild(input); // to get clientHeight
    input.style.left = (left - (scrollWidth / 2) | 0) + 'px';
    input.style.top = (top - (input.clientHeight / 2) | 0) + 'px';
    input.style.textAlign = textblock.textAlign;
  } else {
    diagram.div.appendChild(input);
  }
  input.style.position = 'absolute';
  input.style.zIndex = 100; // put it all the way to the front
  input.className = 'start';

  input['textEditingTool'] = this;
  input.textScale = textscale;

  // Let custom controls run their activation code
  if (custom && input['onActivate'] !== undefined) input['onActivate']();

  this.currentTextEditor = input;
  input.focus();
};

/**
* Abort any text editing operation.
* @this {Tool}
*/
TextEditingTool.prototype.doCancel = function() {
  if (this._oldBorder !== null) {
    this.currentTextEditor.style.border = this._oldBorder;
    this._oldBorder = null;
  }
  this.stopTool();
};

/**
* A click (mouse up) calls {@link TextEditingTool#doActivate} if this tool is not already active
* and if {@link TextEditingTool#canStart} returns true.
* @this {TextEditingTool}
*/
TextEditingTool.prototype.doMouseUp = function() {
  if (!this.isActive && this.canStart()) {
    this.doActivate();
  }
  //this.stopTool();
};

/**
* A click (mouse up) calls {@link TextEditingTool#doActivate} if this tool is not already active
* and if {@link TextEditingTool#canStart} returns true.
* @this {TextEditingTool}
*/
TextEditingTool.prototype.doMouseDown = function() {
  if (this.isActive) {
    this.acceptText(TextEditingTool.MouseDown);
  }
};

/**
* Finish editing by trying to accept the new text.
* @expose
* @this {TextEditingTool}
* @param {EnumValue} reason The reason must be either {@link TextEditingTool#LostFocus},
* {@link TextEditingTool#MouseDown}, {@link TextEditingTool#Tab}, or {@link TextEditingTool#Enter}.
*/
TextEditingTool.prototype.acceptText = function(reason) {
  switch (reason) {
    case TextEditingTool.MouseDown:
      if (this._state === TextEditingTool.StateValidated ||
          this._state === TextEditingTool.StateEditing2) {
        this.currentTextEditor.focus();
      } else if (this._state === TextEditingTool.StateActive ||
                 this._state === TextEditingTool.StateEditing) {
                 this._state = TextEditingTool.StateValidating;
        this.doAcceptText();
      }
      break;
    case TextEditingTool.LostFocus:
    case TextEditingTool.Enter:
    case TextEditingTool.Tab:
      if (TextEditingTool.Enter === reason && this._textBlock.isMultiline === true) return;
      if (this._state === TextEditingTool.StateActive ||
          this._state === TextEditingTool.StateEditing) {
        this._state = TextEditingTool.StateValidating;
        this.doAcceptText();
      }
      break;
  }
};

// Call textValidation
/**
* @ignore
* @this {TextEditingTool}
*/
TextEditingTool.prototype.doAcceptText = function() {
  if (this.textBlock !== null && this.currentTextEditor !== null) {
    var tb = this.textBlock;
    var oldstring = this.textBlock.text;
    // In custom tools value might be a function that returns a string
    var v = this.currentTextEditor.value;
    var newstring = '';
    if (typeof v === 'function')
      newstring = v();
    else
      newstring = v;

    if (!this.isValidText(this.textBlock, oldstring, newstring)) {
      this._state = TextEditingTool.StateEditing;
      if (tb.errorFunction !== null) tb.errorFunction(this, oldstring, newstring);
      if (this._oldBorder === null) {
        this._oldBorder = this.currentTextEditor.style.border;
        this.currentTextEditor.style.border = '3px solid red';
      }
      this.currentTextEditor.focus();
      return false;
    }

    this._state = TextEditingTool.StateValidated;
    if (oldstring !== newstring) {
      this.textBlock.text = newstring;
    }
    this.transactionResult = this.name;
    var diagram = this.diagram;
    if (diagram !== null) diagram.raiseDiagramEvent('TextEdited', this.textBlock, oldstring);
    this.stopTool();
    if (diagram !== null) diagram.focus();
  }
  if (this._oldBorder !== null) {
    this.currentTextEditor.style.border = this._oldBorder;
    this._oldBorder = null;
  }
  return true;
};

/**
* Release the mouse.
* @this {TextEditingTool}
*/
TextEditingTool.prototype.doDeactivate = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  if (this.isActive) this.stopTransaction();
  this._state = TextEditingTool.StateNone;

  this.textBlock = null;
  if (this.currentTextEditor !== null) {
    var input = this.currentTextEditor;
    // Let custom controls run their deactivation code
    if (input['onDeactivate'] !== undefined) input['onDeactivate']();
    if (input !== null) diagram.div.removeChild(input);
  }

  this.isActive = false;
};

/**
* @ignore
* @this {TextEditingTool}
*/
TextEditingTool.prototype.handleFocus = function() {// NYI ?
  if (this._state === TextEditingTool.StateActive) {
    this._state = TextEditingTool.StateEditing;
  } else if (this._state === TextEditingTool.StateValidated) {
    this._state = TextEditingTool.StateEditing2;
  } else if (this._state === TextEditingTool.StateEditing2) {
    this._state = TextEditingTool.StateEditing;
  }
};

/**
* This predicate checks any {@link TextBlock#textValidation} predicate and
* this tool's {@link #textValidation} predicate to make sure the {@link TextBlock#text}
* property may be set to the new string.
* <p/>
* This method may be overridden, although usually it is sufficient to set {@link #textValidation}.
* @expose
* @this {TextEditingTool}
* @param {TextBlock} textblock the {@link TextBlock} that is being edited.
* @param {string} oldstr the previous string value.
* @param {string} newstr the proposed new string value.
* @return {boolean} true if the new string is valid for the given TextBlock.
*/
TextEditingTool.prototype.isValidText = function(textblock, oldstr, newstr) {
  Util.checkClass(textblock, TextBlock, TextEditingTool, 'isValidText:textblock');
  // Check both this.textValidation and textBlock.textValidation
  var func = this.textValidation;
  if (func !== null && !func(textblock, oldstr, newstr)) return false;
  var textfunc = textblock.textValidation;
  if (textfunc !== null && !textfunc(textblock, oldstr, newstr)) return false;
  return true;
};

/**
 * Gets or sets the predicate that determines whether or not a string of text is valid.
 * The default predicate is null, which is equivalent to simply returning true.
 * <p/>
 * The function, if supplied, must not have any side-effects.
 * @name TextEditingTool#textValidation
 * @function.
 * @return {function(TextBlock, string, string):boolean | null}
 */
/** @type {function(TextBlock, string, string):boolean | null} */
TextEditingTool.prototype.textValidation;
Util.exportProperty(TextEditingTool, 'textValidation', TextEditingTool.prototype.textValidation);
Util.defineProperty(TextEditingTool, {textValidation: 'textValidation'},
  /** @this {TextEditingTool} */
  function() { return this._textValidation; },
  /** @this {TextEditingTool} */
  function(val) {
    var old = this._textValidation;
    if (old !== val) {
      this._textValidation = val;
    }
  }
);

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
ToolManager
*/

/**
 * You do not normally need to create an instance of this tool
 * because one already exists as the {@link Diagram#toolManager}, which you can modify.
 * <p/>
 * The constructor produces a ToolManager that manages no tools.
 * Call {@link #initializeStandardTools} to create various tools,
 * initialize the tool properties such as {@link #draggingTool},
 * and initialize the three mouse tool lists with those newly created tools.
 * @constructor
 * @extends Tool
 * @category Tool
 * @class
 * This special {@link Tool} is responsible for managing all of the Diagram's
 * mode-less tools.
 * <p/>
 * Mode-less tools are tools that are present in one of the following lists:
 * {@link #mouseDownTools}, {@link #mouseMoveTools}, or {@link #mouseUpTools}.
 * This ToolManager tool is normally the {@link Diagram#defaultTool},
 * so it is also usually the {@link Diagram#currentTool} when the user is doing "nothing".
 * <p/>
 * When this tool is running as the current tool, it handles mouse-down,
 * mouse-move, and mouse-up events.
 * For each event it iterates over each of the tools in the corresponding list,
 * calling the tool's {@link Tool#canStart} predicate.
 * If that predicate returns true, it starts that tool by making it the
 * diagram's current tool.
 * It then activates the tool and passes on the event to the tool by calling
 * the corresponding method (either {@link Tool#doMouseDown},
 * {@link Tool#doMouseMove}, or {@link Tool#doMouseUp}).
 * <p/>
 * Because this tool is typically the one running as the diagram's current tool
 * when the user isn't "doing" anything, this tool can also handle other events,
 * such as mouse wheel events and keyboard commands.
 * <p/>
 * Keyboard events are just passed on to the {@link Diagram#commandHandler}'s
 * {@link CommandHandler#doKeyDown} or {@link CommandHandler#doKeyUp} method.
 * <p/>
 * This tool also is responsible for showing tooltips.
 * Tooltip {@link Adornment}s may be declared as any {@link GraphObject#toolTip},
 * or as the {@link Diagram#toolTip} if the mouse remains motionless in the background of the diagram.
 * <p/>
 * This tool does not utilize any tool handles.
 * This tool does not conduct any transactions.
 * But of course some of the tools that the ToolManager starts can show tool handles and/or
 * conduct their own transactions.
 */
function ToolManager() {
  Tool.call(this);
  /** @ignore @type {string} */
  this.name = 'ToolManager';
  /** @type {List} */
  this._mouseDownTools = new List(Tool);
  /** @type {List} */
  this._mouseMoveTools = new List(Tool);
  /** @type {List} */
  this._mouseUpTools = new List(Tool);
  /** @type {number} */
  this._hoverDelay = 1000;
  /** @type {number} */
  this._holdDelay = 1000;
  /** @type {Size} */
  this._dragSize = new Size(2, 2).constant();

  // transient properties
  /** @type {Part} */
  this._currentToolTip = null;
  /** @type {GraphObject} */
  this._currentToolTipObject = null;

  /** @type {EnumValue} */
  this._mouseWheelBehavior = ToolManager.WheelScroll;
}

Util.publish('ToolManager', ToolManager);

Util.inherit(ToolManager, Tool);

/**
* This default value for {@link #mouseWheelBehavior} indicates that mouse wheel events scroll the diagram.
* @name ToolManager#WheelScroll
* @constant
* @static
* @return {EnumValue}
*/
ToolManager['WheelScroll'] = ToolManager.WheelScroll = Util.defineEnumValue(ToolManager, 'WheelScroll', 0);

/**
* This value for {@link #mouseWheelBehavior} indicates that the mouse wheel events change the scale of the diagram.
* @name ToolManager#WheelZoom
* @constant
* @static
* @return {EnumValue}
*/
ToolManager['WheelZoom'] = ToolManager.WheelZoom = Util.defineEnumValue(ToolManager, 'WheelZoom', 1);

/**
* This value for {@link #mouseWheelBehavior} indicates that the mouse wheel events are ignored,
* although scrolling or zooming by other means may still be allowed.
* @name ToolManager#WheelNone
* @constant
* @static
* @return {EnumValue}
* @since 1.2
*/
ToolManager['WheelNone'] = ToolManager.WheelNone = Util.defineEnumValue(ToolManager, 'WheelNone', 2);

/**
 * Gets or sets the ToolManager's mouse wheel behavior. Allowed values are {@link ToolManager#WheelScroll} and
 * {@link ToolManager#WheelZoom}.
 * <p/>
 * The default value is {@link ToolManager#WheelScroll}.
 * @name ToolManager#mouseWheelBehavior
 * @function.
 * @return {EnumValue}
 */
/** @type {EnumValue} */
ToolManager.prototype.mouseWheelBehavior;
Util.exportProperty(ToolManager, 'mouseWheelBehavior', ToolManager.prototype.mouseWheelBehavior);
Util.defineProperty(ToolManager, {mouseWheelBehavior: 'mouseWheelBehavior'},
  /** @this {ToolManager} */
  function() { return this._mouseWheelBehavior; },
  /** @this {ToolManager} */
  function(val) { this._mouseWheelBehavior = val; }
);


/**
* Initialize the three mouse tool lists with instances of the standard tools.
* This adds tools to the following three mouse tool lists:
* {@link #mouseDownTools}, {@link #mouseMoveTools}, or {@link #mouseUpTools}.
* This also sets the various tool properties of this ToolManager
* to those newly created tools.
* @expose
* @this {ToolManager}
*/
ToolManager.prototype.initializeStandardTools = function() {
  // For each of these lists, the tools need to be assigned in a specific order,
  // so that they are added to the list in the correct order.

  // mouse-down tools:
  this.actionTool = new ActionTool();
  this.relinkingTool = new RelinkingTool();
  this.linkReshapingTool = new LinkReshapingTool();
  //this.partReshapingTool = new PartReshapingTool();
  this.resizingTool = new ResizingTool();
  this.rotatingTool = new RotatingTool();

  // mouse-move tools:
  this.linkingTool = new LinkingTool();
  this.draggingTool = new DraggingTool();
  this.dragSelectingTool = new DragSelectingTool();
  this.panningTool = new PanningTool();

  // mouse-up tools:
  this.contextMenuTool = new ContextMenuTool();
  this.textEditingTool = new TextEditingTool();
  this.clickCreatingTool = new ClickCreatingTool();
  this.clickSelectingTool = new ClickSelectingTool();
};


/**
* Iterate over the {@link #mouseDownTools} list and start the first tool
* for which its {@link Tool#canStart} predicate returns true.
* <p/>
* Starting a tool replaces the {@link Diagram#currentTool} with the new tool.
* Successfully doing so also activates the new tool by calling {@link Tool#doActivate}
* and passes on the mouse-down event to it by calling {@link Tool#doMouseDown}.
* <p/>
* Not finding any startable tools causes this tool manager to activate,
* thereby enabling the mouse-move and mouse-up behaviors and starts
* detection of a mouse-hold event after {@link #holdDelay} milliseconds.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @this {ToolManager}
*/
ToolManager.prototype.doMouseDown = function() {
  var diagram = this.diagram;
  if (diagram === null) return;

  // don't need to call focus because click in browser assigns focus

  // check to see if there is an ongoing transaction
  var mgr = diagram.undoManager;
  if (mgr.checksTransactionLevel && mgr.transactionLevel !== 0) {
    Util.trace('WARNING: In ToolManager.doMouseDown: UndoManager.transactionLevel is not zero');
  }

  var len = this.mouseDownTools.length;
  for (var i = 0; i < len; i++) {
    var tool = this.mouseDownTools.elt(i);
    if (tool.diagram === null) tool.setDiagram(this.diagram);
    if (tool.canStart()) {  // check if applicable
      diagram.currentTool = tool;  // calls tool.doStart()
      // if tool hasn't stopped itself already, pass on the mouse event
      if (diagram.currentTool === tool) {
        if (!tool.isActive) tool.doActivate();
        tool.doMouseDown();
      }
      return;
    }
  }

  // Default behavior of scroll wheel click
  if (diagram.lastInput.button === 1) {
    if (this.mouseWheelBehavior === ToolManager.WheelScroll) {
      this.mouseWheelBehavior = ToolManager.WheelZoom;
    } else if (this.mouseWheelBehavior === ToolManager.WheelZoom) {
      this.mouseWheelBehavior = ToolManager.WheelScroll;
    }
  }

  this.doActivate();  // enable doMouseMove and doMouseUp

  this.standardWaitAfter(this.holdDelay);  // check for mouseHold event
};


/**
* Iterate over the {@link #mouseMoveTools} list and start the first tool
* for which its {@link Tool#canStart} predicate returns true.
* <p/>
* Starting a tool replaces the {@link Diagram#currentTool} with the new tool.
* Successfully doing so also activates the new tool by calling {@link Tool#doActivate}
* and passes on the mouse-move event to it by calling {@link Tool#doMouseMove}.
* <p/>
* If no tool is found and activated, this calls {@link Tool#standardMouseOver}
* to invoke any mouse-enter, mouse-over, or mouse-leave functions.
* If the mouse has moved sufficiently, such that {@link Tool#isBeyondDragSize} is true,
* this also calls {@link Tool#standardWaitAfter} for a possible call to
* {@link #doWaitAfter} after {@link #hoverDelay} milliseconds.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @this {ToolManager}
*/
ToolManager.prototype.doMouseMove = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  if (this.isActive) {  // gotta handle a mouse-down first
    var len = this.mouseMoveTools.length;
    for (var i = 0; i < len; i++) {
      var tool = this.mouseMoveTools.elt(i);
      if (tool.diagram === null) tool.setDiagram(this.diagram);
      if (tool.canStart()) {  // check if applicable
        diagram.currentTool = tool;  // calls tool.doStart()
        // if tool hasn't stopped itself already, pass on the mouse event
        if (diagram.currentTool === tool) {
          if (!tool.isActive) tool.doActivate();
          tool.doMouseMove();
        }
        return;  // don't do mouse-over events
      }
    }
  }

  this.standardMouseOver();

  if (this.isBeyondDragSize()) {
    // check for mouseHover or mouseHold event
    this.standardWaitAfter((this.isActive ? this.holdDelay : this.hoverDelay));
  }
};

/**
* @ignore
* This is called by {@link #standardMouseOver} when the current object changes.
* @this {ToolManager}
* @param {GraphObject} prev
* @param {GraphObject} curr
*/
ToolManager.prototype.doCurrentObjectChanged = function(prev, curr) {
  var tt = this.currentToolTip;
  if (tt === null) return;
  // don't remove tooltip if we're now over any part of it
  if (curr !== null && (curr === tt || curr.isContainedBy(tt))) return;
  this.hideToolTip();
};

/**
* Implement the standard behavior for when the mouse has not moved for a period of time.
* This is due to an expired timer started by calling {@link Tool#standardWaitAfter}.
* <p/>
* This just calls {@link #doMouseHover} and, if not mouse-down, {@link #doToolTip}.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @this {ToolManager}
*/
ToolManager.prototype.doWaitAfter = function() {
  // It's possible for this to fire after a Diagram has been unloaded
  if (!this.diagram) return;
  if (!this.diagram._canvas) return;

  this.doMouseHover();
  if (!this.isActive) {  // not when mouse down
    this.doToolTip();
  }
};

/**
* Implement the standard behavior for mouse hover and mouse hold events,
* called by {@link #doWaitAfter} when the mouse has not moved for a period of time.
* <p/>
* If there has been no mouse down, the timer is set for {@link #hoverDelay} milliseconds.
* If it executes, it calls any {@link GraphObject#mouseHover} function on the object
* at the mouse or on any of its containing panels,
* or it calls any {@link Diagram#mouseHover} function for a background mouse-hover event.
* <p/>
* If there had been a mouse down, the timer is set for {@link #holdDelay} milliseconds.
* If it executes, it calls any {@link GraphObject#mouseHold} function on the object
* at the mouse or on any of its containing panels,
* or it calls any {@link Diagram#mouseHold} function for a background mouse-held-down event.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {ToolManager}
*/
ToolManager.prototype.doMouseHover = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  var e = diagram.lastInput;
  if (e.targetObject === null) {
    // try again, just in case it had been off by a pixel or two
    e.targetObject = diagram.findObjectAt(e.documentPoint, null, null);
  }
  var currobj = e.targetObject;

  // this.isActive should be true if there had been a mouse down
  // and no mouse-down tool is running

  if (currobj !== null) {  // now inside some GraphObject
    // look for an event handler for current object that we're over
    while (currobj !== null) {
      var func = (this.isActive ? currobj.mouseHold : currobj.mouseHover);
      if (func !== null) {
        func(e, currobj);
        if (e.handled) break;
      }
      currobj = currobj.panel;
    }
  } else {  // not now in any GraphObject
    // maybe execute an event handler;
    var func = (this.isActive ? diagram.mouseHold : diagram.mouseHover);
    if (func !== null) {
      func(e);
    }
  }
};

/**
* Implement the standard behavior for tooltips,
* called by {@link #doWaitAfter} when the mouse has not moved for a period of time.
* <p/>
* This looks for a {@link GraphObject} at the latest mouse point.
* If it finds an object, it checks for a {@link GraphObject#toolTip}.
* If it has none, this method searches up the visual tree for a containing
* {@link Panel} that does have a tooltip.
* <p/>
* If it didn't find any object, this looks for a {@link Diagram#toolTip}.
* <p/>
* If it eventually finds a tooltip, this calls {@link #showToolTip}.
* Otherwise this calls {@link #hideToolTip}.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {ToolManager}
*/
ToolManager.prototype.doToolTip = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  var e = diagram.lastInput;
  if (e.targetObject === null) {
    // try again, just in case it had been off by a pixel or two
    e.targetObject = diagram.findObjectAt(e.documentPoint, null, null);
  }
  var currobj = e.targetObject;

  // this.isActive should be true if there had been a mouse down
  // and no mouse-down tool is running

  if (currobj !== null) {  // now inside some GraphObject
    // don't cancel tooltip if the mouse is now over the tooltip itself
    if (currobj === this.currentToolTip || currobj.isContainedBy(this.currentToolTip)) {
      return;
    }
    // walk up the visual tree, looking for a tooltip
    while (currobj !== null) {
      var tt = currobj.toolTip;
      if (tt !== null) {
        this.showToolTip(tt, currobj);
        return;
      }
      currobj = currobj.panel;
    }
    // no tooltip found: cancel any current tooltip
    this.hideToolTip();
  } else {  // not now in any GraphObject
    var tt = diagram.toolTip;
    if (tt !== null) {
      this.showToolTip(tt, null);
    } else {
      this.hideToolTip();
    }
  }
};

/**
* Show a tooltip Adornment.
* This is called by {@link #doToolTip} once that method has found a tooltip to display.
* <p/>
* This calls {@link #positionToolTip} to make it easier to customize how the tooltip
* is positioned relative to the object with the tooltip.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {ToolManager}
* @param {Adornment} tooltip
* @param {GraphObject} obj The GraphObject getting the tooltip; this is null if the tooltip is being shown for the diagram background.
*/
ToolManager.prototype.showToolTip = function(tooltip, obj) {
  Util.checkClass(tooltip, Adornment, ToolManager, 'showToolTip:tooltip');
  if (obj !== null) Util.checkClass(obj, GraphObject, ToolManager, 'showToolTip:obj');
  var diagram = this.diagram;
  if (diagram === null) return;

  // hide any different existing tooltip
  if (tooltip !== this.currentToolTip) {
    this.hideToolTip();
  }

  // always use Tool layer
  tooltip.layerName = 'Tool';
  tooltip.selectable = false;
  tooltip.scale = 1 / diagram.scale;

  // show
  diagram.add(tooltip);

  // maybe data-bind
  if (obj !== null && obj !== this._currentToolTipObject) {  // don't bother if still over same object
    var data = null;
    var part = obj.findTemplateBinder();
    if (part !== null) data = part.data;
    tooltip.adornedObject = obj;
    tooltip.data = data;
  } else if (obj === null) {  // for diagram background, bind to model
    tooltip.data = diagram.model;
  }

  // position inside the viewport
  if (obj === null || obj !== this._currentToolTipObject) {
    tooltip.ensureBounds();
    this.positionToolTip(tooltip, obj);
  }

  // remember
  this._currentToolTip = tooltip;
  this._currentToolTipObject = obj;

  diagram.requestUpdate();
};

/**
* This is called by {@link #showToolTip} to position the part within the viewport.
* It normally goes just below the cursor.
* But if the mouse is too close to the right edge or the bottom edge of the viewport,
* it is positioned left and/or above the cursor.
* <p/>
* The tooltip part has been measured but not arranged,
* so you can use its {@link GraphObject#measuredBounds} width and height
* but not its {@link GraphObject#actualBounds}.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {ToolManager}
* @param {Adornment} tooltip
* @param {GraphObject} obj The {@link GraphObject} getting the tooltip,
* or null if the tooltip is for the diagram background.
*/
ToolManager.prototype.positionToolTip = function(tooltip, obj) {
  var diagram = this.diagram;
  if (diagram === null) return;

  var p = diagram.lastInput.documentPoint.copy();
  var ttb = tooltip.measuredBounds;
  var viewb = diagram.viewportBounds;
  // when touch event -- shift towards the left, so it's not obscured by the finger
  if (diagram.lastInput.isTouchEvent) {
    p.x -= ttb.width;
  }
  // if extends too far to the right -- shift left
  if (p.x + ttb.width > viewb.right) {
    p.x -= ttb.width + 5;
  }
  // but don't go beyond the left edge of the viewport
  if (p.x < viewb.x) {
    p.x = viewb.x;
  }
  // if extends too far down -- shift up
  if (p.y + 20 + ttb.height > viewb.bottom) {
    p.y -= ttb.height + 5;
  } else {
    p.y += 20;
  }
  // but don't go beyond the top edge of the viewport
  if (p.y < viewb.y) {
    p.y = viewb.y;
  }
  tooltip.position = p;
};

/**
* Hide any tooltip.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @expose
* @this {ToolManager}
*/
ToolManager.prototype.hideToolTip = function() {
  if (this.currentToolTip !== null) {
    var diagram = this.diagram;
    if (diagram === null) return;
    this.currentToolTip.data = null;
    this.currentToolTip.adornedObject = null;
    diagram.remove(this.currentToolTip);
    this._currentToolTip = null;
    this._currentToolTipObject = null;
    diagram.requestUpdate();
  }
};

/**
* Gets the currently showing tooltip, or null if there is none.
* @name ToolManager#currentToolTip
* @function.
* @return {Adornment}
*/
/** @type {Adornment} */
ToolManager.prototype.currentToolTip;
Util.defineReadOnlyProperty(ToolManager, { currentToolTip: 'currentToolTip' },
  /** @this {ToolManager} */
  function() { return this._currentToolTip; }
);


/**
* Iterate over the {@link #mouseUpTools} list and start the first tool
* for which its {@link Tool#canStart} predicate returns true.
* <p/>
* Starting a tool replaces the {@link Diagram#currentTool} with the new tool.
* Successfully doing so also activates the new tool by calling {@link Tool#doActivate}
* and passes on the mouse-up event to it by calling {@link Tool#doMouseUp}.
* <p/>
* If no startable tool is found it deactivates this tool manager,
* to get ready for a mouse-down and ignore mouse-move and mouse-up events.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @this {ToolManager}
*/
ToolManager.prototype.doMouseUp = function() {
  this.cancelWaitAfter();

  if (this.isActive) {  // gotta handle a mouse-down first
    var diagram = this.diagram;
    if (diagram === null) return;

    var len = this.mouseUpTools.length;
    for (var i = 0; i < len; i++) {
      var tool = this.mouseUpTools.elt(i);
      if (tool.diagram === null) tool.setDiagram(this.diagram);
      if (tool.canStart()) {  // check if applicable
        diagram.currentTool = tool;  // calls tool.doStart()
        // if tool hasn't stopped itself already, pass on the mouse event
        if (diagram.currentTool === tool) {
          if (!tool.isActive) tool.doActivate();
          tool.doMouseUp();
        }
        return;
      }
    }
  }

  this.doDeactivate();  // in case no tool is found that canStart
};

/**
* The diagram will call this method as the mouse wheel is rotated.
* <p/>
* By default this just calls {@link Tool#standardMouseWheel}.
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @this {ToolManager}
*/
ToolManager.prototype.doMouseWheel = function() {
  this.standardMouseWheel();
};


/**
* This just calls {@link CommandHandler#doKeyDown} on the diagram's {@link Diagram#commandHandler}.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @this {ToolManager}
*/
ToolManager.prototype.doKeyDown = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  diagram.commandHandler.doKeyDown();
};

/**
* This just calls {@link CommandHandler#doKeyUp} on the diagram's {@link Diagram#commandHandler}.
* <p/>
* This method may be overridden, but you should consider calling this base method in order to get all of its functionality.
* @this {ToolManager}
*/
ToolManager.prototype.doKeyUp = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  diagram.commandHandler.doKeyUp();
};


/**
* @ignore
* @this {ToolManager}
*/
ToolManager.prototype.doCancel = function() {
  if (DraggingTool.source !== null) {
    DraggingTool.source.doCancel();
  }
  Tool.prototype.doCancel.call(this);
};


/**
* Find a mouse tool of a given name.
* This searches the {@link #mouseDownTools}, {@link #mouseMoveTools}, and {@link #mouseUpTools} lists.
* @expose
* @this {ToolManager}
* @param {string} name the type of tool, such as "Dragging" or "ClickSelecting".
* @return {Tool} a {@link Tool} whose {@link Tool#name} exactly matches the given name,
* or null if no such tool is found in any of the three lists.
*/
ToolManager.prototype.findTool = function(name) {
  Util.checkPrimitive(name, 'string', ToolManager, 'findTool:name');

  var len = this.mouseDownTools.length;
  for (var i = 0; i < len; i++) {
    var tool = this.mouseDownTools.elt(i);
    if (tool.name === name) return tool;
  }

  len = this.mouseMoveTools.length;
  for (var i = 0; i < len; i++) {
    var tool = this.mouseMoveTools.elt(i);
    if (tool.name === name) return tool;
  }

  len = this.mouseUpTools.length;
  for (var i = 0; i < len; i++) {
    var tool = this.mouseUpTools.elt(i);
    if (tool.name === name) return tool;
  }
  return null;
};

/**
* Replace a mouse tool of a given name with a new tool.
* This searches the {@link #mouseDownTools}, {@link #mouseMoveTools},
* and {@link #mouseUpTools} lists.
* The new tool is inserted into the same list in which the same-named tool is found,
* at the same position as the old tool.
* @expose
* @this {ToolManager}
* @param {string} name the type of tool, such as "Dragging" or "ClickSelecting".
* @param {Tool} newtool If null, any tool that the search finds will just be removed
* from the list in which it was found.
* @return {Tool} the old tool that was replaced by the new one.
*/
ToolManager.prototype.replaceTool = function(name, newtool) {
  Util.checkPrimitive(name, 'string', ToolManager, 'replaceTool:name');
  if (newtool !== null) {
    Util.checkClass(newtool, Tool, ToolManager, 'replaceTool:newtool');
    if (newtool.diagram && newtool.diagram !== this.diagram) {
      Util.throwError('Cannot share tools between Diagrams: ' + newtool.toString());
    }
    newtool.setDiagram(this.diagram);
  }

  var len = this.mouseDownTools.length;
  for (var i = 0; i < len; i++) {
    var oldtool = this.mouseDownTools.elt(i);
    if (oldtool.name === name) {
      if (newtool !== null)
        this.mouseDownTools.setElt(i, newtool);
      else
        this.mouseDownTools.removeAt(i);
      return oldtool;
    }
  }

  len = this.mouseMoveTools.length;
  for (var i = 0; i < len; i++) {
    var oldtool = this.mouseMoveTools.elt(i);
    if (oldtool.name === name) {
      if (newtool !== null)
        this.mouseMoveTools.setElt(i, newtool);
      else
        this.mouseMoveTools.removeAt(i);
      return oldtool;
    }
  }

  len = this.mouseUpTools.length;
  for (var i = 0; i < len; i++) {
    var oldtool = this.mouseUpTools.elt(i);
    if (oldtool.name === name) {
      if (newtool !== null)
        this.mouseUpTools.setElt(i, newtool);
      else
        this.mouseUpTools.removeAt(i);
      return oldtool;
    }
  }
  return null;  // not found, thus newtool was not added to any list
};

/**
* @ignore
* @this {ToolManager}
*/
ToolManager.prototype._replaceStandardTool = function(name, newtool, list) {
  Util.checkPrimitive(name, 'string', ToolManager, 'replaceStandardTool:name');
  Util.checkClass(list, List, ToolManager, 'replaceStandardTool:list');

  if (newtool !== null) {
    Util.checkClass(newtool, Tool, ToolManager, 'replaceStandardTool:newtool');
    if (newtool.diagram && newtool.diagram !== this.diagram) {
      Util.throwError('Cannot share tools between Diagrams: ' + newtool.toString());
    }
    newtool.name = name;
    newtool.setDiagram(this.diagram);
  }

  if (this.findTool(name)) {  // found an existing tool, regardless of list
    this.replaceTool(name, newtool);  // newtool may be null
  } else if (newtool !== null) {
    list.add(newtool);
  }
};

/**
* Gets the list of {@link Tool}s that might be started upon a mouse-down event.
* When the ToolManager handles a mouse-down event in {@link #doMouseDown},
* it searches this list in order, starting the first tool for which
* {@link Tool#canStart} returns true.
* <p/>
* This list may be modified, but it must not be modified while any tool
* is handling events.
* <p/>
* {@link #initializeStandardTools} installs the following tools, in order:
* <ul>
*   <li>{@link #actionTool}, an {@link ActionTool}</li>
*   <li>{@link #relinkingTool}, a {@link RelinkingTool}</li>
*   <li>{@link #linkReshapingTool}, a {@link LinkReshapingTool}</li>
*   <li>{@link #resizingTool}, a {@link ResizingTool}</li>
*   <li>{@link #rotatingTool}, a {@link RotatingTool}</li>
* </ul>
* @name ToolManager#mouseDownTools
* @function.
* @return {List}
*/
/** @type {List} */
ToolManager.prototype.mouseDownTools;
Util.defineReadOnlyProperty(ToolManager, {mouseDownTools: 'mouseDownTools'},
  /** @this {ToolManager} */
  function() { return this._mouseDownTools; }
);

/**
* Gets the list of {@link Tool}s that might be started upon a mouse-move event.
* When the ToolManager handles a mouse-move event in {@link #doMouseMove},
* it searches this list in order, starting the first tool for which
* {@link Tool#canStart} returns true.
* <p/>
* This list may be modified, but it must not be modified while any tool
* is handling events.
* <p/>
* {@link #initializeStandardTools} installs the following tools, in order:
* <ul>
*   <li>{@link #linkingTool}, a {@link LinkingTool}</li>
*   <li>{@link #draggingTool}, a {@link DraggingTool}</li>
*   <li>{@link #dragSelectingTool}, a {@link DragSelectingTool}</li>
*   <li>{@link #panningTool}, a {@link PanningTool}</li>
* </ul>
* @name ToolManager#mouseMoveTools
* @function.
* @return {List}
*/
/** @type {List} */
ToolManager.prototype.mouseMoveTools;
Util.defineReadOnlyProperty(ToolManager, {mouseMoveTools: 'mouseMoveTools'},
  /** @this {ToolManager} */
  function() { return this._mouseMoveTools; }
);

/**
* Gets the list of {@link Tool}s that might be started upon a mouse-up event.
* When the ToolManager handles a mouse-up event in {@link #doMouseUp},
* it searches this list in order, starting the first tool for which
* {@link Tool#canStart} returns true.
* <p/>
* This list may be modified, but it must not be modified while any tool
* is handling events.
* <p/>
* {@link #initializeStandardTools} installs the following tools, in order:
* <ul>
*   <li>{@link #contextMenuTool}, a {@link ContextMenuTool}</li>
*   <li>{@link #textEditingTool}, a {@link TextEditingTool}</li>
*   <li>{@link #clickCreatingTool}, a {@link ClickCreatingTool}</li>
*   <li>{@link #clickSelectingTool}, a {@link ClickSelectingTool}</li>
* </ul>
* @name ToolManager#mouseUpTools
* @function.
* @return {List}
*/
/** @type {List} */
ToolManager.prototype.mouseUpTools;
Util.defineReadOnlyProperty(ToolManager, {mouseUpTools: 'mouseUpTools'},
  /** @this {ToolManager} */
  function() { return this._mouseUpTools; }
);


/**
* Gets or sets the time between when the mouse stops moving and a hover event,
* in milliseconds. This value affects the delay before {@link GraphObject#toolTip}s are shown.
* The default value is 1000 milliseconds.
* @name ToolManager#hoverDelay
* @function.
* @return {number}
*/
/** @type {number} */
ToolManager.prototype.hoverDelay;
Util.exportProperty(ToolManager, 'hoverDelay', ToolManager.prototype.hoverDelay);
Util.defineProperty(ToolManager, { hoverDelay: 'hoverDelay' },
  /** @this {ToolManager} */
  function() { return this._hoverDelay; },
  /** @this {ToolManager} */
  function(val) { this._hoverDelay = val; }
);

/**
* Gets or sets the time between when the mouse stops moving and a hold event,
* in milliseconds.
* The default value is 1000 milliseconds.
* @name ToolManager#holdDelay
* @function.
* @return {number}
*/
/** @type {number} */
ToolManager.prototype.holdDelay;
Util.exportProperty(ToolManager, 'holdDelay', ToolManager.prototype.holdDelay);
Util.defineProperty(ToolManager, { holdDelay: 'holdDelay' },
  /** @this {ToolManager} */
  function() { return this._holdDelay; },
  /** @this {ToolManager} */
  function(val) { this._holdDelay = val; }
);

/**
* Gets or sets the distance in view coordinates within which a mouse down-and-up is considered a click and beyond which a mouse movement is considered a drag.
* The default value is 2 pixels horizontally and vertically for mouse events and 6 pixels for touch events.
* This value is used by {@link Tool#isBeyondDragSize}.
* @name ToolManager#dragSize
* @function.
* @return {Size}
* @since 1.2
*/
/** @type {number} */
ToolManager.prototype.dragSize;
Util.exportProperty(ToolManager, 'dragSize', ToolManager.prototype.dragSize);
Util.defineProperty(ToolManager, { dragSize: 'dragSize' },
  /** @this {ToolManager} */
  function() { return this._dragSize; },
  /** @this {ToolManager} */
  function(val) { this._dragSize = val; }
);


// Standard mode-less tools

/**
* Gets or sets the mode-less {@link ActionTool}, normally one of the {@link #mouseDownTools}.
* <p/>
* You can disable this tool by setting its {@link Tool#isEnabled} property to false.
* @name ToolManager#actionTool
* @function.
* @return {ActionTool}
*/
/** @type {ActionTool} */
ToolManager.prototype.actionTool;
Util.exportProperty(ToolManager, 'actionTool', ToolManager.prototype.actionTool);
Util.defineProperty(ToolManager, {actionTool: 'actionTool'},
  /** @this {ToolManager} */
  function() { return this.findTool('Action'); },
  /** @this {ToolManager} */
  function(val) { this._replaceStandardTool('Action', val, this.mouseDownTools); }
);

/**
* Gets or sets the mode-less {@link RelinkingTool}, normally one of the {@link #mouseDownTools}.
* <p/>
* You can disable this tool by setting its {@link Tool#isEnabled} property to false.
* @name ToolManager#relinkingTool
* @function.
* @return {RelinkingTool}
*/
/** @type {RelinkingTool} */
ToolManager.prototype.relinkingTool;
Util.exportProperty(ToolManager, 'relinkingTool', ToolManager.prototype.relinkingTool);
Util.defineProperty(ToolManager, {relinkingTool: 'relinkingTool'},
  /** @this {ToolManager} */
  function() { return this.findTool('Relinking'); },
  /** @this {ToolManager} */
  function(val) { this._replaceStandardTool('Relinking', val, this.mouseDownTools); }
);

/**
* Gets or sets the mode-less {@link LinkReshapingTool}, normally one of the {@link #mouseDownTools}.
* <p/>
* You can disable this tool by setting its {@link Tool#isEnabled} property to false.
* @name ToolManager#linkReshapingTool
* @function.
* @return {LinkReshapingTool}
*/
/** @type {LinkReshapingTool} */
ToolManager.prototype.linkReshapingTool;
Util.exportProperty(ToolManager, 'linkReshapingTool', ToolManager.prototype.linkReshapingTool);
Util.defineProperty(ToolManager, {linkReshapingTool: 'linkReshapingTool'},
  /** @this {ToolManager} */
  function() { return this.findTool('LinkReshaping'); },
  /** @this {ToolManager} */
  function(val) { this._replaceStandardTool('LinkReshaping', val, this.mouseDownTools); }
);

///**
//* Gets or sets the mode-less {@link PartReshapingTool}, normally one of the {@link #mouseDownTools}.
//* <p/>
//* You can disable this tool by setting its {@link Tool#isEnabled} property to false.
//* @name ToolManager#partReshapingTool
//* @function.
//* @return {PartReshapingTool}
//*/
///** @type {PartReshapingTool} */
//ToolManager.prototype.partReshapingTool;
//Util.defineProperty(ToolManager, {partReshapingTool : 'partReshapingTool'},
//  /** @this {ToolManager} */
//  function() { return this.findTool('PartReshaping'); },
//  /** @this {ToolManager} */
//  function(val) { this._replaceStandardTool('PartReshaping', val, this.mouseDownTools); }
//);

/**
* Gets or sets the mode-less {@link ResizingTool}, normally one of the {@link #mouseDownTools}.
* <p/>
* You can disable this tool by setting its {@link Tool#isEnabled} property to false.
* @name ToolManager#resizingTool
* @function.
* @return {ResizingTool}
*/
/** @type {ResizingTool} */
ToolManager.prototype.resizingTool;
Util.exportProperty(ToolManager, 'resizingTool', ToolManager.prototype.resizingTool);
Util.defineProperty(ToolManager, {resizingTool: 'resizingTool'},
  /** @this {ToolManager} */
  function() { return this.findTool('Resizing'); },
  /** @this {ToolManager} */
  function(val) { this._replaceStandardTool('Resizing', val, this.mouseDownTools); }
);

/**
* Gets or sets the mode-less {@link RotatingTool}, normally one of the {@link #mouseDownTools}.
* <p/>
* You can disable this tool by setting its {@link Tool#isEnabled} property to false.
* @name ToolManager#rotatingTool
* @function.
* @return {RotatingTool}
*/
/** @type {RotatingTool} */
ToolManager.prototype.rotatingTool;
Util.exportProperty(ToolManager, 'rotatingTool', ToolManager.prototype.rotatingTool);
Util.defineProperty(ToolManager, {rotatingTool: 'rotatingTool'},
  /** @this {ToolManager} */
  function() { return this.findTool('Rotating'); },
  /** @this {ToolManager} */
  function(val) { this._replaceStandardTool('Rotating', val, this.mouseDownTools); }
);


/**
* Gets or sets the mode-less {@link LinkingTool}, normally one of the {@link #mouseMoveTools}.
* <p/>
* You can disable this tool by setting its {@link Tool#isEnabled} property to false.
* @name ToolManager#linkingTool
* @function.
* @return {LinkingTool}
*/
/** @type {LinkingTool} */
ToolManager.prototype.linkingTool;
Util.exportProperty(ToolManager, 'linkingTool', ToolManager.prototype.linkingTool);
Util.defineProperty(ToolManager, {linkingTool: 'linkingTool'},
  /** @this {ToolManager} */
  function() { return this.findTool('Linking'); },
  /** @this {ToolManager} */
  function(val) { this._replaceStandardTool('Linking', val, this.mouseMoveTools); }
);

/**
* Gets or sets the mode-less {@link DraggingTool}, normally one of the {@link #mouseMoveTools}.
* <p/>
* You can disable this tool by setting its {@link Tool#isEnabled} property to false.
* @name ToolManager#draggingTool
* @function.
* @return {DraggingTool}
*/
/** @type {DraggingTool} */
ToolManager.prototype.draggingTool;
Util.exportProperty(ToolManager, 'draggingTool', ToolManager.prototype.draggingTool);
Util.defineProperty(ToolManager, {draggingTool: 'draggingTool'},
  /** @this {ToolManager} */
  function() { return this.findTool('Dragging'); },
  /** @this {ToolManager} */
  function(val) { this._replaceStandardTool('Dragging', val, this.mouseMoveTools); }
);

/**
* Gets or sets the mode-less {@link DragSelectingTool}, normally one of the {@link #mouseMoveTools}.
* <p/>
* You can disable this tool by setting its {@link Tool#isEnabled} property to false.
* @name ToolManager#dragSelectingTool
* @function.
* @return {DragSelectingTool}
*/
/** @type {DragSelectingTool} */
ToolManager.prototype.dragSelectingTool;
Util.exportProperty(ToolManager, 'dragSelectingTool', ToolManager.prototype.dragSelectingTool);
Util.defineProperty(ToolManager, {dragSelectingTool: 'dragSelectingTool'},
  /** @this {ToolManager} */
  function() { return this.findTool('DragSelecting'); },
  /** @this {ToolManager} */
  function(val) { this._replaceStandardTool('DragSelecting', val, this.mouseMoveTools); }
);

/**
* Gets or sets the mode-less {@link PanningTool}, normally one of the {@link #mouseMoveTools}.
* <p/>
* You can disable this tool by setting its {@link Tool#isEnabled} property to false.
* @name ToolManager#panningTool
* @function.
* @return {PanningTool}
*/
/** @type {PanningTool} */
ToolManager.prototype.panningTool;
Util.exportProperty(ToolManager, 'panningTool', ToolManager.prototype.panningTool);
Util.defineProperty(ToolManager, {panningTool: 'panningTool'},
  /** @this {ToolManager} */
  function() { return this.findTool('Panning'); },
  /** @this {ToolManager} */
  function(val) { this._replaceStandardTool('Panning', val, this.mouseMoveTools); }
);

/**
* Gets or sets the mode-less {@link ContextMenuTool}, normally one of the {@link #mouseUpTools}.
* <p/>
* You can disable this tool by setting its {@link Tool#isEnabled} property to false.
* @name ToolManager#contextMenuTool
* @function.
* @return {ContextMenuTool}
*/
/** @type {ContextMenuTool} */
ToolManager.prototype.contextMenuTool;
Util.exportProperty(ToolManager, 'contextMenuTool', ToolManager.prototype.contextMenuTool);
Util.defineProperty(ToolManager, {contextMenuTool: 'contextMenuTool'},
  /** @this {ToolManager} */
  function() { return this.findTool('ContextMenu'); },
  /** @this {ToolManager} */
  function(val) { this._replaceStandardTool('ContextMenu', val, this.mouseUpTools); }
);

/**
* Gets or sets the mode-less {@link TextEditingTool}, normally one of the {@link #mouseUpTools}.
* <p/>
* You can disable this tool by setting its {@link Tool#isEnabled} property to false.
* @name ToolManager#textEditingTool
* @function.
* @return {TextEditingTool}
*/
/** @type {TextEditingTool} */
ToolManager.prototype.textEditingTool;
Util.exportProperty(ToolManager, 'textEditingTool', ToolManager.prototype.textEditingTool);
Util.defineProperty(ToolManager, {textEditingTool: 'textEditingTool'},
  /** @this {ToolManager} */
  function() { return this.findTool('TextEditing'); },
  /** @this {ToolManager} */
  function(val) { this._replaceStandardTool('TextEditing', val, this.mouseUpTools); }
);

/**
* Gets or sets the mode-less {@link ClickCreatingTool}, normally one of the {@link #mouseUpTools}.
* <p/>
* You can disable this tool by setting its {@link Tool#isEnabled} property to false.
* @name ToolManager#clickCreatingTool
* @function.
* @return {ClickCreatingTool}
*/
/** @type {ClickCreatingTool} */
ToolManager.prototype.clickCreatingTool;
Util.exportProperty(ToolManager, 'clickCreatingTool', ToolManager.prototype.clickCreatingTool);
Util.defineProperty(ToolManager, {clickCreatingTool: 'clickCreatingTool'},
  /** @this {ToolManager} */
  function() { return this.findTool('ClickCreating'); },
  /** @this {ToolManager} */
  function(val) { this._replaceStandardTool('ClickCreating', val, this.mouseUpTools); }
);

/**
* Gets or sets the mode-less {@link ClickSelectingTool}, normally one of the {@link #mouseUpTools}.
* <p/>
* You can disable this tool by setting its {@link Tool#isEnabled} property to false.
* @name ToolManager#clickSelectingTool
* @function.
* @return {ClickSelectingTool}
*/
/** @type {ClickSelectingTool} */
ToolManager.prototype.clickSelectingTool;
Util.exportProperty(ToolManager, 'clickSelectingTool', ToolManager.prototype.clickSelectingTool);
Util.defineProperty(ToolManager, {clickSelectingTool: 'clickSelectingTool'},
  /** @this {ToolManager} */
  function() { return this.findTool('ClickSelecting'); },
  /** @this {ToolManager} */
  function(val) {
    this._replaceStandardTool('ClickSelecting', val, this.mouseUpTools);
  }
);

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
Layer
*/

/**
* This constructs an empty Layer; you should set the {@link #name} before adding the Layer to a Diagram.
* @constructor
* @class
* Layers are how named collections of {@link Part}s are drawn in front or behind other collections of Parts in a {@link Diagram}.
* Layers can only contain {@link Part}s -- they cannot hold {@link GraphObject}s directly.
* <p/>
* Each Diagram starts off with the following list of Layers:
* "Grid", "Background", "" (the default layer), "Foreground", "Adornment", "Tool".
* Parts are normally put in the default layer.
* The last two layers are considered {@link #isTemporary}.
* Changes to objects in temporary layers are not recorded by the {@link UndoManager}.
* Parts in temporary layers are not selected and are not considered to be part of the document.
* The "Grid" layer is the furthest back; it also contains "temporary" parts that cannot be selected.
* Furthermore the "Grid" layer has {@link #pickable} set to false so that mouse or touch events
* and calls to the "find..." methods do not even consider any parts in that layer.
* <p/>
* Use {@link Diagram#findLayer} to get the Layer with a particular name.
* You can add your own layers by calling {@link Diagram#addLayerBefore} or {@link Diagram#addLayerAfter}
* to insert a new layer at a particular place in the Z-order, or to re-order existing layers.
* <p/>
* Layers have many properties that control what actions users are permitted to perform involving the parts in the layer.
* These properties are very much like the similarly named properties on {@link Diagram}.
*/
function Layer() {
  if (arguments.length > 1) {
    Util.throwError('Layer constructor cannot take any arguments.');
  }
  Util.uniqueHash(this);
  /** @type {Diagram} */
  this._diagram = null;
  /** @type {List} */
  this._parts = new List(Part);
  /** @type {string} */
  this._name = '';
  /** @type {number} */
  this._opacity = 1;
  /** @type {boolean} */
  this._isTemporary = false;

  /** @type {boolean} */
  this._allowCopy = true;
  /** @type {boolean} */
  this._allowDelete = true;
  /** @type {boolean} */
  this._allowTextEdit = true;
  /** @type {boolean} */
  this._allowGroup = true;
  /** @type {boolean} */
  this._allowUngroup = true;
  /** @type {boolean} */
  this._allowLink = true;
  /** @type {boolean} */
  this._allowRelink = true;
  /** @type {boolean} */
  this._allowMove = true;
  /** @type {boolean} */
  this._allowReshape = true;
  /** @type {boolean} */
  this._allowResize = true;
  /** @type {boolean} */
  this._allowRotate = true;
  /** @type {boolean} */
  this._allowSelect = true;
  /** @type {boolean} */
  this._visible = true;
  /** @type {boolean} */
  this._pickable = true;

  /** @type {Array} */
  this._orthoLinks = [];  // Orthogonal Links that were drawn
}

Util.publish('Layer', Layer);

/**
* @ignore
* @this {Layer}
* @param {Diagram} val
*/
Layer.prototype.setDiagram = function(val) {
  this._diagram = val;
};

/**
* @ignore
* @this {Layer}
* @param {number=} details Optional: If greater than zero, this includes descriptions of each part in the layer.
* @return {string}
*/
Layer.prototype.toString = function(details) {
  if (details === undefined/*notpresent*/) details = 0;
  var str = 'Layer \"' + this.name + '"';
  if (details <= 0) return str;
  // if details >= 1, talk about the parts in the layer
  var numparts = 0;
  var numnodes = 0;
  var numgroups = 0;
  var numlinks = 0;
  var numadorns = 0;
  var it = this._parts.iterator;
  while (it.next()) {
    var p = it.value;
    // gotta check most specific classes first...
    if (p instanceof Group) numgroups++;
    else if (p instanceof Node) numnodes++;
    else if (p instanceof Link) numlinks++;
    else if (p instanceof Adornment) numadorns++;
    else numparts++;
  }
  var msg = '';
  if (numparts > 0) msg += numparts + ' Parts ';
  if (numnodes > 0) msg += numnodes + ' Nodes ';
  if (numgroups > 0) msg += numgroups + ' Groups ';
  if (numlinks > 0) msg += numlinks + ' Links ';
  if (numadorns > 0) msg += numadorns + ' Adornments ';
  if (details > 1) {
    var pit = this._parts.iterator;
    while (pit.next()) {
      var part = pit.value;
      msg += '\n    ' + part.toString(details - 1);
      var data = part.data;
      if (data && Util.hashId(data)) msg += ' #' + Util.hashId(data);
      //?? move into Part
      if (part instanceof Node) {
        msg += ' ' + Binding.toString(data);
      } else if (part instanceof Link) {
        msg += ' ' + Binding.toString(part.fromNode) + ' ' + Binding.toString(part.toNode);
      }
    }
  }
  return str + ' ' + this._parts.count + ': ' + msg;
};


Layer.prototype['findObjectAt'] =
/**
* Find the front-most {@link GraphObject} in this layer
* at the given point in document coordinates.
* <p/>
* If {@link #visible} is false, this method will not find any objects in this layer.
* However, {@link #opacity} does not affect this method.
* @this {Layer}
* @param {Point} p A Point in document coordinates.
* @param {function(GraphObject):GraphObject | null=} navig A function taking a GraphObject and
* returning a GraphObject, defaulting to the identity.
* @param {function(GraphObject):boolean | null=} pred A function taking the GraphObject
* returned by navig and returning true if that object should be returned,
* defaulting to a predicate that always returns true.
* @return {GraphObject} The first GraphObject in the z-order, or else null.
*/
Layer.prototype.findObjectAt = function(p, navig, pred) {
  if (navig === undefined/*notpresent*/) navig = null;
  if (pred === undefined/*notpresent*/) pred = null;
  if (this._pickable === false) return null;

  // if p is in the viewportBounds we can just look at viewportObjects
  var lay = this._parts;
  var inView = false;
  if (this.diagram.viewportBounds.containsPoint(p)) {
    inView = true;
  }

  var mult = Util.tempPoint();
  var l = lay.length;
  for (var i = l; i--;) {
    var part = lay.elt(i);
    if (inView === true && part.getInView() === false) continue;
    if (!part.isVisible()) continue;
    mult.assign(p);
    mult.transformInverted(part.allTransforms);
    var obj = part.findObjectAt(mult, navig, pred);
    if (obj !== null) {
      if (navig !== null) obj = navig(obj);
      if (obj && (pred === null || pred(obj))) {
        Util.freePoint(mult);
        return obj;
      }
    }
  }
  Util.freePoint(mult);
  return null;
};


Layer.prototype['findObjectsAt'] =
/**
* Return a collection of the {@link GraphObject}s of this layer
* at the given point in document coordinates.
* <p/>
* If {@link #visible} is false, this method will not find any objects in this layer.
* However, {@link #opacity} does not affect this method.
* @this {Layer}
* @param {Point} p A Point in document coordinates.
* @param {function(GraphObject):GraphObject | null=} navig A function taking a GraphObject and
* returning a GraphObject, defaulting to the identity.
* If this function returns null, the given GraphObject will not be included in the results.
* @param {function(GraphObject):boolean | null=} pred A function taking the GraphObject
* returned by navig and returning true if that object should be returned,
* defaulting to a predicate that always returns true.
* @param {List|Set=} coll An optional collection (List or Set) to add the results to.
* @return {Iterable} a collection of GraphObjects that will contain all GraphObjects
* located at Point p, or else an empty collection.
* If a List or Set was passed in, it is returned.
*/
Layer.prototype.findObjectsAt = function(p, navig, pred, coll) {
  if (navig === undefined/*notpresent*/) navig = null;
  if (pred === undefined/*notpresent*/) pred = null;
  if (!(coll instanceof List) && !(coll instanceof Set)) {
    coll = new Set(GraphObject);
  }
  if (this._pickable === false) return coll;

  // if p is in the viewportBounds we can just look at viewportObjects
  var lay = this._parts;
  var inView = false;
  if (this.diagram.viewportBounds.containsPoint(p)) {
    inView = true;
  }

  var mult = Util.tempPoint();
  var l = lay.length;
  for (var i = l; i--;) {
    var obj = lay.elt(i);
    if (inView === true && obj.getInView() === false) continue;
    if (!obj.isVisible()) continue;
    mult.assign(p);
    mult.transformInverted(obj.allTransforms);
    if (obj.findObjectsAt(mult, navig, pred, coll)) {
      if (navig !== null) obj = navig(obj);
      if (obj && (pred === null || pred(obj))) {
        coll.add(obj);
      }
    }
  }
  Util.freePoint(mult);
  return coll;
};

Layer.prototype['findObjectsIn'] =
/**
* Returns a collection of all {@link GraphObject}s that are inside or that intersect
* a given {@link Rect} in document coordinates.
* <p/>
* If {@link #visible} is false, this method will not find any objects in this layer.
* However, {@link #opacity} does not affect this method.
* @this {Layer}
* @param {Rect} r A Rect in document coordinates.
* @param {function(GraphObject):GraphObject | null=} navig A function taking a GraphObject and
* returning a GraphObject, defaulting to the identity.
* If this function returns null, the given GraphObject will not be included in the results.
* @param {function(GraphObject):boolean | null=} pred A function taking the GraphObject
* returned by navig and returning true if that object should be returned,
* defaulting to a predicate that always returns true.
* @param {*=} partialInclusion Whether an object can match if it merely intersects the rectangular area (true) or
* if it must be entirely inside the rectangular area (false).  The default value is false.
* @param {List|Set=} coll An optional collection (List or Set) to add the results to.
* @return {Iterable} a collection of GraphObjects that will contain all GraphObjects
* located at Point p, or else an empty collection.
* If a List or Set was passed in, it is returned.
*/
Layer.prototype.findObjectsIn = function(r, navig, pred, partialInclusion, coll) {
  if (navig === undefined/*notpresent*/) navig = null;
  if (pred === undefined/*notpresent*/) pred = null;
  if (partialInclusion === undefined/*notpresent*/) partialInclusion = false;
  if (!(coll instanceof List) && !(coll instanceof Set)) {
    coll = new Set(GraphObject);
  }
  if (this._pickable === false) return coll;

  // if r is in the viewportBounds we can just look at viewportObjects
  var lay = this._parts;
  var inView = false;
  if (this.diagram.viewportBounds.containsRect(r)) {
    inView = true;
  }

  var l = lay.length;
  lay = lay._arr;
  for (var i = l; i--;) {
    var obj = lay[i];
    if (inView === true && obj.getInView() === false) continue;
    if (!obj.isVisible()) continue;
    if (obj.findObjectsIn(r, navig, pred, partialInclusion, coll)) {
      if (navig !== null) obj = navig(obj);
      if (obj && (pred === null || pred(obj))) {
        coll.add(obj);
      }
    }
  }

  return coll;
};


/**
* @ignore
* Special internal findObjectsIn that checks an extra predicate, in order to short-circuit some lookups
* @this {Layer}
* @param {Rect} r
* @param {function(GraphObject):GraphObject | null} navig
* @param {function(GraphObject):boolean | null} pred
* @param {*} partialInclusion
* @param {List|Set} coll
* @param {function(GraphObject):boolean | null} extraPred
* @param {boolean} inView
* @return {Iterable}
*/
Layer.prototype.findObjectsIn2 = function(r, navig, pred, partialInclusion, coll, extraPred, inView) {
  if (this._pickable === false) return coll;

  var lay = this._parts;
  var l = lay.length;
  lay = lay._arr;
  for (var i = l; i--;) {
    var obj = lay[i];
    if (inView === true && obj.getInView() === false) continue;
    if (!extraPred(obj)) continue; // Extra predicate
    if (!obj.isVisible()) continue;
    if (obj.findObjectsIn(r, navig, pred, partialInclusion, coll)) {
      if (navig !== null) obj = navig(obj);
      if (obj && (pred === null || pred(obj))) {
        coll.add(obj);
      }
    }
  }

  return coll;
};

Layer.prototype['findObjectsNear'] =
/**
* Returns a collection of all {@link GraphObject}s that are within a certain distance
* of a given point in document coordinates.
* <p/>
* If {@link #visible} is false, this method will not find any objects in this layer.
* However, {@link #opacity} does not affect this method.
* @this {Layer}
* @param {Point} p A Point in document coordinates.
* @param {number} dist The distance from the point.
* @param {function(GraphObject):GraphObject | null=} navig A function taking a GraphObject and
* returning a GraphObject, defaulting to the identity.
* If this function returns null, the given GraphObject will not be included in the results.
* @param {function(GraphObject):boolean | null=} pred A function taking the GraphObject
* returned by navig and returning true if that object should be returned,
* defaulting to a predicate that always returns true.
* @param {*=} partialInclusion Whether an object can match if it merely intersects the circular area (true) or
* if it must be entirely inside the circular area (false).  The default value is true.
* @param {List|Set=} coll An optional collection (List or Set) to add the results to.
* @return {Iterable} a collection of GraphObjects that will contain all GraphObjects
* located at Point p, or else an empty collection.
* If a List or Set was passed in, it is returned.
*/
Layer.prototype.findObjectsNear = function(p, dist, navig, pred, partialInclusion, coll) {
  if (navig === undefined/*notpresent*/) navig = null;
  if (pred === undefined/*notpresent*/) pred = null;
  if (partialInclusion === undefined/*notpresent*/) partialInclusion = true;
  if (partialInclusion !== false && partialInclusion !== true) {
    if (partialInclusion instanceof List || partialInclusion instanceof Set) {
      coll = partialInclusion;
    }
    partialInclusion = true;
  }
  if (!(coll instanceof List) && !(coll instanceof Set)) {
    coll = new Set(GraphObject);
  }
  if (this._pickable === false) return coll;

  // if p is in the viewportBounds we can just look at viewportObjects
  // ??? but here maybe we want to test objects even if offscreen because they might be "near"?
  var lay = this._parts;
  var inView = false;
  if (this.diagram.viewportBounds.containsPoint(p)) {
    inView = true;
  }

  var mult = Util.tempPoint();
  var distp = Util.tempPoint();
  var l = lay.length;
  for (var i = l; i--;) {
    var obj = lay._arr[i];
    if (inView === true && obj.getInView() === false) continue;
    if (!obj.isVisible()) continue;
    mult.assign(p);
    mult.transformInverted(obj.allTransforms);
    distp._set(p.x + dist, p.y);
    distp.transformInverted(obj.allTransforms);

    if (obj.findObjectsNear(mult, distp, navig, pred, partialInclusion, coll)) {
      if (navig !== null) obj = navig(obj);
      if (obj && (pred === null || pred(obj))) {
        coll.add(obj);
      }
    }
  }
  Util.freePoint(mult);
  Util.freePoint(distp);
  return coll;
};


/**
* @ignore
* @return {Array}
*/
Layer.prototype.getOrthoLinksArray = function() {
  return this._parts._arr;  //?? cannot return _orthoLinks because of missing offscreen links
};

/**
 * @ignore
 * Draws only the parts in the exclusive set or map.
 * @this {Layer}
 * @param {Diagram} diagram
 * @param {Rect=} viewRect an optional alternative viewport rectangle.
 */
Layer.prototype.setInView = function(diagram, viewRect) {
  if (!this.visible) return;
  if (!diagram._invalidViewportObjects) return;

  var parts = this._parts;
  var vpb;
  if (viewRect) {
    vpb = viewRect;
  } else {
    vpb = diagram.viewportBounds;
  }

  var l = parts.length;
  for (var i = 0; i < l; i++) {
    var p = parts._arr[i];
    p._layerIndex = i;
    if (p instanceof Link) {
      if (p._validRoute === false) continue;
    }

    if (p instanceof Adornment && p.adornedPart !== null) continue;

    var ab = p.actualBounds;
    if (ab.intersectsRectPlus(vpb, 10)) { // ??? 10 is an arbitrary amount to cover all adornments
      p.setInView(true);
      // validate p's adornments
      p.validateAdornments();
      for (var ads = p.adornments; ads.next(); ) {
        var ad = ads.value;
        ad.measure(Infinity, Infinity);
        ad.arrange();
        ad.setInView(true);
      }

    } else {
      p.setInView(false);
      if (p.adornments !== null && p.adornments.count > 0) {
        p.validateAdornments();
      }
    }
  }
};

/**
 * @ignore
 * Draws each Part in this layer.
 * @this {Layer}
 * @param {CanvasRenderingContext2D} context
 * @param {Diagram} diagram
 * @param {Rect=} viewRect an optional alternative viewport rectangle.
 * @param {boolean=} showTemporary true if everything should be drawn, false if temporary objects should be omitted.
 */
Layer.prototype.draw = function(context, diagram, viewRect, showTemporary) {
  if (!this.visible) return;
  if (showTemporary === undefined) showTemporary = true;
  if (!showTemporary && this.isTemporary) return;
  if (this._opacity !== 1) context.globalAlpha = this._opacity;

  var parts = this._parts;
  var vpb;
  if (viewRect) {
    vpb = viewRect;
  } else {
    vpb = diagram.viewportBounds;
  }

  var ortho = this._orthoLinks;
  ortho.length = 0;
  var scale = diagram.scale;
  var l = parts.length;
  for (var i = 0; i < l; i++) {
    var p = parts._arr[i];
    if (!p.getInView()) continue;
    if (p instanceof Link) {
      if (p.isOrthogonal) ortho.push(p);
      if (p._validRoute === false) continue;
    }
    var ab = p.actualBounds;
    if (ab.width * scale > 1 || ab.height * scale > 1) {
      p.draw(context, diagram);
    } else {
      p.drawSimple(context, diagram);
    }
  }

  // Not strictly necessary since the next layer will always set it,
  // but helpful for debug drawing:
  context.globalAlpha = 1;
};

/**
 * @ignore
 * Draws each Part in this layer.
 * @this {Layer}
 * @param {CanvasRenderingContext2D} context
 * @param {Diagram} diagram
 * @param {Set} exclusion
 */
Layer.prototype.drawExclusion = function(context, diagram, exclusion) {
  if (!this.visible) return;
  context.globalAlpha = this._opacity;

  var parts = this._parts;
  var vpb = diagram.viewportBounds;

  var ortho = this._orthoLinks;
  ortho.length = 0;
  var scale = diagram.scale;
  var l = parts.length;
  for (var i = 0; i < l; i++) {
    var p = parts._arr[i];
    if (!p.getInView()) continue;
    if (exclusion.contains(p)) continue;
    if (p instanceof Link) {
      if (p.isOrthogonal) ortho.push(p);
      if (p._validRoute === false) continue;
    }
    var ab = p.actualBounds;
    if (ab.width * scale > 1 || ab.height * scale > 1) {
      p.draw(context, diagram);
    } else {
      p.drawSimple(context, diagram);
    }
  }

  // Not strictly necessary since the next layer will always set it,
  // but helpful for debug drawing:
  context.globalAlpha = 1;
};

/**
 * @ignore
 * Draws only the parts in the exclusive set or map.
 * @this {Layer}
 * @param {CanvasRenderingContext2D} context
 * @param {Diagram} diagram
 * @param {Set|Map} exclusive
 * @param {Rect=} viewRect an optional alternative viewport rectangle.
 * @param {boolean=} showTemporary show temporary layers or not
 */
Layer.prototype.drawOnly = function(context, diagram, exclusive, viewRect, showTemporary) {
  if (!this.visible) return;
  if (showTemporary === undefined) showTemporary = true;
  if (!showTemporary && this.isTemporary) return;
  context.globalAlpha = this._opacity;

  var parts = this._parts;
  var vpb;
  if (viewRect) {
    vpb = viewRect;
  } else {
    vpb = diagram.viewportBounds;
  }

  var ortho = this._orthoLinks;
  ortho.length = 0;
  var scale = diagram.scale;
  var l = parts.length;
  for (var i = 0; i < l; i++) {
    var p = parts._arr[i];
    if (!p.getInView()) continue;
    if (!exclusive.contains(p)) continue;
    if (p instanceof Link) {
      if (p.isOrthogonal) ortho.push(p);
      if (p._validRoute === false) continue;
    }
    var ab = p.actualBounds;
    if (ab.width * scale > 1 || ab.height * scale > 1) {
      p.draw(context, diagram);
    } else {
      p.drawSimple(context, diagram);
    }
  }

  // Not strictly necessary since the next layer will always set it,
  // but helpful for debug drawing:
  context.globalAlpha = 1;
};


/**
 * @ignore
 * Draws each Part in this layer that intersects a given rect.
 * No invalidation information is changed with the layer's diagram.
 * This is only used by overviews
 * @this {Layer}
 * @param {CanvasRenderingContext2D} context
 * @param {Rect} allowedBounds
 * @param {Diagram} diagram
 * @param {boolean=} showTemporary
 */
Layer.prototype.drawAllowed = function(context, allowedBounds, diagram, showTemporary) {
  if (showTemporary === undefined) showTemporary = true;
  if (!showTemporary && this.isTemporary) return;
  var parts = this._parts;
  var scale = diagram.scale;

  var l = parts.length;
  for (var i = 0; i < l; i++) {
    var p = parts._arr[i];
    var ab = p.actualBounds;
    if (ab.intersectsRect(allowedBounds)) {
      if (ab.width * scale > 1 || ab.height * scale > 1) {
        p.draw(context, diagram);
      } else {
        p.drawSimple(context, diagram);
      }
    }
  }
};

/**
 * @ignore
 * Draws only the parts that intersect with the given rectangles
 * @this {Layer}
 * @param {CanvasRenderingContext2D} context
 * @param {Diagram} diagram
 * @param {Array} rects
 */
Layer.prototype.drawIntersection = function(context, diagram, rects) {
  if (!this.visible) return;
  context.globalAlpha = this._opacity;

  var parts = this._parts;
  var vpb = diagram.viewportBounds;

  var ortho = this._orthoLinks;
  ortho.length = 0;
  var scale = diagram.scale;
  var l = parts.length;
  var rl = rects.length;
  for (var i = 0; i < l; i++) {
    var p = parts._arr[i];
    if (!p.getInView()) continue;
    if (p instanceof Link) {
      if (p.isOrthogonal) ortho.push(p);
      if (p._validRoute === false) continue;
    }
    var ab = p.getDrawnSize(p.actualBounds);
    if (this.intersectsAnyRect(ab, rects, rl, scale)) {
      if (ab.width * scale > 1 || ab.height * scale > 1) {
        p.draw(context, diagram);
      } else {
        p.drawSimple(context, diagram);
      }
    }
  }

  // Not strictly necessary since the next layer will always set it,
  // but helpful for debug drawing:
  context.globalAlpha = 1;
};

/**
 * @ignore
 * Draws only the parts that intersect with the given rectangles
 * @this {Layer}
 * @param {Rect} ab
 * @param {Array} rects
 * @param {number} l
 * @param {number} scale
 */
Layer.prototype.intersectsAnyRect = function(ab, rects, l, scale) {
  // The size of the rectangles is slightly expanded due to the need to clip to integer pixels
  // See the comment in (Diagram.draw) that references (Layer.intersectsAnyRect)
  var posoff = 2 / scale;
  var sizeoff = 4 / scale;
  for (var i = 0; i < l; i++) {
    var r = rects[i];
    if (r[2] === 0 || r[3] === 0) continue;
    if (ab.intersects(r[0] - posoff, r[1] - posoff, r[2] + sizeoff, r[3] + sizeoff)) return true;
  }
  return false;
};

/**
* @ignore
* Call this method to notify about a property having changed value.
* @this {Layer}
* @param {string} propertyname the name of the property.
* @param {*} oldval the previous or old value for the property.
* @param {*} newval the next or new value for the property.
* @param {*=} oldparam an optional value additionally describing the old value.
* @param {*=} newparam an optional value additionally describing the new value.
*/
Layer.prototype.raiseChanged = function(propertyname, oldval, newval, oldparam, newparam) {
  var diagram = this.diagram;
  if (diagram !== null) {
    diagram.raiseChangedEvent(ChangedEvent.Property, propertyname, this, oldval, newval, oldparam, newparam);
  }
};

/**
* @ignore
* @this {Layer}
* @param {number} index
* @param {Part} part
* @param {boolean=} switchingLayers
* @return {number}
*/
Layer.prototype.internalAdd = function(index, part, switchingLayers) {
  var parts = this._parts;
  // set back-pointer to this Layer
  part.setLayer(this);

  // update internal data structures
  if (index >= parts.count) {  // assume add at end
    index = parts.count;
  } else {
    var p = parts.elt(index);
    if (p === part) return -1;  // already there
  }
  parts.insertAt(index, part);
  part.internalAddProtected();

  var diagram = this.diagram;
  if (diagram !== null) {
    if (!switchingLayers) {
      diagram.internalAdd(part);
    } else {
      diagram.invalidateDraw(); // full redraw ??? using AB causes undo/redo issues
    }
  }

  if (part instanceof Group) this.sortZOrder(part);
  return index;
};

/**
 * @ignore
 * @this {Layer}
 * @param {number} index
 * @param {Part} part
 * @param {boolean=} switchingLayers
 * @return {number}
 */
Layer.prototype.internalRemove = function(index, part, switchingLayers) {
  // confirm that the given Part is in fact at the index
  var parts = this._parts;
  if (index < 0 || index >= parts.length) {  // unknown index
    index = parts.indexOf(part);
    if (index < 0) return -1;
  } else {  // known index, but check to be sure
    var p = parts.elt(index);
    if (p !== part) {  // not there?
      index = parts.indexOf(part);
      if (index < 0) return -1;  // really not there
    }
  }

  // update internal data structures
  part.internalRemoveProtected();
  parts.removeAt(index);

  var diagram = this.diagram;
  if (diagram !== null) {
    if (!switchingLayers) {
      diagram.internalRemove(part);
    } else {
      diagram.invalidateDraw(); // full redraw ??? using AB causes undo/redo issues
    }
  }
  // remove back-pointer to its Layer
  part.setLayer(null);

  return index;
};

/**
* @ignore
* Call moveGroupBehind on the given Group and its containingGroup, up the chain.
* @this {Layer}
* @param {Group} g
*/
Layer.prototype.sortZOrder = function(g) {
  while (g !== null) {
    if (g.layer === this) this.moveGroupBehind(g);
    g = g.containingGroup;
  }
};

/**
* @ignore
* Make sure the given Group is behind all of its immediate members.
* Assumes the Group is also in this Layer.
* @this {Layer}
* @param {Group} sg
*/
Layer.prototype.moveGroupBehind = function(sg) {
  if (!sg.memberParts.next()) return;  // and has at least one member
  var idx = -1;  // index of SG
  var min = -1;  // index of first member of SG
  var arr = this._parts._arr;
  var len = arr.length;
  for (var i = 0; i < len; i++) {
    var p = arr[i];
    if (p === sg) {
      idx = i;  // found index of SG
      if (min >= 0) break;
    }
    if (min < 0 && p.containingGroup === sg) {
      min = i;  // found index of first member of SG
      if (idx >= 0) break;
    }
  }
  // If no members of the group are found in this layer, do nothing
  if (min < 0) return;
  // if some member is behind the group, change index of SG to be at MIN
  if (min < idx) {
    var parts = this._parts;
    parts.removeAt(idx);
    parts.insertAt(min, sg);
  }
};

/**
* @ignore
* Remove all Parts from this layer.
* @this {Layer}
*/
Layer.prototype.clear = function() {
  var parts = this._parts.toArray();
  var l = parts.length;
  for (var i = 0; i < l; i++) {
    parts[i].setInView(false);
    this.internalRemove(-1, parts[i]);
  }
};

/**
* Gets an iterator for this Layer's {@link Part}s.
* The Parts can be {@link Node}s, {@link Link}s, {@link Group}s, {@link Adornment}s, or simple {@link Part}s.
* @name Layer#parts
* @function.
* @return {Iterator}
*/
/** @type {Iterator} */
Layer.prototype.parts;
Util.defineReadOnlyProperty(Layer, {parts: 'parts'},
  function() { return this._parts.iterator; }
);

/**
* Gets a backwards iterator for this Layer's {@link Part}s,
* for iterating over the parts in reverse order.
* The Parts can be {@link Node}s, {@link Link}s, {@link Group}s, {@link Adornment}s, or simple {@link Part}s.
* @name Layer#partsBackwards
* @function.
* @return {Iterator}
*/
/** @type {Iterator} */
Layer.prototype.partsBackwards;
Util.defineReadOnlyProperty(Layer, {partsBackwards: 'partsBackwards'},
  function() { return this._parts.iteratorBackwards; }
);

/**
* Gets the {@link Diagram} that is using this Layer.
* @name Layer#diagram
* @function.
* @return {Diagram}
*/
/** @type {Diagram} */
Layer.prototype.diagram;
Util.defineReadOnlyProperty(Layer, {diagram: 'diagram'},
  /** @this {Layer} */
  function() { return this._diagram; }
);

/**
* Gets or sets the name for this layer.
* The initial value is an empty string, which is also the name of the default layer.
* The name should be unique among the diagram's {@link Diagram#layers}.
* @name Layer#name
* @function.
* @return {string}
*/
/** @type {string} */
Layer.prototype.name;
Util.exportProperty(Layer, 'name', Layer.prototype.name);
Util.defineProperty(Layer, {name: 'name'},
  /** @this {Layer} */
  function() { return this._name; },
  /** @this {Layer} */
  function(val) {
    Util.checkPrimitive(val, 'string', Layer, 'name');
    var old = this._name;
    if (old !== val) {
      var d = this.diagram;
      if (d !== null) {
        // don't allow changing name of default layer
        if (old === '') Util.throwError('Cannot rename default Layer to: ' + val);
        var lit = d.layers;
        while (lit.next()) {
          var lay = lit.value;
          if (lay.name === val)
            Util.throwError('Layer.name is already present in this diagram: ' + val);
        }
      }
      this._name = val;
      this.raiseChanged('name', old, val);
      // Change the name of all parts in this layer to match
      var it = this._parts.iterator;
      while (it.next()) {
        var part = it.value;
        part.layerName = this._name;
      }
    }
  }
);

/**
* Gets or sets the opacity for all parts in this layer.
* The value must be between 0.0 (fully transparent) and 1.0 (no additional transparency).
* This value is multiplicative with any existing transparency,
* for instance from a {@link Brush} or image transparency.
* The default value is 1.
* <p/>
* This property, unlike {@link #visible}, does not change whether any objects are found by the "find..." methods.
* @name Layer#opacity
* @function.
* @return {number}
* @since 1.1
*/
/** @type {number} */
Layer.prototype.opacity;
Util.exportProperty(Layer, 'opacity', Layer.prototype.opacity);
Util.defineProperty(Layer, {opacity: 'opacity'},
  /** @this {Layer} */
  function() { return this._opacity; },
  /** @this {Layer} */
  function(val) {
    var old = this._opacity;
    if (old !== val) {
      Util.checkPrimitive(val, 'number', Layer, 'opacity');
      if (val < 0 || val > 1) Util.throwRangeError(val, '0 <= val <= 1', Layer, 'opacity');
      this._opacity = val;
      this.raiseChanged('opacity', old, val);
      // and make sure everything is re-drawn
      var diagram = this.diagram;
      if (diagram !== null) {
        diagram.invalidateDraw(); // full redraw needed
      }
    }
  }
);

/**
* Gets or sets whether the objects in this layer are considered temporary.
* @name Layer#isTemporary
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Layer.prototype.isTemporary;
Util.exportProperty(Layer, 'isTemporary', Layer.prototype.isTemporary);
Util.defineProperty(Layer, {isTemporary: 'isTemporary'},
  /** @this {Layer} */
  function() { return this._isTemporary; },
  /** @this {Layer} */
  function(val) {
    var old = this._isTemporary;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Layer, 'isTemporary');
      this._isTemporary = val;
      this.raiseChanged('isTemporary', old, val);
    }
  }
);


/**
* Gets or sets whether the user may view any of the objects in this layer.
* <p/>
* The default value is true -- all visible Parts are drawn.
* When this property is false, all of the "find..." methods will fail to find parts that are in this layer.
* @name Layer#visible
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Layer.prototype.visible;
Util.exportProperty(Layer, 'visible', Layer.prototype.visible);
Util.defineProperty(Layer, { visible: 'visible' },
  /** @this {Layer} */
  function() { return this._visible; },
  /** @this {Layer} */
  function(val) {
    var old = this._visible;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Layer, 'visible');
      this._visible = val;
      this.raiseChanged('visible', old, val);
      // update adornments for all parts in this layer
      var it = this._parts.iterator;
      while (it.next()) {
        var part = it.value;
        if (val) {
          part.updateAdornments();
        } else {
          part.clearAdornments();
        }
      }
      // and make sure everything is re-drawn
      var diagram = this.diagram;
      if (diagram !== null) {
        diagram.invalidateDraw(); // full redraw needed
      }
    }
  }
);

/**
* Gets or sets whether methods such as {@link #findObjectAt} find any of the objects in this layer.
* <p/>
* The default value is true.
* When this property is false, all of the "find..." methods will fail to find parts that are in this layer.
* <p/>
* Note that setting pickable to false does not prevent users from selecting nodes.
* It does prevent them from selecting nodes by clicking on them,
* but does not prevent selection through other mechanisms such as the {@link DragSelectingTool} or
* {@link CommandHandler#selectAll} or calls to {@link Diagram#select}.
* <p/>
* You can control whether individual GraphObjects are "hittable" by setting {@link GraphObject#pickable}.
* @name Layer#pickable
* @function.
* @return {boolean}
* @since 1.2
*/
/** @type {boolean} */
Layer.prototype.pickable;
Util.exportProperty(Layer, 'pickable', Layer.prototype.pickable);
Util.defineProperty(Layer, { pickable: 'pickable' },
  /** @this {Layer} */
  function() { return this._pickable; },
  /** @this {Layer} */
  function(val) {
    var old = this._pickable;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Layer, 'pickable');
      this._pickable = val;
      this.raiseChanged('pickable', old, val);
    }
  }
);


// Permissions

/**
* Gets or sets whether the user may copy objects in this layer.
* The initial value is true.
* @name Layer#allowCopy
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Layer.prototype.allowCopy;
Util.exportProperty(Layer, 'allowCopy', Layer.prototype.allowCopy);
Util.defineProperty(Layer, {allowCopy: 'allowCopy'},
  /** @this {Layer} */
  function() { return this._allowCopy; },
  /** @this {Layer} */
  function(val) {
    var old = this._allowCopy;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Layer, 'allowCopy');
      this._allowCopy = val;
      this.raiseChanged('allowCopy', old, val);
    }
  }
);

/**
* Gets or sets whether the user may delete objects in this layer.
* The initial value is true.
* @name Layer#allowDelete
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Layer.prototype.allowDelete;
Util.exportProperty(Layer, 'allowDelete', Layer.prototype.allowDelete);
Util.defineProperty(Layer, {allowDelete: 'allowDelete'},
  /** @this {Layer} */
  function() { return this._allowDelete; },
  /** @this {Layer} */
  function(val) {
    var old = this._allowDelete;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Layer, 'allowDelete');
      this._allowDelete = val;
      this.raiseChanged('allowDelete', old, val);
    }
  }
);

/**
* Gets or sets whether the user may do in-place text editing in this layer.
* The initial value is true.
* @name Layer#allowTextEdit
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Layer.prototype.allowTextEdit;
Util.exportProperty(Layer, 'allowTextEdit', Layer.prototype.allowTextEdit);
Util.defineProperty(Layer, {allowTextEdit: 'allowTextEdit'},
  /** @this {Layer} */
  function() { return this._allowTextEdit; },
  /** @this {Layer} */
  function(val) {
    var old = this._allowTextEdit;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Layer, 'allowTextEdit');
      this._allowTextEdit = val;
      this.raiseChanged('allowTextEdit', old, val);
    }
  }
);

/**
* Gets or sets whether the user may group parts together in this layer.
* The initial value is true.
* @name Layer#allowGroup
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Layer.prototype.allowGroup;
Util.exportProperty(Layer, 'allowGroup', Layer.prototype.allowGroup);
Util.defineProperty(Layer, {allowGroup: 'allowGroup'},
  /** @this {Layer} */
  function() { return this._allowGroup; },
  /** @this {Layer} */
  function(val) {
    var old = this._allowGroup;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Layer, 'allowGroup');
      this._allowGroup = val;
      this.raiseChanged('allowGroup', old, val);
    }
  }
);

/**
* Gets or sets whether the user may ungroup existing groups in this layer.
* The initial value is true.
* @name Layer#allowUngroup
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Layer.prototype.allowUngroup;
Util.exportProperty(Layer, 'allowUngroup', Layer.prototype.allowUngroup);
Util.defineProperty(Layer, {allowUngroup: 'allowUngroup'},
  /** @this {Layer} */
  function() { return this._allowUngroup; },
  /** @this {Layer} */
  function(val) {
    var old = this._allowUngroup;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Layer, 'allowUngroup');
      this._allowUngroup = val;
      this.raiseChanged('allowUngroup', old, val);
    }
  }
);

/**
* Gets or sets whether the user may draw new links in this layer.
* The initial value is true.
* @name Layer#allowLink
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Layer.prototype.allowLink;
Util.exportProperty(Layer, 'allowLink', Layer.prototype.allowLink);
Util.defineProperty(Layer, {allowLink: 'allowLink'},
  /** @this {Layer} */
  function() { return this._allowLink; },
  /** @this {Layer} */
  function(val) {
    var old = this._allowLink;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Layer, 'allowLink');
      this._allowLink = val;
      this.raiseChanged('allowLink', old, val);
    }
  }
);

/**
* Gets or sets whether the user may reconnect existing links in this layer.
* The initial value is true.
* @name Layer#allowRelink
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Layer.prototype.allowRelink;
Util.exportProperty(Layer, 'allowRelink', Layer.prototype.allowRelink);
Util.defineProperty(Layer, {allowRelink: 'allowRelink'},
  /** @this {Layer} */
  function() { return this._allowRelink; },
  /** @this {Layer} */
  function(val) {
    var old = this._allowRelink;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Layer, 'allowRelink');
      this._allowRelink = val;
      this.raiseChanged('allowRelink', old, val);
    }
  }
);

/**
* Gets or sets whether the user may move objects in this layer.
* The initial value is true.
* @name Layer#allowMove
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Layer.prototype.allowMove;
Util.exportProperty(Layer, 'allowMove', Layer.prototype.allowMove);
Util.defineProperty(Layer, {allowMove: 'allowMove'},
  /** @this {Layer} */
  function() { return this._allowMove; },
  /** @this {Layer} */
  function(val) {
    var old = this._allowMove;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Layer, 'allowMove');
      this._allowMove = val;
      this.raiseChanged('allowMove', old, val);
    }
  }
);

/**
* Gets or sets whether the user may reshape parts in this layer.
* The initial value is true.
* @name Layer#allowReshape
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Layer.prototype.allowReshape;
Util.exportProperty(Layer, 'allowReshape', Layer.prototype.allowReshape);
Util.defineProperty(Layer, {allowReshape: 'allowReshape'},
  /** @this {Layer} */
  function() { return this._allowReshape; },
  /** @this {Layer} */
  function(val) {
    var old = this._allowReshape;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Layer, 'allowReshape');
      this._allowReshape = val;
      this.raiseChanged('allowReshape', old, val);
    }
  }
);

/**
* Gets or sets whether the user may resize parts in this layer.
* The initial value is true.
* @name Layer#allowResize
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Layer.prototype.allowResize;
Util.exportProperty(Layer, 'allowResize', Layer.prototype.allowResize);
Util.defineProperty(Layer, {allowResize: 'allowResize'},
  /** @this {Layer} */
  function() { return this._allowResize; },
  /** @this {Layer} */
  function(val) {
    var old = this._allowResize;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Layer, 'allowResize');
      this._allowResize = val;
      this.raiseChanged('allowResize', old, val);
    }
  }
);

/**
* Gets or sets whether the user may rotate parts in this layer.
* The initial value is true.
* @name Layer#allowRotate
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Layer.prototype.allowRotate;
Util.exportProperty(Layer, 'allowRotate', Layer.prototype.allowRotate);
Util.defineProperty(Layer, {allowRotate: 'allowRotate'},
  /** @this {Layer} */
  function() { return this._allowRotate; },
  /** @this {Layer} */
  function(val) {
    var old = this._allowRotate;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Layer, 'allowRotate');
      this._allowRotate = val;
      this.raiseChanged('allowRotate', old, val);
    }
  }
);

/**
* Gets or sets whether the user may select objects in this layer.
* The initial value is true.
* @name Layer#allowSelect
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Layer.prototype.allowSelect;
Util.exportProperty(Layer, 'allowSelect', Layer.prototype.allowSelect);
Util.defineProperty(Layer, {allowSelect: 'allowSelect'},
  /** @this {Layer} */
  function() { return this._allowSelect; },
  /** @this {Layer} */
  function(val) {
    var old = this._allowSelect;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Layer, 'allowSelect');
      this._allowSelect = val;
      this.raiseChanged('allowSelect', old, val);
    }
  }
);

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
Diagram
Palette
*/


/**
 * Construct an empty Diagram for a particular DIV HTML element.
 * <p>
 * You will normally initialize properties of the Diagram that control its appearance and behavior.
 * These properties include:
 * <ul>
 * <li>templates (such as {@link #nodeTemplate} or {@link #linkSelectionAdornmentTemplate}),</li>
 * <li>an automatic layout (if desired, {@link #layout}),</li>
 * <li>positioning or scaling (such as {@link #initialContentAlignment} or {@link #initialAutoScale}),</li>
 * <li>permissions (such as {@link #isReadOnly} or {@link #allowDelete}), or</li>
 * <li>Tool or CommandHandler customization (such as {@link CommandHandler#archetypeGroupData} or
 * {@link Tool#isEnabled}): <code>diagram.toolManager.dragSelectingTool.isEnabled = false;</code>.</li>
 * </ul>
 * Then you will need to construct a Model (usually a {@link GraphLinksModel}) for the Diagram,
 * initialize its data by setting its {@link Model#nodeDataArray} and other properties,
 * and then set the diagram's {@link #model}.
 * <p>
 * Finally you may wish to enable undo/redo: <code>diagram.undoManager.isEnabled = true;</code>
 * <p>
 * It is commonplace to use the static method {@link GraphObject.make} to build a Diagram:
 * <pre>
 *  var $ = go.GraphObject.make;
 *
 *  var diagram =
 *    $(go.Diagram, "myDiagramDiv",
 *      {
 *        initialContentAlignment: go.Spot.Center,
 *        allowZoom: false,
 *        "grid.visible": true,  // display a background grid for the whole diagram
 *        "grid.gridCellSize": new go.Size(20, 20),
 *        // allow double-click in background to create a new node
 *        "clickCreatingTool.archetypeNodeData": { text: "Node" },
 *        // allow Ctrl-G to call the groupSelection command
 *        "commandHandler.archetypeGroupData":
 *            { text: "Group", isGroup: true, color: "blue" },
 *        "toolManager.hoverDelay": 100,  // how quickly tooltips are shown
 *        // mouse wheel zooms instead of scrolls
 *        "toolManager.mouseWheelBehavior": go.ToolManager.WheelZoom,
 *        "commandHandler.copiesTree": true,  // for the copy command
 *        "commandHandler.deletesTree": true, // for the delete command
 *        "draggingTool.dragsTree": true,  // dragging for both move and copy
 *        "draggingTool.isGridSnapEnabled": true,
 *        layout: $(go.TreeLayout,
 *                  { angle: 90, sorting: go.TreeLayout.SortingAscending })
 *      });
 * </pre>
 * @constructor
 * @param {Element|string=} div A reference to a DIV HTML element or its ID as a string.
 * If no DIV is supplied one will be created in memory. The Diagram's {@link Diagram#div} property
 * can then be set later on.
 * @class
 * A Diagram is associated with an HTML DIV element. Constructing a Diagram creates
 * an HTML Canvas element which it places inside of the given DIV element, in addition to several helper DIVs.
 * <b>GoJS</b> will manage the contents of this DIV -- you should not modify the contents of the DIV,
 * although you may style the given DIV (background, border, etc) and position and size it as needed.
 * <p>
 * The diagram will draw onto the Canvas element, which is what users actually see.
 * <p>
 * Each Diagram holds a set of {@link Layer}s each of which holds some number of {@link Part}s
 * such as {@link Node}s and {@link Link}s.
 * Each {@link Part} consists of {@link GraphObject}s such as {@link TextBlock}s and {@link Shape}s
 * and {@link Panel}s holding yet more GraphObjects.
 * <p>
 * A Diagram and its Parts provide the visual representation of a {@link Model} that holds JavaScript
 * data objects for the nodes and the links.
 * The model provides the way to recognize the relationships between the data.
 * <p>
 * A diagram will automatically create {@link Node}s and {@link Link}s corresponding to the model data.
 * The diagram has a number of named templates it uses to create the actual parts:
 * {@link #nodeTemplateMap}, {@link #groupTemplateMap}, and {@link #linkTemplateMap}.
 * Each template may have some data {@link Binding}s that set the part's {@link GraphObject}s' properties
 * based on the value of properties of the data.
 * <p class="box">
 * See the <a href="../../samples/minimal.html">Minimal</a> sample for a simple example of
 * creating a Diagram and setting its model.
 * Read about models on the <a href="../../intro/usingModels.html">Using Models</a> page in the introduction.
 * <hr/>
 * A diagram is responsible for scrolling ({@link #position}) and zooming ({@link #scale}) all of the parts that it shows.
 * Each {@link Part} occupies some area given by its {@link GraphObject#actualBounds}.
 * <p>
 * The union of all of the parts' bounds constitutes the {@link #documentBounds}.
 * The document bounds determines the area that the diagram can be scrolled to.
 * There are several properties that you can set, such as {@link #initialContentAlignment},
 * that control the initial size and position of the diagram contents.
 * <p>
 * At any later time you can also explicitly set the {@link #position} and/or {@link #scale} to
 * get the appearance that you want.  But you may find it easier to call methods to get the desired effect.
 * For example, if you want to make a particular Node be centered in the viewport,
 * call either {@link #centerRect} or {@link #scrollToRect} with the Node's {@link GraphObject#actualBounds},
 * depending on whether or not you want the view to be scrolled if the node is already in view.
 * <p class="box">
 * Read in the Introduction about <a href="../../intro/viewport.html">Viewports</a>
 * and the <a href="../../intro/initialView.html">Initial Viewport</a>.
 * <hr/>
 * You can have the diagram perform automatic layouts of its nodes and links by setting
 * {@link #layout} to an instance of the {@link Layout} subclass of your choice.
 * The default {@link #layout} is an instance of the {@link Layout} base class that ignores links and
 * only positions {@link Node}s that do not have a location.
 * This default layout will allow you to programmatically position nodes (including by loading
 * from a database) and will also allow the user to manually position nodes using the {@link DraggingTool}.
 * <p>
 * If you do supply a particular layout as the {@link #layout}, you can control which {@link Part}s it operates
 * on by setting {@link Part#isLayoutPositioned}.
 * Normally, of course, it works on all top-level nodes and links.
 * The layout is performed both after the model is first loaded as well as after any part is added or removed
 * or changes visibility or size.
 * You can disable the initial layout by setting {@link Layout#isInitial} to false.
 * You can disable later automatic layouts by setting {@link Layout#isOngoing} to false.
 * <p class="box">
 * See the <a href="../../intro/layouts.html">Layouts</a> page in the Introduction for a summary of layout behavior.
 * <p>
 * A diagram maintains a collection of selected parts, the {@link Diagram#selection}.
 * To select a Part you set its {@link Part#isSelected} property to true.
 * <p>
 * There are many properties, named "allow...", that control what operations the user
 * may perform on the parts in the diagram.  These correspond to the same named
 * properties on {@link Layer} that govern the behavior for those parts in a particular layer.
 * Furthermore for some of these properties there are corresponding properties on
 * {@link Part}, named "...able", that govern the behavior for that individual part.
 * For example, the {@link #allowCopy} property corresponds to {@link Layer#allowCopy} and
 * to the property {@link Part#copyable}.
 * The {@link Part#canCopy} predicate is false if any of these properties is false.
 * <p class="box">
 * See the <a href="../../intro/permissions.html">Permissions</a> page for a more thorough discussion.
 * <p>
 * The {@link #commandHandler} implements various standard commands,
 * such as the {@link CommandHandler#deleteSelection} method and the
 * {@link CommandHandler#canDeleteSelection} predicate.
 * <p class="box">
 * See the <a href="../../intro/commands.html">Commands</a> page for a listing of keyboard commands and
 * the use of commands in general.
 * <p>
 * The diagram supports modular behavior for mouse events by implementing "tools".
 * All mouse and keyboard events are represented by {@link InputEvent}s and redirected
 * to the {@link #currentTool}.
 * The default tool is an instance of {@link ToolManager} which keeps three lists of mode-less tools:
 * {@link ToolManager#mouseDownTools}, {@link ToolManager#mouseMoveTools}, and {@link ToolManager#mouseUpTools}.
 * The ToolManager searches these lists when a mouse event happens to find the first tool that can run.
 * It then makes that tool the new {@link #currentTool}, where it can continue to process input events.
 * When the tool is done, it stops itself, causing the {@link #defaultTool} to be the new {@link #currentTool}.
 * <p>
 * Mouse-down tools include:
 * <ul>
 *   <li>{@link ToolManager#actionTool}, to support objects like "buttons"</li>
 *   <li>{@link ToolManager#relinkingTool}, to reconnect an existing link</li>
 *   <li>{@link ToolManager#linkReshapingTool}, to modify the route of an existing link</li>
 *   <li>{@link ToolManager#resizingTool}, to change the size of an object</li>
 *   <li>{@link ToolManager#rotatingTool}, to change the angle of an object</li>
 * </ul>
 * Mouse-move tools include:
 * <ul>
 *   <li>{@link ToolManager#linkingTool}, to draw a new link</li>
 *   <li>{@link ToolManager#draggingTool}, to move or copy the selection</li>
 *   <li>{@link ToolManager#dragSelectingTool}, to select parts within a rectangular area</li>
 *   <li>{@link ToolManager#panningTool}, to pan the diagram</li>
 * </ul>
 * Mouse-up tools include:
 * <ul>
 *   <li>{@link ToolManager#contextMenuTool}, to manage context menus</li>
 *   <li>{@link ToolManager#textEditingTool}, to support in-place text editing</li>
 *   <li>{@link ToolManager#clickCreatingTool}, to create new parts where the user clicks</li>
 *   <li>{@link ToolManager#clickSelectingTool}, to select parts</li>
 * <p>
 * </ul>
 * <p>
 * You can also run a tool in a modal fashion by explicitly setting {@link #currentTool}.
 * That tool will keep running until some code replaces the {@link #currentTool}/
 * This normally happens when the current tool calls {@link Tool#stopTool}, such as on a mouse-up event.
 * <p class="box">
 * See the <a href="../../intro/tools.html">Tools</a> page for a listing of predefined tools and how they operate.
 * <p>
 * A diagram raises various {@link DiagramEvent}s when interesting things happen that may have affected the whole diagram.
 * See the documentation for {@link DiagramEvent} for a complete listing.
 */
function Diagram(div) {
  if (arguments.length > 1) {
    Util.throwError('Diagram constructor can only take one optional argument, the DIV HTML element or its id.');
  }
  Util.uniqueHash(this);
  // reset the list of diagrams traversed
  Util.diagramsTraversed = [];

  // set to false at end of constructor
  /** @type {boolean} */
  this._isAligning = true;

  // for now, set scrollBarBreadth for every Diagram
  /** @type {number} */
  this._scrollBarBreadth = 17; // change when document is loaded, but 17 is the standard for most browsers
  var d = this;
  /** @ignore */
  var setFunc = function() {
    document.removeEventListener('DOMContentLoaded', setFunc, false);
    d.setScrollWidth();
  };
  if (document.body !== null) {
    this.setScrollWidth();
  } else {
    document.addEventListener('DOMContentLoaded', setFunc, false);
  }

  /** @type {List} */
  this._layers = new List(Layer);
  this._canvas = null; // (main) canvas
  this._ctx = null; // the 2D context of this._canvas
  /** @type {Element} */
  this._div = null; // div by ID

  // Padding and border style widths for mouse offsets
  this._stylePaddingLeft = null;
  this._stylePaddingTop = null;
  this._styleBorderLeft = null;
  this._styleBorderTop = null;

  /** @type {Object} */
  this._renderingHints = null;

  /** @type {Point} */
  this._position = new Point(NaN, NaN).freeze();
  /** @type {number} */
  this._scale = 1;
  /** @type {Point} */
  this._initialPosition = new Point(NaN, NaN).freeze();
  /** @type {number} */
  this._initialScale = NaN;

  /** @type {number} */
  this._minScale = 0.0001;
  /** @type {number} */
  this._maxScale = 100;

  /** @type {Transform} */
  this._transform = new Transform();
  /** @type {Point} */
  this._zoomPoint = new Point(NaN, NaN).freeze();
  /** @type {Rect} */
  this._fixedBounds = new Rect(NaN, NaN, NaN, NaN).freeze();
  /** @type {EnumValue} */
  this._autoScale = Diagram.None;
  /** @type {Spot} */
  this._contentAlignment = Spot.Default;
  /** @type {EnumValue} */
  this._initialAutoScale = Diagram.None;
  /** @type {Spot} */
  this._initialContentAlignment = Spot.Default;
  /** @type {Spot} */
  this._initialDocumentSpot = Spot.TopLeft;
  /** @type {Spot} */
  this._initialViewportSpot = Spot.TopLeft;

  /** @type {Set} */
  this._invalidObjects = new Set(GraphObject);
  /** @type {boolean} */
  this._invalidDraw = true;
  /** @type {Map} */
  this._delayedGeometries = new Map(Link, Rect);
  /** @type {boolean} */
  this._drawTainted = true;

  // private for autoScroll
  /** @type {number} */
  this._autoScrollTime = 250;
  /** @type {number} */
  this._autoScrollDelay = 1000;
  // null or {} with 'id' and 'isEnabled' attributes
  /** @type {Object} */
  this._autoScrollTimer = null;
  // public for autoScroll
  /** @type {Margin} */
  this._autoScrollRegion = new Margin(16, 16, 16, 16).freeze();

  // timers and animation
  /** @type {boolean} */
  this._updateQueued = false;
  /** @type {boolean} */
  this._updateLayoutQueued = false;
  /** @type {boolean} */
  this._firstUpdate = true;

  // Events
  /** @type {InputEvent} */
  this._firstInput = new InputEvent();
  /** @type {InputEvent} */
  this._previousInput = new InputEvent();
  /** @type {InputEvent} */
  this._lastInput = new InputEvent();
  /** @type {List} */
  this._changedListeners = null;
  /** @type {number} */
  this._tapTimer = -1;
  /** @type {boolean} */
  this._tapHeld = false;

  /** @type {Map} */
  this._diagramListeners = new Map('string', List);
  /** @type {Map} */
  this._diagramEventNames = new Map('string', 'string');
  this._setupDiagramEvents();

  /** @type {Set} */
  this._nodes = new Set(Node);
  /** @type {Set} */
  this._topLevelGroups = new Set(Group);
  /** @type {Set} */
  this._links = new Set(Link);
  /** @type {Set} */
  this._parts = new Set(Part);
  /** @type {boolean} */
  this._isTreePathToChildren = true;
  /** @ignore @type {boolean} */
  this._isCollapsingExpanding = false;
  /** @type {EnumValue} */
  this._validCycle = Diagram.CycleAll;

  // Tools
  /** @type {ToolManager} */
  this._toolManager = null;
  /** @type {Tool} */
  this._defaultTool = null;
  /** @type {Tool} */
  this._currentTool = null;

  /** @type {string} */
  this._currentCursor = '';
  /** @type {string} */
  this._defaultCursor = 'auto';
  /** @type {function(InputEvent)|null} */
  this._click = null;
  /** @type {function(InputEvent)|null} */
  this._doubleClick = null;
  /** @type {function(InputEvent)|null} */
  this._contextClick = null;
  /** @type {function(InputEvent)|null} */
  this._mouseOver = null;
  /** @type {function(InputEvent)|null} */
  this._mouseHover = null;
  /** @type {function(InputEvent)|null} */
  this._mouseHold = null;
  /** @type {function(InputEvent)|null} */
  this._mouseDragOver = null;
  /** @type {function(InputEvent)|null} */
  this._mouseDrop = null;
  /** @type {Part} */
  this._toolTip = null;
  /** @type {Part} */
  this._contextMenu = null;

  // for iPad only right now
  /** @type {boolean} */
  this._hasGestureZoom = true;
  /** @type {boolean} */
  this._alternateCoordinates = false;
  /** @type {boolean} */
  this._mouseOverQueued = false;

  /** @type {CommandHandler} */
  this._commandHandler = null;
  /** @type {boolean} */
  this._addsToTemporaryLayer = false;

  /** @type {boolean} */
  this._skipsUndoManager = false;

  /** @type {boolean} */
  this._skipsBoundsUpdates = false;

  /** @type {boolean} */
  this._isUpdatingModel = true;
  /** @type {boolean} */
  this._isUpdating = false;
  /** @type {Model} */
  this._model = null;

  var diag = this;
  /** @type {function(ChangedEvent)} */
  this._modelBindingHandler = function(e) { diag.doModelDataChanged(e); };
  /** @type {function(ChangedEvent)} */
  this._modelChangedHandler = function(e) { diag.doModelChanged(e); };

  /** @type {Map} */
  this._dataPartMap = new Map(Object, Part);
  /** @type {Map} */
  this._dataLinkMap = new Map(Object, Link);
  /** @type {Map} */
  this._itemArrayPanelsMap = new Map(Object, Array);  // Array of Panel

  /** @type {boolean} */
  this._isReadOnly = false;
  /** @type {boolean} */
  this._isEnabled = true;
  /** @type {boolean} */
  this._allowClipboard = true;
  /** @type {boolean} */
  this._allowCopy = true;
  /** @type {boolean} */
  this._allowDelete = true;
  /** @type {boolean} */
  this._allowDragOut = false;
  /** @type {boolean} */
  this._allowDrop = false;
  /** @type {boolean} */
  this._allowTextEdit = true;
  /** @type {boolean} */
  this._allowGroup = true;
  /** @type {boolean} */
  this._allowUngroup = true;
  /** @type {boolean} */
  this._allowInsert = true;
  /** @type {boolean} */
  this._allowLink = true;
  /** @type {boolean} */
  this._allowRelink = true;
  /** @type {boolean} */
  this._allowMove = true;
  /** @type {boolean} */
  this._allowReshape = true;
  /** @type {boolean} */
  this._allowResize = true;
  /** @type {boolean} */
  this._allowRotate = true;
  /** @type {boolean} */
  this._allowSelect = true;
  /** @type {boolean} */
  this._allowUndo = true;
  /** @type {boolean} */
  this._allowZoom = true;

  /** @type {boolean} */
  this._isMouseCaptured = false;
  /** @type {boolean} */
  this._isMouseOverDiagram = false;


  // Scrollbars
  /** @type {boolean} */
  this._hasHorizontalScrollbar = true;
  /** @type {boolean} */
  this._hasVerticalScrollbar = true;

  /** @type {boolean} */
  this._allowHorizontalScroll = true;
  /** @type {boolean} */
  this._allowVerticalScroll = true;

  // defaults for these?
  /** @type {number} */
  this._scrollHorizontalLineChange = 16;
  /** @type {number} */
  this._scrollVerticalLineChange = 16;
  /** @type {boolean} */
  this._scrollBarMoving = false;
  /** @type {boolean} */
  this._scrollBarClicked = false;
  /** @type {Element} */
  this._scrollHorizontalParent = null;
  /** @type {Element} */
  this._scrollVerticalParent = null;
  /** @type {Element} */
  this._scrollHelperHorizontal = null;
  /** @type {Element} */
  this._scrollHelperVertical = null;

  /** @type {Margin} */
  this._padding = new Margin(5).freeze();

  /** @type {Set} */
  this._selection = new Set(Part).freeze();
  /** @type {number} */
  this._maxSelectionCount = 999999999;

  // invalidation
  /** @type {boolean} */
  this._invalidDocBounds = true;
  /** @type {boolean} */
  this._invalidScrollBars = true;
  /** @type {boolean} */
  this._invalidViewportObjects = true;

  // Hidden private only for use in draw and onscroll
  /** @type {boolean} */
  this._hasHScroll = false;
  /** @type {boolean} */
  this._hasVScroll = false;

  /** @type {number} */
  this._htmlLeft = 0;
  /** @type {number} */
  this._htmlTop = 0;

  /** @type {Layout} */
  this._layout = null;
  /** @type {boolean} */
  this._anyLayoutInvalid = true;
  /** @type {boolean} */
  this._initialLayoutCompleted = false;

  /** @type {PositionArray} */
  this._positions = null;

  // For gesture events:
  /** @type {number} */
  this._origScale = 1;
  /** @type {boolean} */
  this._gestureStarted = false;
  /** @type {number} */
  this._startDist = 0;

  // Internal so we don't have to allocate so many:
  /** @type {Rect} */
  this._viewportBounds = new Rect(NaN, NaN, NaN, NaN).freeze();
  /** @type {Rect} */
  this._documentBounds = new Rect(NaN, NaN, NaN, NaN).freeze();

  /** @type {Set} */
  this._overviews = new Set(); // collection of all observing overviews //??? NO, ought to be using standard DiagramListener mechanism

  this._setupLayers();

  /** @type {Map} */
  this._nodeTemplateMap = null;
  /** @type {Map} */
  this._groupTemplateMap = null;
  /** @type {Map} */
  this._linkTemplateMap = null;

  /** @type {Node} */
  this._defaultNodeTemplate = null;
  /** @type {Group} */
  this._defaultGroupTemplate = null;
  /** @type {Link} */
  this._defaultLinkTemplate = null;

  /** @type {Adornment} */
  this._nodeSelectionAdornmentTemplate = null;
  /** @type {Adornment} */
  this._groupSelectionAdornmentTemplate = null;
  /** @type {Adornment} */
  this._linkSelectionAdornmentTemplate = null;

  this._setupTemplates();

  /** @type {Panel} */
  this._grid = null;
  /** @type {boolean} */
  this._gridWasVisible = false;

  /** @ignore @type {GraphObject} */
  this.previousEnterLeaveObject = null;
  /** @ignore @type {GraphObject} */
  this.currentEnterLeaveObject = null;

  // setup the ToolManager via property setter
  this.toolManager = new ToolManager();
  this.toolManager.initializeStandardTools();
  this.defaultTool = this.toolManager;
  // initialize currentTool via property setter
  this.currentTool = this.defaultTool;
  // setup the CommandHandler via property setter
  this.commandHandler = new CommandHandler();
  // initialize model via property setter, after setting _modelChangedHandler
  this.model = new GraphLinksModel();
  this._skipsUndoManager = true;
  // initialize with property setter
  this.layout = new Layout();
  this._skipsUndoManager = false;

  // if no div is supplied we will create one in memory
  if (div === undefined/*notpresent*/) {
    div = document.createElement('div');
  }

  // for optimizations
  this._drawCollectionCanvas = null;
  this._drawCollectionCtx = null;
  // Optimizations when ONLY the viewport changes
  /** @type {boolean} */
  this._viewportOptimizations = true;

  // Optimizations for invalidating specific rectangular areas on the screen
  // Default false because they may be unstable on some platforms
  /** @type {boolean} */
  this._rectOptimizations = false;


  // Will be an empty array or array of Rects if using dirty rectangles
  // Otherwise it may be set to null for a complete redraw
  /** @type {?Array} */
  this._drawingRects = null; // null or an array

  this._helper = new DiagramHelper();
  this._helper.setup(this, div);

  /** @type {number} */
  this._lastTouchCount = 1;
  /** @type {number} */
  this._lastTouchStamp = 0;
  /** @type {Point} */
  this._lastTouchpt = new Point();
  /** @type {number} */
  this._touchDoubleClickDelay = 500;

  // simulated mouse events by a touch interface that we want to record and cancel
  // Some mobile browsers (like Android Default browser)
  // insert a mousedown/mousemove/mouseup and we want to disallow that
  // but doing so gets in the way of using tablet styluses
  // to be used in conjunction with _isAndroid534
  this._simulatedDetected = null;

  // In some versions of android 4.1.1, default browser (AppleWebKit/534.30)
  // the clearRect is broken and we must set canvas.width = canvas.width
  // Mozilla/5.0 (Linux; U; Android 4.1.1; en-us; Galaxy Nexus Build/JRO03O) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30
  this._isAndroid534 = false;
  if (window.navigator && window.navigator.userAgent.indexOf('534.30') > 0 && window.navigator.userAgent.indexOf('Android') > 0) {
    this._isAndroid534 = true;
  }
  this._isIE10 = false;
  if (window.navigator && window.navigator.userAgent.indexOf('MSIE 10.0') > 0) {
    this._isIE10 = true;
  }

  this._isAligning = false;
}

Util.publish('Diagram', Diagram);

/**
* @ignore
*/
Diagram.prototype._setupTemplates = function() {
  // Node Templates
  this._nodeTemplateMap = new Map('string', Part);

  // create the default Node template
  var archnode = new Node();
  var nodet = new TextBlock();
  nodet.bind(new Binding('text', '', Binding.toString));
  archnode.add(nodet);
  this._defaultNodeTemplate = archnode;
  this._nodeTemplateMap.add('', archnode);

  // create the default Comment Node template
  var archcmnt = new Node();
  var nodec = new TextBlock();
  nodec.stroke = 'brown';
  nodec.bind(new Binding('text', '', Binding.toString));
  archcmnt.add(nodec);
  this._nodeTemplateMap.add('Comment', archcmnt);

  // create the default Link Label Node template
  var archllab = new Node();
  archllab.selectable = false;
  archllab.avoidable = false;
  var nodel = new Shape();
  nodel.figure = 'Ellipse';
  nodel.fill = 'black';
  nodel.stroke = null;
  nodel.desiredSize = new Size(3, 3).constant();
  archllab.add(nodel);
  this._nodeTemplateMap.add('LinkLabel', archllab);

  // Group Templates
  this._groupTemplateMap = new Map('string', Group);

  // create the default Group template
  var archgrp = new Group();
  archgrp.selectionObjectName = 'GROUPPANEL';
  archgrp.type = Panel.Vertical;
  var grpt = new TextBlock();
  grpt.font = 'bold 12pt sans-serif';
  grpt.bind(new Binding('text', '', Binding.toString));
  archgrp.add(grpt);
  var grppan = new Panel(Panel.Auto);
  grppan.name = 'GROUPPANEL';
  var grpbord = new Shape();
  grpbord.figure = 'Rectangle';
  grpbord.fill = 'rgba(128,128,128,0.2)';
  grpbord.stroke = 'black';
  grppan.add(grpbord);
  var phold = new Placeholder();
  phold.padding = new Margin(5, 5, 5, 5).constant();
  grppan.add(phold);
  archgrp.add(grppan);
  this._defaultGroupTemplate = archgrp;
  this._groupTemplateMap.add('', archgrp);

  // Link Templates
  this._linkTemplateMap = new Map('string', Link);

  // create the default Link template
  var archlink = new Link();
  var archpath = new Shape();
  archpath.isPanelMain = true;
  archlink.add(archpath);
  var archarrow = new Shape();
  archarrow.toArrow = 'Standard';
  archarrow.fill = 'black';
  archarrow.stroke = null;
  archarrow.strokeWidth = 0;
  archlink.add(archarrow);
  this._defaultLinkTemplate = archlink;
  this._linkTemplateMap.add('', archlink);

  // create the default Comment Link template
  var archcmntlink = new Link();
  var archcmntpath = new Shape();
  archcmntpath.isPanelMain = true;
  archcmntpath.stroke = 'brown';
  archcmntlink.add(archcmntpath);
  this._linkTemplateMap.add('Comment', archcmntlink);

  // Selection Adornments
  // create the default Adornment for selection
  var selad = new Adornment();
  selad.type = Panel.Auto;
  var seladhandle = new Shape();
  seladhandle.fill = null;
  seladhandle.stroke = 'magenta';
  seladhandle.strokeWidth = 2;
  selad.add(seladhandle);
  var selplace = new Placeholder();
  selplace.margin = new Margin(1, 1, 1, 1).constant();
  selad.add(selplace);
  this._nodeSelectionAdornmentTemplate = selad;

  // reuse the default Node Adornment for selection
  this._groupSelectionAdornmentTemplate = selad;

  // create the default Link Adornment for selection
  selad = new Adornment();
  selad.type = Panel.Link;
  seladhandle = new Shape();
  seladhandle.isPanelMain = true;
  seladhandle.fill = null;
  seladhandle.stroke = 'magenta';
  seladhandle.strokeWidth = 0;  // use selection object's strokeWidth
  selad.add(seladhandle);
  this._linkSelectionAdornmentTemplate = selad;
};

/**
* @ignore
*/
Diagram.prototype.setScrollWidth = function() {
  var inner = document.createElement('p');
  inner.style.width = '100%';
  inner.style.height = '200px';
  var outer = document.createElement('div');
  outer.style.position = 'absolute';
  outer.style.visibility = 'hidden';
  outer.style.width = '200px';
  outer.style.height = '150px';
  outer.style.overflow = 'hidden';
  outer.appendChild(inner);
  document.body.appendChild(outer);
  var w1 = inner.offsetWidth;
  outer.style.overflow = 'scroll';
  var w2 = inner.offsetWidth;
  if (w1 === w2) w2 = outer.clientWidth;
  document.body.removeChild(outer);
  this._scrollBarBreadth = (w1 - w2);
};

/**
* @ignore
* @this {Diagram}
* @param {number=} details Optional: If greater than zero, this includes descriptions of each layer.
* @return {string}
*/
Diagram.prototype.toString = function(details) {
  if (details === undefined/*notpresent*/) details = 0;
  var name = '';
  if (this.id) name = this.id;
  if (this.div && this.div.id) name = this.div.id;
  var str = 'Diagram \"' + name + '"';
  if (details <= 0) return str;
  // if details >= 1, talk about the layers
  var lit = this._layers.iterator;
  while (lit.next()) {
    var layer = lit.value;
    str += '\n  ' + layer.toString(details - 1);
  }
  return str;
};

Diagram.prototype['checkProperties'] =
/**
* @ignore
* Return a string describing undeclared properties of this Diagram and its Parts.
* This may return complaints about some of the model data.
* @this {Diagram}
* @return {string}
*/
Diagram.prototype.checkProperties = function() {
  return Util.check(this);
};


Diagram['fromDiv'] =
/**
* This static method gets the {@link Diagram} that is attached to an HTML DIV element.
* @this {Diagram}
* @param {Element|string} div
* @return {Diagram} null if there is no {@link Diagram} associated with the given DIV,
* or if the argument is not a DIV element nor a string naming such a DIV element in the HTML document.
*/
Diagram.fromDiv = function(div) {
  var elt = div;
  if (typeof div === 'string') elt = document.getElementById(div);
  if (elt instanceof HTMLDivElement && elt._diagram instanceof Diagram) return elt._diagram;
  return null;
};

/**
* Gets or sets the Diagram's HTMLDivElement, via an HTML Element ID.
* This is typically set automatically when a Div is supplied as an argument to Diagram's constructor.
* <p>
* Setting this property to a new value will clobber any HTML and
* inner DOM elements inside of both the new and the old divs.
* It will then populate the Div with the elements
* (inner Divs, Canvases) needed for the Diagram to function.
* <p>
* You should not attempt to manually modify the contents of this Div.
* @name Diagram#div
* @function.
* @return {HTMLDivElement}
*/
/** @type {HTMLDivElement} */
Diagram.prototype.div;
Util.exportProperty(Diagram, 'div', Diagram.prototype.div);
Util.defineProperty(Diagram, {div: 'div'},
  /** @this {Diagram} */
  function() { return this._div; },
  /** @this {Diagram} */
  function(val) {
    if (val !== null) Util.checkClass(val, HTMLDivElement, Diagram, 'div');
    if (this._div !== val) {
      var olddiv = this._div;
      if (olddiv !== null) {
        delete olddiv._diagram;
        // Clobber any HTML inside the div
        // Also destroys all inner DOM objects, such as the Canvas and the four scroll-related divs
        olddiv.innerHTML = '';
        if (this._canvas !== null) {
          this._canvas._diagram = null;
          this._canvas.removeEventListener('touchstart', this.touchStart, false);
          this._canvas.removeEventListener('touchmove', this.touchMove, false);
          this._canvas.removeEventListener('touchend', this.touchEnd, false);
        }
        // remove all possible tool timers
        var tools = this._toolManager;
        if (tools !== null) {
          var list = tools._mouseDownTools._arr;
          var l = list.length;
          for (var i = 0; i < l; i++) {
            list[i].cancelWaitAfter();
          }
          list = tools._mouseMoveTools._arr;
          l = list.length;
          for (var i = 0; i < l; i++) {
            list[i].cancelWaitAfter();
          }
          list = tools._mouseUpTools._arr;
          l = list.length;
          for (var i = 0; i < l; i++) {
            list[i].cancelWaitAfter();
          }
        }
        tools.cancelWaitAfter();

        this._canvas = null;
        this._ctx = null;
        window.removeEventListener('resize', this.maybeResize, false);
        // just in case a div was changed while captured:
        window.removeEventListener('mousemove', this.mouseMove, true);
        window.removeEventListener('mousedown', this.mouseDown, true);
        window.removeEventListener('mouseup', this.mouseUp, true);
        window.removeEventListener('mousewheel', this.mouseWheel, true);
        window.removeEventListener('DOMMouseScroll', this.mouseWheel, true);
        window.removeEventListener('mouseout', this.mouseOut, true);
      //} else {
      //  // old div was null
      //  this._initialLayoutCompleted = false;
      }
      this._div = null;  // not val, because setup will also set ._div
      if (val !== null) {
        // if new DIV already attached to a Diagram, detach it first
        var olddiag = val._diagram;
        if (olddiag) {
          olddiag.div = null;
        }
        // attach this Diagram to the new DIV element
        this._helper.setup(this, val);
        this.redraw();
      }
    }
  }
);

// wmq
/**
* @ignore
* @constructor
*/
function DiagramHelper() {
  //this._t = true;
  //this._f = false;
  this._n = 218;
  this._tk = '63ad05bbe23a1786468a4c741b6d2';
  // wmq
  // window.location.origin or document.URL
  // this one uses window.location.href
  // we could strip it: .replace(/.*?:\/\//g, "").replace(Util.decrypt('6dbf01fd'),'')
  // don't even make the property until this very moment
if (this._tk === this['_tk']) {this._e = true; return;}
var n = 'p';
var b = window[Util.decrypt('76a715b2f73f148a')][Util.decrypt('72ba13b5')];

// msappx
if (Util.decrypt('77bb5bb2f32603de') === window[Util.decrypt('76a715b2f73f148a')][Util.decrypt('6aba19a7ec351488')]) {
  try {
  this._e = (!window[Util.decrypt('4da118b7ec2108')]
  ([Util.decrypt('5bb806bfea351a904a84515e1b6d38b6')])
  ([Util.decrypt('49bc19a1e6')])
  ([Util.decrypt('59bd04a1e6380fa5539b')])
  ([Util.decrypt('7bb8069ae7')] === Util.decrypt(Util.ady)));
  if (this._e === false) return;
  this._e = (!window[Util.decrypt('4da118b7ec2108')]
  ([Util.decrypt('5bb806bfea351a904a84515e1b6d38b6')])
  ([Util.decrypt('49bc19a1e6')])
  ([Util.decrypt('59bd04a1e6380fa5539b6c7a197c31bb4cfd3e')])
  ([Util.decrypt('7bb8069ae7')] === Util.decrypt(Util.ady)));
  if (this._e === false) return;
  } catch (ex) {}
}
var l = b[Util.decrypt('76ad18b4f73e')];
for (var i = b[Util.decrypt('73a612b6fb191d')](Util.decrypt('35e7')) + 2; i < l; i++) {
n += b[i];
}
var nn = n[Util.decrypt('73a612b6fb191d')](Util.decrypt(Util.ady)); // index of the address
// if not there, consider looking for localh under some ady domain conditions
// if (nn <= 0) nn = n[Util.decrypt('73a612b6fb191d')](Util.decrypt('76a715b2ef3e149757'));
// must be found and also before the first '/'
this._e = !(nn > 0 && nn < n[Util.decrypt('73a612b6fb191d')](Util.decrypt('35')));
// old way:
//this._e = (0 > window[Util.decrypt('76a715b2f73f148a')][Util.decrypt('72ba13b5')].indexOf(Util.decrypt(Util.ady)));
//&& 0 > window[Util.decrypt('76a715b2f73f148a')][Util.decrypt('72ba13b5')].indexOf(Util.decrypt('7ca11ab6b97954')) // file://
// end old way
  // wmq, if this is true then is enabled, check class
  if (this._e) {
    var dd = document[Util.decrypt('69bc0fbfe6051381469f4c')];
    l = dd.length;
    for (var i = 0; i < l; i++) {
      var classes = null;
      try {
        classes = dd[i][Util.decrypt('79bb0581f63a1e97')];
      } catch(ex) {
        // do nothing
      }
      if (classes === null) continue;
      var ll = classes.length;
      for (var x = 0; x < ll; x++) {
        if (classes[x][Util.decrypt('69ad1ab6e0221496778e4767')] === Util.decrypt('02cncncn')) {
          // this will be the string "rgb(174, 61, 255)" or null
          var test = (classes[x][Util.decrypt('69bc0fbfe6')][Util.decrypt('78a704b7e6242f8b53a8507f1b7b')]);
          if (!test) return; // if null we're done
          // Util.color1 and color2 must be numerical values
          if (test.indexOf(Util.decrypt(Util.color1)) !== -1 && test.indexOf(Util.decrypt(Util.color2)) !== -1) {
            this._e = false;
            break;
          }
        }
      }
      if (this._e === false) break;
    }
  }
  //this._nonpt = new Point(NaN, NaN);
}

/**
* @ignore
* @this {DiagramHelper}
* @param {Diagram} dia
* @param {Object=} e
*/
DiagramHelper.prototype.wmq = function(dia, e) {
  dia.__setTransform();
  if (0 < this._e && this !== this._t) return true;
  return false;
};

DiagramHelper.prototype['t'] =
/**
* @ignore
*/
DiagramHelper.prototype.t = function(e) {
  this._t = null;
};

/**
* @ignore
* Initializes the Diagram. Adds a canvas to the specified div and will
* maintain the canvas' size to always be that of the div.
* This is called automatically if a div is supplied in the Diagram's constructor.
* @this {DiagramHelper}
* @param {Diagram} dia A diagram.
* @param {Object|string} div A reference to a div or its ID as a string.
*/
DiagramHelper.prototype.setup = function(dia, div) {
  if (div === undefined/*notpresent*/ || div === null) {
    Util.throwError('Diagram setup requires an argument DIV.');
  }
  if (dia._div !== null) {
    Util.throwError('Diagram has already completed setup.');
  }

  if (typeof div === 'string') {
    dia._div = document.getElementById(div);
  } else if (div instanceof HTMLDivElement) {
    dia._div = div;
  } else {
    Util.throwError('No DIV or DIV id supplied: ' + div);
  }

  if (dia._div === null) {
    Util.throwError('Invalid DIV id; could not get element with id: ' + div);
  }

  if (dia._div._diagram !== undefined) {
    Util.throwError('Invalid div id; div already has a Diagram associated with it.');
  }

  // We cannot let the div position remain static. If it is, make it relative:
  if (window.getComputedStyle(dia._div, null).position === 'static') {
    dia._div.style.position = 'relative';
  }
  // avoid highlighting upon touch in Android
  dia._div.style['-webkit-tap-highlight-color'] = 'rgba(255, 255, 255, 0)';
  // avoid letting users pan over the Diagram in IE10
  dia._div.style['-ms-touch-action'] = 'none';

  // Clobber any HTML inside the div
  dia._div.innerHTML = '';
  dia._div._diagram = dia;

  // Create a new canvas
  var newCanvas = document.createElement('canvas');
  if (!(newCanvas.getContext && newCanvas.getContext('2d'))) {
    dia._div.innerHTML = 'This text is displayed if your browser does not support the Canvas HTML element.';
    return;
  }
  newCanvas.innerHTML = 'This text is displayed if your browser does not support the Canvas HTML element.';
  if (newCanvas.style !== undefined) {
    newCanvas.style.position = 'absolute';
    newCanvas.style.top = '0px';
    newCanvas.style.left = '0px';
    newCanvas.style.zIndex = '2';

    newCanvas.style.userSelect = 'none';
    newCanvas.style.webkitUserSelect = 'none';
    newCanvas.style.MozUserSelect = 'none'; // capital M is intentional
  }

  newCanvas.width = dia._div.clientWidth || 1;
  newCanvas.height = dia._div.clientHeight || 1;

  // fixes mouse co-ordinate problems when there's a border or padding
  // see _getMouse for more detail
  if (newCanvas.style !== undefined && document.defaultView && document.defaultView.getComputedStyle) {
    dia._stylePaddingLeft = parseInt(document.defaultView.getComputedStyle(
      newCanvas, null)['paddingLeft'], 10) || 0;
    dia._stylePaddingTop = parseInt(document.defaultView.getComputedStyle(
      newCanvas, null)['paddingTop'], 10) || 0;
    dia._styleBorderLeft = parseInt(document.defaultView.getComputedStyle(
      newCanvas, null)['borderLeftWidth'], 10) || 0;
    dia._styleBorderTop = parseInt(document.defaultView.getComputedStyle(
      newCanvas, null)['borderTopWidth'], 10) || 0;
  }

  // Init a temp canvas
  var can = document.createElement('canvas');
  var ctx = can.getContext('2d');
  can.width = 1;
  can.height = 1;
  dia._drawCollectionCanvas = can;
  dia._drawCollectionCtx = ctx;

  var diagram = dia; // closure used for all events in constructor

  dia._htmlTop = 0;
  dia._htmlLeft = 0;
  if (document.body) {
    var html = document.body.parentNode;
    dia._htmlTop = html.offsetTop || 0;
    dia._htmlLeft = html.offsetLeft || 0;
  } else {
    document.addEventListener('load', function() {
      if (document.body) {
        var html = document.body.parentNode;
        diagram._htmlTop = html.offsetTop || 0;
        diagram._htmlLeft = html.offsetLeft || 0;
      }
    }, false);
  }

  newCanvas._diagram = dia;

  // Add the canvas to this class and append it to the div
  dia._canvas = newCanvas;
  dia._ctx = newCanvas.getContext('2d');
  ctx = dia._ctx;

  // wmq
  dia.__setTransform = ctx[Util.decrypt('69ad0287f137159745844d7e')][Util.decrypt('78a118b7')](ctx, 1, 0, 0, 1, 0, 0);
  dia.__drawImage = ctx[Util.decrypt('7eba17a4ca3b1a8346')][Util.decrypt('78a118b7')](ctx, Util.wmq, 4, 4);

  dia._div.insertBefore(newCanvas, dia._div.firstChild);

  // ****************************************
  // DOM scrollbars
  // ****************************************

  var scrollHorizontalParent = document.createElement('div');
  var scrollVerticalParent = document.createElement('div');
  var scrollHelperHorizontal = document.createElement('div');
  var scrollHelperVertical = document.createElement('div');

  scrollHorizontalParent.style.position = 'absolute';
  scrollHorizontalParent.style.overflow = 'auto';
  scrollHorizontalParent.style.width = dia._canvas.width + 'px';
  scrollHorizontalParent.style.height = dia._canvas.height + 'px';
  scrollHorizontalParent.style.zIndex = '1';

  scrollVerticalParent.style.position = 'absolute';
  scrollVerticalParent.style.overflow = 'auto';
  scrollVerticalParent.style.width = dia._canvas.width + 'px';
  scrollVerticalParent.style.height = dia._canvas.height + 'px';
  scrollVerticalParent.style.zIndex = '1';

  scrollHelperHorizontal.style.position = 'absolute';
  scrollHelperHorizontal.style.width = '1px';
  scrollHelperHorizontal.style.height = '1px';

  scrollHelperVertical.style.position = 'absolute';
  scrollHelperVertical.style.width = '1px';
  scrollHelperVertical.style.height = '1px';

  dia._div.appendChild(scrollHorizontalParent);
  dia._div.appendChild(scrollVerticalParent);
  scrollHorizontalParent.appendChild(scrollHelperHorizontal);
  scrollVerticalParent.appendChild(scrollHelperVertical);

  scrollHorizontalParent.onscroll = dia._onscroll;
  scrollHorizontalParent.onmousedown = dia._onscrollClick;
  scrollHorizontalParent._diagram = dia;
  scrollHorizontalParent._scrollHorizontal = true;

  scrollVerticalParent.onscroll = dia._onscroll;
  scrollVerticalParent.onmousedown = dia._onscrollClick;
  scrollVerticalParent._diagram = dia;
  scrollVerticalParent._scrollVertical = true;

  // attach these to the diagram so we can keep track
  dia._scrollHorizontalParent = scrollHorizontalParent;
  dia._scrollVerticalParent = scrollVerticalParent;
  dia._scrollHelperHorizontal = scrollHelperHorizontal;
  dia._scrollHelperVertical = scrollHelperVertical;


  // ****************************************
  // Event handlers
  // ****************************************

  /**
  * @ignore
  * @this {HTMLCanvasElement}
  * @param {Event} e
  */
  dia.preventDefault = function(e) { e.preventDefault(); return false; };

  /**
  * @ignore
  * @this {HTMLCanvasElement}
  * @param {Event} e
  */
  dia.mouseMove = function(e) {
    if (!diagram.isEnabled) return;
    dia._isMouseOverDiagram = true;
    var n = diagram._previousInput;


    if (dia._isAndroid534 && n.isTouchEvent) {
      e.preventDefault();
      e['simulated'] = true;
      diagram._simulatedDetected = e;
      return;
    }

    diagram._previousInput = diagram._lastInput;
    diagram._lastInput = n;
    diagram._commonEvent(diagram, e, n, true);
    if (diagram.simulatedMouseMove(e, new Point(), e.target._diagram)) return;
    diagram.currentTool.doMouseMove();
    if (diagram.currentTool.isBeyondDragSize()) {
      diagram.clearTapTimer();
    }

//    var p = diagram._previousInput;
//    Debug.trace((n.viewPoint.x-p.viewPoint.x).toString() + ',' +
//                (n.viewPoint.y-p.viewPoint.y).toString() + '@' +
//                (n.timestamp-p.timestamp).toString());

    //if (Debug && Debug.paintPoint) Debug.paintPoint(n, diagram);
  };

  /**
  * @ignore
  * @this {HTMLCanvasElement}
  * @param {Event} e
  */
  dia.mouseDown = function(e) {
    if (!diagram.isEnabled) return;
    dia._isMouseOverDiagram = true;
    var n = diagram._previousInput;

    if (dia._isAndroid534 && diagram._simulatedDetected !== null) {
      diagram._simulatedDetected = e;
      e.preventDefault();
      return;
    }

    diagram._previousInput = diagram._lastInput;
    diagram._lastInput = n;
    diagram._commonEvent(diagram, e, n, true);
    n.down = true;
    n.clickCount = e.detail;
    diagram._firstInput = n.copy();

    if (n._event['simulated'] === true) {
      e.preventDefault();
      e['simulated'] = true;
      return;
    }

    if (Debug && Debug.nodeInspector) {
      window.nodeInspector = diagram.findObjectsAt(n.documentPoint);
      //Debug.trace(window.nodeInspector)
    }

    DraggingTool.source = null;
    diagram.currentTool.doMouseDown();

    // we do not want to call maybeHandled on a mouseDown because it may break mouseUp events
    // But we do want to stop the page from initiating autoscroll if we middle mouse click
    if (e.button === 1) { e.preventDefault(); return false; }
  };

  /**
  * @ignore
  * @this {HTMLCanvasElement}
  * @param {Event} e
  */
  dia.mouseUp = function(e) {
    if (!diagram.isEnabled) return;
    dia._isMouseOverDiagram = true;
    var n = diagram._previousInput;

    if (dia._isAndroid534 && diagram._simulatedDetected !== null) {
      diagram._simulatedDetected = null; // last in a string of simulated events
      e.preventDefault();
      return;
    }

    diagram._previousInput = diagram._lastInput;
    diagram._lastInput = n;
    diagram._commonEvent(diagram, e, n, true);
    n.up = true;
    n.clickCount = e.detail;

    // IE10 has a bug with event.detail:
    // http://connect.microsoft.com/IE/feedback/details/789773/ie-increments-event-detail-on-clicks-over-different-locations
    // this is a workaround for that bug.
    if (diagram._isIE10) {
      // potential double click, make sure its close in time and space
      if (e.timeStamp - diagram._lastTouchStamp < diagram._touchDoubleClickDelay &&
          !diagram.currentTool.isBeyondDragSize()) {
        diagram._lastTouchCount++;
      } else {
        diagram._lastTouchCount = 1;
      }
      diagram._lastTouchStamp = e.timeStamp;
      n.clickCount = diagram._lastTouchCount;
    }

    n.bubbles = e.bubbles;
    if (e.target._diagram) n.targetDiagram = e.target._diagram;
    if (diagram.simulatedMouseUp(e, null, new Point(), n.targetDiagram)) {
      //diagram.wasLeftButtonDown = false; ???
      return;
    }
    diagram.currentTool.doMouseUp();
    diagram.stopAutoScroll();
    // We do want to call maybeHandled because if the window is uncapturing the event
    // both a window mouseup and a canvas mouseup will fire. This stops that from happening.
    diagram._maybeHandled(n, e);
  };

  /**
  * @ignore
  * @this {HTMLCanvasElement}
  * @param {Event} e
  */
  dia.mouseWheel = function(e) {
    if (!diagram.isEnabled) return;
    var n = diagram._previousInput;
    diagram._previousInput = diagram._lastInput;
    diagram._lastInput = n;
    diagram._commonEvent(diagram, e, n, true);
    n.bubbles = true; // allow mouse wheel events to be handled by browser scrollbars
    // delta that is nonzero
    if (e.wheelDelta !== undefined) {
      n.delta = e.wheelDelta;
    } else {  // Firefox
       // The measurement units of the detail and wheelDelta properties are different.
      n.delta = -40 * e.detail;
    }
    diagram.currentTool.doMouseWheel();
    // The rest of this event gets cancelled sometimes in Tool's standardMouseWheel
    diagram._maybeHandled(n, e);
  };

  /**
   * @ignore
   * @this {HTMLCanvasElement}
   * @param {Event} e
   */
  dia.mouseOut = function(e) {
    if (!diagram.isEnabled) return;
    dia._isMouseOverDiagram = false;
    var tool = diagram.currentTool;
    // cancel any timer
    tool.cancelWaitAfter();
    // remove any tooltip
    if (tool instanceof ToolManager) tool.hideToolTip();
    //if (Debug && Debug.paintPositionArray) {
    //  Debug.paintPositionArray(diagram);
    //}
  };

  /**
   * @ignore
   * Called when the window changes size. When this occurs, we might need to resize the div.
   * @this {HTMLCanvasElement}
   */
  dia.maybeResize = function() {
    var can = diagram._canvas;
    if (can === null) return;
    var div = diagram._div;
    var vpb = diagram._viewportBounds;
    var sw = 0;
    if (diagram._hasVScroll) sw = diagram._scrollBarBreadth;
    var sh = 0;
    if (diagram._hasHScroll) sh = diagram._scrollBarBreadth;

    if (div.clientWidth === 0 || div.clientHeight === 0) {
      //Util.trace('Diagram div has a width or height of zero');
      return;
    }

    if (div.clientWidth !== can.width + sw || div.clientHeight !== can.height + sh) {
      diagram._invalidScrollBars = true;
      diagram._invalidDraw = true;
      var lay = diagram.layout;
      if (lay !== null && lay.isViewportSized) {
        lay.invalidateLayout();
      }
      if (!diagram._isUpdating) diagram.requestUpdate();
    }
  };

  /**
  * @ignore
  */
  dia.touchStart = function(e) {
    if (!diagram.isEnabled) return;
    diagram._tapHeld = false;

    if (e.touches.length > 1) {
      diagram.currentTool.doCancel();
      if (diagram._hasGestureZoom && Util.supportsGestures) {
        e.preventDefault();
        e.cancelBubble = true;
        return false;
      } else if (diagram._hasGestureZoom) {
        diagram._gestureStarted = true;
        diagram._origScale = diagram.scale;

        var can = dia._canvas;
        var bbox = can.getBoundingClientRect();
        var evt = e.targetTouches[0];
        var t0x = evt.clientX - bbox.left * (can.width / bbox.width);
        var t0y = evt.clientY - bbox.top * (can.height / bbox.height);
        evt = e.targetTouches[1];
        var t1x = evt.clientX - bbox.left * (can.width / bbox.width);
        var t1y = evt.clientY - bbox.top * (can.height / bbox.height);
        var x = t1x - t0x;
        var y = t1y - t0y;
        var dist = Math.sqrt((x * x) + (y * y));
        diagram._startDist = dist;
        e.preventDefault();
        e.cancelBubble = true;
        return false;
      } else {
        diagram.clearTapTimer();
        e.cancelBubble = false;
        return true;
      }
    }

    var n = diagram._previousInput;
    diagram._previousInput = diagram._lastInput;
    diagram._lastInput = n;

    // diagram._commonEvent(diagram, e, n) replaced by the following:
    n.diagram = diagram;
    var mouse = diagram._getMouse(e.targetTouches[0]);
    n.viewPoint = diagram.transformDocToView(mouse);
    n.documentPoint = mouse;
    n.modifiers = 0;
    n.button = 0;
    n.down = true;
    n.up = false;
    n.clickCount = 1;
    n.delta = 0;
    n.handled = false;
    n.bubbles = false;
    n.event = e;
    n.timestamp = Date.now();
    if (e.target._diagram) {
      n.targetDiagram = e.target._diagram;
    } else {
      n.targetDiagram = null;
    }
    n.targetObject = null;

    //n.clickCount = e.detail;
    diagram._firstInput = n.copy();

    DraggingTool.source = null;
    diagram.currentTool.doMouseDown();

    diagram.setTapTimer(n);
    diagram._maybeHandled(n, e);
  };

  /**
  * @ignore
  */
  dia.touchMove = function(e) {
    if (!diagram.isEnabled) return;

    if (e.touches.length > 1) {
      diagram.currentTool.doCancel();
      diagram.clearTapTimer();
      if (diagram._hasGestureZoom && Util.supportsGestures) {
        e.preventDefault();
        e.cancelBubble = true;
        return false;
      } else if (diagram._hasGestureZoom && diagram._gestureStarted && e.targetTouches.length > 1) {
        var can = dia._canvas;
        var bbox = can.getBoundingClientRect();
        var evt = e.targetTouches[0];
        var t0x = evt.clientX - bbox.left * (can.width / bbox.width);
        var t0y = evt.clientY - bbox.top * (can.height / bbox.height);
        evt = e.targetTouches[1];
        var t1x = evt.clientX - bbox.left * (can.width / bbox.width);
        var t1y = evt.clientY - bbox.top * (can.height / bbox.height);
        var x = t1x - t0x;
        var y = t1y - t0y;
        var dist = Math.sqrt((x * x) + (y * y));
        var scale = dist / diagram._startDist;
        var center = new Point(Math.min(t1x, t0x) + Math.max(t1x, t0x) / 2,
                                Math.min(t1y, t0y) + Math.max(t1y, t0y) / 2);

        var oldzoom = diagram.zoomPoint;
        diagram.zoomPoint = center;
        diagram.scale = diagram._origScale * scale;
        diagram.zoomPoint = oldzoom;

        e.preventDefault();
        e.cancelBubble = true;
        return false;
      } else {
        e.cancelBubble = false;
        return true;
      }
    }

    var n = diagram._previousInput;
    diagram._previousInput = diagram._lastInput;
    diagram._lastInput = n;

    var targ = null;
    var mouse;
    var evt = null;
    if (e.changedTouches.length > 0) evt = e.changedTouches[0];
    else if (e.targetTouches.length > 0) evt = e.targetTouches[0];
    n.diagram = diagram;
    if (evt) {
      targ = document.elementFromPoint(evt.clientX, evt.clientY);
      var diag;
      if (targ && targ._diagram) {
        mouse = targ._diagram._getMouse(evt);
        diag = targ._diagram;
      } else {
        mouse = diagram._getMouse(e.changedTouches[0]);
        diag = diagram;
      }
      n.documentPoint = mouse;
      n.viewPoint = diag.transformDocToView(mouse);
    } else if (diagram._previousInput !== null) {
      n.documentPoint = diagram._previousInput.documentPoint;
      n.viewPoint = diagram._previousInput.viewPoint;
      targ = diagram._previousInput.targetDiagram;
    } else if (diagram._firstInput !== null) {
      n.documentPoint = diagram._firstInput.documentPoint;
      n.viewPoint = diagram._firstInput.viewPoint;
      targ = diagram._firstInput.targetDiagram;
    }
    n.modifiers = 0;
    n.button = 0;
    n.down = false;
    n.up = false;
    n.clickCount = 1;
    n.delta = 0;
    n.handled = false;
    n.bubbles = false;
    n.event = e;
    n.timestamp = Date.now();
    if (targ === null) {
      n.targetDiagram = e.target._diagram;
    } else if (targ._diagram) {
      n.targetDiagram = targ._diagram;
    } else {
      n.targetDiagram = null;
    }
    n.targetObject = null;

    if (diagram.currentTool.isBeyondDragSize()) {
      diagram.clearTapTimer();
    }
    if (diagram.simulatedMouseMove(evt ? evt : e, new Point(), n.targetDiagram)) return;

    diagram.currentTool.doMouseMove();
    diagram._maybeHandled(n, e);
  };

  /**
  * @ignore
  */
  dia.touchEnd = function(e) {
    if (!diagram.isEnabled) return;
    diagram.clearTapTimer();
    if (diagram._tapHeld) { e.preventDefault(); return false; }
    var n = diagram._previousInput;
    diagram._previousInput = diagram._lastInput;
    diagram._lastInput = n;

    // not currently handling more than one touch on end
    if (e.touches.length > 1) {
      if (diagram._hasGestureZoom) {
        diagram._gestureStarted = false;
      }
      return;
    }


    var targ = null;
    var mouse;
    var evt = null;
    if (e.changedTouches.length > 0) evt = e.changedTouches[0];
    else if (e.targetTouches.length > 0) evt = e.targetTouches[0];
    n.diagram = diagram;
    n.clickCount = 1;
    if (evt) {
      targ = document.elementFromPoint(evt.clientX, evt.clientY);
      var diag;
      if (targ && targ._diagram) {
        mouse = targ._diagram._getMouse(evt);
        diag = targ._diagram;
      } else {
        mouse = diagram._getMouse(e.changedTouches[0]);
        diag = diagram;
      }
      n.documentPoint = mouse;
      n.viewPoint = diag.transformDocToView(mouse);
      var first = new Point(evt.screenX, evt.screenY);
      var last = diagram._lastTouchpt;
      // potential double click, make sure its close in time and space
      if (e.timeStamp - diagram._lastTouchStamp < diagram._touchDoubleClickDelay &&
          // Special isBeyondDragSize
          !(Math.abs(last.x - first.x) > 25 || Math.abs(last.y - first.y) > 25)) {
        diagram._lastTouchCount++;
      } else {
        diagram._lastTouchCount = 1;
      }
      n.clickCount = diagram._lastTouchCount;
      diagram._lastTouchStamp = e.timeStamp;
      diagram._lastTouchpt = first;

    } else if (diagram._previousInput !== null) {
      n.documentPoint = diagram._previousInput.documentPoint;
      n.viewPoint = diagram._previousInput.viewPoint;
      targ = diagram._previousInput.targetDiagram;
    } else if (diagram._firstInput !== null) {
      n.documentPoint = diagram._firstInput.documentPoint;
      n.viewPoint = diagram._firstInput.viewPoint;
      targ = diagram._firstInput.targetDiagram;
    }
    n.modifiers = 0;
    n.button = 0;
    n.down = false;
    n.up = true;
    n.delta = 0;
    n.handled = false;
    n.bubbles = false; // should this be true or false? Might cancel double-click zoom on some browsers
    n.event = e;
    n.timestamp = Date.now();
    if (targ === null) {
      n.targetDiagram = e.target._diagram;
    } else if (targ._diagram) {
      n.targetDiagram = targ._diagram;
    } else {
      n.targetDiagram = null;
    }
    n.targetObject = null;

    //n.clickCount = e.detail;

    if (diagram.simulatedMouseUp(evt ? evt : e, null, new Point(), n.targetDiagram)) {
      //diagram.wasLeftButtonDown = false; ???
      return;
    }
    diagram.currentTool.doMouseUp();
    diagram._maybeHandled(n, e);
  };

  newCanvas.addEventListener('touchstart', dia.touchStart, false);
  newCanvas.addEventListener('touchmove', dia.touchMove, false);
  newCanvas.addEventListener('touchend', dia.touchEnd, false);

  newCanvas.addEventListener('gesturestart', function(e) {
    if (diagram._hasGestureZoom === false) return;
    diagram._origScale = diagram.scale;
    diagram.currentTool.doCancel();
  }, false);

  newCanvas.addEventListener('gesturechange', function(e) {
    if (diagram._hasGestureZoom === false) return;
    var can = diagram._canvas;
    var bbox = can.getBoundingClientRect();
    var mouse = new Point((e.pageX - window.scrollX) - bbox.left * (can.width / bbox.width),
                      (e.pageY - window.scrollY) - bbox.top * (can.height / bbox.height));
    var oldzoom = diagram.zoomPoint;

    var newscale = diagram._origScale * e.scale;
    var command = diagram.commandHandler;
    if (newscale > diagram.scale && command.canIncreaseZoom() ||
        newscale < diagram.scale && command.canDecreaseZoom()) {
      diagram.zoomPoint = mouse;
      diagram.scale = newscale;
      diagram.zoomPoint = oldzoom;
    }
  }, false);

  // Canvas events handled by Diagram

  newCanvas.addEventListener('mousemove', dia.mouseMove, false);
  newCanvas.addEventListener('mousedown', dia.mouseDown, false);
  newCanvas.addEventListener('mouseup', dia.mouseUp, false);
  newCanvas.addEventListener('mousewheel', dia.mouseWheel, false);
  newCanvas.addEventListener('DOMMouseScroll', dia.mouseWheel, false);
  newCanvas.addEventListener('mouseout', dia.mouseOut, false);

  newCanvas.addEventListener('keydown', dia.keyDown, false);
  newCanvas.addEventListener('keyup', dia.keyUp, false);

  // fixes a problem where double clicking causes text to get selected on the canvas
  // 8/29/12 doesn't fix it for FF mobile: https://bugzilla.mozilla.org/show_bug.cgi?id=786660
  /** @ignore */
  newCanvas.addEventListener('selectstart', function(e) { e.preventDefault(); return false; }, false);
  newCanvas.addEventListener('contextmenu', function(e) { e.preventDefault(); return false; }, false);

  window.addEventListener('resize', dia.maybeResize, false);

  newCanvas.tabIndex = 0;
  dia.clearContextCache();
};

Diagram.prototype['focus'] =
/**
* Explicitly bring focus to the Diagram's canvas. Used in tools that may create other HTML elements such as TextEditingTool.
* @this {Diagram}
*/
Diagram.prototype.focus = function() {
  if (this._canvas) this._canvas.focus();
};

/**
* @ignore
* Called by setup and whenever the canvas changes size. Changing the size of the canvas will destroy all canvas state.
* @this {Diagram}
* @param {CanvasRenderingContext2D=} ctx
*/
Diagram.prototype.clearContextCache = function(ctx) {
  if (ctx === undefined/*notpresent*/) ctx = this._ctx;
  ctx.__cachedFont = '';
  ctx.__cachedStrokeStyle = '';
  ctx.__cachedFillStyle = '';
};

/**
* @ignore
* Called by setup, initializes default layers
* @this {Diagram}
*/
Diagram.prototype._setupLayers = function() {
  // three normal layers and two temporary layers

  var layer = new Layer();
  layer.name = 'Background';
  this.addLayer(layer);

  layer = new Layer();
  layer.name = '';
  this.addLayer(layer);

  layer = new Layer();
  layer.name = 'Foreground';
  this.addLayer(layer);

  layer = new Layer();
  layer.name = 'Adornment';
  layer.isTemporary = true;
  this.addLayer(layer);

  layer = new Layer();
  layer.name = 'Tool';
  layer.isTemporary = true;
  this.addLayer(layer);

  layer = new Layer();
  layer.name = 'Grid';
  layer.allowSelect = false;
  layer.pickable = false;
  layer.isTemporary = true;
  this.addLayerBefore(layer, this.findLayer('Background'));
};

/**
* @ignore
* Called by setup, initializes .grid
* @this {Diagram}
*/
Diagram.prototype._setupBackgroundGrid = function() {
  // make the background Grid Panel
  this._grid = new Panel(Panel.Grid);
  this._grid.name = 'GRID';

  var hlines = new Shape();
  hlines.figure = 'LineH';
  hlines.stroke = 'lightgray';
  hlines.strokeWidth = 0.5;
  hlines.interval = 1;
  this._grid.add(hlines);

  hlines = new Shape();
  hlines.figure = 'LineH';
  hlines.stroke = 'gray';
  hlines.strokeWidth = 0.5;
  hlines.interval = 5;
  this._grid.add(hlines);

  hlines = new Shape();
  hlines.figure = 'LineH';
  hlines.stroke = 'gray';
  hlines.strokeWidth = 1;
  hlines.interval = 10;
  this._grid.add(hlines);

  var vlines = new Shape();
  vlines.figure = 'LineV';
  vlines.stroke = 'lightgray';
  vlines.strokeWidth = 0.5;
  vlines.interval = 1;
  this._grid.add(vlines);

  vlines = new Shape();
  vlines.figure = 'LineV';
  vlines.stroke = 'gray';
  vlines.strokeWidth = 0.5;
  vlines.interval = 5;
  this._grid.add(vlines);

  vlines = new Shape();
  vlines.figure = 'LineV';
  vlines.stroke = 'gray';
  vlines.strokeWidth = 1;
  vlines.interval = 10;
  this._grid.add(vlines);

  // create the Part holding the Grid Panel
  var gridpart = new Part();
  gridpart.add(this._grid);
  gridpart.layerName = 'Grid';  // goes in the "Grid" layer
  gridpart.isInDocumentBounds = false;  // never part of the document bounds
  gridpart.pickable = false;
  gridpart.locationObjectName = 'GRID';
  this.add(gridpart);  // add this Part to the Diagram
  this._parts.remove(gridpart);  // don't show up in Diagram.parts collection

  // _updateBackgroundGrid will update the size and position based on the viewport
  this._grid.visible = false;  // grid is by default not visible
};

/**
* @ignore
* Event that fires whenever a scrollbar is moved. Is a no-op unless the scrollbar
* has been clicked by a user.
* @this {HTMLDivElement}
*/
Diagram.prototype._onscroll = function(e) {
  if (!this._diagram.isEnabled) {
    this._diagram.updateScroll();
    return;
  }
  this._diagram.diagramScroll(this);
};

/**
* @ignore
* Used to differentiate scrollbars being clicked and scrollbars moving by other means
* @this {HTMLCanvasElement}
*/
Diagram.prototype._onscrollClick = function(e) {
  if (!this._diagram.isEnabled) {
    this._diagram.updateScroll();
    return;
  }
  this._diagram._scrollBarClicked = true;
};

/**
* @ignore
* @this {Diagram}
* @param {HTMLDivElement} scrolldiv
*/
Diagram.prototype.diagramScroll = function(scrolldiv) {
  if (!this._scrollBarClicked) return;
  var can = this._canvas;
  if (can === null) return;
  this._scrollBarMoving = true;
  // this.scrollLeft, this.scrollTop only works if document is entirely within view

  var docB = this.documentBounds;
  var viewB = this.viewportBounds;

  var dw = docB.width;
  var vw = viewB.width;
  var dh = docB.height;
  var vh = viewB.height;

  var dright = docB.right;
  var vright = viewB.right;
  var dbottom = docB.bottom;
  var vbottom = viewB.bottom;

  var dx = docB.x;
  var vx = viewB.x;
  var dy = docB.y;
  var vy = viewB.y;

  var sc = this.scale;

  // if the view is smaller than the Diagram
  if ((vw < dw) || (vh < dh)) {
    var p = Util.tempPoint();
    if (scrolldiv._scrollHorizontal && this.allowHorizontalScroll) {
       p._set(scrolldiv.scrollLeft / sc + dx, this.position.y);
       this.position = p;
    } else if (scrolldiv._scrollVertical && this.allowVerticalScroll) {
      p._set(this.position.x, scrolldiv.scrollTop / sc + dy);
      this.position = p;
    }
    Util.freePoint(p);

    this._scrollBarMoving = false;
    this._invalidScrollBars = false;
    return;
  }

  var p = Util.tempPoint();
  // scrollHorizontal is something we added to the div to distinguish them
  if (scrolldiv._scrollHorizontal && this.allowHorizontalScroll) {
    if (dx < vx) {  // Left scrolling
      this.position = new Point(
        scrolldiv.scrollLeft + dx,
        this.position.y);
    }

    if (dright > vright) {  // Right scrolling
      var sw = (this._scrollHorizontalParent.scrollWidth - can.width);
      this.position = new Point(
      -sw + scrolldiv.scrollLeft - (can.width / sc) + this.documentBounds.right,
      this.position.y);
    }
  }

  // scrollVertical is something we added to the div to distinguish them
  if (scrolldiv._scrollVertical && this.allowVerticalScroll) {
    if (dy < vy) { // Top scrolling
      this.position = new Point(
        this.position.x,
        scrolldiv.scrollTop + dy);
    }

    if (dbottom > vbottom) { // Bottom scrolling
      var sh = (this._scrollVerticalParent.scrollHeight - can.height);
      this.position = new Point(
      this.position.x,
      -sh + scrolldiv.scrollTop - (can.height / sc) + this.documentBounds.bottom);
    }
  }

  Util.freePoint(p);
  this.invalidateViewportObjects();
  this._scrollBarMoving = false;
  this._invalidScrollBars = false;

  // now we need to see if a scrollbar is no longer necessary (view larger than Diagram)
  docB = this.documentBounds;
  viewB = this.viewportBounds;

  dright = docB.right;
  vright = viewB.right;
  dbottom = docB.bottom;
  vbottom = viewB.bottom;

  dx = docB.x;
  vx = viewB.x;
  dy = docB.y;
  vy = viewB.y;

  // no more horizontal bar:
  if ((vw >= dw) && (dx >= vx) && (dright <= vright)) {
    this._scrollHelperHorizontal.style.width = '1px';
  }

  // no more vertical bar:
  if ((vh >= dh) && (dy >= vy) && (dbottom <= vbottom)) {
    this._scrollHelperVertical.style.height = '1px';
  }
};

Diagram.prototype['computeBounds'] =
/**
* This is called during a Diagram update to determine a new value for {@link #documentBounds}.
* By default this computes the union of the bounds of all the visible
* {@link GraphObject}s in this Diagram, unless {@link Diagram#fixedBounds} is set.
* <p/>
* To compute the bounds of a collection of Parts, call {@link #computePartsBounds}.
* @this {Diagram}
* @return {Rect} a Rect in document coordinates.
*/
Diagram.prototype.computeBounds = function() {
  if (this._invalidObjects.count > 0) {
    this.validateParts();
  }
  return this.computeBoundsNoValidate();
};

/**
* @ignore
* @this {Diagram}
* @return {Rect} a Rect in document coordinates.
*/
Diagram.prototype.computeBoundsNoValidate = function() {
  if (this.fixedBounds.isReal()) {
    var fb = this.fixedBounds.copy();
    fb.addMargin(this.padding);
    return fb;
  }

  var b;
  var first = true;
  var lit = this._layers._arr;
  var l = lit.length;
  for (var i = 0; i < l; i++) {
    var layer = lit[i];
    if (!layer.visible) continue;
    if (layer.isTemporary) continue;
    var pit = layer._parts._arr;
    var ll = pit.length;
    for (var j = 0; j < ll; j++) {
      var part = pit[j];
      if (!part.isInDocumentBounds) continue;
      if (!part.isVisible()) continue;
      var ab = part.actualBounds;
      if (!ab.isReal()) continue;
      if (first) {
        first = false;
        b = ab.copy();
      } else {
        b.unionRect(ab);
      }
    }
  }
  // if no elements make an empty rect
  if (first) {
    b = new Rect(0, 0, 0, 0);
  }
  b.addMargin(this.padding);
  return b;
};

/**
* Find the union of the {@link GraphObject#actualBounds} of all of the {@link Part}s in the given collection.
* <p/>
* Unlike {@link #computeBounds}, this ignores the visibility of each Part and does not add any padding to the result.
* @expose
* @this {Diagram}
* @param {Iterable} coll a collection of {@link Part}s.
* @return {Rect} This returns the bounding area of the given Parts;
* if there are no Parts in the collection, this returns a Rect with zero width and height and an X and Y that are NaN.
* @since 1.1
*/
Diagram.prototype.computePartsBounds = function(coll) {
  var b = null;
  var it = coll.iterator;
  while (it.next()) {
    var part = it.value;
    if (part instanceof Link) continue;
    part.ensureBounds();
    if (b === null)
      b = part.actualBounds.copy();
    else
      b.unionRect(part.actualBounds);
  }
  if (b === null) return new Rect(NaN, NaN, 0, 0);
  return b;
};

// ??? this was called onBoundsAlignmentChanged ? rename it back?

// (NYI:) overridable? public?
/**
* @ignore
* This method is called when the {@link #documentBounds}
* or {@link #contentAlignment} properties change.
* This may change the {@link Diagram#position} and/or {@link Diagram#scale} in order to
* maintain the desired content alignment, depending on the {@link #autoScale} policy.
* The {@link Diagram#scale} will not be greater than 1.
* @param {boolean=} initial whether or not the content alignment is occurring for the first time. Default is false.
* @this {Diagram}
*/
Diagram.prototype.onContentAlignmentChanged = function(initial) {
  //if (this.isAnimating) return;
  if (!initial && !this._initialLayoutCompleted) return;
  if (this._isAligning) return;
  if (!this.documentBounds.isReal()) return;
  if (this._canvas === null) return;
  this._isAligning = true;
  //var oldbounds = this.documentBounds;

  var stretch = this._autoScale;
  if (initial && this._initialAutoScale !== Diagram.None) stretch = this._initialAutoScale;

  var scale = stretch !== Diagram.None ? this._computeScaleForStretch(stretch) : this.scale;

  var oldvbounds = this.viewportBounds.copy();

  var viewwidth = this._canvas.width / scale;
  var viewheight = this._canvas.height / scale;

  this.position.thaw(); // to avoid creating new points
  var contentAlign = this._contentAlignment;
  if (initial && this._initialContentAlignment.isSpot()) contentAlign = this._initialContentAlignment;
  this._setupPos(this._position, this.documentBounds, viewwidth, viewheight, contentAlign);
  this.position.freeze();

  this.scale = scale;
  this._isAligning = false;

  var newvbounds = this.viewportBounds;
  if (!newvbounds.equalsAbout(oldvbounds)) {
    this.onViewportBoundsChanged(oldvbounds, newvbounds);
  }

  /*SetScaleAndPosition(scale, pos, (this._initialLayoutCompleted ? this.ZoomTime : 0),
  () => {
  this._isAligning = false;
  Rect newbounds = this.DiagramBounds;
  OnDiagramBoundsChanged(new RoutedPropertyChangedEventArgs<Rect>(oldbounds, newbounds));
  });*/
};

// policy is the Diagram enum (Diagram.None, .Uniform, or .UniformToFill)
/** @ignore @this {Diagram} */
Diagram.prototype._computeScaleForStretch = function(policy) {
  if (this._canvas === null) return;
  if (this._invalidDocBounds) {
    this.setDocumentBounds(this.computeBounds());
  }
  // Use diagram Bounds to determine if we need to scale up or down.
  var db = this.documentBounds;

  if (!db.isReal()) return 1; // It's possible the documentBounds have never been computed

  var dw = db.width;
  var dh = db.height;
  var vw = this._canvas.width;
  var vh = this._canvas.height;

  var widthscale = vw / dw;
  var heightscale = vh / dh;

  var scale = 1;
  // A scale calculated by Uniform or UniformToFill cannot be greater than 1
  if (policy === Diagram.Uniform) {
    // uniform: expand until the larger side exists within the bounds
    scale = Math.min(heightscale, widthscale);
    if (scale > 1) scale = 1;
    if (scale < this.minScale) { scale = this.minScale; }
    if (scale > this.maxScale) { scale = this.maxScale; }
    return scale;
  } else if (policy === Diagram.UniformToFill) {
    // uniform to fill: expand until the smaller side exists within the bounds
    if (heightscale > widthscale) {
      scale = (vh - this._scrollBarBreadth) / dh; // width is larger so there may be a horizontal scroll
    } else {
      scale = (vw - this._scrollBarBreadth) / dw; // height is larger so there may be a vertical scroll
    }
    if (scale > 1) scale = 1;
    if (scale < this.minScale) { scale = this.minScale; }
    if (scale > this.maxScale) { scale = this.maxScale; }
    return scale;
  }
  // else Diagram.None


  return this.scale;
};

Diagram.prototype['zoomToFit'] =
/**
* Scales the Diagram to uniformly fit into the viewport. To have this done automatically,
* set the Diagram's {@link #autoScale} to {@link #Uniform}.
* @this {Diagram}
*/
Diagram.prototype.zoomToFit = function() {
  this.scale = this._computeScaleForStretch(Diagram.Uniform);
};

Diagram.prototype['zoomToRect'] =
/**
* Modifies the {@link #scale} and {@link #position} of the Diagram
* so that the viewport displays a given document-coordinates rectangle.
* @this {Diagram}
* @param {Rect} r rectangular bounds in document coordinates.
* @param {EnumValue=} scaling an optional value of either {@link #Uniform} (the default) or {@link #UniformToFill}.
* @since 1.1
*/
Diagram.prototype.zoomToRect = function(r, scaling) {
  if (scaling === undefined/*notpresent*/) scaling = Diagram.Uniform;
  var rw = r.width;
  var rh = r.height;
  if (rw === 0 || rh === 0 || (isNaN(rw) && isNaN(rh))) return;
  var sc = 1;
  if (scaling === Diagram.Uniform || scaling === Diagram.UniformToFill) {
    if (isNaN(rw)) {
      sc = (this.viewportBounds.height * this.scale) / rh;
    } else if (isNaN(rh)) {
      sc = (this.viewportBounds.width * this.scale) / rw;
    } else {
      var vw = this._canvas.width;
      var vh = this._canvas.height;
      if (scaling === Diagram.UniformToFill) {
        if (vh / rh > vw / rw) {
          sc = (vh - (this._hasHScroll ? this._scrollBarBreadth : 0)) / rh;  // might be a horizontal scrollbar
        } else {
          sc = (vw - (this._hasVScroll ? this._scrollBarBreadth : 0)) / rw;  // might be a vertical scrollbar
        }
      } else {
        sc = Math.min(vh / rh, vw / rw);
      }
    }
  }
  this.scale = sc;
  this.position = new Point(r.x, r.y);
};



Diagram.prototype['alignDocument'] =
/**
* Aligns the Diagram's {@link #position} based on a desired document {@link Spot} and viewport {@link Spot}.
* @param {Spot} documentspot
* @param {Spot} viewportspot
* @this {Diagram}
*/
Diagram.prototype.alignDocument = function(documentspot, viewportspot) {
  if (this._invalidDocBounds) {
    this.setDocumentBounds(this.computeBounds());
  }
  var doc = this.documentBounds;
  var view = this.viewportBounds;
  var prevAligning = this._isAligning;
  this._isAligning = true;
  this.position = new Point(doc.x + (documentspot.x * doc.width + documentspot.offsetX) - (viewportspot.x * view.width - viewportspot.offsetX),
                            doc.y + (documentspot.y * doc.height + documentspot.offsetY) - (viewportspot.y * view.height - viewportspot.offsetY));
  this._isAligning = prevAligning;
  this.invalidateDraw(); // full redraw, since we were aligning, this won't happen from the above code
  //if (!this._isUpdating) this.requestUpdate();
};

  // Could probably be improved more ???
/**
 * @ignore
 * Code to keep the Diagram constrained
 * @this {Diagram}
 * @param {Point} pos a reference that will be set.
 * @param {Rect} bounds typically documentBounds.
 * @param {number} viewwidth
 * @param {number} viewheight
 * @param {Spot} contentAlignment
 */
Diagram.prototype._setupPos = function(pos, bounds, viewwidth, viewheight, contentAlignment) {
  var x, y;

  // This is where content alignment, if a real spot, is taken care of
  if (contentAlignment.isSpot()) {
    // constrain position so that there edge of the Diagram cannot go past the edge of the view
    if (viewwidth > bounds.width) {
      pos.x = bounds.x + (contentAlignment.x * bounds.width + contentAlignment.offsetX) - (contentAlignment.x * viewwidth - contentAlignment.offsetX);
    }
    if (viewheight > bounds.height) {
      pos.y = bounds.y + (contentAlignment.y * bounds.height + contentAlignment.offsetY) - (contentAlignment.y * viewheight - contentAlignment.offsetY);
    }
  }

  // constrain position so that there edge of the Diagram cannot go past the edge of the view

  if (viewwidth < bounds.width) {
    x = pos.x + viewwidth / 2;
    x = Math.min(x, bounds.right - viewwidth / 2);
    x = Math.max(x, bounds.left + viewwidth / 2);
    pos.x = x - viewwidth / 2;
  } else {
    if (pos.x > bounds.left) pos.x = bounds.left;
    else if (pos.x < bounds.right - viewwidth) pos.x = bounds.right - viewwidth;
  }
  if (viewheight < bounds.height) {
    y = pos.y + viewheight / 2;
    y = Math.min(y, bounds.bottom - viewheight / 2);
    y = Math.max(y, bounds.top + viewheight / 2);
    pos.y = y - viewheight / 2;
  } else {
    if (pos.y > bounds.top) pos.y = bounds.top;
    else if (pos.y < bounds.bottom - viewheight) pos.y = bounds.bottom - viewheight;
  }

  // end constrain code
  if (!isFinite(pos.x)) pos.x = -this.padding.left;
  if (!isFinite(pos.y)) pos.y = -this.padding.top;
};


Diagram.prototype['findPartAt'] =
/**
* This convenience function finds the front-most {@link Part}
* that is at a given point and that might be selectable.
* <p/>
* This just calls {@link #findObjectAt} with appropriate arguments.
* @this {Diagram}
* @param {Point} p a Point in document coordinates.
* @param {boolean} selectable Whether to only consider parts that are {@link Part#selectable}.
* @return {Part}
*/
Diagram.prototype.findPartAt = function(p, selectable) {
  if (selectable) {
    var obj = this.findObjectAtNoTemp(p,
               function(x) { return x.part; },
               function(x) { return x.canSelect(); });
    if (obj instanceof Part) return obj;
  } else {
    var obj = this.findObjectAt(p,
               function(x) { return x.part; });
    if (obj instanceof Part) return obj;
  }
  return null;
};

// In the future we might add an optional final argument
// that serves as a predicate to determine which layers to act on
Diagram.prototype['findObjectAt'] =
/**
* Find the front-most {@link GraphObject}
* at the given point in document coordinates.
* <p/>
* If {@link Layer#visible} is false, this method will not find any objects in that layer.
* However, {@link Layer#opacity} does not affect this method.
* @this {Diagram}
* @param {Point} p A Point in document coordinates.
* @param {function(GraphObject):GraphObject | null=} navig A function taking a GraphObject and
* returning a GraphObject, defaulting to the identity.
* @param {function(GraphObject):boolean | null=} pred A function taking the GraphObject
* returned by navig and returning true if that object should be returned,
* defaulting to a predicate that always returns true.
* @return {GraphObject} The first GraphObject returned by the <i>navig</i> function
* and satisfying the <i>pred</i> function that is at the point <i>p</i>, in z-order from front to back,
* or else null if nothing is found.
*/
Diagram.prototype.findObjectAt = function(p, navig, pred) {
  if (navig === undefined/*notpresent*/) navig = null;
  if (pred === undefined/*notpresent*/) pred = null;
  var lit = this._layers.iteratorBackwards;
  this.validateParts();
  while (lit.next()) {
    var lay = lit.value;
    if (!lay.visible) continue;
    var obj = lay.findObjectAt(p, navig, pred);
    if (obj !== null) return obj;
  }
  return null;
};

/**
* @ignore
* like findObjectAt but excludes temporary layers
* Find the front-most {@link GraphObject}
* at the given point in document coordinates.
* <p/>
* If {@link Layer#visible} is false, this method will not find any objects in that layer.
* However, {@link Layer#opacity} does not affect this method.
* @this {Diagram}
* @param {Point} p A Point in document coordinates.
* @param {function(GraphObject):GraphObject | null=} navig A function taking a GraphObject and
* returning a GraphObject, defaulting to the identity.
* @param {function(GraphObject):boolean | null=} pred A function taking the GraphObject
* returned by navig and returning true if that object should be returned,
* defaulting to a predicate that always returns true.
* @return {GraphObject} The first GraphObject returned by the <i>navig</i> function
* and satisfying the <i>pred</i> function that is at the point <i>p</i>, in z-order from front to back,
* or else null if nothing is found.
*/
Diagram.prototype.findObjectAtNoTemp = function(p, navig, pred) {
  if (navig === undefined/*notpresent*/) navig = null;
  if (pred === undefined/*notpresent*/) pred = null;
  var lit = this._layers.iteratorBackwards;
  this.validateParts();
  while (lit.next()) {
    var lay = lit.value;
    if (!lay.visible || lay.isTemporary) continue;
    var obj = lay.findObjectAt(p, navig, pred);
    if (obj !== null) return obj;
  }
  return null;
};


Diagram.prototype['findObjectsAt'] =
/**
* Return a collection of the {@link GraphObject}s
* at the given point in document coordinates.
* <p/>
* If {@link Layer#visible} is false, this method will not find any objects in that layer.
* However, {@link Layer#opacity} does not affect this method.
* @this {Diagram}
* @param {Point} p A Point in document coordinates.
* @param {function(GraphObject):GraphObject | null=} navig A function taking a GraphObject and
* returning a GraphObject, defaulting to the identity.
* If this function returns null, the given GraphObject will not be included in the results.
* @param {function(GraphObject):boolean | null=} pred A function taking the GraphObject
* returned by navig and returning true if that object should be returned,
* defaulting to a predicate that always returns true.
* @param {List|Set=} coll An optional collection (List or Set) to add the results to.
* @return {Iterable} a collection of GraphObjects returned by the <i>navig</i> function
* and satisfying the <i>pred</i> that are located at the point <i>p</i>, or else an empty collection.
* If a List or Set was passed in, it is returned.
*/
Diagram.prototype.findObjectsAt = function(p, navig, pred, coll) {
  if (navig === undefined/*notpresent*/) navig = null;
  if (pred === undefined/*notpresent*/) pred = null;
  if (!(coll instanceof List) && !(coll instanceof Set)) {
    coll = new Set(GraphObject);
  }
  this.validateParts();
  var lit = this._layers.iteratorBackwards;
  while (lit.next()) {
    var lay = lit.value;
    if (!lay.visible) continue;
    lay.findObjectsAt(p, navig, pred, coll);
  }
  return coll;
};

Diagram.prototype['findObjectsIn'] =
/**
* Returns a collection of all {@link GraphObject}s that are inside or that intersect
* a given {@link Rect} in document coordinates.
* <p/>
* If {@link Layer#visible} is false, this method will not find any objects in that layer.
* However, {@link Layer#opacity} does not affect this method.
* @this {Diagram}
* @param {Rect} r A Rect in document coordinates.
* @param {function(GraphObject):GraphObject | null=} navig A function taking a GraphObject and
* returning a GraphObject, defaulting to the identity.
* If this function returns null, the given GraphObject will not be included in the results.
* @param {function(GraphObject):boolean | null=} pred A function taking the GraphObject
* returned by navig and returning true if that object should be returned,
* defaulting to a predicate that always returns true.
* @param {*=} partialInclusion Whether an object can match if it merely intersects the rectangular area (true) or
* if it must be entirely inside the rectangular area (false).  The default value is false.
* @param {List|Set=} coll An optional collection (List or Set) to add the results to.
* @return {Iterable} a collection of GraphObjects returned by the <i>navig</i> function
* and satisfying the <i>pred</i> function that are within the rectangle <i>r</i>, or else an empty collection.
* If a List or Set was passed in, it is returned.
*/
Diagram.prototype.findObjectsIn = function(r, navig, pred, partialInclusion, coll) {
  if (navig === undefined/*notpresent*/) navig = null;
  if (pred === undefined/*notpresent*/) pred = null;
  if (partialInclusion === undefined/*notpresent*/) partialInclusion = false;
  if (!(coll instanceof List) && !(coll instanceof Set)) {
    coll = new Set(GraphObject);
  }
  this.validateParts();
  var lit = this._layers.iteratorBackwards;
  while (lit.next()) {
    var lay = lit.value;
    if (!lay.visible) continue;
    lay.findObjectsIn(r, navig, pred, partialInclusion, coll);
  }
  return coll;
};

/**
* @ignore
* Special internal findObjectsIn that checks an extra predicate, in order to short-circuit some lookups
* @this {Diagram}
* @param {Rect} r
* @param {function(GraphObject):GraphObject | null} navig
* @param {function(GraphObject):boolean | null} pred
* @param {*} partialInclusion
* @param {function(GraphObject):boolean | null} extraPred
* @param {boolean} inView
* @return {Iterable}
*/
Diagram.prototype.findObjectsIn2 = function(r, navig, pred, partialInclusion, extraPred, inView) {
  var coll = new Set(GraphObject);
  this.validateParts();
  var lit = this._layers.iteratorBackwards;
  while (lit.next()) {
    var lay = lit.value;
    if (!lay.visible) continue;
    lay.findObjectsIn2(r, navig, pred, partialInclusion, coll, extraPred, inView);
  }
  return coll;
};

Diagram.prototype['findObjectsNear'] =
/**
* Returns a collection of all {@link GraphObject}s that are within a certain distance
* of a given point in document coordinates.
* <p/>
* If {@link Layer#visible} is false, this method will not find any objects in that layer.
* However, {@link Layer#opacity} does not affect this method.
* @this {Diagram}
* @param {Point} p A Point in document coordinates.
* @param {number} dist The distance from the point.
* @param {function(GraphObject):GraphObject | null=} navig A function taking a GraphObject and
* returning a GraphObject, defaulting to the identity.
* If this function returns null, the given GraphObject will not be included in the results.
* @param {function(GraphObject):boolean | null=} pred A function taking the GraphObject
* returned by navig and returning true if that object should be returned,
* defaulting to a predicate that always returns true.
* @param {*=} partialInclusion Whether an object can match if it merely intersects the circular area (true) or
* if it must be entirely inside the circular area (false).  The default value is true.
* The default is true.
* @param {List|Set=} coll An optional collection (List or Set) to add the results to.
* @return {Iterable} a collection of GraphObjects returned by the <i>navig</i> function
* and satisfying the <i>pred</i> that are located near the point <i>p</i>, or else an empty collection.
* If a List or Set was passed in, it is returned.
*/
Diagram.prototype.findObjectsNear = function(p, dist, navig, pred, partialInclusion, coll) {
  if (navig === undefined/*notpresent*/) navig = null;
  if (pred === undefined/*notpresent*/) pred = null;
  if (partialInclusion === undefined/*notpresent*/) partialInclusion = true;
  if (partialInclusion !== false && partialInclusion !== true) {
    if (partialInclusion instanceof List || partialInclusion instanceof Set) {
      coll = partialInclusion;
    }
    partialInclusion = true;
  }
  if (!(coll instanceof List) && !(coll instanceof Set)) {
    coll = new Set(GraphObject);
  }
  this.validateParts();
  var lit = this._layers.iteratorBackwards;
  while (lit.next()) {
    var lay = lit.value;
    if (!lay.visible) continue;
    lay.findObjectsNear(p, dist, navig, pred, partialInclusion, coll);
  }
  return coll;
};


// Events:

// These are used for touch devices
/**
* @ignore
* @this {Diagram}
*/
Diagram.prototype.clearTapTimer = function() {
  if (this._tapTimer === -1) return;
  clearTimeout(this._tapTimer);
  this._tapTimer = -1;
};

/**
* @ignore
* @this {Diagram}
*/
Diagram.prototype.setTapTimer = function(event) {
  var diagram = this;
  var evt2 = event.copy();
  this._tapTimer = setTimeout(function() {
    evt2.button = 2;
    diagram.lastInput = evt2;
    diagram._tapHeld = true;
    diagram.currentTool.doMouseUp();
  }, 850);
};

/**
 * @ignore
 * Common code that occurs on every event. Some methods may go on to change
 * the properties from these defaults (ie, mouseWheel changes delta)
 * @param {Diagram} diagram
 * @param {Event} e
 * @param {InputEvent} n
 * @param {boolean} mouseEvent
 */
Diagram.prototype._commonEvent = function(diagram, e, n, mouseEvent) {
  n.diagram = diagram;
  if (mouseEvent) {
    var mouse = diagram._getMouse(e);
    n.viewPoint = diagram.transformDocToView(mouse);
    n.documentPoint = mouse;
  } else {
    n.viewPoint = diagram._lastInput.viewPoint;
    n.documentPoint = diagram._lastInput.documentPoint;
  }
  var mod = 0;
  if (e.ctrlKey) mod += 1;
  if (e.altKey) mod += 2;
  if (e.shiftKey) mod += 4;
  n.modifiers = mod;
  n.button = e.button;
  n.down = false;
  n.up = false;
  n.clickCount = 1;
  n.delta = 0;
  n.handled = false;
  n.bubbles = false;
  n.event = e;
  n.timestamp = Date.now();
  if (e.target._diagram) {
    n.targetDiagram = e.target._diagram;
  } else {
    n.targetDiagram = null;
  }
  n.targetObject = null;
};

/**
* @ignore
* @this {Diagram}
* @param {InputEvent} n
* @param {Event} e
* @return {boolean}
*/
Diagram.prototype._maybeHandled = function(n, e) {
  if (!n.bubbles) {
   if (Debug && Debug.trace && Debug.handleMessages) Debug.trace('handled ' + e.type + ' ' + this.currentTool.name + ' ' + n.toString());
   if (e.stopPropagation !== undefined) {
      e.stopPropagation();
    }

    // ???????????? comments here no longer true???
    // never prevent start touches so that panning and pinch zooming have the option of running
    // ??? used to have: && e.type !== 'touchstart'
    if (e.preventDefault !== undefined) {
      // This method stops panning in mobile if done on a touchstart
      e.preventDefault();
    }

    e.cancelBubble = true;
    return false;
  } else {
    if (Debug && Debug.trace && Debug.handleMessages) Debug.trace('NOT handled ' + e.type + ' ' + n.toString());
    return true;
  }
};

/**
* @ignore
* @this {HTMLCanvasElement}
* @param {Event} e
*/
Diagram.prototype.keyDown = function(e) {
  if (!this._diagram.isEnabled) return;
  var n = this._diagram._lastInput;
  this._diagram._commonEvent(this._diagram, e, n, false);
  n.key = String.fromCharCode(e.which);
  n.down = true;

  switch (e.which) {
    case 33:
    n.key = 'PageUp'; break;
    case 34:
    n.key = 'PageDown'; break;
    case 35:
    n.key = 'End'; break;
    case 36:
    n.key = 'Home'; break;
    case 37:
    n.key = 'Left'; break;
    case 38:
    n.key = 'Up'; break;
    case 39:
    n.key = 'Right'; break;
    case 40:
    n.key = 'Down'; break;
    case 45:
    n.key = 'Insert'; break;
    case 46:
    n.key = 'Del'; break;
    case 48:
    n.key = '0'; break;
    case 187: // the plus/equals key
    n.key = 'Add'; break;
    case 189: // the minus/underscore key
    n.key = 'Subtract'; break;
    case 107:
    n.key = 'Add'; break;
    case 109:
    n.key = 'Subtract'; break;
    case 27:
    n.key = 'Esc'; break;
  }

  this._diagram.currentTool.doKeyDown();

  // We want to stop the browser from doing a normal browser-zoom event.
  // This code will stop that event in Chrome. There is corresponding code to stop it in Firefox.
  // As of 3/1/2010 no other browser has been stopped.
  // 187: +
  // 189: -
  // 48:  0
  if ((e.which === 187 || e.which === 189 || e.which === 48 || e.which === 107 || e.which === 109) &&
      e.ctrlKey === true) {

    e.cancelBubble = true;
    if (e.preventDefault !== undefined) {
      e.preventDefault();

    } else {
      e.returnValue = false;
      // has never happened so far (Tested in all desktop browsers)
    }
    if (Event.stop) {
      Util.throwError('Event.stop can fire for this browser');
      Event.stop(e);
    }
    if (e.stopPropagation !== undefined) {
      e.stopPropagation();
    }
    return false;
  }

  return this._diagram._maybeHandled(n, e);
};

/**
* @ignore
* @this {HTMLCanvasElement}
* @param {Event} e
*/
Diagram.prototype.keyUp = function(e) {
  if (!this._diagram.isEnabled) return;
  var n = this._diagram._lastInput;
  this._diagram._commonEvent(this._diagram, e, n, false);
  n.key = String.fromCharCode(e.which);
  n.up = true;
  // We must check to see if 'which' is one of the special keys. Otherwise
  // PageUp will parse as "!", etc.
  switch (e.which) {
    case 33:
    n.key = 'PageUp'; break;
    case 34:
    n.key = 'PageDown'; break;
    case 35:
    n.key = 'End'; break;
    case 36:
    n.key = 'Home'; break;
    case 37:
    n.key = 'Left'; break;
    case 38:
    n.key = 'Up'; break;
    case 39:
    n.key = 'Right'; break;
    case 40:
    n.key = 'Down'; break;
    case 45:
    n.key = 'Insert'; break;
    case 46:
    n.key = 'Del'; break;
  }
  this._diagram.currentTool.doKeyUp();
  return this._diagram._maybeHandled(n, e);
};

// Returns a mouse position relative to the canvas
// this can be tricky, we have to worry about padding and borders
// right now this gets the mouse for the Diagram's canvas. The arg must
// come from either the topmost canvas or the div.
// ??? update this sometime with newer findings
// ??? currently failing with CSS stretch of canvas?
// Slower, and does not account for margin/width/padding as written
/**
 * @ignore
 * @this {Diagram}
 * @param {Event} e
 */
Diagram.prototype._getMouse = function(e) {
  if (this._alternateCoordinates) return this._getMouseAlt(e);
  var can = this._canvas;
  if (can === null) return new Point(0, 0);
  var bbox = can.getBoundingClientRect();
  var mx = e.clientX - bbox.left * (can.width / bbox.width);
  var my = e.clientY - bbox.top * (can.height / bbox.height);
  if (this._transform !== null) {
    var pt = new Point(mx, my);
    pt.transformInverted(this._transform);
    return pt;
  }
  return new Point(mx, my);
};

// Faster, accounts for margin/width/padding,
// but incorrect with some HTML structures such as an inline div parent in the DOM tree
/**
 * @ignore
 * @this {Diagram}
 * @param {Event} e
 */
Diagram.prototype._getMouseAlt = function(e) {
  var element = this._canvas, offsetX = 0, offsetY = 0, mx, my;

  if (element.offsetParent !== undefined) {
    do {
      offsetX += (element.offsetLeft + element.clientLeft);
      offsetY += (element.offsetTop + element.clientTop);
    } while ((element = element.offsetParent));
  }

  // Add padding and border style widths to offset
  offsetX += this._stylePaddingLeft + this._styleBorderLeft + this._htmlLeft;
  offsetY += this._stylePaddingTop + this._styleBorderTop + this._htmlTop;

  mx = e.pageX - offsetX;
  my = e.pageY - offsetY;

  if (this._transform !== null) {
    var pt = new Point(mx, my);
    pt.transformInverted(this._transform);
    return pt;
  }
  return new Point(mx, my);
};

/**
* @ignore
* Gets or sets whether the canvas context should use an alternate coordinate system
* The default value is false.
* @name Diagram#alternateCoordinates
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Diagram.prototype.alternateCoordinates;
Util.exportProperty(Diagram, 'alternateCoordinates', Diagram.prototype.alternateCoordinates);
Util.defineProperty(Diagram, { alternateCoordinates: null },
  /** @this {Diagram} */
  function() { return this._alternateCoordinates; },
  /** @this {Diagram} */
  function(val) {
    Util.checkPrimitive(val, 'boolean', Diagram, 'alternateCoordinates');
    this._alternateCoordinates = val;
  }
);

/**
* @ignore
* Gets or sets optional parameters used when drawing.
* The default value is null.
* @name Diagram#renderingHints
* @function.
* @return {Object}
*/
/** @type {boolean} */
Diagram.prototype.renderingHints;
Util.exportProperty(Diagram, 'renderingHints', Diagram.prototype.renderingHints);
Util.defineProperty(Diagram, { renderingHints: 'renderingHints' },
  /** @this {Diagram} */
  function() { return this._renderingHints; },
  /** @this {Diagram} */
  function(val) {
    this._renderingHints = val;
    this.redraw();
  }
);

Diagram.prototype['invalidateDocumentBounds'] =
/**
* @ignore
* Requests that the Diagram updates its {@link #documentBounds} in the near-future.
* @this {Diagram}
*/
Diagram.prototype.invalidateDocumentBounds = function() {
  this._invalidDocBounds = true;
  this.requestUpdate();
};

/**
* @ignore
* Call {@link #computeBounds} and set {@link #documentBounds}, then call {@link #onContentAlignmentChanged}.
* @this {Diagram}
*/
Diagram.prototype.updateBounds = function() {
  if (!this._isUpdating) this.validateParts();
  if (this._invalidDocBounds) {
    this.setDocumentBounds(this.computeBounds());
  }
  this.onContentAlignmentChanged(); // happens some of the time in computeBounds, optimize somehow?

  // Lastly, notify any observing Overviews
  var it = this._overviews.iterator;
  while (it.next()) {
    it.value.updateBounds();
  }
};

/**
* @ignore
* @param {boolean} skips
* @this {Diagram}
*/
Diagram.prototype.skipBoundsUpdates = function(skips) {
  this._skipsBoundsUpdates = skips;
};


Diagram.prototype['redraw'] =
/**
 * @ignore
 * Invalidates all non-layout diagram state and forces a redraw.
 * @this {Diagram}
 */
Diagram.prototype.redraw = function() {
  if (this._isAligning || this._isUpdating) return;
  this.invalidateDraw();
  this.invalidateScroll();
  this.invalidateViewportObjects();
  this.invalidateDocumentBounds();
  // do it immediately
  this.maybeUpdate();
};

Diagram.prototype['isUpdateRequested'] =
/**
* @ignore
* @this {Diagram}
*/
Diagram.prototype.isUpdateRequested = function() {
  return this._updateQueued;
};

Diagram.prototype['delayInitialization'] =
/**
* Updates the diagram immediately, then resets initialization flags so that
* actions taken in the argument function will be considered part of Diagram initialization,
* and will participate in initial layouts, {@link #initialAutoScale}, {@link #initialContentAlignment}, etc.
* <p>
* This is useful in situations where you do not wish for the first content added to the diagram to be considered
* the "initial" content, such as with a Node that represents a "Loading" bar.
* @this {Diagram}
* @param {function()|null=} func an optional function of actions to perform as part of another diagram initialization.
* @since 1.1
*/
Diagram.prototype.delayInitialization = function(func) {
  this.doUpdate();
  this._initialLayoutCompleted = false;
  if (func) setTimeout(func, 1);
};

Diagram.prototype['requestUpdate'] =
/**
* @ignore
* Requests that in the near-future the diagram makes sure all GraphObjects are arranged,
* recomputes the document bounds, updates the scrollbars, and redraws the viewport.
* @param {boolean=} alwaysQueueUpdate If true the Diagram will queue another update,
* even if an update is already occurring. The default value is false.
* @this {Diagram}
*/
Diagram.prototype.requestUpdate = function(alwaysQueueUpdate) {
  if (alwaysQueueUpdate === undefined) alwaysQueueUpdate = false;
  if (this._updateQueued === true) return;
  if (this._isAligning || (alwaysQueueUpdate === false && this._isUpdating)) return;
  this._updateQueued = true;
  var dia = this;
  requestAnimationFrame(
    function() {
      // Are we still queued?
      if (!dia._updateQueued) { return; } // no need!
      dia.maybeUpdate();
    });
};

/**
* A special update called when only the viewport has been modified
* @ignore
* @param {Rect} r the viewport intersection rectangle.
* @param {Rect} oldv old viewport bounds.
* @param {Rect} newv new viewport bounds.
* @this {Diagram}
*/
Diagram.prototype.updateViewport = function(r, oldv, newv) {
  if (this._isUpdating) return;
  this._updateQueued = false;
  if (this._div === null) return;
  this._isUpdating = true;

  this.clearDelayedGeometries();

  this.validateParts();

  // make sure documentBounds are sane
  // Note that we do not compute the bounds constantly because we only want them to update on a transaction end
  if (!this.documentBounds.isReal()) this.setDocumentBounds(this.computeBounds());

  var can = this._canvas;
  if (can === null) return;
  var width = can.width;
  var height = can.height;
  var scale = this.scale;

  // Difference between old and new positions, scaled to screen pixels and rounded to the nearest pixel
  // outermost math.round for floating point issues only
  var x = Math.round(Math.round(newv.x * scale) - Math.round(oldv.x * scale));
  var y = Math.round(Math.round(newv.y * scale) - Math.round(oldv.y * scale));

  // Draw the rect onto an in-memory canvas
  var tempCan = this._drawCollectionCanvas;
  var tempCtx = this._drawCollectionCtx;
  tempCan.width = width;
  tempCan.height = height;

  // Positive if scrolling rightward/downward
  // Zero if scrolling leftward/upward
  var sx = Math.max(x, 0);
  var sy = Math.max(y, 0);
  var sw = width - sx;
  var sh = height - sy;
  tempCtx.webkitImageSmoothingEnabled = false;
  tempCtx.imageSmoothingEnabled = false; // ??? not neessarily needed?
  tempCtx.drawImage(can,
    sx, sy, sw, sh, // Source
    0, 0, sw, sh);  // Destination
  this._helper.wmq(this) && tempCtx.clearRect(0, 0, 190, 70);

  // We need the rects in both document and viewport coordinates
  var rects = Util.tempArray();
  var viewRects = Util.tempArray();
  var abx = Math.abs(x);
  var aby = Math.abs(y);
  var temp = (sx === 0) ? 0 : width - abx;
  var p1 = Util.tempPointAt(temp, 0);
  var p2 = Util.tempPointAt(abx + temp, height);
  viewRects.push([Math.min(p1.x, p2.x), Math.min(p1.y, p2.y), Math.abs(p1.x - p2.x), Math.abs(p1.y - p2.y)]);

  var t = this._transform;
  t.reset();
  if (this._scale !== 1) { t.scale(this._scale); }
  var pos = this._position;
  if ((pos.x !== 0 || pos.y !== 0) && isFinite(pos.x) && isFinite(pos.y)) {
    t.translate(-pos.x, -pos.y);
  }
  p1.transformInverted(t);
  p2.transformInverted(t);
  rects.push([Math.min(p1.x, p2.x), Math.min(p1.y, p2.y), Math.abs(p1.x - p2.x), Math.abs(p1.y - p2.y)]);

  temp = (sy === 0) ? 0 : height - aby;
  p1._set(0, temp);
  p2._set(width, aby + temp);
  viewRects.push([Math.min(p1.x, p2.x), Math.min(p1.y, p2.y), Math.abs(p1.x - p2.x), Math.abs(p1.y - p2.y)]);

  p1.transformInverted(t);
  p2.transformInverted(t);
  rects.push([Math.min(p1.x, p2.x), Math.min(p1.y, p2.y), Math.abs(p1.x - p2.x), Math.abs(p1.y - p2.y)]);

  if (this._helper.wmq(this)) {
    var tempx = ((x > 0) ? 0 : - x);
    var tempy = ((y > 0) ? 0 : - y);
    p1._set(tempx, tempy);
    p2._set(190 + tempx, 70 + tempy); // 190x70 for wmq size
    viewRects.push([Math.min(p1.x, p2.x), Math.min(p1.y, p2.y), Math.abs(p1.x - p2.x), Math.abs(p1.y - p2.y)]);
    p1.transformInverted(t);
    p2.transformInverted(t);
    rects.push([Math.min(p1.x, p2.x), Math.min(p1.y, p2.y), Math.abs(p1.x - p2.x), Math.abs(p1.y - p2.y)]);
  }

  Util.freePoint(p1);
  Util.freePoint(p2);

  if (!this._isAligning && this._invalidScrollBars) {
    if (!this.updateScroll()) { // only want to do this if the canvas size has changed
      this.updateScroll();
    }
  }

  this.redrawViewport(rects, viewRects, x, y);
  Util.freeArray(rects);
  Util.freeArray(viewRects);
  this._isUpdating = false;
};


Diagram.prototype['maybeUpdate'] =
/**
* @ignore
* @this {Diagram}
*/
Diagram.prototype.maybeUpdate = function() {
  // unlike update, this method tests several conditions before it does anything
  // this should almost always be used internally instead of update
  if (this._firstUpdate && !this._updateQueued) return;
  // This flag stops hard (non-queued) updates during initialization from prematurely updating the diagram
  if (this._firstUpdate) this._firstUpdate = false;
  this.doUpdate();
};

/**
* @ignore
* Ensure that all GraphObjects are arranged, update the document bounds and the scrollbars,
* and draw all objects in the viewport.
* <p/>
* <strong>Caution:</strong> this method can be very expensive in time and space.
* Avoid calling this method except in infrequent circumstances where redrawing immediately is necessary.
* Under most circumstances you should allow the transaction to perform its normal updating process.
* Calling {@link #requestUpdate} is the usually the right thing to do.
* @this {Diagram}
*/
Diagram.prototype.doUpdate = function() {
  if (this._isUpdating) return;
  this._updateQueued = false;
  if (this._div === null) return;
  this._isUpdating = true;

  // It's possible the viewportbounds changed. Possible to optimzie this in the future too
  // might invalidate scrollbars and resize the diagram,
  // potentially need to do this before and after a layout
  this.maybeResize();
  if (!this._isAligning && this._invalidScrollBars) {
    if (!this.updateScroll()) {
      // only want to do this if the canvas size has changed
      this.updateScroll();
    }
  }

  if (this._grid !== null) {
    if (this._grid.visible && !this._gridWasVisible) {
      this._updateBackgroundGrid();
      this._gridWasVisible = true;
    }
    if (!this._grid.visible && this._gridWasVisible) {
      this._gridWasVisible = false;
    }
  }

  this.validateParts();

  var layoutCompleted = false;
  // by default redraws without performing any layouts, except needing initial layout
  if (!this._initialLayoutCompleted || this._anyLayoutInvalid) {
    if (!this._initialLayoutCompleted) {
      this.updateAllLayouts(false); // perform all invalid layouts right now
    } else {
      this.updateAllLayouts(!this._updateLayoutQueued);
    }

    this._updateLayoutQueued = false;
    layoutCompleted = true;
  }

  this.validateParts();
  if (!this._skipsBoundsUpdates) this.updateBounds();

  if (layoutCompleted) {
    // this is the first time we've computed the diagram bounds since finishing a layout;
    // only raise the Diagram.InitialLayoutCompleted and Diagram.LayoutCompleted events after computing new diagram bounds
    if (!this._initialLayoutCompleted) {
      this.onInitialLayoutCompleted();
      this._updateBackgroundGrid();
    }
    this.onLayoutCompleted();
  }

  this.clearDelayedGeometries();

  this.validateParts();

  if (!this._isAligning && this._invalidScrollBars) {
    if (!this.updateScroll()) {
      // only want to do this if the canvas size has changed
      this.updateScroll();
      this.validateParts(); // A Canvas resize may mean that parts have moved during an update
    }
  }

  // inital layouts can only complete if updates are unpaused
  if (layoutCompleted && !this._initialLayoutCompleted) { this._initialLayoutCompleted = true; }
  this.draw();

  this._isUpdating = false;
};

/**
* @ignore
* @this {Diagram}
* This overridable method is called after the first layout has been performed
* and the {@link #documentBounds} has been computed.
* This uses the {@link #autoScale}, {@link #initialDocumentSpot}, and {@link #initialViewportSpot}
* properties to set the {@link #scale} and {@link #position}
* properties for the initial appearance of the Diagram.
* It then raises the "InitialLayoutCompleted" {@link DiagramEvent}.
* It also clears out the {@link UndoManager}'s recorded changes, if any.
*/
Diagram.prototype.onInitialLayoutCompleted = function() {
  if (this._initialAutoScale !== Diagram.None) {
    this.scale = this._computeScaleForStretch(this._initialAutoScale);
  } else if (this._autoScale !== Diagram.None) {
    this.scale = this._computeScaleForStretch(this._autoScale);
  } else {
    var scale = this.initialScale;
    if (isFinite(scale) && scale > 0) {
      this.scale = scale;
    }
  }

  // normally we dont compute document bounds during updates but for the initial we make an exception:
  // ??? new idea (changeset 16270), might have unintended consequences
  if (this._invalidDocBounds) {
    this.setDocumentBounds(this.computeBounds());
  }

  var pos = this.initialPosition;
  if (pos.isReal()) {
    this.position = pos;
  } else {
    var dp = Util.tempPoint();
    dp.setRectSpot(this.documentBounds, this.initialDocumentSpot);
    // control/view coordinates
    var vp = this.viewportBounds;
    var v = Util.tempRectAt(0, 0, vp.width, vp.height);
    var p = Util.tempPoint();
    p.setRectSpot(v, this.initialViewportSpot);
    this.position = new Point(dp.x - p.x, dp.y - p.y);
    Util.freeRect(v);
    Util.freePoint(p);
    Util.freePoint(dp);
    this.onContentAlignmentChanged(true);
  }

  this.raiseDiagramEvent('InitialLayoutCompleted');
  // clear out the UndoManager
  var undomgr = this.undoManager;
  if (undomgr !== null) {
    undomgr.clear();
  }
};

/**
* @ignore
* @this {Diagram}
* This overridable method is called after each layout has been performed
* and the {@link #documentBounds} has been computed.
* This raises the "LayoutCompleted" {@link DiagramEvent}.
*/
Diagram.prototype.onLayoutCompleted = function() {
  this.raiseDiagramEvent('LayoutCompleted');
};

/**
* @ignore
* Validate all of the invalid Parts.
* For efficiency, some parts can only be measured when other parts are valid.
* For example, a Link should not be measured until the two connected Nodes have been arranged.
* Measuring and arranging some parts will cause other parts to become invalid.
* For example, measuring and arranging a Link will result in routing that may reposition label nodes.
* @this {Diagram}
*/
Diagram.prototype.validateParts = function() {
  if (this._invalidObjects.count === 0) return;
  // only update the objects that are in the measure and arrange sets.
  for (var i = 0; i < 23; i++) {
    var validatings = this._invalidObjects.iterator;
    if (validatings === null || this._invalidObjects.count === 0) break;
    // accumulate a new set of invalid parts, if there are side-effects of measuring/arranging any part
    // or if we have to wait with measuring/arranging because of unmeasured/unarranged dependencies
    this._invalidObjects = new Set(GraphObject);
    this.validate(validatings, this._invalidObjects); // also calls measure/arrange on each
  }
};


/**
* @ignore
* One pass of the validation loop.
* For Parts that probably should not be measured/arranged yet due to dependencies on other Parts,
* instead of calling Part.measure and arrange, just add the Part to the DELAY hashset,
* which will be passed in as the INVALIDS hashset in the next iteration.
* @this {Diagram}
*/
Diagram.prototype.validate = function(invalids, delay) { // make sure everything is measured and arranged
  // first do all atomic (non-Group) Nodes and all instances of simple Parts
  invalids.reset();
  while (invalids.next()) {
    var n = invalids.value;
    // measure only Node and Part, not Adornment nor Link nor Group
    if (!n.isNodeLike() || n instanceof Group) continue;
    if (n.isReadyToMeasureArrange()) {
      n.measure(Infinity, Infinity);
      n.arrange();
    } else {
      delay.add(n);  // try again later
    }
  }

  // do a depth first measure/arrange of all the Nodes/Links that are in Groups
  invalids.reset();
  while (invalids.next()) {
    var g = invalids.value;
    if (!(g instanceof Group)) continue;
    this.measureArrangeGroup(g);
  }

  // then do all Links, which might invalidate label nodes
  invalids.reset();
  while (invalids.next()) {
    var l = invalids.value;
    if (!(l instanceof Link)) continue;
    if (l.isReadyToMeasureArrange()) {
      l.measure(Infinity, Infinity);
      l.arrange();
      // ??? We could put this at draw, but why bother? Right now its also at the end of arrangeLink
      l.makeShapeGeometry();
    } else {
      delay.add(l);
    }
  }

  // then do all Adornments
  invalids.reset();
  while (invalids.next()) {
    var a = invalids.value;
    if (!(a instanceof Adornment)) continue;
    if (a.isReadyToMeasureArrange()) {
      a.measure(Infinity, Infinity);
      a.arrange();
    } else {
      delay.add(a);
    }
  }

};

/**
* Recursively walk through group and measure/arrange all its member parts
* @ignore
* @param {Group} group
* @this {Diagram}
*/
Diagram.prototype.measureArrangeGroup = function(group) {
  var itr = group.memberParts;
  var links = Util.tempArray();
  while (itr.next()) {
    var m = itr.value;
    if (m instanceof Group) {
      if (m.getInvalidMeasure() || m.getInvalidArrange() || m.getInvalidPosition()) {
        this.measureArrangeGroup(m);
      }
    } else if (m instanceof Link) {
      links.push(m);
    } else { // It's a Node or Part
      m.measure(Infinity, Infinity);
      m.arrange();
    }
  }

  var l = links.length;
  for (var i = 0; i < l; i++) {
    var link = links[i];
    link.measure(Infinity, Infinity);
    link.arrange();
  }
  Util.freeArray(links);

  group.measure(Infinity, Infinity);
  group.arrange();
};

/**
* @ignore
* @this {Diagram}
* @param {Array} layers
* @param {number} l
* @param {Diagram} diagram
* @param {Rect=} viewport
*/
Diagram.prototype.setInView = function(layers, l, diagram, viewport) {
  for (var i = 0; i < l; i++) {
    layers[i].setInView(diagram, viewport);
  }
};

/**
* Draws the contents of all layers onto this diagram's HTML canvas element.
* @ignore
* @param {CanvasRenderingContext2D=} ctx Special context to draw upon.
* @param {Set=} exclusion a set of objects to exclude from drawing.
* @this {Diagram}
*/
Diagram.prototype.draw = function(ctx, exclusion) {
  if (this._div === null) { Util.throwError('No div specified'); }
  var can = this._canvas;
  if (can === null) { Util.throwError('No canvas specified'); }

  if (!ctx) ctx = this._ctx;
  var foreign = (ctx !== this._ctx);

  var layers = this._layers._arr;
  var l = layers.length;
  var diagram = this;
  this.setInView(layers, l, diagram);


  if (foreign) {
    this.clearContextCache(ctx);
    this.invalidateViewportObjects();
  } else {
    if (!this._invalidDraw && exclusion === undefined) return;
  }

  var pos = this._position;
  var scale = this._scale;
  var roundedx = Math.round(pos.x * scale) / scale;
  var roundedy = Math.round(pos.y * scale) / scale;

  var t = this._transform;
  t.reset();
  if (scale !== 1) t.scale(scale);
  if (pos.x !== 0 || pos.y !== 0) t.translate(-roundedx, -roundedy);

  var rects = this._drawingRects;
  var usingRects = (rects !== null && rects.length > 0 && this._rectOptimizations === true);

  var collection = null;

  if (usingRects) {
    // IE10 cannot have clipping regions that are not paths of a single rectangle:
    // IE9 is fine!
    // https://connect.microsoft.com/IE/feedback/details/782736/canvas-clearrect-fails-with-non-rectangular-yet-simple-clipping-paths
    var ie10 = this._isIE10;

    ctx.save();
    ctx.beginPath();
    l = rects.length;
    for (var i = 0; i < l; i++) {
      var r = rects[i];
      if (r[2] === 0 && r[3] === 0) continue;
      var rect = this.transformRectDocToView(r);
      // modifying the clipping region like this means we need to intersect a larger area
      // when testing the drawingRect intersections (see Layer.intersectsAnyRect)
      ctx.rect(Math.floor(rect[0]) - 1, Math.floor(rect[1]) - 1, Math.ceil(rect[2]) + 2, Math.ceil(rect[3]) + 2);
      if (ie10) {
        ctx.clearRect(Math.floor(rect[0]) - 1, Math.floor(rect[1]) - 1, Math.ceil(rect[2]) + 2, Math.ceil(rect[3]) + 2);
      }
    }
    ctx.clip();
  }

  if (this._isAndroid534) { // setting width will destroy clipping from usingRects
    can.width = can.width;
    usingRects = false;
    this.clearContextCache(ctx);
  } else {
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, can.width, can.height);
  }

  // to fix a chrome bug:
  // https://code.google.com/p/chromium/issues/detail?id=225512
  ctx.miterLimit = 9;

  ctx.setTransform(t.m11, t.m12, t.m21, t.m22, t.dx, t.dy);

  if (Debug && Debug.boundsInfoEnabled) Debug.drawBoundsInfo(this, ctx);

  var func;
  if (exclusion) {
    /** @ignore */
    func = function(l) { l.drawExclusion(ctx, diagram, exclusion); };
  } else if (collection) {
    /** @ignore */
    func = function(l) { l.drawOnly(ctx, diagram, collection); };
  } else if (usingRects) {
    /** @ignore */
    func = function(l) { l.drawIntersection(ctx, diagram, rects); };
  } else { // redraw everything
    /** @ignore */
    func = function(l) { l.draw(ctx, diagram); };
  }

  this.setRenderingHints(ctx);

  l = layers.length;
  for (var i = 0; i < l; i++) {
    func(layers[i]);
  }
  this._drawingRects = [];

  // wmq
  if (this._helper) {
    this._helper.wmq(this) && this.__drawImage();
  } else {
    this._getMouse = function() { };
  }


  if (usingRects) {
    ctx.restore();
    this.clearContextCache(ctx);
    if (Debug && Debug.drawingRectsEnabled) { Debug.drawRects(rects, ctx, this); }
  }

  if (Debug && (Debug.drawLocationsEnabled || Debug.boundsInfoEnabled)) { Debug.drawBoundsInfoLocations(ctx, this, t); }


  if (foreign) {
    this.clearContextCache();
    this.invalidateViewportObjects();
  } else { // validate
    this._invalidViewportObjects = false;
    this._invalidDraw = false;
  }
};

/**
* Uses a saved image to to redraw the viewport at a different location.
* After drawing the image, this draws the contents that intersects with a given set of rects.
* This is used for scrolling optimizations where two or three regions need to be redrawn.
* @ignore
* @param {Array} rects clipping region rects in document coordinates.
* @param {Array} viewRects precise (integer coordinate) clipping region rects in viewport coordinates.
* @param {number} x coordinates for the saved image.
* @param {number} y
* @this {Diagram}
*/
Diagram.prototype.redrawViewport = function(rects, viewRects, x, y) {
  if (this._div === null) { Util.throwError('No div specified'); }
  var can = this._canvas;
  if (can === null) { Util.throwError('No canvas specified'); }

  var ctx = this._ctx;
  if (!this._invalidDraw) return;

  if (this._isAndroid534) {
    can.width = can.width;
    this.clearContextCache(ctx);
  } else {
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, can.width, can.height);
  }

  // needed for Chrome for android
  // https://code.google.com/p/chromium/issues/detail?id=231916
  ctx.webkitImageSmoothingEnabled = false;
  ctx.imageSmoothingEnabled = false; // ??? not neessarily needed?

  ctx.drawImage(this._drawCollectionCanvas,
    (x > 0) ? 0 : Math.round(-x),
    (y > 0) ? 0 : Math.round(-y));

  var pos = this._position;
  var scale = this._scale;
  var roundedx = Math.round(pos.x * scale) / scale;
  var roundedy = Math.round(pos.y * scale) / scale;
  var t = this._transform;
  t.reset();
  if (scale !== 1) t.scale(scale);
  if (pos.x !== 0 || pos.y !== 0) t.translate(-roundedx, -roundedy);

  // Before transform, make clipping region with viewRects:
  ctx.save();
  ctx.beginPath();
  var l = viewRects.length;
  for (var i = 0; i < l; i++) {
    var rect = viewRects[i];
    if (rect[2] === 0 || rect[3] === 0) continue;
    // modifying the clipping region like this means we need to intersect a larger area
    // when testing the drawingRect intersections (see Layer.intersectsAnyRect)
    ctx.rect(Math.floor(rect[0]), Math.floor(rect[1]), Math.ceil(rect[2]), Math.ceil(rect[3]));
  }
  ctx.clip();

  ctx.setTransform(t.m11, t.m12, t.m21, t.m22, t.dx, t.dy);
  if (Debug && Debug.boundsInfoEnabled) Debug.drawBoundsInfo(this, ctx);

  var layers = this._layers._arr;
  l = layers.length;
  this.setInView(layers, l, this);

  this.setRenderingHints(ctx);

  for (var i = 0; i < l; i++) {
    layers[i].drawIntersection(ctx, this, rects);
  }

  ctx.restore();
  this.clearContextCache();

  if (Debug && (Debug.drawLocationsEnabled || Debug.boundsInfoEnabled)) {
    Debug.drawBoundsInfoLocations(ctx, this, t);
  }

  // wmq
  if (this._helper) {
    this._helper.wmq(this) && this.__drawImage();
  } else {
    this._getMouse = function() { };
  }

  this._invalidViewportObjects = false;
  this._invalidDraw = false;
};

/**
* Draws the contents of all layers onto this diagram's HTML canvas element.
* @ignore
* @param {CanvasRenderingContext2D} ctx Special context to draw upon.
* @param {Margin} padding Padding transform MUST be taken care of here, but padding size must be taken care of before.
* @param {Size} size specific drawing size (typically the size of ctx).
* @param {number} scale specific drawing scale.
* @param {Point} position specific drawing position.
* @param {Iterable=} parts a set of parts to draw instead of everything.
* @param {string=} background a background color.
* @param {boolean=} showTemporary
* @param {boolean=} showGrid
* @this {Diagram}
*/
Diagram.prototype.drawForeign = function(ctx, padding, size, scale, position, parts, background, showTemporary, showGrid) {
  if (this._div === null) { Util.throwError('No div specified'); }
  if (this._canvas === null) { Util.throwError('No canvas specified'); }
  this.clearContextCache();
  this.invalidateViewportObjects();

  var viewRect = undefined;
  if (position && size && scale) viewRect = new Rect(position.x, position.y, size.width / scale, size.height / scale);
  var viewRectPlusPadding = viewRect.copy();
  viewRectPlusPadding.addMargin(padding);
  this._updateBackgroundGrid(viewRectPlusPadding);
  this.validateParts();

  var layers = this._layers._arr;
  var l = layers.length;
  var diagram = this;
  this.setInView(layers, l, diagram, viewRect);

  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, size.width, size.height);
  if (background) {
    ctx.fillStyle = background;
    ctx.fillRect(0, 0, size.width, size.height);
  }

  var t = Util.tempTransform();
  t.reset();
  t.translate(padding.left, padding.top);
  t.scale(scale);
  if (position.x !== 0 || position.y !== 0) {
    t.translate(-position.x, -position.y);
  }
  ctx.setTransform(t.m11, t.m12, t.m21, t.m22, t.dx, t.dy);
  Util.freeTransform(t);

  this.setRenderingHints(ctx);
  var func;
  if (parts) {
    var myset = new Set();
    var itr = parts.iterator;
    itr.reset();
    while (itr.next()) {
      var part = itr.value.part;
      if (showGrid === false && part.layer.name === 'Grid') continue;
      if (part !== null) myset.add(part);
    }
    /** @ignore */
    func = function(l) { l.drawOnly(ctx, diagram, myset, viewRect, showTemporary); };
  } else if (!showTemporary && showGrid) {
    var gp = diagram.grid.part;
    var gridlayer = gp.layer;
    func = function(l) {
      if (l === gridlayer) {
        gp.draw(ctx, diagram);
      } else {
        l.draw(ctx, diagram, viewRect, showTemporary, showGrid);
      }
    };
  } else {
    /** @ignore */
    func = function(l) {
      l.draw(ctx, diagram, viewRect, showTemporary, showGrid);
    };
  }

  for (var i = 0; i < l; i++) {
    func(layers[i]);
  }


  // wmq
  if (this._helper) {
    this._helper.wmq(this) && this.__drawImage();
  } else {
    this._getMouse = function() { };
  }

  this.clearContextCache();
  this.invalidateViewportObjects();
  this._updateBackgroundGrid(); // return to normal
};

/**
* Used at draw time
* @ignore
* @this {Diagram}
*/
Diagram.prototype.setRenderingHints = function(ctx) {
  var r = this.renderingHints;
  if (r === null) return;
  if (r['imageSmoothingEnabled'] !== undefined) {
    var smooth = !!(r['imageSmoothingEnabled']);
    ctx.imageSmoothingEnabled = smooth;
    ctx.webkitImageSmoothingEnabled = smooth;
    ctx.mozImageSmoothingEnabled = smooth;
  }
};


/**
* Used at draw time
* @ignore
* @this {Diagram}
*/
Diagram.prototype.clearDelayedGeometries = function() {
  if (this._delayedGeometries.count > 0) {
    var it = this._delayedGeometries.iterator;
    while (it.next()) {
      var link = it.key;
      var oldbounds = it.value;
      link.invalidateOtherJumpOvers(oldbounds);
    }
    this._delayedGeometries.clear();
  }
};

/**
* Causes the diagram to redraw eventually. Use Diagram.redraw for immediate redrawing.
* @ignore
* @this {Diagram}
* @param {Rect=} rect1 An optional area to invalidate in document coordinates.
* @param {Rect=} rect2 An optional area to invalidate in document coordinates.
*/
Diagram.prototype.invalidateDraw = function(rect1, rect2) {
  // only invalidate draw and request an update if the rect is in the viewportBounds
  if (!this._rectOptimizations || rect1 === undefined || this._drawingRects === null) {
    this._drawingRects = null;
    this._invalidDraw = true;
    this.requestUpdate();
  } else {
    var v = this.viewportBounds;
    if ((rect1 && v.intersectsRect(rect1)) ||
        (rect2 && v.intersectsRect(rect2))) {
      if (this._drawingRects !== null) {
        if (rect1 && rect1.isReal()) {
          this.addDrawingRect(rect1.x - 2, rect1.y - 2, rect1.width + 4, rect1.height + 4);
        }
        if (rect2 && rect2.isReal()) {
          this.addDrawingRect(rect2.x - 2, rect2.y - 2, rect2.width + 4, rect2.height + 4);
        }
      }
      this._invalidDraw = true;
      this.requestUpdate();
    }
  }

  // Lastly, notify any observing Overviews
  var it = this._overviews.iterator;
  while (it.next()) {
    it.value.invalidateDraw(rect1, rect2);
  }
};

// not yet public, published so we can toggle it in realtime
/**
* @ignore
* @name Diagram#viewportOptimizations
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Diagram.prototype.viewportOptimizations;
Util.exportProperty(Diagram, 'viewportOptimizations', Diagram.prototype.viewportOptimizations);
Util.defineProperty(Diagram, { viewportOptimizations: null },
  /** @this {Diagram} */
  function() { return this._viewportOptimizations; },
  /** @this {Diagram} */
  function(val) {
    Util.checkPrimitive(val, 'boolean', Diagram, 'viewportOptimizations');
    this._drawingRects = null;
    this._viewportOptimizations = val;
  }
);

/**
* @ignore
* @this {Diagram}
* @param {Object} obj
* @param {boolean} results
* @return {Object}
*/
Diagram.prototype.unsupported = function(obj, results) {

  if (results === true) {
    var result = {};
    if (obj['viewportOptimizations'] !== undefined) result['viewportOptimizations'] = this.viewportOptimizations;
    return result;
  }

  if (obj['viewportOptimizations'] !== undefined) this.viewportOptimizations = obj['viewportOptimizations'];
  return null;
};

/**
* @ignore
* Add a new rectangle to the drawingRects list
* tests the new rect (A) against each old rect (B). If A has two corners in B,
* A will be shrunk to exclude the union of A+B.
* If B is entirely within A, B will have its width and height set to zero.
* If A is entirely within B, no new rects will be added (return false)
* After rect areas are fixed, they will then be coalesced.
* returns false if A did not expand the dirty area
* @this {Diagram}
* @param {number} x
* @param {number} y
* @param {number} w
* @param {number} h
* @return {boolean}
*/
Diagram.prototype.addDrawingRect = function(x, y, w, h) {
  x = Math.floor(x);
  y = Math.floor(y);
  w = Math.ceil(w);
  h = Math.ceil(h);
  var dRects = this._drawingRects;
  var numRects = dRects.length;
  var epsilon = 50; // some more appropriate number?

  // lossless combinations:
  // compleltely in = flatten a rect
  // partially in = make a rect smaller
  for (var i = 0; i < numRects; i++) {
    var cur = dRects[i];

    // new region falls completely within existing region
    if (x >= cur[0] && y >= cur[1] && x + w <= cur[0] + cur[2] && y + h <= cur[1] + cur[3]) {
      return false;

    // existing region falls completely within new region
    } else if (x <= cur[0] && y <= cur[1] && x + w >= cur[0] + cur[2] && y + h >= cur[1] + cur[3]) {
      dRects[i][2] = 0; // setting width and height to zero
      dRects[i][3] = 0;

    // left end of new region falls within existing region
    } else if (x >= cur[0] && x < cur[0] + cur[2] && y >= cur[1] && y + h <= cur[1] + cur[3]) {
      w = x + w - (cur[0] + cur[2]);
      x = cur[0] + cur[2];
      i = -1; continue;

    // right end of new region falls within existing region
    } else if (x + w > cur[0] && x + w <= cur[0] + cur[2] && y >= cur[1] && y + h <= cur[1] + cur[3]) {
      w = cur[0] - x;
      i = -1; continue;

    // top end of new region falls within existing region
    } else if (x >= cur[0] && x + w <= cur[0] + cur[2] && y >= cur[1] && y < cur[1] + cur[3]) {
      h = y + h - (cur[1] + cur[3]);
      y = cur[1] + cur[3];
      i = -1; continue;

    // bottom end of new region falls within existing region
    } else if (x >= cur[0] && x + w <= cur[0] + cur[2] && y + h > cur[1] && y + h <= cur[1] + cur[3]) {
      h = cur[1] - y;
      i = -1; continue;

    // left end of existing region falls within new region
    } else if (dRects[i][0] >= x && dRects[i][0] < x + w && dRects[i][1] >= y && dRects[i][1] + dRects[i][3] <= y + h) {
      dRects[i][2] = dRects[i][2] - (x + w - dRects[i][0]);
      dRects[i][0] = x + w;
      i = -1; continue;

    // right end of existing region falls within new region
    } else if (dRects[i][0] + dRects[i][2] > x && dRects[i][0] + dRects[i][2] <= x + w &&
               dRects[i][1] >= y && dRects[i][1] + dRects[i][3] <= y + h) {
      dRects[i][2] = x - dRects[i][0];
      i = -1; continue;

    // top end of existing region falls within new region
    } else if (dRects[i][0] >= x && dRects[i][0] + dRects[i][2] <= x + w && dRects[i][1] >= y && dRects[i][1] < y + h) {
      dRects[i][3] = dRects[i][3] - (y + h - dRects[i][1]);
      dRects[i][1] = y + h;
      i = -1; continue;

    // bottom end of existing region falls within new region
    } else if (dRects[i][0] >= x && dRects[i][0] + dRects[i][2] <= x + w &&
               dRects[i][1] + dRects[i][3] > y && dRects[i][1] + dRects[i][3] <= y + h) {
      dRects[i][3] = y - dRects[i][1];
      i = -1; continue;
    }

  }

  // attempt combinations
  for (var i = 0; i < numRects; i++) {
    var cur = dRects[i];
    if (w > 0 && h > 0 && cur[2] > 0 && cur[3] > 0 &&
        ((Math.max(x + w, cur[0] + cur[2]) - Math.min(x, cur[0])) *
         (Math.max(y + h, cur[1] + cur[3]) - Math.min(y, cur[1])) <
         w * h + cur[2] * cur[3] + epsilon)) {
      var a = Math.min(cur[0], x);
      var b = Math.min(cur[1], y);
      var c = Math.max(x + w, cur[0] + cur[2]) - Math.min(cur[0], x);
      var d = Math.max(y + h, cur[1] + cur[3]) - Math.min(cur[1], y);
      dRects[i][2] = 0;
      dRects[i][3] = 0;
      return this.addDrawingRect(a, b, c, d);
    }
  }

  dRects.push([x, y, w, h]);
  return true;
};

/**
* Causes the diagram to redraw.
* @ignore
* @this {Diagram}
* @param {Rect=} oldv old viewport bounds.
* @param {Rect=} newv new viewport bounds.
*/
Diagram.prototype.invalidateViewport = function(oldv, newv) {
  // only invalidate draw and request an update if the rect is in the viewportBounds
  if (this._invalidDraw === true) return;
  this._invalidDraw = true;
  if (this instanceof Overview) {
    this.requestCachedUpdate();
  } else {
    if (this._viewportOptimizations === true &&
        newv.width === oldv.width &&
        newv.height === oldv.height) {
      //oldv, newv
      var scale = this.scale;
      var r = Util.tempRect(); // intersection of oldv and newv
      var maxx = Math.max(oldv.x, newv.x);
      var maxy = Math.max(oldv.y, newv.y);
      var minr = Math.min(oldv.x + oldv.width, newv.x + newv.width);
      var minb = Math.min(oldv.y + oldv.height, newv.y + newv.height);
      r.x = maxx;
      r.y = maxy;
      r.width = Math.max(0, minr - maxx) * scale;
      r.height = Math.max(0, minb - maxy) * scale;

      // if intersection exists
      if (r.width > 0 && r.height > 0) {
        this.updateViewport(r, oldv, newv);
      } else { // if it does not exist, request a normal update
        this.requestUpdate();
      }
      Util.freeRect(r);
    } else {
      this.maybeUpdate();
    }
  }

  // Lastly, notify any observing Overviews
  var it = this._overviews.iterator;
  while (it.next()) {
    it.value.invalidateViewport();
  }
};

/**
* Causes the diagram to update the scrollbars.
* @ignore
* @this {Diagram}
*/
Diagram.prototype.invalidateScroll = function() {
  if (this._invalidScrollBars === false) {
    this._invalidScrollBars = true;
  }
};

/**
* Causes the diagram to redraw.
* @ignore
* @this {Diagram}
*/
Diagram.prototype.invalidateViewportObjects = function() {
  if (this._invalidViewportObjects === false) {
    this._invalidViewportObjects = true;
  }
};

/**
* @ignore
* Method for resizing the canvas as well as the scrollbar helper divs.
* @this {Diagram}
*/
Diagram.prototype.updateScroll = function() {
  var can = this._canvas;
  if (can === null) return;
  var div = this._div;
  var oldw = can.width;
  var oldh = can.height;

  var oldvpb = this._viewportBounds.copy();
  var scrollbarsChanged = false;

  // check and see if the canvas is the same size as its immediate parent in the DOM (this._div)
  // if not, resize the canvas
  var sw = this._hasVScroll ? this._scrollBarBreadth : 0;
  var sh = this._hasHScroll ? this._scrollBarBreadth : 0;

  var cw = div.clientWidth || can.width + sw;
  var ch = div.clientHeight || can.height + sh;

  if (cw !== can.width + sw || ch !== can.height + sh) {
    // if the canvas changes size, we'll need a full repaint
    this._hasVScroll = false;
    this._hasHScroll = false;
    sw = 0;
    sh = 0;
    can.width = cw;
    can.height = ch;
    scrollbarsChanged = true;
  }

  this._invalidScrollBars = false;
  if (this._scrollBarMoving) {
    if (oldw !== can.width || oldh !== can.height) this.maybeUpdate();
    return;
  }

  // The following only happens if we need to move the scrollbars. (Because resize, scale change, position change, etc)
  // Does not happen if a user is moving the scrollbar.
  var viewportBounds = this.viewportBounds; // since it is generated each time
  var docb = this.documentBounds;

  var dw = docb.width;
  var dh = docb.height;
  var vw = viewportBounds.width;
  var vh = viewportBounds.height;

  // for when document is left of viewport
  var dx = docb.x;
  var vx = viewportBounds.x;
  // for when document is right of viewport
  var dright = docb.right;
  var vright = viewportBounds.right;
  // for when document is above
  var dy = docb.y;
  var vy = viewportBounds.y;
  // for when document is below
  var dbottom = docb.bottom;
  var vbottom = viewportBounds.bottom;

  var helperwidth = '1px';
  var helperheight = '1px';
  // If the client width/height is larger than the document bounds,
  // we don't need to do any of this because there cannot be scrollbars
  var scale = this.scale;
  if (!(cw / scale > dw && ch / scale > dh)) {
    if (this.hasHorizontalScrollbar && this.allowHorizontalScroll) { // horizontal scrollbar
      if (vw + 1 < dw) { //smaller view than the diagram
        helperwidth = (dw - vw) * scale + can.width + 'px';
        this._scrollHorizontalParent.scrollLeft = (this.position.x - dx) * scale;
      } else if (dx + 1 < vx) { // diagram is out of the views bounds on the left
        helperwidth = (vx - dx) * scale + can.width + 'px';
        this._scrollHorizontalParent.scrollLeft = this._scrollHorizontalParent.scrollWidth - this._scrollHorizontalParent.clientWidth;
      } else if (dright > vright + 1) { // diagram is out of the views bounds on the right
        helperwidth = (dright - vright) * scale + can.width + 'px';
        this._scrollHorizontalParent.scrollLeft = this.position.x * scale;
      }
    }

    if (this.hasVerticalScrollbar && this.allowVerticalScroll) { // vertical scrollbar
      if (vh + 1 < dh) {
        helperheight = ((dh - vh) * scale) + can.height + 'px';
        this._scrollVerticalParent.scrollTop = (this.position.y - dy) * scale;
      } else if (dy + 1 < vy) { // diagram is out of the views bounds on the top
        helperheight = (vy - dy) * scale + can.height + 'px';
        this._scrollVerticalParent.scrollTop = this._scrollVerticalParent.scrollHeight - this._scrollVerticalParent.clientHeight;
      } else if (dbottom > vbottom + 1) { // diagram is out of the views bounds on the bottom
        helperheight = (dbottom - vbottom) * scale + can.height + 'px';
        this._scrollVerticalParent.scrollTop = this.position.y * scale;
      }
    }
  }
  var newHScroll = (helperwidth !== '1px');
  var newVScroll = (helperheight !== '1px');

  // if different than before
  if (newHScroll !== this._hasHScroll) {
    if (helperwidth === '1px') { // there is no more scrollbar (but once was)
      can.height = can.height + this._scrollBarBreadth;
    } else { // there is now a scrollbar
      can.height = Math.max(can.height - this._scrollBarBreadth, 1);
    }
    scrollbarsChanged = true;
  }
  // Must happen every time (scrollbar might already exist and get bigger/smaller)
  this._hasHScroll = newHScroll;
  this._scrollHelperHorizontal.style.width = helperwidth;

  // if different than before
  if (newVScroll !== this._hasVScroll) {
    if (helperheight === '1px') { // there is no more scrollbar (but once was)
      can.width = can.width + this._scrollBarBreadth;
    } else { // there is now a scrollbar
      can.width = Math.max(can.width - this._scrollBarBreadth, 1);
    }
    scrollbarsChanged = true;
  }
  // Must happen every time (scrollbar might already exist and get bigger/smaller)
  this._hasVScroll = newVScroll;
  this._scrollHelperVertical.style.height = helperheight;

  if (scrollbarsChanged) this.clearContextCache();

  // scroll parents must be sized with the canvas to keep the right form
  cw = can.width;
  ch = can.height;

  this._scrollVerticalParent.style.height = ch + 'px';
  this._scrollVerticalParent.style.width = (cw + (this._hasVScroll ? this._scrollBarBreadth : 0)) + 'px'; // ?
  this._scrollHorizontalParent.style.width = cw + 'px';
  this._scrollHorizontalParent.style.height = (ch + (this._hasHScroll ? this._scrollBarBreadth : 0)) + 'px';

  // signal that a scrollbar has not been clicked so this._onscroll is a no-op
  this._scrollBarClicked = false;

  // Only if a canvas has changed size:
  if (oldw !== cw || oldh !== ch) {
    viewportBounds = this.viewportBounds;
    this.onViewportBoundsChanged(oldvpb, viewportBounds, scrollbarsChanged ? true : undefined);
    return false; // returns false if the canvas size has changed
  }
  return true; // returns true if the canva size has not changed
};

/**
 * @ignore
 * @param {string} name
 * @this {Diagram}
 */
Diagram.prototype._checkLayerName = function(name) {
  var layers = this._layers;
  var l = layers.count;
  for (var i = 0; i < l; i++) {
    if (layers.elt(i).name === name) {
      Util.throwError('Cannot add layer with the name \'' +
      name + '\', a layer of the same name is already present in this diagram.');
    }
  }
};

/**
* @ignore
* Gets or sets whether newly added Parts are forced to be added to a temporary Layer.
* The initial value is false.
* Setting this property does not notify about any changed event.
* @name Diagram#addsToTemporaryLayer
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Diagram.prototype.addsToTemporaryLayer;
Util.exportProperty(Diagram, 'addsToTemporaryLayer', Diagram.prototype.addsToTemporaryLayer);
Util.defineProperty(Diagram, { addsToTemporaryLayer: null },
  /** @this {Diagram} */
  function() { return this._addsToTemporaryLayer; },
  /** @this {Diagram} */
  function(val) {
    Util.checkPrimitive(val, 'boolean', Diagram, 'addsToTemporaryLayer');
    this._addsToTemporaryLayer = val;
  }
);

Diagram.prototype['add'] =
/**
* Adds a {@link Part} to the {@link Layer} that matches the Part's {@link Part#layerName},
* or else the default layer, which is named with the empty string.
* @this {Diagram}
* @param {Part} part
*/
Diagram.prototype.add = function(part) {
  Util.checkClass(part, Part, Diagram, 'add:part');
  var d = part.diagram;
  if (d === this) return;
  if (d !== null) {
    Util.throwError('Cannot add part ' + part.toString() + ' to ' + this.toString() +
                    '. It is already a part of ' + d.toString());
  }
  // Parts have layerNames, which might specify a certain layer they want to be in.
  var layername = (this.addsToTemporaryLayer ? 'Tool' : part.layerName);
  var layer = this.findLayer(layername);
  if (layer === null) layer = this.findLayer('');
  if (layer === null) Util.throwError('Cannot add a Part when unable find a Layer named "' + layername + '" and there is no default Layer');
  if (part.layer === layer) return; // should be a no-op
  if (part.diagram === this) {
    // we are just swapping layers
    var index = layer.internalAdd(99999999, part, true);
  } else {
    var index = layer.internalAdd(99999999, part);
  }
  if (index >= 0) this.raiseChangedEvent(ChangedEvent.Insert, 'parts', layer, null, part, null, index);

  if (!layer.isTemporary) this.invalidateDocumentBounds();
  // called after adding the part to a layer
  part.invalidateLayout(Part.LayoutAdded);

  // Layer.add will call Diagram.internalAdd
  var func = part.layerChanged;
  if (func !== null) func(part, null, layer);
};

/**
* @ignore
* This is called from {@link Layer#internalAdd} for bookkeeping.
* @this {Diagram}
* @param {Part} part
*/
Diagram.prototype.internalAdd = function(part) {
  // Maintain the collection of Nodes (and Groups) and Links, but not Adornments
  if (part instanceof Node) {
    this._nodes.add(part);
    if (part instanceof Group) {
      var cg = part.containingGroup;
      if (cg === null) {
        this._topLevelGroups.add(part);
      } else {
        cg._nestedGroups.add(part);
      }
      // update backpointer for Group.layout
      var layout = part.layout;
      if (layout !== null) layout.diagram = this;
    }
  } else if (part instanceof Link) {
    this._links.add(part);
  } else if (!(part instanceof Adornment)) {
    this._parts.add(part);
  }

  // might be null (Adornment with none) or undefined (regular Node)
  if (part._placeholder) part.invalidateMeasure();

  var data = part.data;
  if (data) {
    if (!(part instanceof Adornment)) {
      if (part instanceof Link) {
        this._dataLinkMap.add(data, part);
      } else {
        this._dataPartMap.add(data, part);
      }
    }
    var dia = this;
    part.walkPanels(function(p) { dia.rememberItemArrayPanel(p); });
  }

  if (part.getInvalidArrange() === true || part.getInvalidPosition() === true) {
    this._invalidObjects.add(part);
  }
  // always notify to ensure that the part is book-kept in the layer too. Important for copying.
  part.notifyDiagram(true, this);

  // Update the document bounds
  if (part.isVisible()) {
    if (part.actualBounds.isReal()) this.invalidateDraw(part.getDrawnSize(part.actualBounds));
    this.invalidateDocumentBounds();
  }
};

/**
* @ignore
* This is called from {@link Layer#internalRemove} for bookkeeping.
* @this {Diagram}
* @param {Part} part
*/
Diagram.prototype.internalRemove = function(part) {
  part.clearAdornments(); // ??? right place to put this? Needed since adornments were virtualized
  if (part instanceof Node) {
    this._nodes.remove(part);
    if (part instanceof Group) {
      var cg = part.containingGroup;
      if (cg === null) {
        this._topLevelGroups.remove(part);
      } else {
        cg._nestedGroups.remove(part);
      }
      // update backpointer for Group.layout
      var layout = part.layout;
      if (layout !== null) layout.diagram = null;
    }
  } else if (part instanceof Link) {
    this._links.remove(part);
  } else if (!(part instanceof Adornment)) {
    this._parts.remove(part);
  }

  var data = part.data;
  if (data) {
    if (!(part instanceof Adornment)) {
      if (part instanceof Link) {
        this._dataLinkMap.remove(data);
      } else {
        this._dataPartMap.remove(data);
      }
    }
    var dia = this;
    part.walkPanels(function(p) { dia.forgetItemArrayPanel(p); });
  }

  this._invalidObjects.remove(part);
  // Update the document bounds
  if (part.isVisible()) {
    if (part.actualBounds.isReal()) this.invalidateDraw(part.getDrawnSize(part.actualBounds));
    this.invalidateDocumentBounds();
  }
};

Diagram.prototype['remove'] =
/**
* Removes a {@link Part} from its {@link Layer}, provided the Layer is in this Diagram.
* @this {Diagram}
* @param {Part} part
*/
Diagram.prototype.remove = function(part) {
  Util.checkClass(part, Part, Diagram, 'remove:part');
  // make sure it's no longer selected
  part.isSelected = false;

  var layer = part.layer;
  if (layer === null) return;
  if (layer.diagram !== this) return;

  // call this before removing from any layer
  part.invalidateLayout(Part.LayoutRemoved);

  // delete links connected to nodes, members of groups, labelnodes of links
  part.deleteCascade();

  // remove from layer; it will call Diagram.internalRemove
  var index = layer.internalRemove(-1, part);
  if (index >= 0) this.raiseChangedEvent(ChangedEvent.Remove, 'parts', layer, part, null, index, null);

  var func = part.layerChanged;
  if (func !== null) func(part, layer, null);
  if (!layer.isTemporary) this.invalidateDocumentBounds();
};


Diagram.prototype['removeParts'] =
/**
* @ignore
* This method removes all of the {@link Part}s in a collection from this Diagram.
* <p/>
* This does not perform a transaction nor does it raise a {@link DiagramEvent}.
* <p/>
* Removing a Group does not remove its member Nodes or Links unless they too are in the argument collection.
* However the {@link CommandHandler#deleteSelection} command does automatically remove Parts owned by a Group,
* and it may delete other Parts as well.
* @this {Diagram}
* @param {Iterable} coll A {@link List} or {@link Set} or {@link Iterable} of {@link Part}s.
* @param {boolean} check Whether to check {@link Part#canDelete} on each part.
*/
Diagram.prototype.removeParts = function(coll, check) {
  var it = coll.iterator;
  while (it.next()) {
    var part = it.value;
    var diagram = part.diagram;
    if (diagram !== this) continue;
    if (check && !part.canDelete()) continue;
    this.remove(part);
  }
};

Diagram.prototype['copyParts'] =
/**
* @ignore
* Make a copy of a collection of {@link Part}s and return them in a {@link Map} mapping each original Part to its copy.
* It may optionally add them to a given {@link Diagram}.
* <p/>
* This does not perform a transaction nor does it raise a {@link DiagramEvent}.
* <p/>
* Copying a Group will also copy its member Nodes and Links.
* Copying a Link will also copy any label Nodes that it owns.
* The {@link CommandHandler#copySelection} command may also copy additional Parts as well.
* @this {Diagram}
* @param {Iterable} coll  A {@link List} or a {@link Set} or {@link Iterable} of {@link Part}s.
* @param {Diagram} diagram  The destination diagram; if null, the copied parts are not added to this diagram.
* @param {boolean} check  Whether to check {@link Part#canCopy} on each part.
* @return {Map}  Map(Part, Part).
*/
Diagram.prototype.copyParts = function(coll, diagram, check) {
  return this.commandHandler.copyParts(coll, diagram, check);
};

Diagram.prototype['moveParts'] =
/**
* @ignore
* Move a collection of {@link Part}s in this Diagram by a given offset.
* <p/>
* This does not perform a transaction nor does it raise a {@link DiagramEvent}.
* <p/>
* Moving a Group does not move its member Nodes or Links unless they too are in the argument collection.
* You can call {@link Part#move} on a Group to move the Group and all of its member Parts.
* The {@link DraggingTool} may move additional Parts as well.
* @this {Diagram}
* @param {Iterable} coll  A {@link List} or a {@link Set} or {@link Iterable} of {@link Part}s.
* @param {Point} offset  the X and Y change to be made to each Part, in document coordinates.
* @param {boolean} check  Whether to check {@link Part#canMove} on each part.
*/
Diagram.prototype.moveParts = function(coll, offset, check) {
  var mgr = this.toolManager;
  if (mgr === null) return;
  var tool = mgr.draggingTool;
  if (tool === null) return;
  var map = new Map(Part, Object);
  var it = coll.iterator;
  while (it.next()) {
    var p = it.value;
    if (p instanceof Link) {
      map.add(p, tool._newDraggingInfo());
    } else {
      map.add(p, tool._newDraggingInfo(p.location));
    }
  }
  tool.moveParts(map, offset, check);
};


Diagram.prototype['addLayer'] =
/**
* Adds a {@link Layer} to the list of layers.
* If {@link Layer#isTemporary} is false, the layer is added after all existing non-temporary layers.
* If {@link Layer#isTemporary} is true, the layer is added as the very last layer.
* @this {Diagram}
* @param {Layer} layer The Layer to add.
* @see #addLayerBefore
* @see #addLayerAfter
* @see #removeLayer
* @see #findLayer
*/
Diagram.prototype.addLayer = function(layer) {
  Util.checkClass(layer, Layer, Diagram, 'addLayer:layer');
  this._checkLayerName(layer.name);
  layer.setDiagram(this);
  var firsttemplayer = null;
  var layers = this._layers;
  var i = layers.count - 1;
  if (!layer.isTemporary) {
    while (i >= 0 && layers.elt(i).isTemporary) i--;
  }
  layers.insertAt(i + 1, layer);
  if (this._model !== null) this.raiseChangedEvent(ChangedEvent.Insert, 'layers', this, null, layer, null, i + 1);
  this.invalidateDocumentBounds();
};

Diagram.prototype['addLayerBefore'] =
/**
* Adds a layer to the list of layers before a specified layer.
* @this {Diagram}
* @param {Layer} layer The Layer to add.
* @param {Layer} existingLayer The layer to insert before.
* @see #addLayer
* @see #addLayerAfter
* @see #removeLayer
*/
Diagram.prototype.addLayerBefore = function(layer, existingLayer) {
  Util.checkClass(layer, Layer, Diagram, 'addLayer:layer');
  Util.checkClass(existingLayer, Layer, Diagram, 'addLayerBefore:existingLayer');
  this._checkLayerName(layer.name);
  layer.setDiagram(this);
  var found = false;
  var l = this._layers.count;
  for (var i = 0; i < l; i++) {
    if (this._layers.elt(i) === existingLayer) {
      this._layers.insertAt(i, layer);
      found = true;
      break;
    }
  }
  if (!found) Util.throwError('addLayerBefore: Existing layer ' + existingLayer.toString() + ' not found.');
  if (this._model !== null) this.raiseChangedEvent(ChangedEvent.Insert, 'layers', this, null, layer, null, i);
  this.invalidateDocumentBounds();
};

Diagram.prototype['addLayerAfter'] =
/**
* Adds a layer to the list of layers after a specified layer.
* @this {Diagram}
* @param {Layer} layer The Layer to add.
* @param {Layer} existingLayer The layer to insert after.
* @see #addLayer
* @see #addLayerBefore
* @see #removeLayer
*/
Diagram.prototype.addLayerAfter = function(layer, existingLayer) {
  Util.checkClass(layer, Layer, Diagram, 'addLayer:layer');
  Util.checkClass(existingLayer, Layer, Diagram, 'addLayerAfter:existingLayer');
  this._checkLayerName(layer.name);
  layer.setDiagram(this);
  var found = false;
  var l = this._layers.count;
  for (var i = 0; i < l; i++) {
    if (this._layers.elt(i) === existingLayer) {
      this._layers.insertAt(i + 1, layer);
      found = true;
      break;
    }
  }
  if (!found) Util.throwError('addLayerAfter: Existing layer ' + existingLayer.toString() + ' not found.');
  if (this._model !== null) this.raiseChangedEvent(ChangedEvent.Insert, 'layers', this, null, layer, null, i + 1);
  this.invalidateDocumentBounds();
};

/**
* @ignore
* Adds a layer to the list of layers at a specified index
* only used in undo and redo
* @this {Diagram}
* @param {Layer} layer The Layer to add.
* @param {number} index The index to insert at.
*/
Diagram.prototype.addLayerAt = function(layer, index) {
  Util.checkClass(layer, Layer, Diagram, 'addLayer:layer');
  this._checkLayerName(layer.name);
  layer.setDiagram(this);
  this._layers.insertAt(index, layer);
  if (this._model !== null) this.raiseChangedEvent(ChangedEvent.Insert, 'layers', this, null, layer, null, index);
  this.invalidateDocumentBounds();
};


Diagram.prototype['removeLayer'] =
/**
* Removes the given layer from the list of layers.
* <p/>
* You cannot remove the default layer, the one named with the empty string.
* @this {Diagram}
* @param {Layer} layer
* @see #addLayer
* @see #addLayerBefore
* @see #addLayerAfter
* @see #findLayer
*/
Diagram.prototype.removeLayer = function(layer) {
  if (layer.name === '') return;
  var index = this._layers.indexOf(layer);
  if (this._layers.remove(layer)) {
    var oldparts = layer._parts.copy();
    var pit = oldparts.iterator;
    while (pit.next()) {
      var part = pit.value;
      var oldlayername = part.layerName;
      part.layerName = '';  // change to default layer
      if (oldlayername !== layer.name) {
        part.layerName = oldlayername;  // maybe switch to the originally intended layer
      }
    }
    if (this._model !== null) this.raiseChangedEvent(ChangedEvent.Remove, 'layers', this, layer, null, index, null);
    this.invalidateDocumentBounds();
  }
};

Diagram.prototype['findLayer'] =
/**
* Finds a layer with a given name.
* @this {Diagram}
* @param {string} name
* @return {Layer} a Layer with the given name, or null if no such layer was found.
* @see #addLayerBefore
* @see #addLayerAfter
* @see #removeLayer
*/
Diagram.prototype.findLayer = function(name) {
  var it = this.layers;
  while (it.next()) {
    var layer = it.value;
    if (layer.name === name) return layer;
  }
  return null;
};


// For ChangedEvents and notification:

Diagram.prototype['addChangedListener'] =
/**
* Register an event handler that is called when there is a {@link ChangedEvent}.
* @this {Diagram}
* @param {function(ChangedEvent)} listener a function that takes a {@link ChangedEvent} as its argument.
* @see #removeChangedListener
*/
Diagram.prototype.addChangedListener = function(listener) {
  Util.checkPrimitive(listener, 'function', Diagram, 'addChangedListener:listener');
  if (this._changedListeners === null) this._changedListeners = new List('function');
  this._changedListeners.add(listener);
};

Diagram.prototype['removeChangedListener'] =
/**
* Unregister a {@link ChangedEvent} handler.
* @this {Diagram}
* @param {function(ChangedEvent)} listener a function that takes a {@link ChangedEvent} as its argument.
* @see #addChangedListener
*/
Diagram.prototype.removeChangedListener = function(listener) {
  Util.checkPrimitive(listener, 'function', Diagram, 'removeChangedListener:listener');
  if (this._changedListeners !== null) {
    this._changedListeners.remove(listener);
    if (this._changedListeners.count === 0) this._changedListeners = null;
  }
};

/**
* @ignore
* Notify any ChangedEvent listeners.
* This is called by {@link #raiseChangedEvent}.
* Each listener function registered with calls to {@link #addChangedListener} is called with the given event.
* Unless {@link #skipsUndoManager} is true, this then calls {@link UndoManager#handleChanged}
* so that the UndoManager gets the opportunity to record the change.
* @this {Diagram}
* @param {ChangedEvent} e
*/
Diagram.prototype.callChangedListeners = function(e) {
  if (!this.skipsUndoManager) {
    this.undoManager.handleChanged(e);
  }

  if (e.change !== ChangedEvent.Transaction) {
    this.isModified = true;
  }

  if (this._changedListeners !== null) {
    var list = this._changedListeners;
    var l = list.length;
    if (l === 1) {
      var func = list.elt(0);
      func(e);
    } else if (l !== 0) {
      var arr = list.toArray();
      for (var i = 0; i < l; i++) {
        var func = arr[i];
        func(e);
      }
    }
  }
};

Diagram.prototype['raiseChangedEvent'] =
/**
* @ignore
* Call this method to notify that the diagram or its objects have changed.
* This constructs a {@link ChangedEvent} and calls the Diagram listeners.
* @this {Diagram}
* @param {EnumValue} change specifies the general nature of the change;
* permissible values include {@link ChangedEvent#Property}, {@link ChangedEvent#Insert},
* {@link ChangedEvent#Remove}, and {@link ChangedEvent#Transaction}.
* @param {string|function(Object):*} propertyname names the property that was modified.
* @param {Object} obj the object that was modified, typically a {@link GraphObject}, {@link Diagram}, or a {@link Layer}.
* @param {*} oldval the previous or older value.
* @param {*} newval the next or newer value.
* @param {*=} oldparam an optional value that helps describe the older value.
* @param {*=} newparam an optional value that helps describe the newer value.
*/
Diagram.prototype.raiseChangedEvent = function(change, propertyname, obj, oldval, newval, oldparam, newparam) {
  // ChangedEvent property setters will check argument types
  if (oldparam === undefined/*notpresent*/) oldparam = null;
  if (newparam === undefined/*notpresent*/) newparam = null;

  var e = new ChangedEvent();  //?? cache event objects
  e.diagram = this;
  e.change = change;
  e.propertyName = propertyname;
  e.object = obj;
  e.oldValue = oldval;
  e.oldParam = oldparam;
  e.newValue = newval;
  e.newParam = newparam;

  this.callChangedListeners(e);
};

Diagram.prototype['raiseChanged'] =
/**
* @ignore
* Call this method to notify about a diagram property having changed value.
* @this {Diagram}
* @param {string|function(*)} propertyname the name of the property.
* @param {*} oldval the previous or old value for the property.
* @param {*} newval the next or new value for the property.
* @param {*=} oldparam an optional value additionally describing the old value.
* @param {*=} newparam an optional value additionally describing the new value.
*/
Diagram.prototype.raiseChanged = function(propertyname, oldval, newval, oldparam, newparam) {
  this.raiseChangedEvent(ChangedEvent.Property, propertyname, this, oldval, newval, oldparam, newparam);
};


// for undo/redo:

/**
* Gets the {@link UndoManager} for this Diagram, which actually belongs to the {@link #model}.
* <p/>
* The default UndoManager has its {@link UndoManager#isEnabled} property set to false.
* If you want users to undo and redo, you should set that property to true once you have initialized the Diagram or its Model.
* @name Diagram#undoManager
* @function.
* @return {UndoManager}
*/
/** @type {UndoManager} */
Diagram.prototype.undoManager;
Util.defineReadOnlyProperty(Diagram, {undoManager: 'undoManager'},
  /** @this {Diagram} */
  function() { return this._model.undoManager; }
);

/**
* Gets or sets whether ChangedEvents are not recorded by the UndoManager.
* The initial and normal value is false.
* While this property is true, changing the Diagram or any GraphObject does not call {@link UndoManager#handleChanged}.
* Even when this property is true,
* transactions (such as calls to {@link #startTransaction}) and
* undo/redo (such as calls to {@link CommandHandler#undo})
* are still delegated to the {@link #undoManager}.
* <p/>
* You should set this to true only temporarily, and you should remember its previous value
* before setting this to true.
* When finishing the period for which you want the UndoManager to be disabled,
* you should set this back to the remembered value it had before it was set to true.
* <p>
* For more permanent disabling of the {@link UndoManager}, set {@link UndoManager#isEnabled} to false.
* <p>
* Setting this property also sets {@link Model#skipsUndoManager} to the same value.
* Setting this property does not notify about any changed event.
* @name Diagram#skipsUndoManager
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Diagram.prototype.skipsUndoManager;
Util.exportProperty(Diagram, 'skipsUndoManager', Diagram.prototype.skipsUndoManager);
Util.defineProperty(Diagram, {skipsUndoManager: 'skipsUndoManager'},
  /** @this {Diagram} */
  function() { return this._skipsUndoManager; },
  /** @this {Diagram} */
  function(val) {
    Util.checkPrimitive(val, 'boolean', Diagram, 'skipsUndoManager');
    this._skipsUndoManager = val;
    this._model._skipsUndoManager = val;
  }
);

/**
* @ignore
* This is called during an undo or redo to modify the diagram or its objects.
* @expose
* @this {Diagram}
* @param {ChangedEvent} e This describes the change that needs to be done.
* @param {boolean} undo If true, this method should restore the older state, otherwise the newer state.
*/
Diagram.prototype.changeState = function(e, undo) {
  if (e === null) return;
  if (e.diagram !== this) return;  // ignore changes to Model
  var chg = e.change;
  if (chg === ChangedEvent.Property) {
    var obj = e.object;
    var pn = e.propertyName;
    var v = e.getValue(undo);
    Util.safePropertySet(obj, pn, v);
    if (obj instanceof GraphObject) {
      var part = obj.part;
      if (part !== null) part.clearAdornments();
    }
  } else if (chg === ChangedEvent.Insert) {
    var container = e.object;
    var idx = e.newParam;
    var obj = e.newValue;
    if (container instanceof Panel) {
      if (typeof idx === 'number' && obj instanceof GraphObject) {
        var panel = container;
        if (undo) {
          panel.internalRemove(idx);
        } else {
          panel.insertAt(idx, obj);
        }
        var part = container.part;
        if (part !== null) part.clearAdornments();
      }
    } else if (container instanceof Layer) {
      var layerSwap = (e.oldParam === true); // oldParam is true if a part is changing layers instead of being deleted
      if (typeof idx === 'number' && obj instanceof Part) {
        var layer = container;
        if (undo) {
          obj.clearAdornments();
          if (layerSwap) {
            layer.internalRemove(idx, obj, layerSwap);
          } else {
            // instead, remove the object to its own layer via diagram.remove,
            // since it might have changed layers outside of a transaction
            this.remove(obj);
          }
        } else {
          layer.internalAdd(idx, obj, layerSwap);
        }
      }
    } else if (container instanceof Diagram) {
      if (typeof idx === 'number' && obj instanceof Layer) {
        if (undo) {
          this.removeLayer(obj);
        } else {
          this.addLayerAt(obj, idx);
        }
      }
    } else {
      Util.throwError('unknown ChangedEvent.Insert object: ' + e.toString());
    }
  } else if (chg === ChangedEvent.Remove) {
    var container = e.object;
    var idx = e.oldParam;
    var obj = e.oldValue;
    if (container instanceof Panel) {
      if (typeof idx === 'number' && obj instanceof GraphObject) {
        var panel = container;
        if (undo) {
          panel.insertAt(idx, obj);
        } else {
          panel.internalRemove(idx);
        }
      }
    } else if (container instanceof Layer) {
      var layerSwap = (e.newParam === true); // newParam is true if a part is changing layers instead of being deleted
      if (typeof idx === 'number' && obj instanceof Part) {
        var layer = container;
        if (undo) {
          layer.internalAdd(idx, obj, layerSwap);
        } else {
          obj.clearAdornments();
          if (layerSwap) {
            layer.internalRemove(idx, obj, layerSwap);
          } else {
            // instead, remove the object to its own layer via diagram.remove,
            // since it might have changed layers outside of a transaction
            this.remove(obj);
          }
        }
      }
    } else if (container instanceof Diagram) {
      if (typeof idx === 'number' && obj instanceof Layer) {
        if (undo) {
          this.addLayerAt(obj, idx);
        } else {
          this.removeLayer(obj);
        }
      }
    } else {
      Util.throwError('unknown ChangedEvent.Remove object: ' + e.toString());
    }
  } else if (chg === ChangedEvent.Transaction) {
    // don't do anything
  } else {
    Util.throwError('unknown ChangedEvent: ' + e.toString());
  }
};


Diagram.prototype['startTransaction'] =
/**
* Begin a transaction, where the changes are held by a {@link Transaction} object
* in the {@link UndoManager}.
* This just calls {@link UndoManager#startTransaction}.
* @this {Diagram}
* @param {string=} tname a descriptive name for the transaction.
* @return {boolean} the value returned by {@link UndoManager#startTransaction}.
*/
Diagram.prototype.startTransaction = function(tname) {
  return this.undoManager.startTransaction(tname);
};

Diagram.prototype['commitTransaction'] =
/**
* Commit the changes of the current transaction.
* This just calls {@link UndoManager#commitTransaction}.
* @this {Diagram}
* @param {string} tname a descriptive name for the transaction.
* @return {boolean} the value returned by {@link UndoManager#commitTransaction}.
*/
Diagram.prototype.commitTransaction = function(tname) {
  return this.undoManager.commitTransaction(tname);
};

Diagram.prototype['rollbackTransaction'] =
/**
* Rollback the current transaction, undoing any recorded changes.
* This just calls {@link UndoManager#rollbackTransaction}.
* @this {Diagram}
* @return {boolean} the value returned by {@link UndoManager#rollbackTransaction}.
*/
Diagram.prototype.rollbackTransaction = function() {
  return this.undoManager.rollbackTransaction();
};

Diagram.prototype['updateAllTargetBindings'] =
/**
* Update all of the data-bound properties of {@link Node}s and {@link Link}s in this diagram.
* This copies/converts model data properties to set properties on {@link Part}s.
* If you know which model data objects have been modified,
* it may be more efficient to update only the {@link Part}s that need it
* by calling {@link Panel#updateTargetBindings}.
* @this {Diagram}
*/
Diagram.prototype.updateAllTargetBindings = function() {
  var it = this.parts;
  while (it.next()) {
    var part = it.value;
    part.updateTargetBindings();
  }
  it = this.nodes;
  while (it.next()) {
    var node = it.value;
    node.updateTargetBindings();
  }
  it = this.links;
  while (it.next()) {
    var link = it.value;
    link.updateTargetBindings();
  }
};

/**
* @ignore
 * This method is called when {@link Diagram#scale} changes.
 * @param {number} oldscale
 * @param {number} newscale
 * This may change the {@link Diagram#position} in order to maintain the desired content alignment.
 * This method may be called during initialization even if the old and new scale values are the same.
 * This method calls {@link Diagram#onViewportBoundsChanged}.
 */
Diagram.prototype.onScaleChanged = function(oldscale, newscale) {
  //if (this.isAnimating) return;
  if (this._isAligning || this._isUpdating) return;
  this._isAligning = true;
  var can = this._canvas;
  if (can === null) return;

  var oldvbounds = this.viewportBounds.copy();
  var viewwidth = can.width / newscale;
  var viewheight = can.height / newscale;
  oldvbounds.width = can.width / oldscale;
  oldvbounds.height = can.height / oldscale;
  var z = this.zoomPoint.copy();  // in element coordinates, not model coordinates
  // if the zoom point is NaN, default it according to the ...ContentAlignment properties
  if (isNaN(z.x)) {
    switch (this.contentAlignment) {
      case Spot.LeftSide: z.x = 0; break;
      case Spot.RightSide: z.x = viewwidth - 1; break;
      case Spot.Center: z.x = viewwidth / 2; break;
      case Spot.Default:
      case Spot.AllSides: z.x = viewwidth / 2; break;
    }
  }
  if (isNaN(z.y)) {
    switch (this.contentAlignment) {
      case Spot.TopSide: z.y = 0; break;
      case Spot.BottomSide: z.y = viewheight - 1; break;
      case Spot.Center: z.y = viewheight / 2; break;
      case Spot.Default:
      case Spot.AllSides: z.y = viewheight / 2; break;
    }
  }
  var oldpos = this.position;
  var pos = new Point(oldpos.x + z.x / oldscale - z.x / newscale, oldpos.y + z.y / oldscale - z.y / newscale);
  var bounds = this.documentBounds;

  this._setupPos(pos, bounds, viewwidth, viewheight, this._contentAlignment);

  this.position = pos;
  this._isAligning = false;
  var newvbounds = this.viewportBounds;
  this.onViewportBoundsChanged(oldvbounds, newvbounds);
};

/**
* @ignore
* This method is called when the {@link #position} changes.
* @this {Diagram}
* @param {Point} oldpos a Point in model coordinates.
* @param {Point} newpos a Point in model coordinates.
* This may change the position in order to maintain the desired content alignment.
* This method may be called during initialization even if the old and new position values are the same.
*/
Diagram.prototype.onPositionChanged = function(oldpos, newpos) {
  if (oldpos.equalsApprox(newpos)) return oldpos;
  //if (this.isAnimating) return oldpos;
  if (this._isAligning) return newpos;
  if (this._canvas === null) return newpos;
  this._isAligning = true;

  var pos = newpos;
  var bounds = this.documentBounds;
  var scale = this.scale;
  var viewwidth = this._canvas.width / scale;
  var viewheight = this._canvas.height / scale;

  this._setupPos(pos, bounds, viewwidth, viewheight, this._contentAlignment);

  this._isAligning = false;
  return pos;
};

/**
* @ignore
* This method is called when the {@link #position} or {@link #scale} change, or when update notices the canvas has changed size.
* @this {Diagram}
* @param {Rect} oldvbounds a Rect in document coordinates.
* @param {Rect} newvbounds a Rect in document coordinates.
* The X or Y may have changed because of a change to {@link #position}.
* The Width or Height may have changed either because this Diagram has changed size
* or because the {@link #scale} has changed value.
* @param {boolean=} isScroll true if the viewport change was only caused by a scrollbar changing size.
*/
Diagram.prototype.onViewportBoundsChanged = function(oldvbounds, newvbounds, isScroll) {
  this.invalidateScroll();
  this.invalidateViewportObjects();
  var lay = this.layout;
  if ((lay !== null && lay.isViewportSized && !isScroll) &&
      ((oldvbounds.width !== newvbounds.width || oldvbounds.height !== newvbounds.height) ||
       (isNaN(oldvbounds.x) && !isNaN(newvbounds.x)) || (isNaN((oldvbounds.y) && !isNaN(newvbounds.y))))) {
    lay.invalidateLayout();  //??? not being called when the diagram/canvas changes size
  }

  if (!this._isAligning) {
    this.onContentAlignmentChanged();
  }
  this._updateBackgroundGrid();

  // This is necessary because the VPB will change (such as on keypress) without the mouse moving
  // Chrome accomodates this automatically by firing a mouseMove event, other browsers do not
  // maybe the mouse is hovering over a different object (change tooltips, etc)
  var mgr = this.currentTool;
  if (this._isMouseOverDiagram === true && mgr instanceof ToolManager) {
    // adjust the mouse point for the new position/scale
    this.lastInput.documentPoint = this.transformViewToDoc(this.lastInput.viewPoint);
    mgr.doMouseMove();
  }

  this.invalidateViewport(oldvbounds, newvbounds);

  // used to be inside of "if (!this._isAligning)" above
  // For now, if the scrollbar caused the viewportBounds change, we pass an empty object instead of null
  this.raiseDiagramEvent('ViewportBoundsChanged', isScroll ? {} : null, oldvbounds);
};

/**
* @ignore
* @this {Diagram}
* @param {Rect=} viewRect optional viewportBounds replacement.
*/
Diagram.prototype._updateBackgroundGrid = function(viewRect) {
  var grid = this._grid;
  if (grid === null || !grid.visible) return;
  var tile = Util.tempSize();
  grid._computeTileSize(tile);
  var width, height, vx, vy;
  if (viewRect) {
    width = viewRect.width;
    height = viewRect.height;
    vx = viewRect.x;
    vy = viewRect.y;
  } else {
    var bounds = Util.tempRect();
    var vb = this.viewportBounds;
    bounds._set(vb.x, vb.y, vb.width, vb.height);
    // get the largest viewport bounds of the diagram or any overview
    var it = this._overviews.iterator;
    while (it.next()) {
      vb = it.value.viewportBounds;
      bounds.unionNoCheck(vb.x, vb.y, vb.width, vb.height);
    }
    width = bounds.width;
    height = bounds.height;
    vx = bounds.x;
    vy = bounds.y;
    if (!bounds.isReal()) return;
  }
  grid.width = width + tile.width * 2;
  grid.height = height + tile.height * 2;
  var gridpt = Util.tempPoint();
  Geo.findNearestInfiniteGridPoint(vx, vy, 0, 0, tile.width, tile.height, gridpt);
  gridpt.offset(-tile.width, -tile.height);
  Util.freeSize(tile);
  grid.part.location = gridpt;
  Util.freePoint(gridpt);
};

// Selection

Diagram.prototype['clearSelection'] =
/**
* Deselect all selected {@link Part}s.
* This removes all objects from the {@link #selection} collection.
* This method raises the "ChangingSelection" and "ChangedSelection" Diagram events.
* @this {Diagram}
* @see #select
* @see #selectCollection
*/
Diagram.prototype.clearSelection = function() {
  var any = this.selection.count > 0;
  if (any) this.raiseDiagramEvent('ChangingSelection');
  this.internalClearSelection();
  if (any) this.raiseDiagramEvent('ChangedSelection');
};

/**
* @ignore
* Deselect all selected {@link Part}s,
* but don't raise "ChangingSelection" or "ChangedSelection" Diagram events.
* @this {Diagram}
*/
Diagram.prototype.internalClearSelection = function() {
  var coll = this.selection;
  if (coll.count > 0) {
    var arr = coll.toArray();
    var len = arr.length;
    for (var i = 0; i < len; i++) {
      var part = arr[i];
      part.isSelected = false;
    }
    coll.thaw();
    coll.clear();
    coll.freeze();
  }
};

Diagram.prototype['select'] =
/**
* Make the given object the only selected object.
* This method raises the "ChangingSelection" and "ChangedSelection" Diagram events.
* @this {Diagram}
* @param {GraphObject} part a GraphObject that is already in a layer of this Diagram.
* If the value is null, this does nothing.
* @see #selectCollection
* @see #clearSelection
*/
Diagram.prototype.select = function(part) {
  if (part !== null && part.layer.diagram === this) {
    if (!part.isSelected || this.selection.count > 1) {
      this.raiseDiagramEvent('ChangingSelection');
      this.internalClearSelection();  // don't raise ChangingSelection/Finished
      part.isSelected = true;
      this.raiseDiagramEvent('ChangedSelection');
    }
  }
};

Diagram.prototype['selectCollection'] =
/**
* Select all of the {@link Part}s supplied in the given collection.
* This method raises the "ChangingSelection" and "ChangedSelection" Diagram events.
* @this {Diagram}
* @param {Iterable} coll a {@link List} or {@link Set} of {@link Part}s to be selected.
* @see #select
* @see #clearSelection
*/
Diagram.prototype.selectCollection = function(coll) {
  this.raiseDiagramEvent('ChangingSelection');
  this.internalClearSelection();  //??? ought not to de-select things in the given collection
  var it = coll.iterator;
  while (it.next()) {
    var part = it.value;
    part.isSelected = true;
  }
  this.raiseDiagramEvent('ChangedSelection');
};


/**
 * Scrolling function used by primarily by {@link #commandHandler}'s {@link CommandHandler#doKeyDown}.
 * @this {Diagram}
 * @param {string} unit A string representing the unit of the scroll operation. Can be 'pixel', 'line', or 'page'.
 * @param {string} dir The direction of the scroll operation. Can be 'up', 'down', 'left', or 'right'.
 * @param {number=} dist An optional distance multiplier, for multiple pixels, lines, or pages. The default value is 1.
 * @see #scrollToRect
 * @see #centerRect
 */
Diagram.prototype.scroll = function(unit, dir, dist) {
  if (dist === undefined/*notpresent*/) dist = 1;
  var vertical = (dir === 'up' || dir === 'down');

  var scrollPixels;
  if (unit === 'pixel') {
    scrollPixels = dist;
  } else if (unit === 'line') {
    scrollPixels = dist * (vertical ? this.scrollVerticalLineChange : this.scrollHorizontalLineChange);
  } else if (unit === 'page') {
    // We want the page's length in pixels minue one line
    // But we don't want accidentally scroll backwards
    var viewport = vertical ? this.viewportBounds.height : this.viewportBounds.width;
    viewport *= this.scale;
    if (viewport !== 0) {
      var length = Math.max(viewport - (vertical ? this.scrollVerticalLineChange : this.scrollHorizontalLineChange), 0);
      scrollPixels = dist * length;
    }
  } else {
    Util.throwError('scrolling unit must be \'pixel\', \'line\', or \'page\', not: ' + unit);
  }

  scrollPixels /= this.scale;

  var p = this.position.copy();
  if (dir === 'up') {
    p.y = this.position.y - scrollPixels;
  } else if (dir === 'down') {
    p.y = this.position.y + scrollPixels;
  } else if (dir === 'left') {
    p.x = this.position.x - scrollPixels;
  } else if (dir === 'right') {
    p.x = this.position.x + scrollPixels;
  } else {
    Util.throwError('scrolling direction must be \'up\', \'down\', \'left\', or \'right\', not: ' + dir);
  }
  this.position = p;

};

Diagram.prototype['scrollToRect'] =
/**
* Modifies the {@link #position} to show a given Rect of the Diagram by centering the
* viewport on that Rect. Does nothing if the Rect is already in view.
* <p>
* See also {@link #centerRect}
* @this {Diagram}
* @param {Rect} r
* @see #centerRect
* @see #scroll
*/
Diagram.prototype.scrollToRect = function(r) {
  var vb = this.viewportBounds;
  if (vb.containsRect(r)) return; // do nothing if R is already in view
  var midpt = r.center;
  midpt.x -= vb.width / 2;
  midpt.y -= vb.height / 2;
  this.position = midpt;
};

Diagram.prototype['centerRect'] =
/**
* Modifies the {@link #position} to show a given Rect of the Diagram by centering the
* viewport on that Rect.
* <p>
* See also {@link #scrollToRect}
* @this {Diagram}
* @param {Rect} r
* @see #scrollToRect
* @see #scroll
*/
Diagram.prototype.centerRect = function(r) {
  var vb = this.viewportBounds;
  var midpt = r.center;
  midpt.x -= vb.width / 2;
  midpt.y -= vb.height / 2;
  this.position = midpt;
};

Diagram.prototype['transformDocToView'] =
/**
* Given a Point in document coorindates, return a new Point in viewport coordinates.
* @this {Diagram}
* @param {Point} p
* @return {Point} The given Point converted into View coordinates.
* @see #transformViewToDoc
* @see GraphObject#getDocumentPoint
*/
Diagram.prototype.transformDocToView = function(p) {
  var t = this._transform;
  t.reset();
  if (this._scale !== 1) { t.scale(this._scale); }
  var pos = this._position;
  if ((pos.x !== 0 || pos.y !== 0) && isFinite(pos.x) && isFinite(pos.y)) {
    t.translate(-pos.x, -pos.y);
  }
  return p.copy().transform(this._transform);
};

/**
* @ignore
* Given a rect[0,1,2,3] in document coordinates, return a new rect in view coordinates.
* @this {Diagram}
* @param {Array} rect
*/
Diagram.prototype.transformRectDocToView = function(rect) {
  var t = this._transform;
  var x = rect[0];
  var y = rect[1];
  var r = x + rect[2];
  var b = y + rect[3];
  var m0 = t.m11;
  var m1 = t.m12;
  var m2 = t.m21;
  var m3 = t.m22;
  var m4 = t.dx;
  var m5 = t.dy;
  var ltx = x * m0 + y * m2 + m4;
  var lty = x * m1 + y * m3 + m5;
  var rtx = r * m0 + y * m2 + m4;
  var rty = r * m1 + y * m3 + m5;
  var lbx = x * m0 + b * m2 + m4;
  var lby = x * m1 + b * m3 + m5;
  var rbx = r * m0 + b * m2 + m4;
  var rby = r * m1 + b * m3 + m5;
  var minx = ltx;
  var maxx = ltx;
  var miny = lty;
  var maxy = lty;

  minx = Math.min(minx, rtx);
  maxx = Math.max(maxx, rtx);
  miny = Math.min(miny, rty);
  maxy = Math.max(maxy, rty);
  minx = Math.min(minx, lbx);
  maxx = Math.max(maxx, lbx);
  miny = Math.min(miny, lby);
  maxy = Math.max(maxy, lby);
  minx = Math.min(minx, rbx);
  maxx = Math.max(maxx, rbx);
  miny = Math.min(miny, rby);
  maxy = Math.max(maxy, rby);

  return [minx, miny, maxx - minx, maxy - miny];
};


Diagram.prototype['transformViewToDoc'] =
/**
* Given a point in viewport coordinates, return a new Point in document coordinates.
* @this {Diagram}
* @param {Point} p
* @return {Point} The given point converted into Document coordinates.
* @see #transformDocToView
* @see GraphObject#getDocumentPoint
*/
Diagram.prototype.transformViewToDoc = function(p) {
  // ?? We might optimize this in the future instead of (re)constructing that transform every time. Same for doctoview
  var t = this._transform;
  t.reset();
  if (this._scale !== 1) { t.scale(this._scale); }
  var pos = this._position;
  if ((pos.x !== 0 || pos.y !== 0) && isFinite(pos.x) && isFinite(pos.y)) {
    t.translate(-pos.x, -pos.y);
  }
  return p.copy().transformInverted(this._transform);
};

/**
* The default autoScale type, used as the value of {@link Diagram#autoScale}:
* The Diagram does not attempt to scale its bounds to fit the view.
* @name Diagram#None
* @constant
* @static
* @return {EnumValue}
*/
Diagram['None'] = Diagram.None = Util.defineEnumValue(Diagram, 'None', 0);

/**
* Diagrams with this autoScale type, used as the value of {@link Diagram#autoScale},
* are scaled uniformly until the documentBounds fits in the view.
* @name Diagram#Uniform
* @constant
* @static
* @return {EnumValue}
*/
Diagram['Uniform'] = Diagram.Uniform = Util.defineEnumValue(Diagram, 'Uniform', 1);

/**
* Diagrams with this autoScale type, used as the value of {@link Diagram#autoScale},
* are scaled until the documentBounds fits in the view in both directions.
* @name Diagram#UniformToFill
* @constant
* @static
* @return {EnumValue}
*/
Diagram['UniformToFill'] = Diagram.UniformToFill = Util.defineEnumValue(Diagram, 'UniformToFill', 2);


/**
* This value for {@link Diagram#validCycle} states that
* there are no restrictions on making cycles of links.
* @name Diagram#CycleAll
* @constant
* @static
* @return {EnumValue}
*/
Diagram['CycleAll'] = Diagram.CycleAll = Util.defineEnumValue(Diagram, 'CycleAll', 10);

/**
* This value for {@link Diagram#validCycle} states that
* a valid link from a node will not produce a directed cycle in the graph.
* @name Diagram#CycleNotDirected
* @constant
* @static
* @return {EnumValue}
*/
Diagram['CycleNotDirected'] = Diagram.CycleNotDirected = Util.defineEnumValue(Diagram, 'CycleNotDirected', 11);

/**
* @ignore
* This value for {@link Diagram#validCycle} states that
* a valid link from a node will not produce a directed cycle in the graph,
* assuming there are no directed cycles anywhere accessible from either node.
* @name Diagram#CycleNotDirectedFast
* @constant
* @static
* @return {EnumValue}
*/
Diagram['CycleNotDirectedFast'] = Diagram.CycleNotDirectedFast = Util.defineEnumValue(Diagram, 'CycleNotDirectedFast', 12);

/**
* This value for {@link Diagram#validCycle} states that
* a valid link from a node will not produce an undirected cycle in the graph.
* @name Diagram#CycleNotUndirected
* @constant
* @static
* @return {EnumValue}
*/
Diagram['CycleNotUndirected'] = Diagram.CycleNotUndirected = Util.defineEnumValue(Diagram, 'CycleNotUndirected', 13);

/**
* This value for {@link Diagram#validCycle} states that
* any number of destination links may go out of a node, but at most one
* source link may come into a node, and there are no directed cycles.
* @name Diagram#CycleDestinationTree
* @constant
* @static
* @return {EnumValue}
*/
Diagram['CycleDestinationTree'] = Diagram.CycleDestinationTree = Util.defineEnumValue(Diagram, 'CycleDestinationTree', 14);

/**
* This value for {@link Diagram#validCycle} states that
* any number of source links may come into a node, but at most one
* destination link may go out of a node, and there are no directed cycles.
* @name Diagram#CycleSourceTree
* @constant
* @static
* @return {EnumValue}
*/
Diagram['CycleSourceTree'] = Diagram.CycleSourceTree = Util.defineEnumValue(Diagram, 'CycleSourceTree', 15);


/**
* Gets or sets what kinds of graphs this diagram allows the user to draw.
* By default this property is {@link Diagram#CycleAll} -- all kinds of cycles are permitted.
* Common values include {@link Diagram#CycleDestinationTree} and {@link Diagram#CycleNotDirected}.
* @name Diagram#validCycle
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
Diagram.prototype.validCycle;
Util.exportProperty(Diagram, 'validCycle', Diagram.prototype.validCycle);
Util.defineProperty(Diagram, { validCycle: 'validCycle' },
  /** @this {Diagram} */
  function() { return this._validCycle; },
  /** @this {Diagram} */
  function(val) {
    var old = this._validCycle;
    if (old !== val) {
      Util.checkEnumValue(val, Diagram, Diagram, 'validCycle');
      this._validCycle = val;
      this.raiseChanged('validCycle', old, val);
    }
  }
);


/**
* Gets an iterator for this Diagram's Layers.
* @name Diagram#layers
* @function.
* @return {Iterator}
* @see #addLayer
* @see #removeLayer
*/
/** @type {Iterator} */
Diagram.prototype.layers;
Util.defineReadOnlyProperty(Diagram, {layers: 'layers'},
  /** @this {Diagram} */
  function() { return this._layers.iterator; }
);

// Permissions

//??? focusable?

/**
* Gets or sets whether the Diagram's {@link Diagram#model} is {@link Model#isReadOnly}.
* @name Diagram#isModelReadOnly
* @function.
* @return {boolean}
* @see #isReadOnly
* @see #isEnabled
*/
/** @type {boolean} */
Diagram.prototype.isModelReadOnly;
Util.exportProperty(Diagram, 'isModelReadOnly', Diagram.prototype.isModelReadOnly);
Util.defineProperty(Diagram, { isModelReadOnly: 'isModelReadOnly' },
  /** @this {Diagram} */
  function() {
    var model = this._model;
    if (model === null) return false;
    return model.isReadOnly;
  },
  /** @this {Diagram} */
  function(val) {
    var model = this._model;
    if (model !== null) model.isReadOnly = val;
  }
);

/**
* Gets or sets whether the Diagram may be modified by the user,
* while still allowing the user to scroll, zoom, and select.
* The initial value is false.
* @name Diagram#isReadOnly
* @function.
* @return {boolean}
* @see #isModelReadOnly
* @see #isEnabled
*/
/** @type {boolean} */
Diagram.prototype.isReadOnly;
Util.exportProperty(Diagram, 'isReadOnly', Diagram.prototype.isReadOnly);
Util.defineProperty(Diagram, {isReadOnly: 'isReadOnly'},
  /** @this {Diagram} */
  function() { return this._isReadOnly; },
  /** @this {Diagram} */
  function(val) {
    var old = this._isReadOnly;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Diagram, 'isReadOnly');
      this._isReadOnly = val;
      this.raiseChanged('isReadOnly', old, val);
    }
  }
);

/**
* Gets or sets whether the user may interact with the Diagram.
* @name Diagram#isEnabled
* @function.
* @return {boolean}
* @see #isReadOnly
* @see #isModelReadOnly
*/
/** @type {boolean} */
Diagram.prototype.isEnabled;
Util.exportProperty(Diagram, 'isEnabled', Diagram.prototype.isEnabled);
Util.defineProperty(Diagram, {isEnabled: 'isEnabled'},
  /** @this {Diagram} */
  function() { return this._isEnabled; },
  /** @this {Diagram} */
  function(val) {
    var old = this._isEnabled;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Diagram, 'isEnabled');
      this._isEnabled = val;
      this.raiseChanged('isEnabled', old, val);
    }
  }
);

/**
* Gets or sets whether the user may copy to or paste parts from the internal clipboard.
* This allows use of {@link CommandHandler#cutSelection},
* {@link CommandHandler#copySelection} and {@link CommandHandler#pasteSelection}.
* The initial value is true.
* @name Diagram#allowClipboard
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Diagram.prototype.allowClipboard;
Util.exportProperty(Diagram, 'allowClipboard', Diagram.prototype.allowClipboard);
Util.defineProperty(Diagram, {allowClipboard: 'allowClipboard'},
  /** @this {Diagram} */
  function() { return this._allowClipboard; },
  /** @this {Diagram} */
  function(val) {
    var old = this._allowClipboard;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Diagram, 'allowClipboard');
      this._allowClipboard = val;
      this.raiseChanged('allowClipboard', old, val);
    }
  }
);

/**
* Gets or sets whether the user may copy objects.
* The initial value is true.
* @name Diagram#allowCopy
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Diagram.prototype.allowCopy;
Util.exportProperty(Diagram, 'allowCopy', Diagram.prototype.allowCopy);
Util.defineProperty(Diagram, {allowCopy: 'allowCopy'},
  /** @this {Diagram} */
  function() { return this._allowCopy; },
  /** @this {Diagram} */
  function(val) {
    var old = this._allowCopy;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Diagram, 'allowCopy');
      this._allowCopy = val;
      this.raiseChanged('allowCopy', old, val);
    }
  }
);

/**
* Gets or sets whether the user may delete objects from the Diagram.
* The initial value is true.
* @name Diagram#allowDelete
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Diagram.prototype.allowDelete;
Util.exportProperty(Diagram, 'allowDelete', Diagram.prototype.allowDelete);
Util.defineProperty(Diagram, {allowDelete: 'allowDelete'},
  /** @this {Diagram} */
  function() { return this._allowDelete; },
  /** @this {Diagram} */
  function(val) {
    var old = this._allowDelete;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Diagram, 'allowDelete');
      this._allowDelete = val;
      this.raiseChanged('allowDelete', old, val);
    }
  }
);

/**
* Gets or sets whether the user may start a drag-and-drop in this Diagram,
* possibly dropping in a different element.
* The initial value is false.
* @name Diagram#allowDragOut
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Diagram.prototype.allowDragOut;
Util.exportProperty(Diagram, 'allowDragOut', Diagram.prototype.allowDragOut);
Util.defineProperty(Diagram, {allowDragOut: 'allowDragOut'},
  /** @this {Diagram} */
  function() { return this._allowDragOut; },
  /** @this {Diagram} */
  function(val) {
    var old = this._allowDragOut;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Diagram, 'allowDragOut');
      this._allowDragOut = val;
      this.raiseChanged('allowDragOut', old, val);
    }
  }
);

/**
* Gets or sets whether the user may end a drag-and-drop operation in this Diagram.
* This is typically set to true when a Diagram is used with a {@link #Palette}.
* <p>
* The initial value is false.
* @name Diagram#allowDrop
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Diagram.prototype.allowDrop;
Util.exportProperty(Diagram, 'allowDrop', Diagram.prototype.allowDrop);
Util.defineProperty(Diagram, {allowDrop: 'allowDrop'},
  /** @this {Diagram} */
  function() { return this._allowDrop; },
  /** @this {Diagram} */
  function(val) {
    var old = this._allowDrop;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Diagram, 'allowDrop');
      this._allowDrop = val;
      this.raiseChanged('allowDrop', old, val);
    }
  }
);

/**
* Gets or sets whether the user may do in-place text editing.
* The initial value is true.
* @name Diagram#allowTextEdit
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Diagram.prototype.allowTextEdit;
Util.exportProperty(Diagram, 'allowTextEdit', Diagram.prototype.allowTextEdit);
Util.defineProperty(Diagram, {allowTextEdit: 'allowTextEdit'},
  /** @this {Diagram} */
  function() { return this._allowTextEdit; },
  /** @this {Diagram} */
  function(val) {
    var old = this._allowTextEdit;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Diagram, 'allowTextEdit');
      this._allowTextEdit = val;
      this.raiseChanged('allowTextEdit', old, val);
    }
  }
);

/**
* Gets or sets whether the user may group parts together.
* The initial value is true.
* @name Diagram#allowGroup
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Diagram.prototype.allowGroup;
Util.exportProperty(Diagram, 'allowGroup', Diagram.prototype.allowGroup);
Util.defineProperty(Diagram, {allowGroup: 'allowGroup'},
  /** @this {Diagram} */
  function() { return this._allowGroup; },
  /** @this {Diagram} */
  function(val) {
    var old = this._allowGroup;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Diagram, 'allowGroup');
      this._allowGroup = val;
      this.raiseChanged('allowGroup', old, val);
    }
  }
);

/**
* Gets or sets whether the user may ungroup existing groups.
* The initial value is true.
* @name Diagram#allowUngroup
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Diagram.prototype.allowUngroup;
Util.exportProperty(Diagram, 'allowUngroup', Diagram.prototype.allowUngroup);
Util.defineProperty(Diagram, {allowUngroup: 'allowUngroup'},
  /** @this {Diagram} */
  function() { return this._allowUngroup; },
  /** @this {Diagram} */
  function(val) {
    var old = this._allowUngroup;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Diagram, 'allowUngroup');
      this._allowUngroup = val;
      this.raiseChanged('allowUngroup', old, val);
    }
  }
);

/**
* Gets or sets whether the user may add parts to the Diagram.
* The initial value is true.
* @name Diagram#allowInsert
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Diagram.prototype.allowInsert;
Util.exportProperty(Diagram, 'allowInsert', Diagram.prototype.allowInsert);
Util.defineProperty(Diagram, {allowInsert: 'allowInsert'},
  /** @this {Diagram} */
  function() { return this._allowInsert; },
  /** @this {Diagram} */
  function(val) {
    var old = this._allowInsert;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Diagram, 'allowInsert');
      this._allowInsert = val;
      this.raiseChanged('allowInsert', old, val);
    }
  }
);

/**
* Gets or sets whether the user may draw new links.
* The initial value is true.
* @name Diagram#allowLink
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Diagram.prototype.allowLink;
Util.exportProperty(Diagram, 'allowLink', Diagram.prototype.allowLink);
Util.defineProperty(Diagram, {allowLink: 'allowLink'},
  /** @this {Diagram} */
  function() { return this._allowLink; },
  /** @this {Diagram} */
  function(val) {
    var old = this._allowLink;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Diagram, 'allowLink');
      this._allowLink = val;
      this.raiseChanged('allowLink', old, val);
    }
  }
);

/**
* Gets or sets whether the user may reconnect existing links.
* The initial value is true.
* @name Diagram#allowRelink
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Diagram.prototype.allowRelink;
Util.exportProperty(Diagram, 'allowRelink', Diagram.prototype.allowRelink);
Util.defineProperty(Diagram, {allowRelink: 'allowRelink'},
  /** @this {Diagram} */
  function() { return this._allowRelink; },
  /** @this {Diagram} */
  function(val) {
    var old = this._allowRelink;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Diagram, 'allowRelink');
      this._allowRelink = val;
      this.raiseChanged('allowRelink', old, val);
    }
  }
);

/**
* Gets or sets whether the user may move objects.
* The initial value is true.
* @name Diagram#allowMove
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Diagram.prototype.allowMove;
Util.exportProperty(Diagram, 'allowMove', Diagram.prototype.allowMove);
Util.defineProperty(Diagram, {allowMove: 'allowMove'},
  /** @this {Diagram} */
  function() { return this._allowMove; },
  /** @this {Diagram} */
  function(val) {
    var old = this._allowMove;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Diagram, 'allowMove');
      this._allowMove = val;
      this.raiseChanged('allowMove', old, val);
    }
  }
);

/**
* Gets or sets whether the user may reshape parts.
* The initial value is true.
* @name Diagram#allowReshape
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Diagram.prototype.allowReshape;
Util.exportProperty(Diagram, 'allowReshape', Diagram.prototype.allowReshape);
Util.defineProperty(Diagram, {allowReshape: 'allowReshape'},
  /** @this {Diagram} */
  function() { return this._allowReshape; },
  /** @this {Diagram} */
  function(val) {
    var old = this._allowReshape;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Diagram, 'allowReshape');
      this._allowReshape = val;
      this.raiseChanged('allowReshape', old, val);
    }
  }
);

/**
* Gets or sets whether the user may resize parts.
* The initial value is true.
* @name Diagram#allowResize
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Diagram.prototype.allowResize;
Util.exportProperty(Diagram, 'allowResize', Diagram.prototype.allowResize);
Util.defineProperty(Diagram, {allowResize: 'allowResize'},
  /** @this {Diagram} */
  function() { return this._allowResize; },
  /** @this {Diagram} */
  function(val) {
    var old = this._allowResize;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Diagram, 'allowResize');
      this._allowResize = val;
      this.raiseChanged('allowResize', old, val);
    }
  }
);

/**
* Gets or sets whether the user may rotate parts.
* The initial value is true.
* @name Diagram#allowRotate
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Diagram.prototype.allowRotate;
Util.exportProperty(Diagram, 'allowRotate', Diagram.prototype.allowRotate);
Util.defineProperty(Diagram, {allowRotate: 'allowRotate'},
  /** @this {Diagram} */
  function() { return this._allowRotate; },
  /** @this {Diagram} */
  function(val) {
    var old = this._allowRotate;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Diagram, 'allowRotate');
      this._allowRotate = val;
      this.raiseChanged('allowRotate', old, val);
    }
  }
);

/**
* Gets or sets whether the user may select objects.
* The initial value is true.
* @name Diagram#allowSelect
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Diagram.prototype.allowSelect;
Util.exportProperty(Diagram, 'allowSelect', Diagram.prototype.allowSelect);
Util.defineProperty(Diagram, {allowSelect: 'allowSelect'},
  /** @this {Diagram} */
  function() { return this._allowSelect; },
  /** @this {Diagram} */
  function(val) {
    var old = this._allowSelect;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Diagram, 'allowSelect');
      this._allowSelect = val;
      this.raiseChanged('allowSelect', old, val);
    }
  }
);

/**
* Gets or sets whether the user may undo or redo any changes.
* The initial value is true.
* @name Diagram#allowUndo
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Diagram.prototype.allowUndo;
Util.exportProperty(Diagram, 'allowUndo', Diagram.prototype.allowUndo);
Util.defineProperty(Diagram, {allowUndo: 'allowUndo'},
  /** @this {Diagram} */
  function() { return this._allowUndo; },
  /** @this {Diagram} */
  function(val) {
    var old = this._allowUndo;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Diagram, 'allowUndo');
      this._allowUndo = val;
      this.raiseChanged('allowUndo', old, val);
    }
  }
);

/**
* Gets or sets whether the user may zoom into or out of the Diagram.
* The initial value is true.
* @name Diagram#allowZoom
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Diagram.prototype.allowZoom;
Util.exportProperty(Diagram, 'allowZoom', Diagram.prototype.allowZoom);
Util.defineProperty(Diagram, {allowZoom: 'allowZoom'},
  /** @this {Diagram} */
  function() { return this._allowZoom; },
  /** @this {Diagram} */
  function(val) {
    var old = this._allowZoom;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Diagram, 'allowZoom');
      this._allowZoom = val;
      this.raiseChanged('allowZoom', old, val);
    }
  }
);

/**
* Gets or sets whether the Diagram has a vertical Scrollbar.
* <p>
* To enable or disable scrolling itself, use {@link #allowHorizontalScroll} and {@link #allowVerticalScroll}.
* <p>
* The initial value is true.
* @name Diagram#hasVerticalScrollbar
* @function.
* @return {boolean}
* @see #allowVerticalScroll
* @see #hasHorizontalScrollbar
*/
/** @type {boolean} */
Diagram.prototype.hasVerticalScrollbar;
Util.exportProperty(Diagram, 'hasVerticalScrollbar', Diagram.prototype.hasVerticalScrollbar);
Util.defineProperty(Diagram, {hasVerticalScrollbar: 'hasVerticalScrollbar'},
  /** @this {Diagram} */
  function() { return this._hasVerticalScrollbar; },
  /** @this {Diagram} */
  function(val) {
    var old = this._hasVerticalScrollbar;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Diagram, 'hasVerticalScrollbar');
      this._hasVerticalScrollbar = val;
      this.raiseChanged('hasVerticalScrollbar', old, val);
      this.onContentAlignmentChanged();
    }
  }
);

/**
* Gets or sets whether the Diagram has a horizontal Scrollbar.
* <p>
* To enable or disable scrolling itself, use {@link #allowHorizontalScroll} and {@link #allowVerticalScroll}.
* <p>
* The initial value is true.
* @name Diagram#hasHorizontalScrollbar
* @function.
* @return {boolean}
* @see #allowHorizontalScroll
* @see #hasVerticalScrollbar
*/
/** @type {boolean} */
Diagram.prototype.hasHorizontalScrollbar;
Util.exportProperty(Diagram, 'hasHorizontalScrollbar', Diagram.prototype.hasHorizontalScrollbar);
Util.defineProperty(Diagram, {hasHorizontalScrollbar: 'hasHorizontalScrollbar'},
  /** @this {Diagram} */
  function() { return this._hasHorizontalScrollbar; },
  /** @this {Diagram} */
  function(val) {
    var old = this._hasHorizontalScrollbar;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Diagram, 'hasHorizontalScrollbar');
      this._hasHorizontalScrollbar = val;
      this.raiseChanged('hasHorizontalScrollbar', old, val);
      this.onContentAlignmentChanged();
    }
  }
);

/**
* Gets or sets whether the user is allowed to use the horizontal scrollbar.
* The initial value is true.
* @name Diagram#allowHorizontalScroll
* @function.
* @return {boolean}
* @see #hasHorizontalScrollbar
* @see #allowVerticalScroll
*/
/** @type {boolean} */
Diagram.prototype.allowHorizontalScroll;
Util.exportProperty(Diagram, 'allowHorizontalScroll', Diagram.prototype.allowHorizontalScroll);
Util.defineProperty(Diagram, {allowHorizontalScroll: 'allowHorizontalScroll'},
  /** @this {Diagram} */
  function() { return this._allowHorizontalScroll; },
  /** @this {Diagram} */
  function(val) {
    var old = this._allowHorizontalScroll;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Diagram, 'allowHorizontalScroll');
      this._allowHorizontalScroll = val;
      this.raiseChanged('allowHorizontalScroll', old, val);
      this.onContentAlignmentChanged();
    }
  }
);

/**
* Gets or sets whether the user is allowed to use the vertical scrollbar.
* The initial value is true.
* @name Diagram#allowVerticalScroll
* @function.
* @return {boolean}
* @see #hasVerticalScrollbar
* @see #allowHorizontalScroll
*/
/** @type {boolean} */
Diagram.prototype.allowVerticalScroll;
Util.exportProperty(Diagram, 'allowVerticalScroll', Diagram.prototype.allowVerticalScroll);
Util.defineProperty(Diagram, {allowVerticalScroll: 'allowVerticalScroll'},
  /** @this {Diagram} */
  function() { return this._allowVerticalScroll; },
  /** @this {Diagram} */
  function(val) {
    var old = this._allowVerticalScroll;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Diagram, 'allowVerticalScroll');
      this._allowVerticalScroll = val;
      this.raiseChanged('allowVerticalScroll', old, val);
      this.onContentAlignmentChanged();
    }
  }
);

/**
* Gets or sets the distance in screen pixels that the horizontal scrollbar will scroll
* when scrolling by a line.
* <p>
* The default value is 16.
* @name Diagram#scrollHorizontalLineChange
* @function.
* @return {number}
* @see #scrollVerticalLineChange
*/
/** @type {number} */
Diagram.prototype.scrollHorizontalLineChange;
Util.exportProperty(Diagram, 'scrollHorizontalLineChange', Diagram.prototype.scrollHorizontalLineChange);
Util.defineProperty(Diagram, {scrollHorizontalLineChange: 'scrollHorizontalLineChange'},
  /** @this {Diagram} */
  function() { return this._scrollHorizontalLineChange; },
  /** @this {Diagram} */
  function(val) {
    var old = this._scrollHorizontalLineChange;
    if (old !== val) {
      Util.checkPrimitive(val, 'number', Diagram, 'scrollHorizontalLineChange');
      if (val < 0) Util.throwRangeError(val, '>= 0', Diagram, 'scrollHorizontalLineChange');
      this._scrollHorizontalLineChange = val;
      this.raiseChanged('scrollHorizontalLineChange', old, val);
    }
  }
);

/**
* Gets or sets the distance in screen pixels that the vertical scrollbar will scroll
* when scrolling by a line.
* <p>
* The default value is 16.
* @name Diagram#scrollVerticalLineChange
* @function.
* @return {number}
* @see #scrollHorizontalLineChange
*/
/** @type {number} */
Diagram.prototype.scrollVerticalLineChange;
Util.exportProperty(Diagram, 'scrollVerticalLineChange', Diagram.prototype.scrollVerticalLineChange);
Util.defineProperty(Diagram, {scrollVerticalLineChange: 'scrollVerticalLineChange'},
  /** @this {Diagram} */
  function() { return this._scrollVerticalLineChange; },
  /** @this {Diagram} */
  function(val) {
    var old = this._scrollVerticalLineChange;
    if (old !== val) {
      Util.checkPrimitive(val, 'number', Diagram, 'scrollVerticalLineChange');
      if (val < 0) Util.throwRangeError(val, '>= 0', Diagram, 'scrollVerticalLineChange');
      this._scrollVerticalLineChange = val;
      this.raiseChanged('scrollVerticalLineChange', old, val);
    }
  }
);


// Input

/**
* Gets or sets the last {@link InputEvent} that occurred.
* <p>
* Setting this property does not notify about any changed event.
* @name Diagram#lastInput
* @function.
* @return {InputEvent}
* @see #firstInput
*/
/** @type {InputEvent} */
Diagram.prototype.lastInput;
Util.exportProperty(Diagram, 'lastInput', Diagram.prototype.lastInput);
Util.defineProperty(Diagram, {lastInput: 'lastInput'},
  /** @this {Diagram} */
  function() { return this._lastInput; },
  /** @this {Diagram} */
  function(val) {
    if (Debug) Util.checkClass(val, InputEvent, Diagram, 'lastInput');
    this._lastInput = val;
  }
);

/**
* Gets or sets the most recent mouse-down {@link InputEvent} that occurred.
* <p>
* Setting this property does not notify about any changed event.
* @name Diagram#firstInput
* @function.
* @return {InputEvent}
* @see #lastInput
*/
/** @type {InputEvent} */
Diagram.prototype.firstInput;
Util.exportProperty(Diagram, 'firstInput', Diagram.prototype.firstInput);
Util.defineProperty(Diagram, {firstInput: 'firstInput'},
  /** @this {Diagram} */
  function() { return this._firstInput; },
  /** @this {Diagram} */
  function(val) {
    if (Debug) Util.checkClass(val, InputEvent, Diagram, 'firstInput');
    this._firstInput = val;
  }
);

/**
* Gets or sets the current cursor for the Diagram, overriding the {@link #defaultCursor}.
* <p>
* Valid CSS cursors are accepted,
* such as "auto", "default", "none", "context-menu", "help", "pointer", "progress", "wait", etc.
* To read more about cursor syntax, go to:
* <a href="http://developer.mozilla.org/en-US/docs/Web/CSS/cursor">CSS cursors</a>.
* <p>
* Setting this property does not notify about any changed event.
* Setting this value to the empty string ('') returns the Diagram's cursor to the {@link #defaultCursor}.
* @name Diagram#currentCursor
* @function.
* @return {string}
* @see #defaultCursor
* @see GraphObject#cursor
*/
/** @type {string} */
Diagram.prototype.currentCursor;
Util.exportProperty(Diagram, 'currentCursor', Diagram.prototype.currentCursor);
Util.defineProperty(Diagram, {currentCursor: 'currentCursor'},
  /** @this {Diagram} */
  function() { return this._currentCursor; },
  /** @this {Diagram} */
  function(val) {
    Util.checkPrimitive(val, 'string', Diagram, 'currentCursor');
    if (this._canvas === null || this._currentCursor === val ||
       (val === '' && this._currentCursor === this._defaultCursor)) return;
    this._currentCursor = val;
    // set element's style.cursor
    if (val !== '') {
      this._canvas.style.cursor = val;
      document.body.style.cursor = val;
    } else {
      this._canvas.style.cursor = this.defaultCursor;
      document.body.style.cursor = this.defaultCursor;
    }
  }
);

/**
* Gets or sets the cursor to be used for the Diagram
* when no {@link GraphObject} specifies a different cursor.
* <p>
* Valid CSS cursors are accepted,
* such as "auto", "default", "none", "context-menu", "help", "pointer", "progress", "wait", etc.
* To read more about cursor syntax, go to:
* <a href="http://developer.mozilla.org/en-US/docs/Web/CSS/cursor">CSS cursors</a>.
* The default value is "auto".
* @name Diagram#defaultCursor
* @function.
* @return {string}
* @see #currentCursor
* @see GraphObject#cursor
*/
/** @type {string} */
Diagram.prototype.defaultCursor;
Util.exportProperty(Diagram, 'defaultCursor', Diagram.prototype.defaultCursor);
Util.defineProperty(Diagram, {defaultCursor: 'defaultCursor'},
  /** @this {Diagram} */
  function() { return this._defaultCursor; },
  /** @this {Diagram} */
  function(val) {
    Util.checkPrimitive(val, 'string', Diagram, 'defaultCursor');
    var old = this._defaultCursor;
    if (old !== val) {
      this._defaultCursor = val;
      this.raiseChanged('defaultCursor', old, val);
    }
  }
);

/**
* @ignore
* Gets or sets whether the Diagram will use touch gestures to zoom the diagram.
* If true, zoom gestures affect and zoom the Diagram.
* If false, zoom gestures bubble instead, typically affecting and zooming the web page.
* <p>
* The default value is true.
* @name Diagram#hasGestureZoom
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Diagram.prototype.hasGestureZoom;
Util.exportProperty(Diagram, 'hasGestureZoom', Diagram.prototype.hasGestureZoom);
Util.defineProperty(Diagram, {hasGestureZoom: 'hasGestureZoom'},
  /** @this {Diagram} */
  function() { return this._hasGestureZoom; },
  /** @this {Diagram} */
  function(val) {
    var old = this._hasGestureZoom;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Diagram, 'hasGestureZoom');
      this._hasGestureZoom = val;
      this.raiseChanged('hasGestureZoom', old, val);
    }
  }
);

/**
* Gets or sets the function to execute when the user single-primary-clicks
* on the background of the Diagram.
* This typically involves a mouse-down followed by a prompt mouse-up
* at approximately the same position using the left (primary) mouse button.
* This property is used by the {@link ClickSelectingTool}
* when the user clicks on no object.
* The function is called in addition to the {@link DiagramEvent}
* that is raised with the name "BackgroundSingleClicked".
* <p/>
* If this property value is a function, it is called with an {@link InputEvent}.
* By default this property is null.
* <p/>
* If you do provide a function that makes changes to the diagram or to its model,
* you should do so within a transaction -- call {@link #startTransaction} and {@link #commitTransaction}.
* @name Diagram#click
* @function.
* @return {function(InputEvent) | null}
* @see #doubleClick
* @see #contextClick
* @see GraphObject#click
*/
/** @type {function(InputEvent) | null} */
Diagram.prototype.click;
Util.exportProperty(Diagram, 'click', Diagram.prototype.click);
Util.defineProperty(Diagram, {click: 'click'},
  /** @this {Diagram} */
  function() { return this._click; },
  /** @this {Diagram} */
  function(val) {
    var old = this._click;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', Diagram, 'click');
      this._click = val;
      this.raiseChanged('click', old, val);
    }
  }
);

/**
* Gets or sets the function to execute when the user double-primary-clicks
* on the background of the Diagram.
* This typically involves a mouse-down/up/down/up in rapid succession
* at approximately the same position using the left (primary) mouse button.
* This property is used by the {@link ClickSelectingTool}
* when the user clicks on no object.
* The function is called in addition to the {@link DiagramEvent}
* that is raised with the name "BackgroundDoubleClicked".
* <p/>
* If this property value is a function, it is called with an {@link InputEvent}.
* By default this property is null.
* <p/>
* If you do provide a function that makes changes to the diagram or to its model,
* you should do so within a transaction -- call {@link #startTransaction} and {@link #commitTransaction}.
* @name Diagram#doubleClick
* @function.
* @return {function(InputEvent) | null}
* @see #click
* @see #contextClick
* @see GraphObject#doubleClick
*/
/** @type {function(InputEvent) | null} */
Diagram.prototype.doubleClick;
Util.exportProperty(Diagram, 'doubleClick', Diagram.prototype.doubleClick);
Util.defineProperty(Diagram, {doubleClick: 'doubleClick'},
  /** @this {Diagram} */
  function() { return this._doubleClick; },
  /** @this {Diagram} */
  function(val) {
    var old = this._doubleClick;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', Diagram, 'doubleClick');
      this._doubleClick = val;
      this.raiseChanged('doubleClick', old, val);
    }
  }
);

/**
* Gets or sets the function to execute when the user single-secondary-clicks
* on the background of the Diagram.
* This typically involves a mouse-down followed by a prompt mouse-up
* at approximately the same position using the right (secondary) mouse button.
* This property is used by the {@link ClickSelectingTool}
* when the user clicks on no object.
* The function is called in addition to the {@link DiagramEvent}
* that is raised with the name "BackgroundContextClicked".
* <p/>
* If this property value is a function, it is called with an {@link InputEvent}.
* By default this property is null.
* <p/>
* If you do provide a function that makes changes to the diagram or to its model,
* you should do so within a transaction -- call {@link #startTransaction} and {@link #commitTransaction}.
* @name Diagram#contextClick
* @function.
* @return {function(InputEvent) | null}
* @see #click
* @see #doubleClick
* @see GraphObject#contextClick
*/
/** @type {function(InputEvent) | null} */
Diagram.prototype.contextClick;
Util.exportProperty(Diagram, 'contextClick', Diagram.prototype.contextClick);
Util.defineProperty(Diagram, {contextClick: 'contextClick'},
  /** @this {Diagram} */
  function() { return this._contextClick; },
  /** @this {Diagram} */
  function(val) {
    var old = this._contextClick;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', Diagram, 'contextClick');
      this._contextClick = val;
      this.raiseChanged('contextClick', old, val);
    }
  }
);

/**
* Gets or sets the function to execute when the user moves the mouse in
* the background of the Diagram without holding down any buttons,
* not over any {@link GraphObject}s.
* This property is used by the {@link ToolManager}.
* <p/>
* If this property value is a function, it is called with an {@link InputEvent}.
* By default this property is null.
* <p/>
* This function is called with {@link Diagram#skipsUndoManager} temporarily set to true,
* so that any changes to {@link GraphObject}s are not recorded in the {@link UndoManager}.
* You do not need to start and commit any transaction in this function.
* After calling this function the diagram will be updated immediately.
* @name Diagram#mouseOver
* @function.
* @return {function(InputEvent) | null}
* @see #mouseHover
* @see GraphObject#mouseOver
*/
/** @type {function(InputEvent) | null} */
Diagram.prototype.mouseOver;
Util.exportProperty(Diagram, 'mouseOver', Diagram.prototype.mouseOver);
Util.defineProperty(Diagram, {mouseOver: 'mouseOver'},
  /** @this {Diagram} */
  function() { return this._mouseOver; },
  /** @this {Diagram} */
  function(val) {
    var old = this._mouseOver;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', Diagram, 'mouseOver');
      this._mouseOver = val;
      this.raiseChanged('mouseOver', old, val);
    }
  }
);

/**
* Gets or sets the function to execute when the user holds the mouse stationary in
* the background of the Diagram without holding down any buttons,
* not over any {@link GraphObject}s.
* This property is used by the {@link ToolManager}.
* <p/>
* If this property value is a function, it is called with an {@link InputEvent}.
* By default this property is null.
* <p/>
* If you do provide a function that makes changes to the diagram or to its model,
* you should do so within a transaction -- call {@link #startTransaction} and {@link #commitTransaction}.
* @name Diagram#mouseHover
* @function.
* @return {function(InputEvent) | null}
* @see #mouseOver
* @see GraphObject#mouseHover
* @see ToolManager#doMouseHover
*/
/** @type {function(InputEvent) | null} */
Diagram.prototype.mouseHover;
Util.exportProperty(Diagram, 'mouseHover', Diagram.prototype.mouseHover);
Util.defineProperty(Diagram, {mouseHover: 'mouseHover'},
  /** @this {Diagram} */
  function() { return this._mouseHover; },
  /** @this {Diagram} */
  function(val) {
    var old = this._mouseHover;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', Diagram, 'mouseHover');
      this._mouseHover = val;
      this.raiseChanged('mouseHover', old, val);
    }
  }
);

/**
* Gets or sets the function to execute when the user holds the mouse stationary in
* the background of the Diagram while holding down a button,
* not over any {@link GraphObject}s.
* This property is used by the {@link ToolManager}.
* <p/>
* If this property value is a function, it is called with an {@link InputEvent}.
* By default this property is null.
* <p/>
* If you do provide a function that makes changes to the diagram or to its model,
* you should do so within a transaction -- call {@link #startTransaction} and {@link #commitTransaction}.
* @name Diagram#mouseHold
* @function.
* @return {function(InputEvent) | null}
* @see GraphObject#mouseHold
* @see ToolManager#doMouseHover
*/
/** @type {function(InputEvent) | null} */
Diagram.prototype.mouseHold;
Util.exportProperty(Diagram, 'mouseHold', Diagram.prototype.mouseHold);
Util.defineProperty(Diagram, {mouseHold: 'mouseHold'},
  /** @this {Diagram} */
  function() { return this._mouseHold; },
  /** @this {Diagram} */
  function(val) {
    var old = this._mouseHold;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', Diagram, 'mouseHold');
      this._mouseHold = val;
      this.raiseChanged('mouseHold', old, val);
    }
  }
);

/**
* Gets or sets the function to execute when the user is dragging the selection in
* the background of the Diagram during a {@link DraggingTool} drag-and-drop,
* not over any {@link GraphObject}s.
* <p/>
* If this property value is a function, it is called with an {@link InputEvent}.
* It is called within the transaction performed by the {@link DraggingTool}.
* By default this property is null.
* <p/>
* This function is called with {@link Diagram#skipsUndoManager} temporarily set to true,
* so that any changes to {@link GraphObject}s are not recorded in the {@link UndoManager}.
* You do not need to start and commit any transaction in this function.
* After calling this function the diagram will be updated immediately.
* <p>
* For example, if you want to prevent the user from dropping Parts into the background of the diagram,
* and want to provide feedback about that during a drag:
* <pre>
*   myDiagram.mouseDragOver = function(e) {
*     myDiagram.currentCursor = "not-allowed";
*   };
* </pre>
* @name Diagram#mouseDragOver
* @function.
* @return {function(InputEvent) | null}
* @see #mouseDrop
* @see GraphObject#mouseDragOver
*/
/** @type {function(InputEvent) | null} */
Diagram.prototype.mouseDragOver;
Util.exportProperty(Diagram, 'mouseDragOver', Diagram.prototype.mouseDragOver);
Util.defineProperty(Diagram, { mouseDragOver: 'mouseDragOver' },
  /** @this {Diagram} */
  function() { return this._mouseDragOver; },
  /** @this {Diagram} */
  function(val) {
    var old = this._mouseDragOver;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', Diagram, 'mouseDragOver');
      this._mouseDragOver = val;
      this.raiseChanged('mouseDragOver', old, val);
    }
  }
);

/**
* Gets or sets the function to execute when the user drops the selection in
* the background of the Diagram at the end of a {@link DraggingTool} drag-and-drop,
* not onto any {@link GraphObject}s.
* <p/>
* If this property value is a function, it is called with an {@link InputEvent}.
* It is called within the transaction performed by the {@link DraggingTool}.
* By default this property is null.
* <p>
* For example, if you want to prevent the user from dropping Parts into the background of the diagram:
* <pre>
*   myDiagram.mouseDrop = function(e) {
*     myDiagram.currentTool.doCancel();
*   };
* </pre>
* @name Diagram#mouseDrop
* @function.
* @return {function(InputEvent) | null}
* @see #mouseDragOver
* @see GraphObject#mouseDrop
*/
/** @type {function(InputEvent) | null} */
Diagram.prototype.mouseDrop;
Util.exportProperty(Diagram, 'mouseDrop', Diagram.prototype.mouseDrop);
Util.defineProperty(Diagram, { mouseDrop: 'mouseDrop' },
  /** @this {Diagram} */
  function() { return this._mouseDrop; },
  /** @this {Diagram} */
  function(val) {
    var old = this._mouseDrop;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', Diagram, 'mouseDrop');
      this._mouseDrop = val;
      this.raiseChanged('mouseDrop', old, val);
    }
  }
);


/**
* This {@link Adornment} is shown when the mouse stays motionless in the background.
* The default value is null, which means no tooltip is shown.
* <p>
* Here is a simple example:
* <pre>
*  diagram.toolTip =
*    $(go.Adornment, "Auto",
*      $(go.Shape, { fill: "#CCFFCC" }),
*      $(go.TextBlock, { margin: 4 },
*        "This diagram lets you control the world.")
*    );
* </pre>
* @name Diagram#toolTip
* @function.
* @return {Adornment}
* @see GraphObject#toolTip
* @see ToolManager#doToolTip
*/
/** @type {Adornment} */
Diagram.prototype.toolTip;
Util.exportProperty(Diagram, 'toolTip', Diagram.prototype.toolTip);
Util.defineProperty(Diagram, {toolTip: 'toolTip'},
  /** @this {Diagram} */
  function() { return this._toolTip; },
  /** @this {Diagram} */
  function(val) {
    var old = this._toolTip;
    if (old !== val) {
      if (val !== null) Util.checkClass(val, Adornment, Diagram, 'toolTip');
      this._toolTip = val;
      this.raiseChanged('toolTip', old, val);
    }
  }
);

/**
* This {@link Adornment} is shown when the use context clicks in the background.
* The default value is null, which means no context menu is shown.
* On touch devices, a special default context menu will appear even there is no context menu defined.
* <p>
* <pre>
*  diagram.contextMenu =
*    $(go.Adornment, "Vertical",
*      $("ContextMenuButton",
*        $(go.TextBlock, "Undo"),
*        { click: function(e, obj) { e.diagram.commandHandler.undo(); } },
*        new go.Binding("visible", "", function(o) {
*            return o.diagram.commandHandler.canUndo();
*          }).ofObject()),
*      $("ContextMenuButton",
*        $(go.TextBlock, "Redo"),
*        { click: function(e, obj) { e.diagram.commandHandler.redo(); } },
*        new go.Binding("visible", "", function(o) {
*            return o.diagram.commandHandler.canRedo();
*          }).ofObject())
*    );
* </pre>
* @name Diagram#contextMenu
* @function.
* @return {Adornment}
* @see GraphObject#contextMenu
* @see ContextMenuTool
*/
/** @type {Adornment} */
Diagram.prototype.contextMenu;
Util.exportProperty(Diagram, 'contextMenu', Diagram.prototype.contextMenu);
Util.defineProperty(Diagram, {contextMenu: 'contextMenu'},
  /** @this {Diagram} */
  function() { return this._contextMenu; },
  /** @this {Diagram} */
  function(val) {
    var old = this._contextMenu;
    if (old !== val) {
      if (val !== null) Util.checkClass(val, Adornment, Diagram, 'contextMenu');
      this._contextMenu = val;
      this.raiseChanged('contextMenu', old, val);
    }
  }
);


/**
* Gets or sets the {@link CommandHandler} for this Diagram.
* <p>
* This is set to a new instance of {@link CommandHandler} on Diagram instantiation.
* <p>
* Setting this property does not notify about any changed event; the new value must not be null.
* @name Diagram#commandHandler
* @function.
* @return {CommandHandler}
*/
/** @type {CommandHandler} */
Diagram.prototype.commandHandler;
Util.exportProperty(Diagram, 'commandHandler', Diagram.prototype.commandHandler);
Util.defineProperty(Diagram, {commandHandler: 'commandHandler'},
  /** @this {Diagram} */
  function() { return this._commandHandler; },
  /** @this {Diagram} */
  function(val) {
    var old = this._commandHandler;
    if (old !== val) {
      Util.checkClass(val, CommandHandler, Diagram, 'commandHandler');
      if (val.diagram !== null) Util.throwError('Cannot share CommandHandlers between Diagrams: ' + val.toString());
      if (old !== null) old.setDiagram(null);
      this._commandHandler = val;
      val.setDiagram(this);
    }
  }
);

/**
* Gets or sets the {@link ToolManager} for this Diagram.
* This tool is used for mode-less operation.
* It is responsible for choosing a particular tool to run as the {@link #currentTool}.
* <p>
* This tool is normally also the {@link #defaultTool}.
* If you don't want the ToolManager to run at all,
* replace the {@link #defaultTool} with your own tool.
* <p>
* Setting this property does not notify about any changed event; the new value must not be null.
* If you set this property, you will probably also want to set {@link #defaultTool}.
* @name Diagram#toolManager
* @function.
* @return {ToolManager}
* @see #defaultTool
*/
/** @type {ToolManager} */
Diagram.prototype.toolManager;
Util.exportProperty(Diagram, 'toolManager', Diagram.prototype.toolManager);
Util.defineProperty(Diagram, {toolManager: 'toolManager'},
  /** @this {Diagram} */
  function() { return this._toolManager; },
  /** @this {Diagram} */
  function(val) {
    var old = this._toolManager;
    if (old !== val) {
      Util.checkClass(val, ToolManager, Diagram, 'toolManager');
      if (val.diagram !== null) Util.throwError('Cannot share ToolManagers between Diagrams: ' + val.toString());
      if (old !== null) old.setDiagram(null);
      this._toolManager = val;
      val.setDiagram(this);
    }
  }
);

/**
* Gets or sets the default tool for this Diagram that becomes the current tool when the current tool stops.
* Initially this value is the same tool as {@link #toolManager}, which is an instance of {@link ToolManager}.
* <p>
* Setting this property also sets the {@link #currentTool} if the old default tool is the currently running tool.
* <p>
* Setting this property does not notify about any changed event; the new value must not be null.
* @name Diagram#defaultTool
* @function.
* @return {Tool}
* @see #currentTool
* @see #toolManager
*/
/** @type {Tool} */
Diagram.prototype.defaultTool;
Util.exportProperty(Diagram, 'defaultTool', Diagram.prototype.defaultTool);
Util.defineProperty(Diagram, {defaultTool: 'defaultTool'},
  /** @this {Diagram} */
  function() { return this._defaultTool; },
  /** @this {Diagram} */
  function(val) {
    var old = this._defaultTool;
    if (old !== val) {
      Util.checkClass(val, Tool, Diagram, 'defaultTool');
      this._defaultTool = val;
      if (this.currentTool === old) {  // maybe replace the currentTool too
        this.currentTool = val;
      }
    }
  }
);

/**
* Gets or sets the current tool for this Diagram that handles all input events.
* This value is frequently replaced by the {@link #toolManager} as different tools run.
* <p>
* Each Diagram has a number of tools that define its behavior when responding to mouse events.
* These include {@link ClickSelectingTool}, {@link DraggingTool}, {@link DragSelectingTool}, {@link LinkingTool}, and {@link ResizingTool}, among others.
* <p>
* Initially this is set to the value of {@link #defaultTool}.
* Setting this to a null value is treated as if it were set to the {@link #defaultTool},
* because there should always be a currently running tool, except when the diagram is being initialized.
* <p>
* A {@link ToolManager} is the default tool used by a Diagram - it chooses to run one of the other tools
* depending on the circumstances.
* <p>
* Setting this property to a new tool stops the previous current tool
* <p>
* Setting this property does not notify about any changed event.
* @name Diagram#currentTool
* @function.
* @return {Tool}
* @see #defaultTool
* @see #toolManager
*/
/** @type {Tool} */
Diagram.prototype.currentTool;
Util.exportProperty(Diagram, 'currentTool', Diagram.prototype.currentTool);
Util.defineProperty(Diagram, {currentTool: 'currentTool'},
  /** @this {Diagram} */
  function() { return this._currentTool; },
  /** @this {Diagram} */
  function(val) {
    var old = this._currentTool;
    if (old !== null) {
      if (old.isActive) old.doDeactivate();
      old.cancelWaitAfter();
      old.doStop();
    }
    // assume null value for new tool means use the defaultTool instead
    if (val === null) val = this.defaultTool;
    if (val !== null) {
      Util.checkClass(val, Tool, Diagram, 'currentTool');
      this._currentTool = val;
      val.setDiagram(this);
      //Debug.trace('--> ' + val.toString());
      val.doStart();
      // but not doActivate, since that might depend on conditions
    }
  }
);


// Selection

/**
* Gets the read-only collection of selected objects.
* <p/>
* Do not modify this collection.
* If you want to select or deselect a particular object in a Diagram,
* set the {@link Part#isSelected} property.
* If you want to deselect all objects, call {@link #clearSelection}.
* If you want to deselect all objects and select a single object, call {@link #select}.
* <p/>
* You can limit how many objects the user can select by setting {@link #maxSelectionCount}.
* @name Diagram#selection
* @function.
* @return {Set} a collection of {@link Part}s.
*/
/** @type {Set} */
Diagram.prototype.selection;
Util.defineReadOnlyProperty(Diagram, {selection: 'selection'},
  /** @this {Diagram} */
  function() { return this._selection; }
);

/**
* Gets or sets the maximum number of selected objects.
* The default value is a large positive integer.
* Values must be non-negative.
* Decreasing this value may cause objects to be removed from {@link #selection}
* in order to meet the new lower limit.
* @name Diagram#maxSelectionCount
* @function.
* @return {number}
*/
/** @type {number} */
Diagram.prototype.maxSelectionCount;
Util.exportProperty(Diagram, 'maxSelectionCount', Diagram.prototype.maxSelectionCount);
Util.defineProperty(Diagram, {maxSelectionCount: 'maxSelectionCount'},
  /** @this {Diagram} */
  function() { return this._maxSelectionCount; },
  /** @this {Diagram} */
  function(val) {
    var old = this._maxSelectionCount;
    if (old !== val) {
      Util.checkPrimitive(val, 'number', Diagram, 'maxSelectionCount');
      if (val >= 0 && !isNaN(val)) {
        this._maxSelectionCount = val;
        this.raiseChanged('maxSelectionCount', old, val);
        if (!this.undoManager.isUndoingRedoing) {
          var excess = this.selection.count - val;
          if (excess > 0) {
            this.raiseDiagramEvent('ChangingSelection');
            var all = this.selection.toArray();
            for (var i = 0; i < excess; i++) {
              all[i].isSelected = false;
            }
            this.raiseDiagramEvent('ChangedSelection');
          }
        }
      } else {
        Util.throwRangeError(val, '>= 0', Diagram, 'maxSelectionCount');
      }
    }
  }
);

/**
* Gets or sets the default selection {@link Adornment} template, used to adorn selected Parts other than Groups or Links.
* <p/>
* Each {@link Node} or simple {@link Part} can have its own {@link Part#selectionAdornmentTemplate}, which if non-null will take precedence over this Diagram property.
* <p/>
* This Adornment must not be in the visual tree of any Diagram.
* @name Diagram#nodeSelectionAdornmentTemplate
* @function.
* @return {Adornment}
*/
/** @type {Adornment} */
Diagram.prototype.nodeSelectionAdornmentTemplate;
Util.exportProperty(Diagram, 'nodeSelectionAdornmentTemplate', Diagram.prototype.nodeSelectionAdornmentTemplate);
Util.defineProperty(Diagram, {nodeSelectionAdornmentTemplate: 'nodeSelectionAdornmentTemplate'},
  /** @this {Diagram} */
  function() { return this._nodeSelectionAdornmentTemplate; },
  /** @this {Diagram} */
  function(val) {
    var old = this._nodeSelectionAdornmentTemplate;
    if (old !== val) {
      Util.checkClass(val, Adornment, Diagram, 'nodeSelectionAdornmentTemplate');
      this._nodeSelectionAdornmentTemplate = val;
      this.raiseChanged('nodeSelectionAdornmentTemplate', old, val);
    }
  }
);

/**
* Gets or sets the default selection {@link Adornment} template, used to adorn selected Groups.
* <p/>
* Each {@link Group} can have its own {@link Part#selectionAdornmentTemplate}, which if non-null will take precedence over this Diagram property.
* <p/>
* This Adornment must not be in the visual tree of any Diagram.
* @name Diagram#groupSelectionAdornmentTemplate
* @function.
* @return {Adornment}
*/
/** @type {Adornment} */
Diagram.prototype.groupSelectionAdornmentTemplate;
Util.exportProperty(Diagram, 'groupSelectionAdornmentTemplate', Diagram.prototype.groupSelectionAdornmentTemplate);
Util.defineProperty(Diagram, {groupSelectionAdornmentTemplate: 'groupSelectionAdornmentTemplate'},
  /** @this {Diagram} */
  function() { return this._groupSelectionAdornmentTemplate; },
  /** @this {Diagram} */
  function(val) {
    var old = this._groupSelectionAdornmentTemplate;
    if (old !== val) {
      Util.checkClass(val, Adornment, Diagram, 'groupSelectionAdornmentTemplate');
      this._groupSelectionAdornmentTemplate = val;
      this.raiseChanged('groupSelectionAdornmentTemplate', old, val);
    }
  }
);

/**
* Gets or sets the default selection {@link Adornment} template, used to adorn selected Links.
* <p/>
* Each {@link Link} can have its own {@link Part#selectionAdornmentTemplate}, which if non-null will take precedence over this Diagram property.
* <p/>
* This Adornment must not be in the visual tree of any Diagram.
* @name Diagram#linkSelectionAdornmentTemplate
* @function.
* @return {Adornment}
*/
/** @type {Adornment} */
Diagram.prototype.linkSelectionAdornmentTemplate;
Util.exportProperty(Diagram, 'linkSelectionAdornmentTemplate', Diagram.prototype.linkSelectionAdornmentTemplate);
Util.defineProperty(Diagram, {linkSelectionAdornmentTemplate: 'linkSelectionAdornmentTemplate'},
  /** @this {Diagram} */
  function() { return this._linkSelectionAdornmentTemplate; },
  /** @this {Diagram} */
  function(val) {
    var old = this._linkSelectionAdornmentTemplate;
    if (old !== val) {
      Util.checkClass(val, Adornment, Diagram, 'linkSelectionAdornmentTemplate');
      this._linkSelectionAdornmentTemplate = val;
      this.raiseChanged('linkSelectionAdornmentTemplate', old, val);
    }
  }
);


/**
* Gets or sets whether this Diagram's state has been modified.
* Setting this property does not notify about any changed event.
* <p>
* return true if the Diagram has been changed,
* if the {@link #undoManager} has recorded any changes, or
* if an undo has been performed without a corresponding redo.
* @name Diagram#isModified
* @function.
* @return {boolean} true if the Diagram has been changed,
* if the {@link #undoManager} has recorded any changes, or
* if an undo has been performed without a corresponding redo.
*/
/** @type {boolean} */
Diagram.prototype.isModified;
Util.exportProperty(Diagram, 'isModified', Diagram.prototype.isModified);
Util.defineProperty(Diagram, {isModified: 'isModified'},
  /** @this {Diagram} */
  function() {
    var m = this.undoManager;
    if (m === null) return this._isModified;
    if (m.currentTransaction !== null) return true;
    return this._isModified && this._historyIndex !== m.historyIndex;
  },
  /** @this {Diagram} */
  function(val) {
    var old = this._isModified;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Diagram, 'isModified');
      this._isModified = val;
      var m = this.undoManager;
      if (!val && m) {  // remember current UndoManager.historyIndex
        this._historyIndex = m.historyIndex;
      }
    }
  }
);


/**
* Gets or sets the {@link Model} holding data corresponding to the
* data-bound nodes and links of this Diagram.
* <p>
* Replacing this value causes all of the bound Nodes and Links to be deleted and re-created
* from the new model data.
* <p>
* Models may be shared by multiple Diagrams. One common approach is to have two
* Diagrams displaying the same Model but using different templates
* (see {@link #nodeTemplate}, {@link #nodeTemplateMap}, and the associated link and group properties) and sometimes even different Layouts.
* <p>
* Setting this property does not notify about any changed event; the new value must not be null.
* Typically a new Model will have its own {@link UndoManager}, thereby replacing the Diagram's
* current UndoManager.
* <p>
* Replacing or re-setting the model will re-initialize the Diagram, taking in to account
* {@link #initialPosition}, {@link #initialScale}, {@link #initialAutoScale}, and {@link #initialContentAlignment}.
* <p>
* It is an error to replace the Diagram.model while a transaction is in progress.
* @name Diagram#model
* @function.
* @return {Model}
*/
/** @type {Model} */
Diagram.prototype.model;
Util.exportProperty(Diagram, 'model', Diagram.prototype.model);
Util.defineProperty(Diagram, { model: 'model' },
  /** @this {Diagram} */
  function() { return this._model; },
  /** @this {Diagram} */
  function(val) {
    var old = this._model;
    if (old !== val) {
      Util.checkClass(val, Model, Diagram, 'model');

      if (old !== null && old.undoManager !== val.undoManager && old.undoManager.isInTransaction) {
        Util.throwError('Do not replace a Diagram.model while a transaction is in progress.');
      }

      // reset some internal state
      this._initialLayoutCompleted = false;
      this._firstUpdate = true;
      this._updateQueued = false;
      // need to make layouts invalid without updating
      var oldUpdating = this._isUpdating;
      this._isUpdating = true;

      if (old !== null) {
        old.removeChangedListener(this._modelChangedHandler);
        if (old instanceof GraphLinksModel) this.removeBoundParts(old.linkDataArray);
        this.removeBoundParts(old.nodeDataArray);
      }
      this._model = val;
      // add partial listener first, in case of need to update data bindings while creating Parts
      val.addChangedListener(this._modelBindingHandler);
      this.addBoundParts(val.nodeDataArray);  // also calls invalidateAllLayouts
      if (val instanceof GraphLinksModel) this.addBoundLinks(val.linkDataArray);
      // remove temporary partial listener
      val.removeChangedListener(this._modelBindingHandler);
      // add real listener afterwards, to avoid unnecessary churn during the construction of Parts
      val.addChangedListener(this._modelChangedHandler);
      this._isUpdating = oldUpdating;
      if (!this._isAligning) this.invalidateDraw(); // calls requestUpdate

      // if the old UndoManager was enabled, the new one is too
      if (old !== null) {
        val.undoManager.isEnabled = old.undoManager.isEnabled;
      }
    }
  }
);

/** @ignore */
/** @type {boolean} */
Diagram.prototype.isUpdatingModel;
Util.defineProperty(Diagram, { isUpdatingModel: null },
  /** @this {Diagram} */
  function() { return this._isUpdatingModel; },
  /** @this {Diagram} */
  function(val) { this._isUpdatingModel = val; }
);

/**
* @ignore
* This function is called when the Diagram's {@link #model} has changed.
* @this {Diagram}
* @param {ChangedEvent} e
*/
Diagram.prototype.doModelChanged = function(e) {
  if (e.model !== this.model) return;
  if (!this.isUpdatingModel) return;
  this.isUpdatingModel = false;  // now Model is updating Diagram, not vice-versa
  try {
    var chg = e.change;
    var mname = e.modelChange;
    if (mname !== '') {
      // first consider all model data changes (not simple model property changes)
      if (chg === ChangedEvent.Property) {
        if (mname === 'linkFromKey') {
          var data = e.object;
          var link = this.findLinkForData(data);
          if (link !== null) {
            var nid = e.newValue;
            var node = this.findNodeForKey(nid);
            link.fromNode = node;  // might be null
          }
        } else if (mname === 'linkToKey') {
          var data = e.object;
          var link = this.findLinkForData(data);
          if (link !== null) {
            var nid = e.newValue;
            var node = this.findNodeForKey(nid);
            link.toNode = node;  // might be null
          }
        } else if (mname === 'linkFromPortId') {
          var data = e.object;
          var link = this.findLinkForData(data);
          if (link !== null) {
            var pid = e.newValue;
            if (typeof pid === 'string') {
              link.fromPortId = pid;
            }
          }
        } else if (mname === 'linkToPortId') {
          var data = e.object;
          var link = this.findLinkForData(data);
          if (link !== null) {
            var pid = e.newValue;
            if (typeof pid === 'string') {
              link.toPortId = pid;
            }
          }
        } else if (mname === 'nodeGroupKey') {
          var data = e.object;
          var part = this.findPartForData(data);
          if (part !== null) {
            var gid = e.newValue;
            if (gid !== undefined) {
              var group = this.findNodeForKey(gid);
              if (group instanceof Group) {
                part.containingGroup = group;
              } else {
                part.containingGroup = null;
              }
            } else {
              part.containingGroup = null;
            }
          }
        } else if (mname === 'linkLabelKeys') {
          var data = e.object;
          var link = this.findLinkForData(data);
          if (link !== null) {
            var oldkeys = e.oldValue;
            var newkeys = e.newValue;
            if (Util.isArray(oldkeys)) {
              var len = Util.arrayLength(oldkeys);
              for (var i = 0; i < len; i++) {
                var k = Util.arrayElt(oldkeys, i);
                var node = this.findNodeForKey(k);
                if (node !== null) {
                  node.labeledLink = null;
                }
              }
            }
            if (Util.isArray(newkeys)) {
              var len = Util.arrayLength(newkeys);
              for (var i = 0; i < len; i++) {
                var k = Util.arrayElt(newkeys, i);
                var node = this.findNodeForKey(k);
                if (node !== null) {
                  node.labeledLink = link;
                }
              }
            }
          }
        } else if (mname === 'nodeParentKey') {
          var childdata = e.object;  // the child node data
          var parentkey = e.newValue;
          var parentnode = this.findNodeForKey(parentkey);
          var childnode = this.findNodeForData(childdata);
          if (childnode !== null) {
            var parentlink = childnode.findTreeParentLink();
            // found an existing parent link
            if (parentlink !== null) {
              // if no new parent node, delete the link
              if (parentnode === null) {
                this.remove(parentlink);
              } else {
                // otherwise reconnect the existing parent link
                if (this.isTreePathToChildren) {
                  parentlink.fromNode = parentnode;
                } else {
                  parentlink.toNode = parentnode;
                }
              }
            } else {  // not found -- create new link
              this.addParentLink(parentnode, childnode);
            }
          }
        } else if (mname === 'parentLinkCategory') {
          var childdata = e.object;  // the child node data
          var childnode = this.findNodeForData(childdata);
          var newcat = e.newValue;
          if (childnode !== null && typeof newcat === 'string') {
            var parentlink = childnode.findTreeParentLink();
            if (parentlink !== null) {
              parentlink.category = newcat;
            }
          }
        } else if (mname === 'nodeCategory') {
          var data = e.object;
          // if had been selected before, select it again
          var oldpart = this.findPartForData(data);
          var newcat = e.newValue;
          if (oldpart !== null && typeof newcat === 'string') {
            oldpart.category = newcat;
          }
        } else if (mname === 'linkCategory') {
          var data = e.object;
          var oldlink = this.findLinkForData(data);
          var newcat = e.newValue;
          if (oldlink !== null && typeof newcat === 'string') {
            oldlink.category = newcat;
          }
        } else if (mname === 'nodeDataArray') {
          this.invalidateDraw();
          var olddata = e.oldValue;
          this.removeBoundParts(olddata);
          var newdata = e.newValue;
          this.addBoundParts(newdata);
        } else if (mname === 'linkDataArray') {
          this.invalidateDraw();
          var olddata = e.oldValue;
          this.removeBoundParts(olddata);
          var newdata = e.newValue;
          this.addBoundLinks(newdata);
        }
        this.isModified = true;
        // end of ChangedEvent.Property
      } else if (chg === ChangedEvent.Insert) {
        var newdata = e.newValue;
        if (mname === 'nodeDataArray' && Util.isObject(newdata)) {  // model property
          this.addBoundPart(newdata);
        } else if (mname === 'linkDataArray' && Util.isObject(newdata)) {  // model property
          this.addBoundLink(newdata);
        } else if (mname === 'linkLabelKeys' && e.model.isKeyType(newdata)) {  // model data change
          // presumably e.object is a link data object
          // and newdata is a key for a label node
          var linkdata = e.object;
          var link = this.findLinkForData(linkdata);
          var node = this.findNodeForKey(newdata);
          if (link !== null && node !== null) {
            node.labeledLink = link;
          }
        }
        this.isModified = true;
        // end of ChangedEvent.Insert
      } else if (chg === ChangedEvent.Remove) {
        var olddata = e.oldValue;
        if (mname === 'nodeDataArray' && Util.isObject(olddata)) {  // model property
          this.removeBoundPart(olddata);
        } else if (mname === 'linkDataArray' && Util.isObject(olddata)) {  // model property
          this.removeBoundPart(olddata);
        } else if (mname === 'linkLabelKeys' && e.model.isKeyType(olddata)) {  // model data change
          // presumably olddata is a key for a label node
          var node = this.findNodeForKey(olddata);
          if (node !== null) {
            node.labeledLink = null;
          }
        }
        this.isModified = true;
        // end of ChangedEvent.Remove
      } else if (chg === ChangedEvent.Transaction) {
        if (mname === 'SourceChanged') {
          var part = this.findPartForData(e.object);
          var srcpropname = e.propertyName;
          if (part !== null && typeof srcpropname === 'string') {
            part.updateTargetBindings(srcpropname);
            if (this.model instanceof TreeModel) {
              var link = this.findLinkForData(e.object);  // handle parent links when TreeModel
              if (link !== null) {
                link.updateTargetBindings(srcpropname);
              }
            }
          }
        }
        // end of ChangedEvent.Transaction
      }
    } else {  // mname === '', not a named model-structure change
      if (chg === ChangedEvent.Property) {
        var pname = e.propertyName;
        var data = e.object;
        var model = this.model;
        if (data === model) {  // property change to model itself
          if (pname === 'nodeKeyProperty' ||
              pname === 'nodeCategoryProperty' ||
              pname === 'linkFromKeyProperty' ||
              pname === 'linkToKeyProperty' ||
              pname === 'linkFromPortIdProperty' ||
              pname === 'linkToPortIdProperty' ||
              pname === 'nodeIsLinkLabelProperty' ||
              pname === 'linkLabelKeysProperty' ||
              pname === 'nodeIsGroupProperty' ||
              pname === 'nodeGroupKeyProperty' ||
              pname === 'nodeParentKeyProperty' ||
              pname === 'linkCategoryProperty') {
            if (!this.undoManager.isUndoingRedoing) this.rebuildParts();
          }
          // ignore the 'name', 'dataFormat' model properties;
          // 'nodeDataArra' and 'linkDataArray' are covered above
          // as named model-structure changes
        } else {  // property change to model data -- update the Part
          this.updateDataBindings(data, pname);
        }
        this.isModified = true;
      } else if (chg === ChangedEvent.Insert || chg === ChangedEvent.Remove) {
        // changes to some data array, perhaps used as Panel.itemArray in multiple Panels
        this.modifyItemArray(e);
        this.isModified = true;
      } else if (chg === ChangedEvent.Transaction) {
        // ignore 'Start' transaction events, but handle 'Commit' and 'Finish' and 'Property'
        var xname = e.propertyName;
        if (xname[0] !== 'S') {
          if (xname === 'CommittingTransaction') {
            // this happens before the transaction is actually completed by the UndoManager
            // this now does nothing special, since updateLayoutQueued now occurs all the time below
          } else {
            if (xname === 'FinishedUndo' || xname === 'FinishedRedo') {
              // At the end of an undo/redo we want to validate all parts but not have any side effects occur,
              // such as parts invalidating layouts. In the future we will do away with this in favor of having
              // nothing invalid (therefore nothing to validate) by the time Finished Undo/Redo occur.
              this.undoManager._isUndoingRedoing = true;
              this.validateParts();
              this.undoManager._isUndoingRedoing = false;
            }
          }
          this._updateLayoutQueued = true;  // perform any automatic layouts
          this.maybeUpdate();
          // Parts may have moved or been removed, so we need to give tooltips and other objects
          // that are sensitive to a mouse-over a chance to update themselves.
          // This must be done after the transaction is all done, as if a separate mouse event.
          // Should this only be done when the real mouse position is over this Diagram???
          // (Tool.standardMouseOver uses lastInput, which may contain out-of-date event info.)
          if (!this._mouseOverQueued && xname === 'CommittedTransaction') {
            this._mouseOverQueued = true;
            var diag = this;
            setTimeout(function() {
                diag.currentTool.standardMouseOver();
                diag._mouseOverQueued = false;
              }, 10);
          }
          // call Diagram.checkProperties at each transaction, to look for unexpectedly set property names
          //var msg = this.checkProperties(); if (msg !== '') Util.trace(msg);  // for debugging only!
        } else if (xname === 'StartingFirstTransaction' && !this._isUpdating && !this._initialLayoutCompleted) {
          this._updateLayoutQueued = true;  // perform any automatic layouts
          if (this._firstUpdate) this._updateQueued = true;
        }
        // end of ChangedEvent.Transaction
      }
    }  // end of regular (not named model-structure) change
  } finally {
    this.isUpdatingModel = true;
  }
};

/**
* @ignore
* This is a temporary Model Changed event handler.
* @this {Diagram}
* @param {ChangedEvent} e
*/
Diagram.prototype.doModelDataChanged = function(e) {
  if (e.model !== this.model) return;
  if (!this.isUpdatingModel) return;
  this.isUpdatingModel = false;  // now Model is updating Diagram, not vice-versa
  try {
    var chg = e.change;
    var mname = e.modelChange;
    if (mname === '' && chg === ChangedEvent.Property) {
      var pname = e.propertyName;
      var data = e.object;
      this.updateDataBindings(data, pname);
    }
  } finally {
    this.isUpdatingModel = true;
  }
};

/**
* @ignore
* @this {Diagram}
* @param {Object} data
*/
Diagram.prototype.updateDataBindings = function(data, pname) {
  var part = this.findPartForData(data);
  if (part !== null && typeof pname === 'string') {
    part.updateTargetBindings(pname);
    if (this.model instanceof TreeModel) {
      var link = this.findLinkForData(data);  // handle parent links when TreeModel
      if (link !== null) {
        link.updateTargetBindings(pname);
      }
    }
  } else {
    if (typeof pname === 'string') {
      var panels = this.findPanelsForItem(data);
      if (panels !== null) {
        for (var i = 0; i < panels.length; i++) {
          var p = panels[i];
          p.updateTargetBindings(pname);
        }
        Util.freeArray(panels);
      }
    }
  }
};

/**
* @ignore
* Return an Array of item Panels that are bound to the given data.
* There may be multiple container Panels whose .itemArray refers to the Array holding this data.
* This assumes that a data object is not shared by different Arrays.
* @this {Diagram}
* @param {Object} data
* @return {Array} null or a temporary Array that must be Util.freeArray()'d
*/
Diagram.prototype.findPanelsForItem = function(data) {
  var results = null;
  var it = this._itemArrayPanelsMap.iterator;  // using this is slow!
  while (it.next()) {
    var panels = it.value;
    for (var i = 0; i < panels.length; i++) {
      var pan = panels[i];
      if (pan._itemElementMap !== null) {
        var p = pan._itemElementMap.getValue(data);
        if (p !== null) {
          if (results === null) results = Util.tempArray();
          results.push(p);
        }
      }
    }
    // assume the DATA is only in one ITEMARRAY, not shared by multiple Arrays;
    // but the item Array may be used by multiple container Panels,
    // so there can be multiple item Panels.
    if (results !== null) break;
  }
  return results;
};

/**
* @ignore
* Support for ChangedEvent.Insert/Remove into/from item array for model data.
* @this {Diagram}
* @param {ChangedEvent} e
*/
Diagram.prototype.modifyItemArray = function(e) {
  var arr = e.object;
  var insert = e.change === ChangedEvent.Insert;
  var idx = insert ? e.newParam : e.oldParam;
  var val = insert ? e.newValue : e.oldValue;
  var panels = this._itemArrayPanelsMap.getValue(arr);
  // there may be multiple Panels whose Panel.itemArray refers to the modified Array
  if (Array.isArray(panels)) {
    for (var i = 0; i < panels.length; i++) {
      var p = panels[i];
      // add or remove an element from that Panel
      if (typeof idx === 'number') {  // stupid Closure compiler requires type checks
        if (p.type === Panel.Spot || p.type === Panel.Auto) idx++;  // skip first element
        if (insert) {
          if (Util.isObject(val)) {
            p.addItemElement(val, idx);
            p.updateTableIndexes(p, idx);  // update any row/column values after this item
          }
        } else {
          p.internalRemove(idx);
          p.updateTableIndexes(p, idx);  // update any row/column values after this item
        }
      }
    }
  }
};

/**
* @ignore
* @this {Diagram}
*/
Diagram.prototype.rememberItemArrayPanel = function(pan) {
  var arr = pan._itemArray;
  if (Util.isArray(arr)) {
    var panels = this._itemArrayPanelsMap.getValue(arr);
    if (panels === null) {
      // if the array is unknown, remember the array and the one Panel
      this._itemArrayPanelsMap.add(arr, [pan]);
    } else {
      // is the Panel already known for the array, don't need to do anything
      for (var i = 0; i < panels.length; i++) {
        if (panels[i] === pan) return;
      }
      // otherwise add to the collection
      panels.push(pan);
    }
  }
};

/**
* @ignore
* @this {Diagram}
*/
Diagram.prototype.forgetItemArrayPanel = function(pan) {
  var arr = pan._itemArray;
  if (Util.isArray(arr)) {
    var panels = this._itemArrayPanelsMap.getValue(arr);
    if (panels !== null) {
      for (var i = 0; i < panels.length; i++) {
        if (panels[i] === pan) {
          panels.splice(i, 1);
          if (panels.length === 0) {
            this._itemArrayPanelsMap.remove(arr);
          }
          return;
        }
      }
    }
  }
};

Diagram.prototype['clear'] =
/**
* Removes all Parts from the Diagram, including unbound Parts and the background grid,
* and also clears out the {@link Model} and {@link UndoManager}.
* This operation is not undoable.
* <p>
* Alternative actions are to replace the {@link #model} with a new {@link Model}
* (probably a {@link GraphLinksModel} or a {@link TreeModel}),
* or to set {@link Model#nodeDataArray} with an empty JavaScript Array
* (and {@link GraphLinksModel#linkDataArray}).
* @this {Diagram}
*/
Diagram.prototype.clear = function() {
  var gridpart = null;
  if (this._grid !== null) {
    gridpart = this._grid.part;
  }
  this.model.clear();
  var l = this._layers.length;
  for (var i = 0; i < l; i++) {
    this._layers._arr[i].clear();
  }
  this._invalidObjects.clear();
  this._delayedGeometries.clear();
  this._nodes.clear();
  this._topLevelGroups.clear();
  this._links.clear();
  this._parts.clear();
  this._dataPartMap.clear();
  this._dataLinkMap.clear();
  this._itemArrayPanelsMap.clear();
  this._selection.thaw();
  this._selection.clear();
  this._selection.freeze();
  this.previousEnterLeaveObject = null;
  this.currentEnterLeaveObject = null;
  Util.clipboardParts = null;
  this._documentBounds = new Rect(NaN, NaN, NaN, NaN).freeze();
  if (gridpart !== null) {
    this.add(gridpart);  // add this Part to the Diagram
    this._parts.remove(gridpart);  // don't show up in Diagram.parts collection
  }
  this.invalidateDraw();
};

Diagram.prototype['reset'] =
/**
* @ignore
* Call {@link #clear} and also restore the templates, layers, layout and various Diagram properties to their original state.
* @this {Diagram}
*/
Diagram.prototype.reset = function() {
  this._isAligning = true;
  this.clear();
  this._layers = new List(Layer);
  this._position = new Point(NaN, NaN).freeze();
  this._scale = 1;
  this._minScale = 0.0001;
  this._maxScale = 100;
  this._zoomPoint = new Point(NaN, NaN).freeze();
  this._fixedBounds = new Rect(NaN, NaN, NaN, NaN).freeze();
  this._autoScale = Diagram.None;
  this._contentAlignment = Spot.Default;
  this._initialAutoScale = Diagram.None;
  this._initialContentAlignment = Spot.Default;
  this._initialDocumentSpot = Spot.TopLeft;
  this._initialViewportSpot = Spot.TopLeft;
  this._autoScrollRegion = new Margin(16, 16, 16, 16).freeze();
  this._isTreePathToChildren = true;
  this._validCycle = Diagram.CycleAll;
  this._defaultCursor = 'auto';
  this._click = null;
  this._doubleClick = null;
  this._contextClick = null;
  this._mouseOver = null;
  this._mouseHover = null;
  this._mouseHold = null;
  this._mouseDragOver = null;
  this._mouseDrop = null;
  this._toolTip = null;
  this._contextMenu = null;
  this._model = null;
  this._isReadOnly = false;
  this._isEnabled = true;
  this._allowClipboard = true;
  this._allowCopy = true;
  this._allowDelete = true;
  this._allowDragOut = false;
  this._allowDrop = false;
  this._allowTextEdit = true;
  this._allowGroup = true;
  this._allowUngroup = true;
  this._allowInsert = true;
  this._allowLink = true;
  this._allowRelink = true;
  this._allowMove = true;
  this._allowReshape = true;
  this._allowResize = true;
  this._allowRotate = true;
  this._allowSelect = true;
  this._allowUndo = true;
  this._allowZoom = true;
  this._hasHorizontalScrollbar = true;
  this._hasVerticalScrollbar = true;
  this._allowHorizontalScroll = true;
  this._allowVerticalScroll = true;
  this._scrollHorizontalLineChange = 16;
  this._scrollVerticalLineChange = 16;
  this._padding = new Margin(5).freeze();
  this._maxSelectionCount = 999999999;
  this._layout = null;

  this._setupLayers();
  this._setupTemplates();
  this._grid = null;
  this.model = new GraphLinksModel();
  this._skipsUndoManager = true;
  this.layout = new Layout();
  this._skipsUndoManager = false;
  this._isAligning = false;
  this.invalidateDraw();
};

Diagram.prototype['rebuildParts'] =
/**
* Remove all of the {@link Part}s created from model data
* and then create them again.
* This must be called after modifying or replacing any of the template maps
* such as {@link #nodeTemplateMap}.
* This selects all of the new Parts that were created from data of the original selected Parts.
* <p>
* If you modify a template Map, there is no notification that the map has changed.
* You will need to call rebuildParts explicitly.
* If you are replacing the {@link #nodeTemplate} or the {@link #nodeTemplateMap} or
* the corresponding properties for Groups or Links,
* the Diagram property setters will automatically call rebuildParts.
* @this {Diagram}
*/
Diagram.prototype.rebuildParts = function() {
  //??? no-op if isUndoingRedoing
  // make sure all template maps have proper kinds of templates in them
  var it = this.nodeTemplateMap.iterator;
  while (it.next()) {
    var part = it.value;
    if (!part.isNodeLike() || part instanceof Group) {
      Util.throwError('Invalid node template in Diagram.nodeTemplateMap: template for "' + it.key + '" must be a Node or a simple Part, not a Group or Link: ' + part);
    }
  }
  it = this.groupTemplateMap.iterator;
  while (it.next()) {
    var part = it.value;
    if (!(part instanceof Group)) {
      Util.throwError('Invalid group template in Diagram.groupTemplateMap: template for "' + it.key + '" must be a Group, not a normal Node or Link: ' + part);
    }
  }
  it = this.linkTemplateMap.iterator;
  while (it.next()) {
    var part = it.value;
    if (!(part instanceof Link)) {
      Util.throwError('Invalid link template in Diagram.linkTemplateMap: template for "' + it.key + '" must be a Link, not a normal Node or simple Part: ' + part);
    }
  }
  // remember selected part data
  var seldata = Util.tempArray();
  var pit = this.selection.iterator;
  while (pit.next()) {
    var d = pit.value.data;
    if (d) seldata.push(d);
  }
  // clear out all data-bound Parts, but leave unbound parts alone
  var m = this.model;
  if (m instanceof GraphLinksModel) this.removeBoundParts(m.linkDataArray);
  this.removeBoundParts(m.nodeDataArray);
  // create Nodes and Links for all new data
  this.addBoundParts(m.nodeDataArray);  // this also invalidates all layouts
  if (m instanceof GraphLinksModel) this.addBoundLinks(m.linkDataArray);
  // no requestUpdate needed, addBoundParts will do it
  // restore selection
  for (var i = 0; i < seldata.length; i++) {
    var p = this.findPartForData(seldata[i]);
    if (p) p.isSelected = true;
  }
  Util.freeArray(seldata);
};


/**
* @ignore
* @this {Diagram}
* @param dataarray this is an Array-like object -- must use Util methods for access.
*/
Diagram.prototype.addBoundParts = function(dataarray) {
  if (dataarray === null) return;
  var model = this.model;
  var len = Util.arrayLength(dataarray);
  for (var i = 0; i < len; i++) {
    var data = Util.arrayElt(dataarray, i);
    if (model.containsNodeData(data)) {
      this.addBoundPart(data, false);
    } else if (model instanceof GraphLinksModel) {
      this.addBoundLink(data);
    }
  }
  if (model instanceof GraphLinksModel || model instanceof TreeModel) {
    // now handle "forward" references inside node data,
    // but all should be resolved within the given array of data
    for (var i = 0; i < len; i++) {
      var data = Util.arrayElt(dataarray, i);
      if (model.containsNodeData(data)) {
        this.resolveReferencesWithBoundNodeData(data);
      }
    }
    if (model instanceof GraphLinksModel) {
      // nodes may have changed group membership -- need to update all links
      var lit = this.links;
      while (lit.next()) {
        var link = lit.value;
        link.updateContainingGroup();
      }
    }
  }
  this.invalidateAllLayouts(false);
};

/**
* @ignore
* @this {Diagram}
* @param data, a data for a Part/Node but not for a Link.
* @param {boolean=} resolve, default true.
* @return {Part}
*/
Diagram.prototype.addBoundPart = function(data, resolve) {
  if (data === undefined || data === null) return null;
  if (this.undoManager.isUndoingRedoing) return null;
  if (this._dataPartMap.contains(data)) return null;
  if (resolve === undefined/*notpresent*/) resolve = true;

  var cat = this.getCategoryForNodeData(data);
  var template = this.findTemplateForNodeData(data, cat);
  if (template instanceof Part) {
    template.freezeBindings();
    var part = template.copy();
    if (part instanceof Part) {
      part._category = cat;  // don't call property setter
      this.add(part);
      part.data = data;
      if (resolve) {
        this.resolveReferencesWithBoundNodeData(data);
      }
      return part;
    }
  }
  return null;
};

/**
* @ignore
* @expose
* @this {Diagram}
* @param {Object} data, a data for a Part/Node but not for a Link.
* @return {string}
*/
Diagram.prototype.getCategoryForNodeData = function(data) {
  var model = this.model;
  var cat = model.getCategoryForNodeData(data);
  var islabel = false;
  if (model instanceof GraphLinksModel) {
    islabel = model.isLinkLabelForNodeData(data);
  }
  // try defaulting the category for link label nodes
  if (islabel && cat === '') {
    cat = 'LinkLabel';
  }
  return cat;
};

/**
* @ignore
* @expose
* @this {Diagram}
* @param {Object} data, a data for a Part/Node but not for a Link.
* @param {string} cat the category.
* @return {Part}
*/
Diagram.prototype.findTemplateForNodeData = function(data, cat) {
  var isgroup = false;
  var model = this.model;
  if (model instanceof GraphLinksModel) {
    isgroup = model.isGroupForNodeData(data);
  }
  var part = null;
  if (isgroup) {
    var template = this.groupTemplateMap.getValue(cat);
    if (template === null) {
      template = this.groupTemplateMap.getValue('');
      if (template === null) {
        if (!Util.warnedAboutNoGroupTemplate) {
          Util.warnedAboutNoGroupTemplate = true;
          Util.trace('No Group template found for category "' + cat + '"');
          Util.trace('  Using default group template');
        }
        template = this._defaultGroupTemplate;
      }
    }
  } else {
    var template = this.nodeTemplateMap.getValue(cat);
    if (template === null) {
      template = this.nodeTemplateMap.getValue('');
      if (template === null) {
        if (!Util.warnedAboutNoNodeTemplate) {
          Util.warnedAboutNoNodeTemplate = true;
          Util.trace('No Node template found for category "' + cat + '"');
          Util.trace('  Using default node template');
        }
        template = this._defaultNodeTemplate;
      }
    }
  }
  if (template instanceof Part) return template;
  return null;
};

/**
* @ignore
* @this {Diagram}
* @param {Object} data a non-link data.
*/
Diagram.prototype.resolveReferencesWithBoundNodeData = function(data) {
  var model = this.model;
  if (model instanceof GraphLinksModel || model instanceof TreeModel) {
    var key = model.getKeyForNodeData(data);
    if (key !== undefined) {
      var refs = model.findDelayedReferences(key);
      var node = this.findNodeForData(data);  // might be a Part or a Node or a Group
      if (refs !== null && node !== null) {
        // add references from other parts
        var refit = refs.iterator;
        while (refit.next()) {
          var ref = refit.value;
          if (model instanceof GraphLinksModel) {
            if (model.containsNodeData(ref)) {  // the reference is from a node
              if (node instanceof Group && model.getGroupKeyForNodeData(ref) === key) {  // a member node?
                var mem = this.findPartForData(ref);
                if (mem !== null) {
                  mem.containingGroup = node;
                }
              }
            } else {  // the reference is from a link
              var link = this.findLinkForData(ref);
              if (link !== null) {
                if (model.getFromKeyForLinkData(ref) === key) {
                  link.fromNode = node;
                }
                if (model.getToKeyForLinkData(ref) === key) {
                  link.toNode = node;
                }
                // label nodes
                var lkeys = model.getLabelKeysForLinkData(ref);
                for (var i = 0; i < lkeys.length; i++) {
                  if (lkeys[i] === key) {
                    node.labeledLink = link;
                    break;
                  }
                }
              }
            }
          } else if (model instanceof TreeModel) {
            if (model.containsNodeData(ref)) {
              if (model.getParentKeyForNodeData(ref) === key) {
                var child = this.findNodeForData(ref);
                this.addParentLink(node, child);
              }
            }
          }
        }
        // we have resolved all delayed/unresolved references
        model.forgetDelayedReference(key);
      }

      if (model instanceof GraphLinksModel) {
        // this part might be part of a group
        var groupkey = model.getGroupKeyForNodeData(data);
        if (groupkey !== undefined) {
          var container = this.findNodeForKey(groupkey);
          if (container instanceof Group) {
            node.containingGroup = container;
          }
        }
      } else if (model instanceof TreeModel) {
        // this node might be child of a parent
        var parentkey = model.getParentKeyForNodeData(data);
        if (parentkey !== undefined) {
          var parent = this.findNodeForKey(parentkey);
          this.addParentLink(parent, node);
        }
      }
    }
  }
};

/**
* @ignore
* Create Link from PARENT to CHILD, assuming both Nodes are data-bound in a TreeModel.
* If !this.isTreePathToChildren, create Link in opposite direction.
* If !valid, do not create Link.
* @this {Diagram}
* @param {Node} parent
* @param {Node} child
* @return {Link}
*/
Diagram.prototype.addParentLink = function(parent, child) {
  if (parent === null || child === null) return null;
  var tool = this.toolManager.linkingTool;
  var from = parent;
  var to = child;
  if (this.isTreePathToChildren) {
    var lit = to.linksConnected;
    while (lit.next()) {
      var l = lit.value;
      if (l.toNode === to) return null;
    }
    if (tool !== null && tool._MakesDirectedCycleFast(from, to, null, true)) return null;
  } else {
    from = child;
    to = parent;
    var lit = from.linksConnected;
    while (lit.next()) {
      var l = lit.value;
      if (l.fromNode === from) return null;
    }
    if (tool !== null && tool._MakesDirectedCycleFast(from, to, null, true)) return null;
  }

  var cat = this.getCategoryForLinkData(child.data);
  var template = this.findTemplateForLinkData(child.data, cat);
  if (template instanceof Link) {
    template.freezeBindings();
    var link = template.copy();
    if (link instanceof Link) {
      link._category = cat;  // don't call property setter
      link.fromNode = from;
      link.toNode = to;
      this.add(link);
      link.data = child.data;  // no link data, so bind to child node data
      return link;
    }
  }
  return null;
};


/**
* @ignore
* @this {Diagram}
* @param dataarray this is an Array-like object -- must use Util methods for access.
*/
Diagram.prototype.addBoundLinks = function(dataarray) {
  if (dataarray === null) return;
  var len = Util.arrayLength(dataarray);
  for (var i = 0; i < len; i++) {
    var data = Util.arrayElt(dataarray, i);
    this.addBoundLink(data);
  }
  this.invalidateAllLayouts(false);
};

/**
* @ignore
* This should only be called when the model is a GraphLinksModel.
* @this {Diagram}
* @param data
* @return {Link}
*/
Diagram.prototype.addBoundLink = function(data) {
  if (data === undefined || data === null) return null;
  if (this.undoManager.isUndoingRedoing) return null;
  if (this._dataLinkMap.contains(data)) return null;

  var cat = this.getCategoryForLinkData(data);
  var template = this.findTemplateForLinkData(data, cat);
  if (template instanceof Link) {
    template.freezeBindings();
    var link = template.copy();
    if (link instanceof Link) {
      link._category = cat;  // don't call property setter

      // try to resolve references to Nodes
      var model = this.model;

      var frompid = model.getFromPortIdForLinkData(data);
      if (frompid !== '') {
        link.fromPortId = frompid;
      }
      var fromid = model.getFromKeyForLinkData(data);
      if (fromid !== undefined) {
        var fromnode = this.findNodeForKey(fromid);
        if (fromnode instanceof Node) {
          link.fromNode = fromnode;
        }
      }

      var topid = model.getToPortIdForLinkData(data);
      if (topid !== '') {
        link.toPortId = topid;
      }
      var toid = model.getToKeyForLinkData(data);
      if (toid !== undefined) {
        var tonode = this.findNodeForKey(toid);
        if (tonode instanceof Node) {
          link.toNode = tonode;
        }
      }

      // label nodes
      var labkeys = model.getLabelKeysForLinkData(data);
      if (Util.isArray(labkeys)) {
        var len = Util.arrayLength(labkeys);
        for (var i = 0; i < len; i++) {
          var k = Util.arrayElt(labkeys, i);
          var node = this.findNodeForKey(k);
          if (node !== null) {
            node.labeledLink = link;
          }
        }
      }

      this.add(link);
      link.data = data;
      return link;
    }
  }
  return null;
};

/**
* @ignore
* @expose
* @this {Diagram}
* @param {Object} data, a data for a Link (if GraphLinksModel) or for the child Node (if TreeModel).
* @return {string}
*/
Diagram.prototype.getCategoryForLinkData = function(data) {
  var model = this.model;
  var cat = '';
  if (model instanceof GraphLinksModel) {
    cat = model.getCategoryForLinkData(data);
  } else if (model instanceof TreeModel) {
    cat = model.getParentLinkCategoryForNodeData(data);
  }
  return cat;
};

/**
* @ignore
* @expose
* @this {Diagram}
* @param {Object} data, a data for a Link (if GraphLinksModel) or for the child Node (if TreeModel).
* @param {string} cat the category.
* @return {Link}
*/
Diagram.prototype.findTemplateForLinkData = function(data, cat) {
  var template = this.linkTemplateMap.getValue(cat);
  if (template === null) {
    template = this.linkTemplateMap.getValue('');
    if (template === null) {
      if (!Util.warnedAboutNoLinkTemplate) {
        Util.warnedAboutNoLinkTemplate = true;
        Util.trace('No Link template found for category "' + cat + '"');
        Util.trace('  Using default link template');
      }
      template = this._defaultLinkTemplate;
    }
  }
  if (template instanceof Link) return template;
  return null;
};


/**
* @ignore
* @this {Diagram}
* @param dataarray this is an Array-like object -- must use Util methods for access.
*/
Diagram.prototype.removeBoundParts = function(dataarray) {
  var len = Util.arrayLength(dataarray);
  for (var i = 0; i < len; i++) {
    var data = Util.arrayElt(dataarray, i);
    this.removeBoundPart(data);
  }
};

/**
* @ignore
* @this {Diagram}
* @param data
* @return {boolean}  true if the corresponding {@link Part} was removed from this Diagram.
*/
Diagram.prototype.removeBoundPart = function(data) {
  if (data === undefined || data === null) return false;
  var part = this.findPartForData(data);
  if (part instanceof Part) {
    // make sure it's no longer selected
    part.isSelected = false;

    var layer = part.layer;
    if (layer === null) return false;
    if (layer.diagram !== this) return false;

    this.unresolveReferencesWithBoundPart(part);
    // that also removes any parent Link if it's a TreeModel

    // remove from layer only; then it calls Diagram.internalRemove to finish cleaning up here
    var index = layer.internalRemove(-1, part);
    if (index >= 0) this.raiseChangedEvent(ChangedEvent.Remove, 'parts', layer, part, null, index, null);

    var func = part.layerChanged;
    if (func !== null) func(part, layer, null);
    return true;
  }
  return false;
};

/**
* @ignore
* @this {Diagram}
* @param {Part} part a Part/Node/Group, but not a Link or Adornment.
*/
Diagram.prototype.unresolveReferencesWithBoundPart = function(part) {
  // no references in a plain Model, nor for a plain Part
  var model = this.model;
  if (model instanceof GraphLinksModel && part instanceof Node) {
    var key = model.getKeyForNodeData(part.data);
    if (key !== undefined) {
      // remember references from all connected links
      var lit = part.linksConnected;
      while (lit.next()) {
        var linkdata = lit.value.data;
        model.delayReference(key, linkdata);
      }

      // for link label nodes, remember the reference from the labeled link
      if (part.isLinkLabel) {
        var llink = part.labeledLink;
        if (llink !== null) {
          var linkdata = llink.data;
          model.delayReference(key, linkdata);
        }
      }

      // for groups, remember container references from member nodes
      if (part instanceof Group) {
        var mit = part.memberParts;
        while (mit.next()) {
          var memnodedata = mit.value.data;
          if (model.containsNodeData(memnodedata)) {
            model.delayReference(key, memnodedata);
          }
        }
      }
    }
  } else if (model instanceof TreeModel && part instanceof Node) {
    // handle the implicitly defined parent Link that may exist for each Node
    var link = this.findLinkForData(part.data);
    if (link !== null) {
      // Don't call this.remove(link), because that will have side-effects on the model/data
      // Instead, do what removeBoundPart does for regular Parts:
      // make sure it's no longer selected
      link.isSelected = false;
      // remove from layer only; it calls Diagram.internalRemove to finish cleaning up here
      var layer = link.layer;
      if (layer !== null) {
        var index = layer.internalRemove(-1, link);
        if (index >= 0) this.raiseChangedEvent(ChangedEvent.Remove, 'parts', layer, link, null, index, null);
        var func = link.layerChanged;
        if (func !== null) func(link, layer, null);
      }
    }

    // remember references from all tree children
    var tochildren = this.isTreePathToChildren;
    var it = part.linksConnected;
    while (it.next()) {
      var l = it.value;
      var childnode = (tochildren ? l.toNode : l.fromNode);
      var childdata = childnode.data;
      if (model.containsNodeData(childdata)) {
        model.delayReference(key, childdata);
      }
    }
  }
};


Diagram.prototype['findPartForKey'] =
/**
* Look for a {@link Part} or {@link Node} or {@link Group} corresponding to a model's data object's unique key.
* @this {Diagram}
* @param {*} key a string or number.
* @return {Part} null if a data with that key cannot be found in the model,
* or if a corresponding {@link Part} cannot be found in the Diagram.
* This will not return a {@link Link}.
*/
Diagram.prototype.findPartForKey = function(key) {
  if (key === null || key === undefined) return null;
  var data = this.model.findNodeDataForKey(key);
  if (data === null) return null;
  var part = this._dataPartMap.getValue(data);
  if (part instanceof Part) return part;
  return null;
};

Diagram.prototype['findNodeForKey'] =
/**
* Look for a {@link Node} or {@link Group} corresponding to a model's node data object's unique key.
* @this {Diagram}
* @param {*} key a string or number.
* @return {Node} null if a node data with that key cannot be found in the model,
* or if a corresponding {@link Node} or {@link Group} cannot be found in the Diagram,
* or if what is found is just a {@link Part}.
*/
Diagram.prototype.findNodeForKey = function(key) {
  if (key === null || key === undefined) return null;
  var data = this.model.findNodeDataForKey(key);
  if (data === null) return null;
  var node = this._dataPartMap.getValue(data);
  if (node instanceof Node) return node;
  return null;
};

Diagram.prototype['findPartForData'] =
/**
* Look for a {@link Part}, {@link Node}, {@link Group}, or {@link Link} corresponding to a {@link Model}'s data object.
* We recommend that you call {@link #findNodeForData} or {@link #findLinkForData} if you are looking for a {@link Node} or a {@link Link}.
* @this {Diagram}
* @param {Object} data
* @return {Part} an existing {@link Part} in this Diagram that was
* created because its <code>Part.data</code> was the data in the Diagram's {@link Model}.
*/
Diagram.prototype.findPartForData = function(data) {
  if (data === null) return null;
  var part = this._dataPartMap.getValue(data);
  if (part instanceof Part) return part;
  part = this._dataLinkMap.getValue(data);
  if (part instanceof Part) return part;
  return null;
};

Diagram.prototype['findNodeForData'] =
/**
* Look for a {@link Node} or {@link Group}  corresponding to a model's node data object.
* @this {Diagram}
* @param {Object} nodedata
* @return {Node} an existing {@link Node} or {@link Group} in this Diagram that was
* created because its <code>Part.data</code> was the node data in the Diagram's {@link Model};
* this will be null if there is no such part or if it's just a {@link Part} or {@link Link}.
*/
Diagram.prototype.findNodeForData = function(nodedata) {
  if (nodedata === null) return null;
  var node = this._dataPartMap.getValue(nodedata);
  if (node instanceof Node) return node;
  return null;
};

Diagram.prototype['findLinkForData'] =
/**
* Look for a {@link Link} corresponding to a {@link GraphLinksModel}'s link data object.
* @this {Diagram}
* @param {Object} linkdata
* @return {Link} an existing {@link Link} in this Diagram that was
* created because its <code>Part.data</code> was the link data in the Diagram's {@link Model}.
*/
Diagram.prototype.findLinkForData = function(linkdata) {
  if (linkdata === null) return null;
  var link = this._dataLinkMap.getValue(linkdata);
  if (link instanceof Link) return link;
  return null;
};


/**
* Gets or sets the default {@link Node} template used as the archetype
* for node data that is added to the {@link #model}.
* Setting this property just modifies the {@link #nodeTemplateMap}
* by replacing the entry named with the empty string.
* <p>
* The value must not be null.
* The template may be either a {@link Node} or a simple {@link Part},
* but not a {@link Link} or a {@link Group}.
* <p/>
* This Part must not be in the visual tree of any Diagram.
* @name Diagram#nodeTemplate
* @function.
* @return {Part}
*/
/** @type {Part} */
Diagram.prototype.nodeTemplate;
Util.exportProperty(Diagram, 'nodeTemplate', Diagram.prototype.nodeTemplate);
Util.defineProperty(Diagram, {nodeTemplate: 'nodeTemplate'},
  /** @this {Diagram} */
  function() { return this._nodeTemplateMap.getValue(''); },
  /** @this {Diagram} */
  function(val) {
    var old = this._nodeTemplateMap.getValue('');
    if (old !== val) {
      Util.checkClass(val, Part, Diagram, 'nodeTemplate');
      this._nodeTemplateMap.add('', val);
      this.raiseChanged('nodeTemplate', old, val);
      if (!this.undoManager.isUndoingRedoing) this.rebuildParts();
    }
  }
);

/**
* Gets or sets a {@link Map} mapping template names to {@link Part}s.
* These nodes are copied for each node data that is added to the {@link #model}.
* <p/>
* The new value must not be null and must contain {@link Node}s or simple {@link Part}s.
* These Parts must not be in the visual tree of any Diagram.
* Replacing this Map will automatically call {@link #rebuildParts}.
* <p/>
* If you modify this {@link Map}, by replacing a {@link Node} or by adding or
* removing a map entry, you need to explicitly call {@link #rebuildParts} afterwards.
* Any new map values must not be {@link Link}s or {@link Group}s.
* <p/>
* If you want to create {@link Group}s, use {@link #groupTemplateMap} instead.
* @name Diagram#nodeTemplateMap
* @function.
* @return {Map} mapping string to Part.
*/
/** @type {Map} */
Diagram.prototype.nodeTemplateMap;
Util.exportProperty(Diagram, 'nodeTemplateMap', Diagram.prototype.nodeTemplateMap);
Util.defineProperty(Diagram, {nodeTemplateMap: 'nodeTemplateMap'},
  /** @this {Diagram} */
  function() { return this._nodeTemplateMap; },
  /** @this {Diagram} */
  function(val) {
    var old = this._nodeTemplateMap;
    if (old !== val) {
      Util.checkClass(val, Map, Diagram, 'nodeTemplateMap');
      this._nodeTemplateMap = val;
      this.raiseChanged('nodeTemplateMap', old, val);
      if (!this.undoManager.isUndoingRedoing) this.rebuildParts();
    }
  }
);

/**
* Gets or sets the default {@link Group} template used as the archetype
* for group data that is added to the {@link #model}.
* <p/>
* Setting this property just modifies the {@link #groupTemplateMap}
* by replacing the entry named with the empty string.
* The value must not be null and must be a {@link Group}, not a {@link Node} or simple {@link Part}.
* This Part must not be in the visual tree of any Diagram.
* @name Diagram#groupTemplate
* @function.
* @return {Group}
*/
/** @type {Group} */
Diagram.prototype.groupTemplate;
Util.exportProperty(Diagram, 'groupTemplate', Diagram.prototype.groupTemplate);
Util.defineProperty(Diagram, {groupTemplate: 'groupTemplate'},
  /** @this {Diagram} */
  function() { return this._groupTemplateMap.getValue(''); },
  /** @this {Diagram} */
  function(val) {
    var old = this._groupTemplateMap.getValue('');
    if (old !== val) {
      Util.checkClass(val, Group, Diagram, 'groupTemplate');
      this._groupTemplateMap.add('', val);
      this.raiseChanged('groupTemplate', old, val);
      if (!this.undoManager.isUndoingRedoing) this.rebuildParts();
    }
  }
);

/**
* Gets or sets a {@link Map} mapping template names to {@link Group}s.
* These groups are copied for each group data that is added to the {@link #model}.
* <p/>
* The new value must not be null, nor may it contain a {@link Node} or {@link Link} or simple {@link Part}.
* The Links must not be in the visual tree of any Diagram.
* Replacing this Map will automatically call {@link #rebuildParts}.
* <p/>
* If you modify this {@link Map}, by replacing a {@link Group} in it or by adding or
* removing a map entry, you need to explicitly call {@link #rebuildParts} afterwards.
* @name Diagram#groupTemplateMap
* @function.
* @return {Map} mapping string to Group.
*/
/** @type {Map} */
Diagram.prototype.groupTemplateMap;
Util.exportProperty(Diagram, 'groupTemplateMap', Diagram.prototype.groupTemplateMap);
Util.defineProperty(Diagram, {groupTemplateMap: 'groupTemplateMap'},
  /** @this {Diagram} */
  function() { return this._groupTemplateMap; },
  /** @this {Diagram} */
  function(val) {
    var old = this._groupTemplateMap;
    if (old !== val) {
      Util.checkClass(val, Map, Diagram, 'groupTemplateMap');
      this._groupTemplateMap = val;
      this.raiseChanged('groupTemplateMap', old, val);
      if (!this.undoManager.isUndoingRedoing) this.rebuildParts();
    }
  }
);


/**
* Gets or sets the default {@link Link} template used as the archetype
* for link data that is added to the {@link #model}.
* <p/>
* Setting this property just modifies the {@link #linkTemplateMap}
* by replacing the entry named with the empty string.
* The value must not be null and must be a {@link Link}, not a {@link Node} or simple {@link Part}.
* This Link must not be in the visual tree of any Diagram.
* @name Diagram#linkTemplate
* @function.
* @return {Link}
*/
/** @type {Link} */
Diagram.prototype.linkTemplate;
Util.exportProperty(Diagram, 'linkTemplate', Diagram.prototype.linkTemplate);
Util.defineProperty(Diagram, {linkTemplate: 'linkTemplate'},
  /** @this {Diagram} */
  function() { return this._linkTemplateMap.getValue(''); },
  /** @this {Diagram} */
  function(val) {
    var old = this._linkTemplateMap.getValue('');
    if (old !== val) {
      Util.checkClass(val, Link, Diagram, 'linkTemplate');
      this._linkTemplateMap.add('', val);
      this.raiseChanged('linkTemplate', old, val);
      if (!this.undoManager.isUndoingRedoing) this.rebuildParts();
    }
  }
);

/**
* Gets or sets a {@link Map} mapping template names to {@link Link}s.
* These links are copied for each link data that is added to the {@link #model}.
* <p/>
* The new value must not be null and must contain only {@link Link}s, not {@link Node}s or simple {@link Part}s.
* The Links must not be in the visual tree of any Diagram.
* Replacing this Map will automatically call {@link #rebuildParts}.
* <p/>
* If you modify this {@link Map}, by replacing a {@link Link} in it or by adding or
* removing a map entry, you need to explicitly call {@link #rebuildParts} afterwards.
* @name Diagram#linkTemplateMap
* @function.
* @return {Map} mapping string to Link.
*/
/** @type {Map} */
Diagram.prototype.linkTemplateMap;
Util.exportProperty(Diagram, 'linkTemplateMap', Diagram.prototype.linkTemplateMap);
Util.defineProperty(Diagram, {linkTemplateMap: 'linkTemplateMap'},
  /** @this {Diagram} */
  function() { return this._linkTemplateMap; },
  /** @this {Diagram} */
  function(val) {
    var old = this._linkTemplateMap;
    if (old !== val) {
      Util.checkClass(val, Map, Diagram, 'linkTemplateMap');
      this._linkTemplateMap = val;
      this.raiseChanged('linkTemplateMap', old, val);
      if (!this.undoManager.isUndoingRedoing) this.rebuildParts();
    }
  }
);


/**
* Gets or sets whether mouse events initiated within the Diagram will be captured.
* The initial value is true.
* Setting this property does not notify about any changed event.
* @name Diagram#isMouseCaptured
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Diagram.prototype.isMouseCaptured;
Util.exportProperty(Diagram, 'isMouseCaptured', Diagram.prototype.isMouseCaptured);
Util.defineProperty(Diagram, {isMouseCaptured: 'isMouseCaptured'},
  /** @this {Diagram} */
  function() { return this._isMouseCaptured; },
  /** @this {Diagram} */
  function(val) {
    var can = this._canvas;
    if (can === null) return;
    if (val) {
      this.lastInput.bubbles = false;
      can.removeEventListener('mousemove', this.mouseMove, false);
      can.removeEventListener('mousedown', this.mouseDown, false);
      can.removeEventListener('mouseup', this.mouseUp, false);
      can.removeEventListener('mousewheel', this.mouseWheel, false);
      can.removeEventListener('DOMMouseScroll', this.mouseWheel, false);
      can.removeEventListener('mouseout', this.mouseOut, false);

      window.addEventListener('mousemove', this.mouseMove, true);
      window.addEventListener('mousedown', this.mouseDown, true);
      window.addEventListener('mouseup', this.mouseUp, true);
      window.addEventListener('mousewheel', this.mouseWheel, true);
      window.addEventListener('DOMMouseScroll', this.mouseWheel, true);
      window.addEventListener('mouseout', this.mouseOut, true);
      window.addEventListener('selectstart', this.preventDefault, false);

      // can.removeEventListener('touchstart', this.touchStart, false);
      // can.removeEventListener('touchmove', this.touchMove, false);
      // can.removeEventListener('touchend', this.touchEnd, false);
      // window.addEventListener('touchstart', this.touchStart, false);
      // window.addEventListener('touchmove', this.touchMove, false);
      // window.addEventListener('touchend', this.touchEnd, false);
    } else {
      window.removeEventListener('mousemove', this.mouseMove, true);
      window.removeEventListener('mousedown', this.mouseDown, true);
      window.removeEventListener('mouseup', this.mouseUp, true);
      window.removeEventListener('mousewheel', this.mouseWheel, true);
      window.removeEventListener('DOMMouseScroll', this.mouseWheel, true);
      window.removeEventListener('mouseout', this.mouseOut, true);
      window.removeEventListener('selectstart', this.preventDefault, false);

      can.addEventListener('mousemove', this.mouseMove, false);
      can.addEventListener('mousedown', this.mouseDown, false);
      can.addEventListener('mouseup', this.mouseUp, false);
      can.addEventListener('mousewheel', this.mouseWheel, false);
      can.addEventListener('DOMMouseScroll', this.mouseWheel, false);
      can.addEventListener('mouseout', this.mouseOut, false);

      // window.removeEventListener('touchstart', this.touchStart, false);
      // window.removeEventListener('touchmove', this.touchMove, false);
      // window.removeEventListener('touchend', this.touchEnd, false);
      // can.addEventListener('touchstart', this.touchStart, false);
      // can.addEventListener('touchmove', this.touchMove, false);
      // can.addEventListener('touchend', this.touchEnd, false);
    }

    this._isMouseCaptured = val;
  }
);

/**
 * Gets or sets the coordinates of this Diagram in the viewport.
 * Value must be of type {@link Point} in document coordinates.
 * The default is Point(NaN, NaN), but is typically set to a real value when a Diagram is initialized.
 * <p>
 * Scrolling and panning the Diagram modify the Diagram's position.
 * <p>
 * Setting this property does not notify about any changed event.
 * However you can listen with {@link #addDiagramListener} for a {@link DiagramEvent}
 * with the name "ViewportBoundsChanged".
 * The {@link #viewportBounds} x and y values are always the same as the Diagram's position values.
 * @name Diagram#position
 * @function.
 * @return {Point} the document coordinates of the top-left corner of the Diagram.
 */
/** @type {Point} */
Diagram.prototype.position;
Util.exportProperty(Diagram, 'position', Diagram.prototype.position);
Util.defineProperty(Diagram, {position: 'position'},
  /** @this {Diagram} */
  function() { return this._position; },
  /** @this {Diagram} */
  function(val) {
    var old = this._position;
    if (!old.equals(val)) {
      Util.checkClass(val, Point, Diagram, 'position');
      var oldvbounds = this.viewportBounds.copy();
      oldvbounds.x = old.x; // why do this? ???
      oldvbounds.y = old.y;
      // ??? this calls setupPos, but so does onViewportBoundsChanged -> onContentAlignmentChanged below
      this._position = this.onPositionChanged(old, val.copy()).copyFrozen();
      // If its aligning (such as setting scale), onViewportBoundsChanged will get called
      if (!this._isAligning) {
        var newvbounds = this.viewportBounds;
        this.onViewportBoundsChanged(oldvbounds, newvbounds);
      }
    }
  }
);

/**
 * Gets or sets the initial coordinates of this Diagram in the viewport, eventually setting the {@link #position}.
 * This value is relevant on initialization of a {@link #model} or if {@link #delayInitialization} is called.
 * Value must be of type Point in document coordinates.
 * The default is Point(NaN, NaN).
 * <p/>
 * Setting this property does not notify about any changed event.
 * @name Diagram#initialPosition
 * @function.
 * @return {Point}
 * @since 1.1
 */
/** @type {Point} */
Diagram.prototype.initialPosition;
Util.exportProperty(Diagram, 'initialPosition', Diagram.prototype.initialPosition);
Util.defineProperty(Diagram, {initialPosition: 'initialPosition'},
  /** @this {Diagram} */
  function() { return this._initialPosition; },
  /** @this {Diagram} */
  function(val) {
    var old = this._initialPosition;
    if (!old.equals(val)) {
      Util.checkClass(val, Point, Diagram, 'initialPosition');
      this._initialPosition = val.copyFrozen();
    }
  }
);

/**
 * Gets or sets the initial scale of this Diagram in the viewport, eventually setting the {@link #scale}.
 * This value is relevant on initialization of a {@link #model} or if {@link #delayInitialization} is called.
 * The default is NaN.
 * @name Diagram#initialScale
 * @function.
 * @return {number}
 * @since 1.1
 */
/** @type {number} */
Diagram.prototype.initialScale;
Util.exportProperty(Diagram, 'initialScale', Diagram.prototype.initialScale);
Util.defineProperty(Diagram, {initialScale: 'initialScale'},
  /** @this {Diagram} */
  function() { return this._initialScale; },
  /** @this {Diagram} */
  function(val) {
    var old = this._initialScale;
    if (old !== val) {
      Util.checkPrimitive(val, 'number', Diagram, 'initialScale');
      this._initialScale = val;
    }
  }
);

/**
 * Gets or sets a {@link Panel} of type {@link Panel#Grid} acting as the background grid
 * extending across the whole viewport of this diagram.
 * @name Diagram#grid
 * @function.
 * @return {Panel}
 */
/** @type {Panel} */
Diagram.prototype.grid;
Util.exportProperty(Diagram, 'grid', Diagram.prototype.grid);
Util.defineProperty(Diagram, {grid: 'grid'},
  /** @this {Diagram} */
  function() {
    if (this._grid === null) this._setupBackgroundGrid();
    return this._grid;
  },
  /** @this {Diagram} */
  function(val) {
    var old = this._grid;
    if (old !== val) {
      if (old === null) {
        this._setupBackgroundGrid();
        old = this._grid;
      }
      Util.checkClass(val, Panel, Diagram, 'grid');
      if (val.type !== Panel.Grid) Util.throwError('Diagram.grid must be a Panel of type Panel.Grid');
      var oldpart = old.panel;
      if (oldpart !== null) oldpart.remove(old);
      this._grid = val;
      val.name = 'GRID';
      if (oldpart !== null) oldpart.add(val);
      this.invalidateDraw();
      this.raiseChanged('grid', old, val);
    }
  }
);

/**
 * Gets the bounds of the portion of the Diagram in document coordinates that is viewable from its HTML Canvas.
 * Typically when the viewport bounds are smaller than the {@link #documentBounds}, the user can scroll or pan the view.
 * <p>
 * The x and y coordinates are equal to the {@link #position} of the Diagram,
 * and the width and height are equal to the Diagram's canvas width and height,
 * divided by the {@link #scale}.
 * @name Diagram#viewportBounds
 * @function.
 * @return {Rect} the visible area in document coordinates.
 */
/** @type {Rect} */
Diagram.prototype.viewportBounds;
Util.defineReadOnlyProperty(Diagram, {viewportBounds: 'viewportBounds'},
  /** @this {Diagram} */
  function() {
    var can = this._canvas;
    var vb = this._viewportBounds;
    if (can === null) return vb;
    var pos = this._position;
    var sc = this._scale;
    vb._set(pos.x, pos.y, Math.max(can.width, 0) / sc, Math.max(can.height, 0) / sc);
    return vb;
  }
);


/**
 * Gets or sets a fixed bounding rectangle to be returned by {@link #documentBounds}
 * and {@link #computeBounds}.
 * By default this has Double.NaN values, meaning that {@link #computeBounds}
 * will compute the union of all of the parts in the Diagram to determine the {@link #documentBounds}.
 * If all x/y/width/height values are real numbers, this value is used as the {@link #documentBounds}.
 * @name Diagram#fixedBounds
 * @function.
 * @return {Rect}
 */
/** @type {Rect} */
Diagram.prototype.fixedBounds;
Util.exportProperty(Diagram, 'fixedBounds', Diagram.prototype.fixedBounds);
Util.defineProperty(Diagram, {fixedBounds: 'fixedBounds'},
  /** @this {Diagram} */
  function() { return this._fixedBounds; },
  /** @this {Diagram} */
  function(val) {
    var old = this._fixedBounds;
    if (!old.equals(val)) {
      Util.checkClass(val, Rect, Diagram, 'fixedBounds');
      val = val.copyFrozen();
      this._fixedBounds = val;
      this.invalidateDocumentBounds();
      this.raiseChanged('fixedBounds', old, val);
    }
  }
);

/**
 * Gets the bounds of the diagram's contents, in document coordinates.
 * <p>
 * This is normally computed and set by {@link #computeBounds} during Diagram updates
 * that can occur for any number of relevant reasons, such as a {@link Part} changing size.
 * <p>
 * The Diagram's documentBounds can have an unvarying specific value
 * by setting the {@link #fixedBounds} property.
 * <p>
 * If the documentBounds are larger than the {@link #viewportBounds},
 * scrollbars will appear on desktop browsers. You can disable scrolling with the
 * {@link #allowHorizontalScroll} and {@link #allowVerticalScroll} properties, and
 * you can disable scrollbars themselves with the {@link #hasHorizontalScrollbar}
 * and {@link #hasVerticalScrollbar} properties.
 * @name Diagram#documentBounds
 * @function.
 * @return {Rect}
 */
/** @type {Rect} */
Diagram.prototype.documentBounds;
Util.defineReadOnlyProperty(Diagram, {documentBounds: 'documentBounds'},
  /** @this {Diagram} */
  function() {
    return this._documentBounds;
  }
);

/**
* @ignore
*/
Diagram.prototype.setDocumentBounds = function(val) {
  var old = this._documentBounds;
  if (!old.equals(val)) {
    val = val.copyFrozen();
    this._documentBounds = val;
    this._invalidDocBounds = false; // now they're valid

    // ??? is it really proper to invalidate the drawing rects here? It must be done
    //     because some operations (like layouts) both move nodes and change the document bounds
    //     without changing the diagram.position
    //     See also: "// ??? if setDocumentBounds" note
    this._drawingRects = null;

    this.onContentAlignmentChanged();
    this.raiseDiagramEvent('DocumentBoundsChanged', null, old.copy());
    this.invalidateScroll();
  }
};

/**
 * Gets or sets the scale transform of this Diagram.
 * Value must be a positive number.
 * The default value is 1.
 * <p>
 * Scale can automatically be set by the {@link #autoScale} property.
 * There are also {@link #initialScale} and {@link #initialAutoScale} for
 * setting the scale on (re)initialization of a Diagram.
 * <p>
 * Setting this property does not notify about any changed event.
 * However you can listen with {@link #addDiagramListener} for a {@link DiagramEvent}
 * with the name "ViewportBoundsChanged".
 * @name Diagram#scale
 * @function.
 * @return {number}
 */
/** @type {number} */
Diagram.prototype.scale;
Util.exportProperty(Diagram, 'scale', Diagram.prototype.scale);
Util.defineProperty(Diagram, {scale: 'scale'},
  /** @this {Diagram} */
  function() { return this._scale; },
  /** @this {Diagram} */
  function(val) {
    var old = this._scale;
    Util.checkRealNumber(val, Diagram, 'scale');
    if (val < this.minScale) { val = this.minScale; }
    if (val > this.maxScale) { val = this.maxScale; }
    if (old !== val) {
      this._scale = val;
      this.onScaleChanged(old, val);
      this.invalidateDraw();
      this.invalidateScroll();
    }
  }
);

/**
 * Gets or sets the autoScale behavior of the Diagram, controlling whether or not the
 * Diagram's bounds automatically scale to fit the view.
 * The only accepted values are the constant properties of Diagram,
 * {@link Diagram#None}, {@link Diagram#Uniform}, or {@link Diagram#UniformToFill}.
 * Setting this will change the Diagram's {@link Diagram#scale} and {@link Diagram#position}, if appropriate.
 * <p/>
 * The default value is {@link Diagram#None} - the scale and position are not automatically adjusted
 * according to the area covered by the document.
 * When the value is not None, any value for {@link #initialAutoScale} or {@link #initialScale} is ignored.
 * <p>
 * Note that depending on the values of {@link #maxScale} and {@link #minScale}, the actual value for {@link #scale}
 * might be limited.
 * @name Diagram#autoScale
 * @function.
 * @return {EnumValue}
 */
/** @type {EnumValue} */
Diagram.prototype.autoScale;
Util.exportProperty(Diagram, 'autoScale', Diagram.prototype.autoScale);
Util.defineProperty(Diagram, {autoScale: 'autoScale'},
  /** @this {Diagram} */
  function() { return this._autoScale; },
  /** @this {Diagram} */
  function(val) {
    var old = this._autoScale;
    if (old !== val) {
      Util.checkEnumValue(val, Diagram, Diagram, 'autoScale');
      this._autoScale = val;
      this.raiseChanged('autoScale', old, val);
      if (val !== Diagram.None) this.onContentAlignmentChanged(); // don't bother if setting to none
    }
  }
);

/**
 * Gets or sets the initialAutoScale of the Diagram.
 * The only accepted values are listed as constant properties of Diagram,
 * such as {@link Diagram#None}, {@link Diagram#Uniform}, or {@link Diagram#UniformToFill}.
 * Setting this will change the Diagram's {@link Diagram#scale} and {@link Diagram#position}, if appropriate.
 * <p>
 * If you want to always automatically scale the Diagram, use {@link #autoScale} instead.
 * If you want to set the scale to a value on initialization (for instance every time the model is replaced),
 * use {@link #initialScale}.
 * <p>
 * The default value is {@link Diagram#None} -- the scale and position are not automatically adjusted
 * according to the area covered by the document.
 * <p>
 * Note that depending on the values of {@link #maxScale} and {@link #minScale}, the actual value for {@link #scale}
 * might be limited.
 * @name Diagram#initialAutoScale
 * @function.
 * @return {EnumValue}
 */
/** @type {EnumValue} */
Diagram.prototype.initialAutoScale;
Util.exportProperty(Diagram, 'initialAutoScale', Diagram.prototype.initialAutoScale);
Util.defineProperty(Diagram, {initialAutoScale: 'initialAutoScale'},
  /** @this {Diagram} */
  function() { return this._initialAutoScale; },
  /** @this {Diagram} */
  function(val) {
    var old = this._initialAutoScale;
    if (old !== val) {
      Util.checkEnumValue(val, Diagram, Diagram, 'initialAutoScale');
      this._initialAutoScale = val;
      this.raiseChanged('initialAutoScale', old, val);
    }
  }
);

/**
 * Gets or sets the spot in the viewport that should be coincident with the
 * {@link #initialDocumentSpot} of the document when the document is first initialized.
 * The default value is {@link Spot#TopLeft}.
 * If you set this, often you will also want to set {@link #initialDocumentSpot}.
 * @name Diagram#initialViewportSpot
 * @function.
 * @return {Spot}
 */
/** @type {Spot} */
Diagram.prototype.initialViewportSpot;
Util.exportProperty(Diagram, 'initialViewportSpot', Diagram.prototype.initialViewportSpot);
Util.defineProperty(Diagram, {initialViewportSpot: 'initialViewportSpot'},
  /** @this {Diagram} */
  function() { return this._initialViewportSpot; },
  /** @this {Diagram} */
  function(val) {
    var old = this._initialViewportSpot;
    if (old !== val) {
      Util.checkClass(val, Spot, Diagram, 'initialViewportSpot');
      if (!val.isSpot()) Util.throwError('initialViewportSpot must be a real Spot: ' + val);
      this._initialViewportSpot = val;
      this.raiseChanged('initialViewportSpot', old, val);
    }
  }
);

/**
 * Gets or sets the spot in the document's area that should be coincident with the
 * {@link #initialViewportSpot} of the viewport when the document is first initialized.
 * The default value is {@link Spot#TopLeft}.
 * If you set this, often you will also want to set {@link #initialViewportSpot}.
 * @name Diagram#initialDocumentSpot
 * @function.
 * @return {Spot}
 */
/** @type {Spot} */
Diagram.prototype.initialDocumentSpot;
Util.exportProperty(Diagram, 'initialDocumentSpot', Diagram.prototype.initialDocumentSpot);
Util.defineProperty(Diagram, {initialDocumentSpot: 'initialDocumentSpot'},
  /** @this {Diagram} */
  function() { return this._initialDocumentSpot; },
  /** @this {Diagram} */
  function(val) {
    var old = this._initialDocumentSpot;
    if (old !== val) {
      Util.checkClass(val, Spot, Diagram, 'initialDocumentSpot');
      if (!val.isSpot()) Util.throwError('initialViewportSpot must be a real Spot: ' + val);
      this._initialDocumentSpot = val;
      this.raiseChanged('initialDocumentSpot', old, val);
    }
  }
);

/**
 * Gets or sets the smallest value greater than zero that {@link #scale} may take.
 * This property is only used to limit the range of new values of {@link #scale}.
 * <p/>
 * The default value is 0.0001.
 * Values must be larger than zero and not greater than one.
 * @name Diagram#minScale
 * @function.
 * @return {number}
 */
/** @type {number} */
Diagram.prototype.minScale;
Util.exportProperty(Diagram, 'minScale', Diagram.prototype.minScale);
Util.defineProperty(Diagram, {minScale: 'minScale'},
  /** @this {Diagram} */
  function() { return this._minScale; },
  /** @this {Diagram} */
  function(val) {
    Util.checkRealNumber(val, Diagram, 'minScale');
    var old = this._minScale;
    if (old !== val && val > 0) {
      this._minScale = val;
      this.raiseChanged('minScale', old, val);
      if (val > this.scale) this.scale = val;
    } else {
      Util.throwRangeError(val, '> 0', Diagram, 'minScale');
    }
  }
);

/**
 * Gets or sets the largest value that {@link #scale} may take.
 * This property is only used to limit the range of new values of {@link #scale}.
 * <p/>
 * The default value is 100.0.
 * Values must be no less than one.
 * @name Diagram#maxScale
 * @function.
 * @return {number}
 */
/** @type {number} */
Diagram.prototype.maxScale;
Util.exportProperty(Diagram, 'maxScale', Diagram.prototype.maxScale);
Util.defineProperty(Diagram, {maxScale: 'maxScale'},
  /** @this {Diagram} */
  function() { return this._maxScale; },
  /** @this {Diagram} */
  function(val) {
    Util.checkRealNumber(val, Diagram, 'maxScale');
    var old = this._maxScale;
    if (old !== val && val > 0) {
      this._maxScale = val;
      this.raiseChanged('maxScale', old, val);
      if (val < this.scale) this.scale = val;
    } else {
      Util.throwRangeError(val, '> 0', Diagram, 'maxScale');
    }
  }
);



/**
 * Gets or sets the zoom point of this Diagram.
 * This is used by {@link Tool#standardMouseWheel} and scale-setting commands to control where to zoom in or out.
 * <p/>
 * Typical usage is to remember the value of this property and
 * to set this property to some point within the viewport (between zero and the canvas width and height).
 * Then one changes the {@link #scale} somehow, perhaps by executing one of the {@link CommandHandler} commands,
 * or by rotating the mouse wheel, or just by setting the Diagram.scale property.
 * Finally one restores the original value of this property.
 * <p/>
 * The default value is Point(NaN, NaN).
 * Value must be of type {@link Point}, in element coordinates, not in document coordinates.
 * Setting this property does not notify about any changed event.
 * @name Diagram#zoomPoint
 * @function.
 * @return {Point}
 * @since 1.2
 */
/** @type {Point} */
Diagram.prototype.zoomPoint;
Util.exportProperty(Diagram, 'zoomPoint', Diagram.prototype.zoomPoint);
Util.defineProperty(Diagram, {zoomPoint: 'zoomPoint'},
  /** @this {Diagram} */
  function() { return this._zoomPoint; },
  /** @this {Diagram} */
  function(val) {
    var old = this._zoomPoint;
    if (!old.equals(val)) {
      Util.checkClass(val, Point, Diagram, 'zoomPoint');
      val = val.copyFrozen();
      this._zoomPoint = val;
    }
  }
);

/**
* Gets or sets the content alignment {@link Spot} of this Diagram, to be used in determining
* how parts are positioned when the {@link #viewportBounds} width or height is smaller than the {@link #documentBounds}.
* <p>
* For instance a spot of Spot.Center would ensure that the Diagram's
* contents are always centered in the viewport.
* <p>
* If you want the content to be aligned only initially, use {@link #initialContentAlignment} instead.
* <p>
* The default value is {@link Spot#Default}, which causes no automatic scrolling or positioning.
* When the value is not Default, any value for {@link #initialContentAlignment} or {@link #initialPosition} is ignored.
* @name Diagram#contentAlignment
* @function.
* @return {Spot}
*/
/** @type {Spot} */
Diagram.prototype.contentAlignment;
Util.exportProperty(Diagram, 'contentAlignment', Diagram.prototype.contentAlignment);
Util.defineProperty(Diagram, {contentAlignment: 'contentAlignment'},
  /** @this {Diagram} */
  function() { return this._contentAlignment; },
  /** @this {Diagram} */
  function(val) {
    var old = this._contentAlignment;
    if (!old.equals(val)) {
      Util.checkClass(val, Spot, Diagram, 'contentAlignment');
      val = val.copyFrozen();
      this._contentAlignment = val;
      this.raiseChanged('contentAlignment', old, val);
      this.onContentAlignmentChanged();
    }
  }
);

/**
* Gets or sets the initial content alignment {@link Spot} of this Diagram, to be used in determining
* how parts are positioned initially relative to the viewport.
* For instance a spot of Spot.Center would ensure that the Diagram's contents are initially centered in the viewport.
* <p>
* If you want the content to be constantly aligned with a spot, use {@link #contentAlignment} instead.
* <p>
* The default value is {@link Spot#Default}, which causes no automatic scrolling or positioning.
* @name Diagram#initialContentAlignment
* @function.
* @return {Spot}
*/
/** @type {Spot} */
Diagram.prototype.initialContentAlignment;
Util.exportProperty(Diagram, 'initialContentAlignment', Diagram.prototype.initialContentAlignment);
Util.defineProperty(Diagram, {initialContentAlignment: 'initialContentAlignment'},
  /** @this {Diagram} */
  function() { return this._initialContentAlignment; },
  /** @this {Diagram} */
  function(val) {
    var old = this._initialContentAlignment;
    if (!old.equals(val)) {
      Util.checkClass(val, Spot, Diagram, 'initialContentAlignment');
      val = val.copyFrozen();
      this._initialContentAlignment = val;
      this.raiseChanged('initialContentAlignment', old, val);
    }
  }
);

/**
 * Gets or sets the Margin that describes the Diagram's padding,
 * which controls how much extra space there is around the area occupied by the document.
 * This keeps nodes from butting up against the side of the diagram (unless scrolled).
 * <p/>
 * The default value is a margin of 5, all around the edge of the document.
 * @name Diagram#padding
 * @function.
 * @return {Margin|number}
 */
/** @type {Margin} */
Diagram.prototype.padding;
Util.exportProperty(Diagram, 'padding', Diagram.prototype.padding);
Util.defineProperty(Diagram, {padding: 'padding'},
  /** @this {Diagram} */
  function() { return this._padding; },
  /** @this {Diagram} */
  function(val) {
    if (typeof val === 'number') {
      val = new Margin(val);
    } else {
      Util.checkClass(val, Margin, Diagram, 'padding');
    }
    var old = this._padding;
    if (!old.equals(val)) {
      val = val.copyFrozen();
      this._padding = val;
      this.invalidateDocumentBounds();
      this.raiseChanged('padding', old, val);
    }
  }
);

/**
* Returns an iterator of all {@link Node}s and {@link Group}s in the Diagram.
* <p>
* This includes both data-bound and unbound nodes,
* and both top-level nodes and nodes inside {@link Group}s.
* All of the simple {@link Part}s are accessible via the {@link #parts} property.
* <p>
* See also {@link #findTopLevelGroups} and {@link #findTreeRoots}.
* @name Diagram#nodes
* @function.
* @return {Iterator}
*/
/** @type {Iterator} */
Diagram.prototype.nodes;
Util.defineReadOnlyProperty(Diagram, {nodes: 'nodes'},
  /** @this {Diagram} */
  function() { return this._nodes.iterator; }
);

/**
* Returns an iterator of all {@link Link}s in the Diagram.
* <p/>
* This includes both data-bound and unbound links,
* and both top-level links and links inside {@link Group}s.
* @name Diagram#links
* @function.
* @return {Iterator}
*/
/** @type {Iterator} */
Diagram.prototype.links;
Util.defineReadOnlyProperty(Diagram, {links: 'links'},
  /** @this {Diagram} */
  function() { return this._links.iterator; }
);

/**
* Returns an iterator of all {@link Part}s in the Diagram
* that are not {@link Node}s or {@link Link}s or {@link Adornment}s.
* <p/>
* This includes both data-bound and unbound parts,
* and both top-level parts and parts inside {@link Group}s.
* Use the {@link #nodes} or {@link #links} properties for getting the
* collection of all {@link Node}s or {@link Link}s in the diagram.
* @name Diagram#parts
* @function.
* @return {Iterator}
*/
/** @type {Iterator} */
Diagram.prototype.parts;
Util.defineReadOnlyProperty(Diagram, {parts: 'parts'},
  /** @this {Diagram} */
  function() { return this._parts.iterator; }
);

Diagram.prototype['findTopLevelGroups'] =
/**
* Returns an iterator of all {@link Group}s that are at top-level,
* in other words that are not themselves inside other Groups.
* <p/>
* This is useful for when you want to traverse the diagram's graph by recursing into Groups.
* @this {Diagram}
* @return {Iterator}
* @since 1.2
*/
Diagram.prototype.findTopLevelGroups = function() {
  return this._topLevelGroups.iterator;
};

/**
* Gets or sets the {@link Layout} used to position all of the top-level nodes and links in this Diagram.
* By default this property is an instance of a simple {@link Layout}
* that assigns positions to all parts that need it.
* The value cannot be null.
* @name Diagram#layout
* @function.
* @return {Layout}
*/
/** @type {Layout} */
Diagram.prototype.layout;
Util.exportProperty(Diagram, 'layout', Diagram.prototype.layout);
Util.defineProperty(Diagram, {layout: 'layout'},
  /** @this {Diagram} */
  function() { return this._layout; },
  /** @this {Diagram} */
  function(val) {
    var old = this._layout;
    if (old !== val) {
      Util.checkClass(val, Layout, Diagram, 'layout');
      if (old !== null) {
        old.diagram = null;
        old.group = null;
      }
      this._layout = val;
      val.diagram = this;
      val.group = null;
      this._anyLayoutInvalid = true;
      this.raiseChanged('layout', old, val);
      this.requestUpdate();
    }
  }
);

Diagram.prototype['layoutDiagram'] =
/**
* Perform all invalid layouts.
* If the optional argument is true,
* this will perform all of the layouts ({@link Diagram#layout} and all {@link Group#layout}s),
* not just the invalid ones.
* <p/>
* Under normal circumstances you should not need to call this method,
* because layouts will be performed automatically after they become invalid.
* However you may have disabled automatic layouts by setting {@link Layout#isInitial}
* and/or {@link Layout#isOngoing} to false, or by restricting a Part's {@link Part#layoutConditions}.
* If that is the case you might call this method
* (perhaps due to a user command) to perform the layout at a time of your choosing.
* @this {Diagram}
* @param {boolean=} invalidateAll If true, this will explicitly set {@link Layout#isValidLayout} to false on each {@link Layout} in the diagram.
*/
Diagram.prototype.layoutDiagram = function(invalidateAll) {
  this.validateParts();
  if (invalidateAll) this.invalidateAllLayouts(true);
  this.updateAllLayouts(false);  // perform all invalid layouts right now
};

/**
* @ignore
* @this {Diagram}
* @param {boolean} unconditional
*/
Diagram.prototype.invalidateAllLayouts = function(unconditional) {
  var git = this._topLevelGroups.iterator;
  while (git.next()) {
    this.invalidateGroupLayouts(git.value, unconditional);
  }
  if (this.layout !== null) {
    if (unconditional)
      this.layout.isValidLayout = false;
    else
      this.layout.invalidateLayout();
  }
};

/**
* @ignore
* @this {Diagram}
* @param {Group} g
* @param {boolean} unconditional
*/
Diagram.prototype.invalidateGroupLayouts = function(g, unconditional) {
  if (g === null) return;
  var git = g._nestedGroups.iterator;
  while (git.next()) {
    this.invalidateGroupLayouts(git.value, unconditional);
  }
  if (g.layout !== null) {
    if (unconditional)
      g.layout.isValidLayout = false;
    else
      g.layout.invalidateLayout();
  }
};


/**
* @ignore
* Layout all invalid layouts in this Diagram
* @this {Diagram}
* @param {boolean} checkRealtime
*/
Diagram.prototype.updateAllLayouts = function(checkRealtime) {
  var git = this._topLevelGroups.iterator;
  while (git.next()) {
    this.updateGroupLayouts(git.value, checkRealtime);
  }
  var lay = this.layout;
  if (lay !== null && !lay.isValidLayout) {
    if (checkRealtime && !lay.isRealtime) return;
    lay.doLayout(this);
    this.validateParts();
    lay.isValidLayout = true;  // make sure it's now valid
  }
  this._anyLayoutInvalid = false;
};

/**
* @ignore
* @this {Diagram}
* @param {Group} g
* @param {boolean} checkRealtime
*/
Diagram.prototype.updateGroupLayouts = function(g, checkRealtime) {
  if (g === null) return false;
  var git = g._nestedGroups.iterator;
  while (git.next()) {
    this.updateGroupLayouts(git.value, checkRealtime);
  }
  var lay = g.layout;
  if (lay !== null && !lay.isValidLayout) {
    if (checkRealtime && !lay.isRealtime) return;
    g._needsLocation = !g.location.isReal();  // hack for Layout.needsLocation
    lay.doLayout(g);
    g.invalidateLayout(Part.LayoutGroupLayout);  // maybe invalidate the parent Layout
    lay.isValidLayout = true;  // make sure it's now valid
    // now make sure all of G's members have valid size and position
    this.measureArrangeGroup(g);
  }
};


/**
* Gets or sets whether the Diagram tree structure is defined by
* links going from the parent node to their children, or vice-versa.
* By default this property is true: links go from the parent node to the child node.
* @name Diagram#isTreePathToChildren
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Diagram.prototype.isTreePathToChildren;
Util.exportProperty(Diagram, 'isTreePathToChildren', Diagram.prototype.isTreePathToChildren);
Util.defineProperty(Diagram, { isTreePathToChildren: 'isTreePathToChildren' },
  /** @this {Diagram} */
  function() { return this._isTreePathToChildren; },
  /** @this {Diagram} */
  function(val) {
    var old = this._isTreePathToChildren;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Diagram, 'isTreePathToChildren');
      this._isTreePathToChildren = val;
      this.raiseChanged('isTreePathToChildren', old, val);
      // need to update Node.isTreeLeaf on every Node
      if (!this.undoManager.isUndoingRedoing) {
        var nit = this.nodes;
        while (nit.next()) {
          var node = nit.value;
          node.updateTreeLeaf();
        }
      }
    }
  }
);

Diagram.prototype['findTreeRoots'] =
/**
* Returns an iterator of all top-level {@link Node}s that have no tree parents.
* <p/>
* This is useful for when you want to traverse the diagram's graph by starting at the root of each tree,
* assuming that the diagram consists of one tree or a forest of trees.
* @this {Diagram}
* @return {Iterator}
* @since 1.2
*/
Diagram.prototype.findTreeRoots = function() {
  // this could be implemented more efficiently
  var roots = new List(Node);
  var it = this.nodes.iterator;
  while (it.next()) {
    var node = it.value;
    if (node.isTopLevel && node.findTreeParentLink() === null) {
      roots.add(node);
    }
  }
  return roots.iterator;
};

/**
* @ignore
*/
/** @type {boolean} */
Diagram.prototype.isCollapsingExpanding;
Util.exportProperty(Diagram, 'isCollapsingExpanding', Diagram.prototype.isCollapsingExpanding);
Util.defineProperty(Diagram, { isCollapsingExpanding: null},
  /** @this {Diagram} */
  function() { return this._isCollapsingExpanding; },
  /** @this {Diagram} */
  function(val) { this._isCollapsingExpanding = val; }
);


/**
* @ignore
* @this {Diagram}
*/
Diagram.prototype._setupDiagramEvents = function() {
  var handlers = new Map('string', List);
  var names = new Map('string', 'string');
  // store the same List of event handler functions for both the regular name and the downcased name
  // also be able to canonicalize the name by mapping the downcased name to the "normally" case name
  /** @ignore */
  function defineListener(n) {
    var lname = n.toLowerCase();
    var l = new List('function');
    handlers.add(n, l);
    handlers.add(lname, l);
    names.add(n, n);
    names.add(lname, n);
  }
  defineListener('BackgroundSingleClicked');
  defineListener('BackgroundDoubleClicked');
  defineListener('BackgroundContextClicked');
  defineListener('ClipboardChanged');
  defineListener('ClipboardPasted');
  defineListener('DocumentBoundsChanged');
  defineListener('ExternalObjectsDropped');
  defineListener('InitialLayoutCompleted');
  defineListener('LayoutCompleted');
  defineListener('LinkDrawn');
  defineListener('LinkRelinked');
  defineListener('LinkReshaped');
  defineListener('ObjectSingleClicked');
  defineListener('ObjectDoubleClicked');
  defineListener('ObjectContextClicked');
  defineListener('PartCreated');
  //defineListener('PartReshaped');
  defineListener('PartResized');
  defineListener('PartRotated');
  defineListener('SelectionMoved');
  defineListener('SelectionCopied');
  defineListener('SelectionDeleting');
  defineListener('SelectionDeleted');
  defineListener('SelectionGrouped');
  defineListener('SelectionUngrouped');
  defineListener('ChangingSelection');
  defineListener('ChangedSelection');
  defineListener('SubGraphCollapsed');
  defineListener('SubGraphExpanded');
  defineListener('TextEdited');
  defineListener('TreeCollapsed');
  defineListener('TreeExpanded');
  defineListener('ViewportBoundsChanged');
  this._diagramListeners = handlers;
  this._diagramEventNames = names;
};

/**
* @ignore
* @param {string} name
* @return {string}  may return null if the name is unknown.
*/
Diagram.prototype.canonicalizeDiagramEventName = function(name) {
  // avoid converting to lower case unnecessarily
  var canon = this._diagramEventNames.getValue(name);
  if (canon !== null) return canon;
  return this._diagramEventNames.getValue(name.toLowerCase());
};

/**
* @ignore
* This throws an error if the {@link DiagramEvent} name is unknown.
* @param {string} name
* @return {List}  a List of event handler functions.
*/
Diagram.prototype.getDiagramListeners = function(name) {
  var list = this._diagramListeners.getValue(name);
  if (list !== null) return list;
  var lname = name.toLowerCase();
  list = this._diagramListeners.getValue(lname);
  if (list !== null) return list;
  Util.throwError('Unknown DiagramEvent name: ' + name);
  return null;
};

Diagram.prototype['addDiagramListener'] =
/**
* Register an event handler that is called when there is a {@link DiagramEvent} of a given name.
* <p/>
* See the {@link DiagramEvent} documentation for a complete listing of diagram event names and their purposes.
* @this {Diagram}
* @param {string} name the name is normally capitalized, but this method uses case-insensitive comparison.
* @param {function(DiagramEvent)} listener a function that takes a {@link DiagramEvent} as its argument.
*/
Diagram.prototype.addDiagramListener = function(name, listener) {
  Util.checkPrimitive(name, 'string', Diagram, 'addDiagramListener:name');
  Util.checkPrimitive(listener, 'function', Diagram, 'addDiagramListener:listener');
  var list = this.getDiagramListeners(name);
  if (list !== null) list.add(listener);
};

Diagram.prototype['removeDiagramListener'] =
/**
* Unregister a {@link DiagramEvent} handler.
* <p/>
* See the documentation for {@link DiagramEvent} for a complete listing of diagram event names and their purposes.
* @this {Diagram}
* @param {string} name the name is normally capitalized, but this method uses case-insensitive comparison.
* @param {function(DiagramEvent)} listener a function that takes a {@link DiagramEvent} as its argument.
*/
Diagram.prototype.removeDiagramListener = function(name, listener) {
  Util.checkPrimitive(name, 'string', Diagram, 'removeDiagramListener:name');
  Util.checkPrimitive(listener, 'function', Diagram, 'addDiagramListener:listener');
  var list = this.getDiagramListeners(name);
  if (list !== null) list.remove(listener);
};

Diagram.prototype['raiseDiagramEvent'] =
/**
* @ignore
* Notify any {@link DiagramEvent} listeners by calling all event handlers registered by {@link #addDiagramListener}.
* @this {Diagram}
* @param {string} name the name is normally capitalized, but this method uses case-insensitive comparison.
* @param {Object=} obj an optional subject of the event.
* @param {*=} param an optional parameter describing the change to the subject of the event.
* @return {boolean} true if any listener set {@link DiagramEvent#cancel} to true.
*/
Diagram.prototype.raiseDiagramEvent = function(name, obj, param) {
  if (Debug) Util.checkPrimitive(name, 'string', Diagram, 'raiseDiagramEvent:name');
  var list = this.getDiagramListeners(name);
  var e = new DiagramEvent();
  e.diagram = this;
  e.name = this.canonicalizeDiagramEventName(name);  // make sure the name is cased correctly
  if (obj !== undefined/*notpresent*/) e.subject = obj;
  if (param !== undefined/*notpresent*/) e.parameter = param;
  var l = list.length;
  if (l === 1) {
    var func = list.elt(0);
    func(e);
  } else if (l !== 0) {
    var arr = list.toArray();
    for (var i = 0; i < l; i++) {
      var func = arr[i];
      func(e);
    }
  }
  return e.cancel;
};


// AvoidsNodes support

/**
* @ignore
* Called by DraggingTool.
* @param {Rect} region
*/
Diagram.prototype.invalidateAvoidsNodesLinks = function(region) {
  var inView = false;
  if (this.viewportBounds.containsRect(region)) {
    inView = true;
  }
  var it = this.findObjectsIn2(region,
                              function(x) { return x.part; },
                              function(p) { return p instanceof Link; },
                              true,
                              // Extra predicate:
                              function(p) { return p instanceof Link; },
                              inView);
  if (it.count === 0) return;
  it = it.iterator;
  while (it.next()) {
    var l = it.value;
    if (l.routing === Link.AvoidsNodes) l.invalidateRoute();
  }
};

//Diagram.prototype['isUnoccupied'] =
///**
//* @ignore
//* Returns true if there are any nodes within or intersecting the given rectangular region.
//* @param {Rect} r a Rect in document coordinates
//* @param {function(Part):boolean=} skip
//* a predicate that should return true for nodes to be ignored when checking for collisions,
//* usually the node in the document that you are considering moving;
//* may be <c>null</c> to consider all non-temporary nodes
//* @return {boolean}
//*/
////Diagram.prototype.isUnoccupied = function(r, skip) {
//  IEnumerable<Node> found = FindPartsIn<Node>(r, SearchFlags.Nodes, SearchInclusion.Intersects, SearchLayers.Nodes);
//  if (skip !== null)
//    return !found.Where(n => !skip(n)).Any();
//  else
//    return !found.Any();
//};

/**
* @ignore
* Internal, used by Link.addOrthoPoints to get and initialize a PositionArray
* representing the occupied areas of this Diagram.
* @this {Diagram}
* @param {boolean} clearunoccupied
* @param {Link} link
* @param {Node} skip
* @return {PositionArray}
*/
Diagram.prototype.getPositions = function(clearunoccupied, link, skip) {
  if (this._positions === null) {
    this._positions = new PositionArray();
  }
  var subgraph = (link !== null ? link.containingGroup : null);
  if (this._positions.invalid || this._positions.group !== subgraph) {
    //Diagram.Debug("GetPositionsArray " + (this.GetPositionsCount++).ToString() + " " + Diagram.Str(link));
    if (subgraph === null) {
      var docbounds;
      if (this._invalidDocBounds) {
        // ?? This method occurs inside of validation,
        //    and computing the bounds in the middle of validation is a problem
        //    So instead we avoid validating further.
        //    This could be optimized so that addOrthoPoints/getPositions only occurs after all objects are normally validated
        docbounds = this.computeBoundsNoValidate();
      } else {
        docbounds = this.documentBounds.copy();
      }
      docbounds.inflate(100, 100);
      // make sure the array is big enough, and set all cells to MAX
      this._positions.initialize(docbounds);
      var tempRect = Util.tempRect();
      // now for each object that matters, set the corresponding cell to OCCUPIED
      var nit = this.nodes;
      while (nit.next()) {
        var node = nit.value;
        var layer = node.layer;
        if (layer === null || !layer.visible || layer.isTemporary) continue;
        this.getPositions1(node, skip, tempRect);
      }
      Util.freeRect(tempRect);
    } else {
      var sgbounds = subgraph.actualBounds.copy();
      sgbounds.inflate(20, 20);
      this._positions.initialize(sgbounds);
      var tempRect = Util.tempRect();
      var mit = subgraph.memberParts;
      while (mit.next()) {
        var n = mit.value;
        if (n instanceof Node) {
          this.getPositions1(n, skip, tempRect);
        }
      }
      Util.freeRect(tempRect);
    }
    this._positions.group = subgraph;
    this._positions.invalid = false;
  } else if (clearunoccupied) {
    // assume the OCCUPIED cells should be left alone, but clear out
    // any earlier distance calculations
    this._positions.clearAllUnoccupied();
  }
  return this._positions;
};

/**
* @ignore
* @this {Diagram}
* @param {Node} obj
* @param {Node} skip
* @param {Rect} temp
*/
Diagram.prototype.getPositions1 = function(obj, skip, temp) {
  if (obj === skip) return;
  if (obj.canAvoid()) {
    var rect = obj.getAvoidableRectangle(temp);
    var cellx = this._positions.cellWidth;
    var celly = this._positions.cellHeight;
    var endx = rect.x + rect.width;
    var endy = rect.y + rect.height;
    for (var i = rect.x; i < endx; i += cellx) {
      for (var j = rect.y; j < endy; j += celly) {
        this._positions.setOccupied(i, j);
      }
      this._positions.setOccupied(i, endy);
    }
    for (var j = rect.y; j < endy; j += celly) {
      this._positions.setOccupied(endx, j);
    }
    this._positions.setOccupied(endx, endy);
  } else {
    var g = obj;
    if (g instanceof Group) {
      var it = g.memberParts;
      while (it.next()) {
        var o = it.value;
        if (o instanceof Node) this.getPositions1(o, skip, temp);
      }
    }
  }
};

/**
* @ignore
* @this {Diagram}
* @param {Node} node
*/
Diagram.prototype.invalidatePositionArray = function(node) {
  if (this._positions !== null && !this._positions.invalid) {
    if (node === null || node.canAvoid())
      this._positions.invalid = true;
  }
};

// common methods for simulated drag-and-drop
Diagram.prototype['simulatedMouseMove'] =
/**
* @ignore
* @this {Diagram}
* @param {Event} e
* @param {Point} modelpt
* @param {Diagram|undefined} overdiag the diagram attached to the target of the mouse move event, if any.
*/
Diagram.prototype.simulatedMouseMove = function(e, modelpt, overdiag) {
  var draggingTool = this.toolManager.draggingTool;

  if (DraggingTool.source !== null) {

    // Dragging tool is active but we still may
    // wish to return false (go on normally) if the mouse is still in initial diagram
    if (!(overdiag instanceof Diagram)) overdiag = null;
    var cd = DraggingTool.currentDiagram;
    var originDiagram = DraggingTool.source.diagram;

    DraggingTool.currentDiagram = overdiag;
    // If the diagram we're over does not allow drop, then treat it as if it were empty space

    if (overdiag !== cd) {
      if (cd !== null && cd !== originDiagram && cd.toolManager.draggingTool !== null) {
        cd.toolManager.draggingTool.doSimulatedDragLeave();
        return false; // we are back no longer simulating
      }
      if (overdiag !== null && overdiag.toolManager.draggingTool !== null) {
        overdiag.toolManager.draggingTool.doSimulatedDragEnter();
      }
    }

    if (overdiag === null) return false;
    // If it's not null:
    if (!overdiag.allowDrop) return false;
    if (!overdiag.allowInsert) return false;
    // if (!overdiag.allowMove) return false; // ????
    if (overdiag.isReadOnly) return false;


    if (overdiag === originDiagram) return false;

    var target = overdiag.toolManager.draggingTool;
    if (target !== null) {
      var docpos = modelpt;
      if (e !== null) {
        docpos = overdiag._getMouse(e);  // Was Model
      }
      overdiag._lastInput.documentPoint = docpos;
      overdiag._lastInput.down = false;
      overdiag._lastInput.up = false;

      target.doSimulatedDragOver();
    }
    return true;
  }
  return false;
};

Diagram.prototype['simulatedMouseUp'] =
/**
* @ignore
* @this {Diagram}
* @param {Event} e
* @param {Diagram} other
* @param {Point} modelpt
*/
Diagram.prototype.simulatedMouseUp = function(e, other, modelpt, curdiag) {
  var draggingTool = this.toolManager.draggingTool;
  if (DraggingTool.source !== null) {
    if (curdiag === null) curdiag = other;
    var cd = DraggingTool.currentDiagram;
    var originDiagram = DraggingTool.source.diagram;

    if (curdiag !== cd) {
      if (cd !== null && cd !== originDiagram && cd.toolManager.draggingTool !== null) {
        cd.toolManager.draggingTool.doSimulatedDragLeave();
        return false; // back to no longer simulating
      }
      if (curdiag !== null && curdiag.toolManager.draggingTool !== null) {
        curdiag.toolManager.draggingTool.doSimulatedDragEnter();
      }
    }

    DraggingTool.currentDiagram = curdiag;
    if (curdiag === null) {
      DraggingTool.source.doCancel();  //?? generalize dropping onto other Controls
      return true;
    }
    if (curdiag !== this) {
      var docpos = modelpt;
      if (e !== null) {
        docpos = curdiag._getMouse(e);  // Was Model
      }
      curdiag._lastInput.documentPoint = docpos;
      curdiag._lastInput.down = false;
      curdiag._lastInput.up = true;

      var target = curdiag.toolManager.draggingTool;
      if (target !== null) target.doSimulatedDrop();

      var dsource = DraggingTool.source;
      if (dsource !== null) {
        var copying = dsource.mayCopy();
        dsource.transactionResult = (copying ? 'Copy' : 'Move');
        dsource.stopTool();
      }
      return true;
    }
  }
  return false;
};

// Autoscrolling

/**
 * Gets or sets the Margin that describes the Diagram's autoScrollRegion. The default value is a Margin of 16 on all sides.
 * When the mouse drag point is within this region on the left or right sides,
 * the view will automatically scroll horizontally in that direction.  When the point is within
 * the region on the top or bottom, the view will automatically scroll
 * vertically in that direction.  You can specify a distance of zero to disable autoscrolling
 * in a direction; a value of 0,0,0,0 turns off autoscrolling altogether.
 * @name Diagram#autoScrollRegion
 * @function.
 * @return {Margin|number}
 */
/** @type {Margin} */
Diagram.prototype.autoScrollRegion;
Util.exportProperty(Diagram, 'autoScrollRegion', Diagram.prototype.autoScrollRegion);
Util.defineProperty(Diagram, {autoScrollRegion: 'autoScrollRegion'},
  /** @this {Diagram} */
  function() { return this._autoScrollRegion; },
  /** @this {Diagram} */
  function(val) {
    if (typeof val === 'number') {
      val = new Margin(val);
    } else {
      Util.checkClass(val, Margin, Diagram, 'autoScrollRegion');
    }
    var old = this._autoScrollRegion;
    if (!old.equals(val)) {
      val = val.copyFrozen();
      this._autoScrollRegion = val;
      this.invalidateDocumentBounds();
      this.raiseChanged('autoScrollRegion', old, val);
    }
  }
);

/**
* @ignore
* @this {Diagram}
* @param {Point} modelPnt
*/
Diagram.prototype.doAutoScroll = function(modelPnt) {
  this._autoScrollPoint = this.transformDocToView(modelPnt); // was model-to-view
  var newdocpos = this.computeAutoScrollPosition(this._autoScrollPoint);
  if (!newdocpos.equalsAbout(this.position)) {
    this.startAutoScroll();
  } else {
    this.stopAutoScroll();
  }
};

/**
* @ignore
* @this {Diagram}
*/
Diagram.prototype.startAutoScroll = function() {
  if (this._autoScrollTimer !== null) return;
  this._autoScrollTimer = {};
  var interval;
  if (this.currentTool !== this.toolManager.draggingTool) {
    interval = this._autoScrollDelay;
  } else {
    interval = this._autoScrollTime;
  }
  // starts automatically
  this._autoScrollTimer.isEnabled = true;
  var diagram = this;
  var id = setInterval(function() {
    var id2 = id;
    if (diagram._autoScrollTimer !== null && diagram._autoScrollTimer.isEnabled) {
      diagram._autoScrollTimer = null; clearInterval(id2);  // assume timer is now stopped
      var newdocpos = diagram.computeAutoScrollPosition(diagram._autoScrollPoint);
      if (!newdocpos.equalsAbout(diagram.position)) {
        diagram.position = newdocpos;
        // adjust due to new diagram position
        diagram.lastInput.documentPoint = diagram.transformViewToDoc(diagram._autoScrollPoint);
        // need to fake a mouse move to keep dragging while autoscrolling
        diagram.currentTool.doMouseMove();

        diagram._invalidDocBounds = true;
        diagram.setDocumentBounds(diagram.computeBounds());
        diagram._invalidDraw = true;
        diagram.maybeUpdate(); //DoUpdateDiagramBounds //?? synchronous
        diagram.startAutoScroll();
      }
    }
  }, interval);
  this._autoScrollTimer.id = id;
};

/**
* @ignore
* Stop any ongoing auto-scroll action.
* @this {Diagram}
*/
Diagram.prototype.stopAutoScroll = function() {
  if (this._autoScrollTimer === null) return;
  if (this._autoScrollTimer.isEnabled) {
    clearInterval(this._autoScrollTimer.id); // stops
  }
  this._autoScrollTimer = null;
};


/**
* @ignore
* @this {Diagram}
* @param {Point} viewPnt
* @return {Point}
*/
Diagram.prototype.computeAutoScrollPosition = function(viewPnt) {
  var docpos = this.position;
  var margin = this.autoScrollRegion;
  // no autoscroll region? just return current Position
  if (margin.top <= 0 && margin.left <= 0 && margin.right <= 0 && margin.bottom <= 0) return docpos;
  // get the visible part of the panel
  var vp = this.viewportBounds;
  var scale = this.scale;
  var dispRect = Util.tempRectAt(0, 0, vp.width * scale, vp.height * scale);
  // get the current panel position, in element coordinates
  var viewpos = Util.tempPointAt(0, 0);
  // and compute the new position if viewPnt is near any of the four sides, within the margin
  if (viewPnt.x >= dispRect.x && viewPnt.x < dispRect.x + margin.left) {
    var deltaX = Math.max(this.scrollHorizontalLineChange, 1);
    deltaX = deltaX | 0;
    viewpos.x -= deltaX;
    if (viewPnt.x < dispRect.x + margin.left / 2)
      viewpos.x -= deltaX;
    if (viewPnt.x < dispRect.x + margin.left / 4)
      viewpos.x -= 4 * deltaX;
  } else if (viewPnt.x <= dispRect.x + dispRect.width && viewPnt.x > dispRect.x + dispRect.width - margin.right) {
    var deltaX = Math.max(this.scrollHorizontalLineChange, 1);
    deltaX = deltaX | 0;
    viewpos.x += deltaX;
    if (viewPnt.x > dispRect.x + dispRect.width - margin.right / 2)
      viewpos.x += deltaX;
    if (viewPnt.x > dispRect.x + dispRect.width - margin.right / 4)
      viewpos.x += 4 * deltaX;
  }
  if (viewPnt.y >= dispRect.y && viewPnt.y < dispRect.y + margin.top) {
    var deltaY = Math.max(this.scrollVerticalLineChange, 1);
    deltaY = deltaY | 0;
    viewpos.y -= deltaY;
    if (viewPnt.y < dispRect.y + margin.top / 2)
      viewpos.y -= deltaY;
    if (viewPnt.y < dispRect.y + margin.top / 4)
      viewpos.y -= 4 * deltaY;
  } else if (viewPnt.y <= dispRect.y + dispRect.height && viewPnt.y > dispRect.y + dispRect.height - margin.bottom) {
    var deltaY = Math.max(this.scrollVerticalLineChange, 1);
    deltaY = deltaY | 0;
    viewpos.y += deltaY;
    if (viewPnt.y > dispRect.y + dispRect.height - margin.bottom / 2)
      viewpos.y += deltaY;
    if (viewPnt.y > dispRect.y + dispRect.height - margin.bottom / 4)
      viewpos.y += 4 * deltaY;
  }
  // don't bother changing DOCPOS if VIEWPOS hasn't changed
  // Also avoids differences due to round-off errors!
  if (!viewpos.equalsAbout(Geo.Origin)) {
    // but return a Point in model coordinates
    docpos = new Point(docpos.x + viewpos.x / scale, docpos.y + viewpos.y / scale);
  }
  //if (this.Position !== docpos) Diagram.Debug(Diagram.Str(viewPnt) + Diagram.Str(dispRect) + " " +
  //  Diagram.Str(TransformModelToView(this.Position)) + " --> " + Diagram.Str(viewpos) + "  " + Diagram.Str(this.Position) + " --> " + Diagram.Str(docpos));
  Util.freeRect(dispRect);
  Util.freePoint(viewpos);
  return docpos;
};

Diagram.prototype['makeImage'] =
/**
* <p>
* Create an HTMLImageElement that contains a bitmap of the current Diagram.
* This method is just a convenience function that creates an image,
* sets its source to the returned string of {@link #makeImageData},
* and returns a reference to that Image.
* <p>
* By default this method returns a snapshot of the visible diagram, but optional arguments give more options.
* @this {Diagram}
* @param {{ size: Size,
            scale: number,
            maxSize: Size,
            position: Point,
            parts: Iterable,
            padding: (Margin|number),
            showTemporary: boolean,
            showGrid: boolean,

            type: string,
            details: *
          }|Object=} properties a JavaScript object detailing optional arguments for image creation, to be passed to {@link makeImageData}.
* @return {HTMLImageElement}
*/
Diagram.prototype.makeImage = function(properties) {
  var img = document.createElement('img');
  img.src = this.makeImageData(properties);
  if (img instanceof HTMLImageElement) return img;
  else return null;
};

Diagram.prototype['makeImageData'] =
/**
* Create a bitmap of the current Diagram encoded as a base64 string.
* This method uses the toDataURL method of the HTMLCanvasElement to create the data URL.
* Unlike toDataURL, this method will not throw an error if cross-domain images
* were drawn on the canvas, instead it will return a data URL of a bitmap with those images omitted.
* @this {Diagram}
* @param {{ size: Size,
            scale: number,
            maxSize: Size,
            position: Point,
            parts: Iterable,
            padding: (Margin|number),
            showTemporary: boolean,
            showGrid: boolean,

            type: string,
            details: *
          }|Object=} properties a JavaScript object detailing optional arguments for image creation.
* <p>Image creation arguments:
* <ul>
* <li><strong>size:</strong>
* The size of the created image, as a {@link Size}.
* If no scale or position is specified then the diagram will be scaled to fit the given size.
* <li><strong>scale:</strong>
* The scale of the diagram. If scale is specified and size is not, the resulting image will be sized to uniformly fit the space needed for the given scale.
* Can be constrained by the <strong>maxSize</strong> property.
* <li><strong>maxSize:</strong>
* The maximum size of the created image, as a {@link Size}. The default value is (2000, 2000).
* This is typically used when <strong>scale</strong> is specified.
* <li><strong>position:</strong>
* The position of the diagram, as a {@link Point}.
* By default this is the position of {@link Diagram#documentBounds} with the {@link Diagram#padding} removed.
* If a specific parts collection is used, by default this is the top-left diagram position of their collective bounds.
* <li><strong>parts:</strong>
* An iterator of GraphObjects, typically Parts, such as one from {@link Diagram#selection} or {@link Layer#parts}.
* If GraphObjects are specified their containing Part will be drawn.
* <li><strong>padding:</strong>
* A {@link Margin} (or number) to pad the image with. The default value is zero padding.
* <li><strong>background:</strong>
* A valid CSS color to replace the default (transparent) canvas background. Any padding area is also colored.
* <li><strong>showTemporary:</strong>
* A boolean value, defaulting to false,
* that determines whether or not temporary objects such as adornments are included in the image.
* <li><strong>showGrid:</strong>
* A boolean value, defaulting to the value of <strong>showTemporary</strong>,
* that determines whether or not the Grid Layer (containing {@Link Diagram#grid}) is included in the image regardless of the value of <strong>showTemporary</strong>.
* This is useful if you want to include the grid but not adornments, or vice versa.
* </ul>
* <p>Image type arguments:
* <ul>
* <li><strong>type:</strong>
* The optional MIME type of the image. Valid values are typically "image/png" and "image/jpeg".
* Some browsers allow "image/webp". The default value is "image/png", and unrecognized values will defer to the default.
* <li><strong>details:</strong>
* The optional details to pass to the HTMLCanvasElement's toDataURL function.
* If the type is "image/jpeg" then this can be a number from 0 to 1, inclusive, describing the desired jpeg quality.
* </ul>
* @return {string} A base64-encoded string describing the image.
*/
Diagram.prototype.makeImageData = function(properties) {
  this.maybeUpdate();
  var can = this._canvas;
  if (can === null) return '';
  if (properties === undefined) properties = {};
  if (typeof properties !== 'object') Util.throwError('properties argument must be an Object.');
  var defaultMaxSize = false;

  var size = properties['size'] || null;
  var scale = properties['scale'] || null;
  var maxSize = properties['maxSize'] || new Size(2000, 2000);
  if (properties['maxSize'] === undefined) defaultMaxSize = true;
  var position = properties['position'] || null;
  var parts = properties['parts'] || null;
  var padding = properties['padding'] || 1;
  var background = properties['background'] || null;
  var omitTemporary = properties['omitTemporary'];
  if (omitTemporary === undefined) omitTemporary = true;

  var showTemporary = properties['showTemporary'];
  // If showTemporary is not defined it defaults to omitTemporary, which is typically false
  if (showTemporary === undefined) showTemporary = !omitTemporary;
  var showGrid = properties['showGrid'];
  if (showGrid === undefined) showGrid = showTemporary;

  if (size !== null && isNaN(size.width) && isNaN(size.height)) size = null;
  if (padding && typeof padding === 'number') padding = new Margin(padding);
  if (!padding) padding = new Margin(0);
  padding.left = Math.max(padding.left, 0);
  padding.right = Math.max(padding.right, 0);
  padding.top = Math.max(padding.top, 0);
  padding.bottom = Math.max(padding.bottom, 0);

  this._drawTainted = false;
  this.clearContextCache();
  var canvas = document.createElement('canvas');
  var ctx = canvas.getContext('2d');
  if (!(size || scale || parts || position)) {
    canvas.width = this._canvas.width + Math.ceil(padding.left + padding.right);
    canvas.height = this._canvas.height + Math.ceil(padding.top + padding.bottom);
    this.drawForeign(ctx, padding, new Size(canvas.width, canvas.height), this._scale, this._position, parts, background, showTemporary, showGrid);
    this._drawTainted = true;
    return canvas.toDataURL(properties['type'], properties['details']);
  }

  var width, height;
  var pos = new Point(0, 0);

  var db = this.documentBounds.copy();
  db.subtractMargin(this.padding);

  // replace position if given by options, which also replaces scale if scale is not given
  if (position !== null && position.isReal()) {
    pos = position;
    if (!scale) scale = 1;
  } else {
    pos.x = db.x;
    pos.y = db.y;
  }

  db.width -= pos.x;
  db.height -= pos.y;
  if (parts) {
    var b;
    var first = true;
    parts = parts.iterator;
    parts.reset();
    while (parts.next()) {
      var part = parts.value;
      if (!(part instanceof Part)) continue;
      var layer = part.layer;
      if (layer && !layer.visible) continue;
      if (layer && layer.isTemporary) continue;
      if (!part.isVisible()) continue;
      var ab = part.actualBounds;
      if (!ab.isReal()) continue;
      if (first) {
        first = false;
        b = ab.copy();
      } else {
        b.unionRect(ab);
      }
    }
    // if no elements make an empty rect
    if (first) {
      b = new Rect(0, 0, 0, 0);
    }
    // replace document bounds with the smaller bounds from parts list
    db.width = b.width;
    db.height = b.height;
    pos.x = b.x;
    pos.y = b.y;
  }

  var pw = 0, ph = 0;
  if (padding) {
    pw = (padding.left + padding.right);
    ph = (padding.top + padding.bottom);
  }

  var sw = 0, sh = 0;
  if (size) {
    sw = size.width;
    sh = size.height;
    if (isFinite(sw)) sw = Math.max(0, sw - pw);
    if (isFinite(sh)) sh = Math.max(0, sh - ph);
  }

  if (size && scale) {
    // size and scale
    if (size.isReal()) {
      width = sw;
      height = sh;
    } else if (isNaN(sh)) {
      width = sw;
      height = db.height * scale;
    } else {
      width = db.width * scale;
      height = sh;
    }
  } else if (size) {
    // size and no scale = auto scale
    if (size.isReal()) {
      scale = Math.min(sw / db.width, sh / db.height);
      width = sw;
      height = sh;
    } else if (isNaN(sh)) {
      scale = (sw / db.width);
      width = sw;
      height = db.height * scale;
    } else {
      scale = (sh / db.height);
      width = db.width * scale;
      height = sh;
    }
  } else if (scale) {
    // no size, only scale
    width = db.width * scale;
    height = db.height * scale;
  } else {
    scale = 1;
    width = db.width;
    height = db.height;
  }

  if (padding) {
    width += pw;
    height += ph;
  } else {
    padding = new Margin(0);
  }

  if (maxSize) {
    var mw = maxSize.width;
    var mh = maxSize.height;
    if (defaultMaxSize && !Util.warnedAboutMakeImageSize) {
      if ((width > mw) || (height > mh)) {
        Debug.trace('Diagram.makeImage(data): Diagram width or height is larger than the default max size. (' +
           width + 'x' + height + ' vs 2000x2000) Consider increasing the max size.')
        Util.warnedAboutMakeImageSize = true;
      }
    }
    if (isNaN(mw)) mw = 2000;
    if (isNaN(mh)) mh = 2000;

    if (isFinite(mw)) width = Math.min(width, mw);
    if (isFinite(mh)) height = Math.min(height, mh);
  }

  canvas.width = Math.ceil(width);
  canvas.height = Math.ceil(height);
  this.drawForeign(ctx, padding, new Size(Math.ceil(width), Math.ceil(height)), scale, pos, parts, background, showTemporary, showGrid);
  this._drawTainted = true;
  return canvas.toDataURL(properties['type'], properties['details']);
};


Diagram['inherit'] =
/**
* This static function declares that a class (constructor function) derives from another class --
* <b><i>but please note that most classes do not support inheritance</i></b>.
* <p/>
* Because you must not modify the prototypes for the <b>GoJS</b> classes,
* in order to override methods you need to define a new class that inherits from a predefined class.
* You can then modify the prototype of your derived class.
* <p/>
* Typical usage is:
* <pre>
*  function BaseClass() {
*    this._total = 0;
*  }
*
*  BaseClass.prototype.increment = function(x) {
*    this._total += x;
*  }
*
*  function DerivedClass() {
*    this._anotherProperty = "";
*  }
*  go.Diagram.inherit(DerivedClass, BaseClass);
*
*  DerivedClass.prototype.someMethod = ...;
* </pre>
* <p/>
* <b><i>Note that most classes do not support inheritance.</i></b>
* Currently you can only inherit from {@link Layout}, {@link Tool}, and {@link CommandHandler} or their subclasses.
* When you override a method, you must strongly consider calling the base method.
* <p/>
* The call to <code>Diagram.inherit</code> should be made after defining the subclass constructor function
* and before defining any new methods or overriding any base class methods.
* <p/>
* The need for subclassing is greatly diminished by the presence of a number of properties that have functional values.
* Setting such a property to a function will cause that function to be called as if it were
* an override of a virtual method or an event handler for that particular object.
* Example properties include: {@link GraphObject#click}, {@link GraphObject#mouseEnter}, {@link Part#layerChanged},
* {@link Node#treeExpandedChanged}, {@link LinkingBaseTool#linkValidation}, {@link CommandHandler#memberValidation},
* {@link TextEditingTool#textValidation}.
* @this {Diagram}
* @param {Function} derivedclass
* @param {Function} baseclass
*/
Diagram.inherit = function(derivedclass, baseclass) {
  Util.checkPrimitive(derivedclass, 'function', Diagram, 'inherit');
  Util.checkPrimitive(baseclass, 'function', Diagram, 'inherit');
  Util.inherit(derivedclass, baseclass);
};


/**
 * @constructor
 * @param {HTMLDivElement|string} div A reference to a div or its ID as a string.
 * @extends Diagram
 * @this {Palette}
 * @class
 * Palette extends the Diagram class to allow objects to be dragged and placed onto other Diagrams.
 * Its {@link Diagram#layout} is a {@link GridLayout}.
 * The Palette is {@link Diagram#isReadOnly} but to support drag-and-drop its {@link Diagram#allowDragOut} is true.
 */
function Palette(div) {
  if (arguments.length > 1) {
    Util.throwError('Palette constructor can only take one optional argument, the DIV HTML element or its id.');
  }
  Diagram.call(this, div);

  this.allowDragOut = true;
  this.allowMove = false;
  this.isReadOnly = true;
  this.contentAlignment = Spot.TopCenter;

  this.layout = new GridLayout();
}

Util.publish('Palette', Palette);

Util.inherit(Palette, Diagram);

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
Overview
*/

/**
 * @constructor
 * @param {Element|string} div A reference to a div or its ID as a string.
 * @extends Diagram
 * @this {Overview}
 * @class
 * An Overview is a {@link Diagram} that displays all of a different diagram,
 * with a rectangular box showing the viewport displayed by that other diagram.
 * <p/>
 * All you need to do is set {@link Overview#observed}.
 * For example:
 * <p/>
 * <pre>
 *   var myDiagram = new go.Diagram("myDiagramDIV");
 *   . . . other initialization . . .
 *
 *   // create and initialize the Overview:
 *   new go.Overview("myOverviewDIV").observed = myDiagram;
 * </pre>
 * <p/>
 * The Overview draws what the observed Diagram is displaying,
 * so setting or modifying any diagram templates or template Maps has no effect.
 * <p/>
 * For more discussion, see <a href="../../intro/overview.html">Overview</a>.
 */
function Overview(div) {
  if (arguments.length > 1) {
    Util.throwError('Overview constructor can only take one optional argument, the DIV HTML element or its id.');
  }
  Diagram.call(this, div);

  this._isAligning = true;
  /** @type {Diagram} */
  this._observed = null;

  /** @type {boolean} */
  this._drawsTemporaryLayers = true;

  var box = new Part();
  var s = new Shape();
  s.stroke = 'magenta';
  s.strokeWidth = 2;
  s.fill = null;
  s.name = 'BOXSHAPE';
  box.selectionObjectName = 'BOXSHAPE';
  box.locationObjectName = 'BOXSHAPE';
  box.add(s);
  /** @type {Part} */
  this._box = box;
  /** @type {Element} */
  this._tempCanvas = document.createElement('canvas');
  this._tempCtx = this._tempCanvas.getContext('2d');

  var tool = new MoveBoxTool();
  tool.setDiagram(this);
  this.toolManager.mouseDownTools.insertAt(0, tool);

  var that = this;
  /**
  * @ignore
  * @this {Overview}
  * @param {DiagramEvent} e
  */
  this.observedPanel_ViewportBoundsChanged = function(e) {
    that.updateBox();
  };

  /**
  * @ignore
  * @param {DiagramEvent} e
  */
  this.observedPanel_DocumentBoundsChanged = function(e) {
    var observed = that._observed;
    if (observed === null) return;
    that.invalidateDocumentBounds();
    that.invalidateDraw();
  };

  this.isReadOnly = true;
  this.allowSelect = false;
  this.autoScale = Diagram.Uniform;
  this.toolManager.mouseWheelBehavior = ToolManager.WheelZoom;
  this._isAligning = false;
}

Util.publish('Overview', Overview);

Util.inherit(Overview, Diagram);

/**
* @ignore
* Uses draw2 instead of draw
* @this {Overview}
*/
Overview.prototype.requestCachedUpdate = function() {
  if (this._isAligning || this._isUpdating) return;
  if (this._updateQueued === false) {
    this._updateQueued = true;
    var dia = this;
    requestAnimationFrame(
      function() {
        // Are we still queued?
        if (!dia._updateQueued) { return; } // no need!
        dia.update2();
      });
  }
};

/**
* @ignore
* Ensure that all GraphObjects are arranged, update the document bounds and the scrollbars,
* and draw all objects in the viewport.
* <p/>
* <strong>Caution:</strong> this method can be very expensive in time and space.
* Avoid calling this method except in infrequent circumstances where redrawing immediately is necessary.
* Under most circumstances you should allow the transaction to perform its normal updating process.
* Calling {@link #requestUpdate} is the usually the right thing to do.
* @this {Overview}
*/
Overview.prototype.update2 = function() {
  if (this._isUpdating) return;
  this._updateQueued = false;
  if (this._div === null) return;
  this._isUpdating = true;

  this.validateParts();

  // make sure documentBounds are sane
  // Note that we do not compute the bounds constantly because we only want them to update on a transaction end
  if (!this.documentBounds.isReal()) this.setDocumentBounds(this.computeBounds());

  this.draw2();
  this._isUpdating = false;
};

/**
* @ignore
* Draw a scaled version of the observed diagram
* @this {Overview}
*/
Overview.prototype.draw = function() {
  if (this._div === null) { Util.throwError('No div specified'); }
  if (this._canvas === null) { Util.throwError('No canvas specified'); }
  if (!this._invalidDraw) return;
  var observed = this._observed;
  if (observed === null) return;

  var grid = observed.grid;
  if (grid && grid.visible &&
    isNaN(grid.width) || isNaN(grid.height)) {
    observed._updateBackgroundGrid();
  }

  var can = this._canvas;
  var ctx = this._ctx;
  var tempcan = this._tempCanvas;
  var tempctx = this._tempCtx;
  // ?? ideally we set this much more rarely and clear the tempcan a different way:
  tempcan.width = can.width;
  tempcan.height = can.height;

  // ?? cached font needs to be reset in case model or something changes. Might be a more efficient place to put this
  ctx.__cachedFont = '';

  // clear canvas
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  // Will always clear the right space
  ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);

  var t = this._transform;
  t.reset();
  if (this._scale !== 1) { t.scale(this.scale); }
  if (this.position.x !== 0 || this.position.y !== 0) {
    t.translate(-this._position.x, -this._position.y);
  }
  ctx.setTransform(t.m11, t.m12, t.m21, t.m22, t.dx, t.dy);

  var showTemporary = this._drawsTemporaryLayers;
  var vb = this.viewportBounds;
  var l = observed._layers.length;
  for (var i = 0; i < l; i++) {
    observed._layers._arr[i].drawAllowed(ctx, vb, this, showTemporary);
  }

  // Once the observed is finished, draw it to the temp canvas:
  tempctx.drawImage(can, 0, 0);
  if (Debug && Debug.boundsInfoEnabled) {
    tempctx.fillStyle = 'red';
    tempctx.fillRect(0, tempcan.height / 2, tempcan.width, 4);
  }


  var ll = this._layers.length;
  for (var i = 0; i < ll; i++) {
    this._layers._arr[i].draw(ctx, this);
  }

  if (Debug && (Debug.drawLocationsEnabled || Debug.boundsInfoEnabled)) {
    Debug.drawBoundsInfoLocations(ctx, this, t);
  }

  // validate
  this._invalidViewportObjects = false;
  this._invalidDraw = false;
};

/**
* @ignore
* Draw a scaled version of the observed diagram
* @this {Overview}
*/
Overview.prototype.draw2 = function() {
  if (this._div === null) { Util.throwError('No div specified'); }
  if (this._canvas === null) { Util.throwError('No canvas specified'); }
  if (!this._invalidDraw) return;
  var observed = this._observed;
  if (observed === null) return;

  var can = this._canvas;
  var ctx = this._ctx;
  var tempcan = this._tempCanvas;
  var tempctx = this._tempCtx;

  // clear canvas
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  // Will always clear the right space
  ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);

  // Recall the scene from the temp canvas instead of iterating through all observed objects
  ctx.drawImage(tempcan, 0, 0);

  var t = this._transform;
  t.reset();
  if (this._scale !== 1) { t.scale(this.scale); }
  if (this.position.x !== 0 || this.position.y !== 0) {
    t.translate(-this._position.x, -this._position.y);
  }
  ctx.setTransform(t.m11, t.m12, t.m21, t.m22, t.dx, t.dy);

  var ll = this._layers.length;
  for (var i = 0; i < ll; i++) {
    this._layers._arr[i].draw(ctx, this);
  }

  // validate
  this._invalidViewportObjects = false;
  this._invalidDraw = false;
};


/**
* Gets or sets the {@link Diagram} for which this Overview is
* displaying a model and showing its viewport into that model.
* <p/>
* The value must be null or another Diagram, but may not be an Overview.
* @name Overview#observed
* @function.
* @return {Diagram}
*/
/** @type {Diagram} */
Overview.prototype.observed;
Util.exportProperty(Overview, 'observed', Overview.prototype.observed);
Util.defineProperty(Overview, { observed: 'observed' },
  /** @this {Overview} */
  function() { return this._observed; },
  /** @this {Overview} */
  function(val) {
    var old = this._observed;
    if (val !== null) Util.checkClass(val, Diagram, Overview, 'observed');
    if (old !== val && !(val instanceof Overview)) {
      this.unbindFromDiagram(old);
      this._observed = val;
      this.bindToDiagram(val);
      this.invalidateDocumentBounds();
      this.raiseChanged('observed', old, val);
    }
  }
);

/**
* Gets or sets the rectangular {@link Part} that represents the
* viewport of the {@link #observed} {@link Diagram}.
* By default the part contains only a magenta {@link Shape}.
* @name Overview#box
* @function.
* @return {Part}
*/
/** @type {Part} */
Overview.prototype.box;
Util.exportProperty(Overview, 'box', Overview.prototype.box);
Util.defineProperty(Overview, {box: 'box'},
  /** @this {Overview} */
  function() { return this._box; },
  /** @this {Overview} */
  function(val) {
    var old = this._box;
    if (old !== val) {
      this._box = val;
      this.raiseChanged('box', old, val);
    }
  }
);

/**
* Gets or sets whether this overview draws the temporary layers of the observed Diagram.
* @name Overview#drawsTemporaryLayers
* @function.
* @return {boolean}
* @since 1.2
*/
/** @type {boolean} */
Overview.prototype.drawsTemporaryLayers;
Util.exportProperty(Overview, 'drawsTemporaryLayers', Overview.prototype.drawsTemporaryLayers);
Util.defineProperty(Overview, {drawsTemporaryLayers: 'drawsTemporaryLayers'},
  /** @this {Overview} */
  function() { return this._drawsTemporaryLayers; },
  /** @this {Overview} */
  function(val) {
    var old = this._drawsTemporaryLayers;
    if (old !== val) {
      this._drawsTemporaryLayers = val;
      this.redraw();
    }
  }
);

/**
* @ignore
* @this {Overview}
* @param {Diagram} diagram
*/
Overview.prototype.bindToDiagram = function(diagram) {
  if (diagram === null) return;
  diagram.addDiagramListener('ViewportBoundsChanged', this.observedPanel_ViewportBoundsChanged);
  diagram.addDiagramListener('DocumentBoundsChanged', this.observedPanel_DocumentBoundsChanged);
  diagram._overviews.add(this);
  this.add(this.box);
  this.updateBox();
};

/**
* @ignore
* @this {Overview}
* @param {Diagram} diagram
*/
Overview.prototype.unbindFromDiagram = function(diagram) {
  if (diagram === null) return;
  this.remove(this.box);
  diagram.removeDiagramListener('ViewportBoundsChanged', this.observedPanel_ViewportBoundsChanged);
  diagram.removeDiagramListener('DocumentBoundsChanged', this.observedPanel_DocumentBoundsChanged);
  diagram._overviews.remove(this);
};

/**
* @ignore
* @this {Overview}
*/
Overview.prototype.updateBox = function() {
  var box = this.box;
  if (box === null) return;
  var observed = this._observed;
  if (observed === null) return;
  this._invalidDraw = true;
  var viewportbounds = observed.viewportBounds;
  var selObj = box.selectionObject;
  var dessz = Util.tempSize();
  dessz._set(viewportbounds.width, viewportbounds.height);
  selObj.desiredSize = dessz;
  Util.freeSize(dessz);
  var sw = 2 / this.scale;
  if (selObj instanceof Shape) selObj.strokeWidth = sw;
  box.location = new Point(viewportbounds.x - sw / 2, viewportbounds.y - sw / 2);
};

/**
* @ignore
* @this {Overview}
*/
Overview.prototype.computeBounds = function() {
  var observed = this._observed;
  if (observed === null) return Geo.ZeroRect;
  return observed.documentBounds;
};

/**
* @ignore
* This method is called when the {@link #position} or {@link #scale} change.
* @this {Diagram}
* @param {Rect} oldvbounds a Rect in document coordinates.
* @param {Rect} newvbounds a Rect in document coordinates.
* The X or Y may have changed because of a change to {@link #position}.
* The Width or Height may have changed either because this Diagram has changed size
* or because the {@link #scale} has changed value.
*/
Overview.prototype.onViewportBoundsChanged = function(oldvbounds, newvbounds) {
  if (this._isAligning) return;
  this.invalidateViewportObjects();
  this.invalidateDraw();
  this.invalidateScroll();
  this.invalidateDocumentBounds();
  this.updateBox();
  this.raiseDiagramEvent('ViewportBoundsChanged', oldvbounds);
};

// support for clicking or dragging to move the Box
/**
 * @ignore
 * @constructor
 * @extends Tool
 * @category Tool
 * @class
 */
function MoveBoxTool() {
  Tool.call(this);
  this.name = 'MoveBox';
}

Util.inherit(MoveBoxTool, Tool);

/**
* @ignore
* @this {MoveBoxTool}
*/
MoveBoxTool.prototype.doStart = function() {
  this.diagram.isMouseCaptured = true;
  this.isActive = true;
};

/**
* @ignore
* @this {MoveBoxTool}
*/
MoveBoxTool.prototype.doMouseMove = function() {
  if (!this.isActive) return;
  var overview = this.diagram;
  if (overview === null || overview._observed === null) return;
  var ob = overview._observed;
  var viewport = ob.viewportBounds;
  var pt = overview.lastInput.documentPoint;
  ob.position = new Point(pt.x - viewport.width / 2, pt.y - viewport.height / 2);
  overview.requestUpdate();
};

/**
* @ignore
* @this {MoveBoxTool}
*/
MoveBoxTool.prototype.doMouseUp = function() {
  if (this.isActive) {
    this.doMouseMove();
  }
  this.stopTool();
};

/**
* @ignore
* @this {MoveBoxTool}
*/
MoveBoxTool.prototype.doStop = function() {
  this.isActive = false;
  var diagram = this.diagram;
  diagram.isMouseCaptured = false;
  diagram.updateBox();
};

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
Brush
*/


/**
* Construct a Brush class that holds the given color information.
* @constructor
* @param {EnumValue|string=} type Optional,
* one of the values {@link Brush#Solid}, {@link Brush#Linear}, {@link Brush#Radial},
* {@link Brush#Pattern}, or a well-formed CSS string describing a solid color brush. No parameter
* defaults to a Brush.Solid with a color description of 'black'.
* @category Geometry
* @class
* A Brush holds color information and describes how to draw the inside
* of a {@link Shape} or the stroke of a shape or a {@link TextBlock} or the
* background of any {@link GraphObject}.
* <p/>
* A Brush must not be modified once it has been assigned to a {@link GraphObject},
* such as the {@link Shape#fill} or {@link TextBlock#stroke}
* or {@link GraphObject#background}.
* However, a Brush may be shared by multiple GraphObjects.
*/
function Brush(type) {
  if (arguments.length > 1) {
    Util.throwError('Brush constructor can take at most one optional argument, the Brush type.');
  }
  Util.uniqueHash(this);
  /** @type {boolean} */
  this._isFrozen = false;
  if (type === undefined/*notpresent*/) {
    /** @type {EnumValue} */
    this._type = Brush.Solid;
    /** @type {string} */
    this._color = 'black';
  } else if (typeof type === 'string') {
    this._type = Brush.Solid;
    this._color = type;
  } else {
    if (Debug) Util.checkEnumValue(type, Brush, Brush, 'constructor:type');
    this._type = type;
    this._color = 'black';
  }

  var t = this._type;
  if (t === Brush.Linear) {
    /** @type {Spot} */
    this._start = Spot.TopCenter;
    /** @type {Spot} */
    this._end = Spot.BottomCenter;
  } else if (t === Brush.Radial) {
    this._start = Spot.Center;
    this._end = Spot.Center;
  } else {
    this._start = Spot.None;
    this._end = Spot.None;
  }

  /** @type {number} */
  this._startRadius = 0;
  /** @type {number} */
  this._endRadius = NaN;

  /** @type {Map} */
  this._colorStops = null;

  /** @type {HTMLCanvasElement|HTMLImageElement} */
  this._pattern = null;

  // private only caching of the brush
  // The first time a Brush is drawn it is constructed on the canvas
  // Gets set in GraphObject.setBrush and cleared whenever a Brush property is changed
  this._constructed = null;
  this._constructedWidth = null;
  this._constructedHeight = null;
}

Util.publish('Brush', Brush);

/**
* For simple, solid color brushes, used as the value for {@link Brush#type}.
* @name Brush#Solid
* @constant
* @static
* @return {EnumValue}
*/
Brush['Solid'] = Brush.Solid = Util.defineEnumValue(Brush, 'Solid', 0);

/**
* For linear gradient brushes, used as the value for {@link Brush#type}.
* @name Brush#Linear
* @constant
* @static
* @return {EnumValue}
*/
Brush['Linear'] = Brush.Linear = Util.defineEnumValue(Brush, 'Linear', 1);

/**
* For radial gradient brushes, used as the value for {@link Brush#type}.
* @name Brush#Radial
* @constant
* @static
* @return {EnumValue}
*/
Brush['Radial'] = Brush.Radial = Util.defineEnumValue(Brush, 'Radial', 2);

/**
* For pattern brushes, used as the value for {@link Brush#type}.
* @name Brush#Pattern
* @constant
* @static
* @return {EnumValue}
*/
Brush['Pattern'] = Brush.Pattern = Util.defineEnumValue(Brush, 'Pattern', 2);


/**
* Create a copy of this Brush, with the same values.
* @expose
* @this {Brush}
* @return {Brush}
*/
Brush.prototype.copy = function() {
  var copy = new Brush();
  copy._type = this._type;
  copy._color = this._color;
  copy._start = this._start;
  copy._end = this._end;
  copy._startRadius = this._startRadius;
  copy._endRadius = this._endRadius;
  if (this._colorStops !== null) {
    copy._colorStops = this._colorStops.copy();
  }
  copy._pattern = this._pattern;
  // _constructed* are private cached properties
  return copy;
};

/**
* @ignore
* Make this object 'constant' and 'frozen'.
* Future attempts to change its state may result in an exception.
* This constant object may be shared freely.
* @this {Brush}
* @return {Brush}
*/
Brush.prototype.constant = function() {
  this.freeze();
  Object.freeze(this);
  return this;
};

/**
* @ignore
* Make this object 'frozen' or immutable.
* Future attempts to change its state, for example by setting any of its properties,
* may result in an exception, until it is thaw()'ed.
* @this {Brush}
* @return {Brush}
*/
Brush.prototype.freeze = function() {
  this._isFrozen = true;
  if (this._colorStops !== null) this._colorStops.freeze();
  return this;
};

/**
* @ignore
* Make this object 'thawed' or mutable.
* Caution: this object might be shared, which would mean that any changes
* to this object would need to update all users of this object.
* @this {Brush}
* @return {Brush}
*/
Brush.prototype.thaw = function() {
  if (Object.isFrozen(this)) Util.throwError('cannot thaw constant: ' + this);
  this._isFrozen = false;
  if (this._colorStops !== null) this._colorStops.thaw();
  return this;
};

/**
* @ignore
* @this {Brush}
* @return {string}
*/
Brush.prototype.toString = function() {
  var s = 'Brush(';
  if (this.type === Brush.Solid) {
    s += this.color;
  } else {
    if (this.type === Brush.Linear) s += 'Linear ';
    else if (this.type === Brush.Radial) s += 'Radial ';
    else if (this.type === Brush.Pattern) s += 'Pattern ';
    else s += '(unknown) ';
    s += this.start + ' ' + this.end;
    if (this.colorStops !== null) {
      for (var it = this.colorStops.iterator; it.next(); ) {
        s += ' ' + it.key + ':' + it.value;
      }
    }
  }
  s += ')';
  return s;
};

Brush.prototype['addColorStop'] =
/**
* Specify a particular color at a particular fraction of the distance.
* If the {@link #type} is {@link Brush#Solid}, change the type to {@link Brush#Linear}.
* You should have a color stop at zero and a color stop at one.
* You should not have duplicate color stop values at the same fractional distance.
* @this {Brush}
* @param {number} loc between zero and one, inclusive.
* @param {string} color
*/
Brush.prototype.addColorStop = function(loc, color) {
  Util.checkFrozen(this);
  if (typeof loc !== 'number' || !isFinite(loc) || loc > 1 || loc < 0) {
    Util.throwRangeError(loc, '0 <= loc <= 1', Brush, 'addColorStop:loc');
  }
  Util.checkPrimitive(color, 'string', Brush, 'addColorStop:color');
  if (this._colorStops === null) this._colorStops = new Map('number', 'string');
  this._colorStops.add(loc, color);
  if (this._type === Brush.Solid) this.type = Brush.Linear;
  this._constructed = null;
};

/**
 * Gets or sets the type of brush.
 * The value must be one of: {@link Brush#Solid}, {@link Brush#Linear}, {@link Brush#Radial}, {@link Brush#Pattern}.
 * If the new value is a linear or radial brush type,
 * and if the {@link #start} or {@link #end} spots are not specific spots,
 * they are changed to be specific spots, depending on the type of brush.
 * @name Brush#type
 * @function.
 * @return {EnumValue}
 */
/** @type {EnumValue} */
Brush.prototype.type;
Util.exportProperty(Brush, 'type', Brush.prototype.type);
Util.defineProperty(Brush, {type: 'type'},
  /** @this {Brush} */
  function() { return this._type; },
  /** @this {Brush} */
  function(val) {
    Util.checkFrozen(this, val);
    Util.checkEnumValue(val, Brush, Brush, 'type');
    this._type = val;
    if (this.start.isNoSpot()) {
      if (val === Brush.Linear) this.start = Spot.TopCenter;
      else if (val === Brush.Radial) this.start = Spot.Center;
    }
    if (this.end.isNoSpot()) {
      if (val === Brush.Linear) this.end = Spot.BottomCenter;
      else if (val === Brush.Radial) this.end = Spot.Center;
    }
    this._constructed = null;
  }
);

/**
* Gets or sets the color of a solid Brush.
* @name Brush#color
* @function.
* @return {string}
*/
/** @type {string} */
Brush.prototype.color;
Util.exportProperty(Brush, 'color', Brush.prototype.color);
Util.defineProperty(Brush, {color: 'color'},
  /** @this {Brush} */
  function() { return this._color; },
  /** @this {Brush} */
  function(val) {
    Util.checkFrozen(this, val);
    Util.checkPrimitive(val, 'string', Brush, 'color');
    this._color = val;
    this._constructed = null;
  }
);

/**
* Gets or sets the starting location for a linear or radial gradient.
* A {@link Spot} value specifies a relative point in the object's {@link GraphObject#naturalBounds}.
* This defaults to Spot.TopCenter for linear gradients and Spot.Center for radial gradients.
* @name Brush#start
* @function.
* @return {Spot}
*/
/** @type {Spot} */
Brush.prototype.start;
Util.exportProperty(Brush, 'start', Brush.prototype.start);
Util.defineProperty(Brush, {start: 'start'},
  /** @this {Brush} */
  function() { return this._start; },
  /** @this {Brush} */
  function(val) {
    Util.checkFrozen(this, val);
    if (!(val instanceof Spot)) {
      Util.throwTypeError(val, 'Spot', Brush, 'start');
    }
    this._start = val.copyFrozen();
    this._constructed = null;
  }
);

/**
* Gets or sets the ending location for a linear or radial gradient.
* A {@link Spot} value specifies a relative point in the object's {@link GraphObject#naturalBounds}.
* This defaults to Spot.BottomCenter for linear gradients and Spot.Center for radial gradients.
* @name Brush#end
* @function.
* @return {Spot}
*/
/** @type {Spot} */
Brush.prototype.end;
Util.exportProperty(Brush, 'end', Brush.prototype.end);
Util.defineProperty(Brush, {end: 'end'},
  /** @this {Brush} */
  function() { return this._end; },
  /** @this {Brush} */
  function(val) {
    Util.checkFrozen(this, val);
    if (!(val instanceof Spot)) {
      Util.throwTypeError(val, 'Spot', Brush, 'end');
    }
    this._end = val.copyFrozen();
    this._constructed = null;
  }
);

/**
* Gets or sets the radius of a radial brush at the start location.
* This defaults to zero.
* @name Brush#startRadius
* @function.
* @return {number}
*/
/** @type {number} */
Brush.prototype.startRadius;
Util.exportProperty(Brush, 'startRadius', Brush.prototype.startRadius);
Util.defineProperty(Brush, {startRadius: 'startRadius'},
  /** @this {Brush} */
  function() { return this._startRadius; },
  /** @this {Brush} */
  function(val) {
    Util.checkFrozen(this, val);
    Util.checkRealNumber(val, Brush, 'startRadius');
    if (val < 0) Util.throwRangeError(val, '>= zero', Brush, 'startRadius');
    this._startRadius = val;
    this._constructed = null;
  }
);

/**
* Gets or sets the radius of a radial brush at the end location.
* The default value is NaN.
* @name Brush#endRadius
* @function.
* @return {number}
*/
/** @type {number} */
Brush.prototype.endRadius;
Util.exportProperty(Brush, 'endRadius', Brush.prototype.endRadius);
Util.defineProperty(Brush, {endRadius: 'endRadius'},
  /** @this {Brush} */
  function() { return this._endRadius; },
  /** @this {Brush} */
  function(val) {
    Util.checkFrozen(this, val);
    Util.checkRealNumber(val, Brush, 'endRadius');
    if (val < 0) Util.throwRangeError(val, '>= zero', Brush, 'endRadius');
    this._endRadius = val;
    this._constructed = null;
  }
);

/**
* Gets or sets a Map holding all of the color stops used in this gradient,
* where the key is a number, the fractional distance between zero and one (inclusive),
* and where the corresponding value is a color string.
* <p/>
* Call {@link #addColorStop} in order to add color stops to this brush.
* This property value may be null if no gradient stops have been defined.
* @name Brush#colorStops
* @function.
* @return {Map}
*/
/** @type {Map} */
Brush.prototype.colorStops;
Util.exportProperty(Brush, 'colorStops', Brush.prototype.colorStops);
Util.defineProperty(Brush, {colorStops: 'colorStops'},
  /** @this {Brush} */
  function() { return this._colorStops; },
  /** @this {Brush} */
  function(val) {
    Util.checkFrozen(this, val);
    if (Debug) Util.checkClass(val, Map, Brush, 'colorStops');
    this._colorStops = val;
    this._constructed = null;
  }
);

/**
* Gets or sets the pattern of a brush of type {@link Brush#Pattern}.
* Must be a reference to an HTMLCanvasElement or HTMLImageElement.
* @name Brush#pattern
* @function.
* @return {HTMLCanvasElement|HTMLImageElement}
*/
/** @type {HTMLCanvasElement|HTMLImageElement} */
Brush.prototype.pattern;
Util.exportProperty(Brush, 'pattern', Brush.prototype.pattern);
Util.defineProperty(Brush, {pattern: 'pattern'},
  /** @this {Brush} */
  function() { return this._pattern; },
  /** @this {Brush} */
  function(val) {
    Util.checkFrozen(this, val);
    // NYI type checking
    this._pattern = val;
    this._constructed = null;
  }
);


Brush['randomColor'] =
/**
* This static method can be used to generate a random color.
* @param {number=} min a number between zero and 255, defaults to 128.
* @param {number=} max a number between zero and 255, defaults to 255.
* @return {string} a color value in # hexadecimal format.
*/
Brush.randomColor = function(min, max) {
  if (min === undefined/*notpresent*/) min = 128;
  if (Debug) {
    Util.checkRealNumber(min, Brush, 'randomColor:min');
    if (min < 0 || min > 255) Util.throwRangeError(min, '0 <= min <= 255', Brush, 'randomColor:min');
  }
  if (max === undefined/*notpresent*/) max = Math.max(min, 255);
  if (Debug) {
    Util.checkRealNumber(max, Brush, 'randomColor:max');
    if (max < min || max > 255) Util.throwRangeError(max, 'min <= max <= 255', Brush, 'randomColor:max');
  }
  var range = Math.abs(max - min);
  var r = Math.floor(min + Math.random() * range).toString(16);
  var g = Math.floor(min + Math.random() * range).toString(16);
  var b = Math.floor(min + Math.random() * range).toString(16);
  if (r.length < 2) r = '0' + r;
  if (g.length < 2) g = '0' + g;
  if (b.length < 2) b = '0' + b;
  return '#' + r + g + b;
};

//?? add other color methods, such as lighter & darker
//?? add support for HSL and other color models

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
GraphObject
*/

/**
* This is an abstract class, so you should not use this constructor.
* @constructor
* @class
* This is the abstract base class for all graphical objects.
* Classes inheriting from GraphObject include:
* {@link Shape}, {@link TextBlock}, {@link Picture}, and {@link Panel}.
* From the Panel class the {@link Part} class is derived, from which the
* {@link Node} and {@link Link} classes derive.
* <p>
* It is very common to make use of the static method {@link GraphObject.make} in order to build up
* a visual tree of GraphObjects.  You can see many examples of this throughout the
* Introduction, starting at <a href="../../intro/buildingObjects.html">Building Objects</a>,
* and the Samples, starting with <a href="../../samples/minimal.html">Minimal Sample</a>.
* <p>
* Since GraphObject is an abstract class, programmers do not create GraphObjects themselves,
* but this class defines many properties used by all kinds of GraphObjects.
* <p>
* The only visual properties on GraphObject are {@link #background} and {@link #areaBackground}.
* However one can control whether the GraphObject is drawn at all by setting {@link #visible}.
* Also, if you want to control whether any mouse or touch events "see" the GraphObject,
* you can set {@link #pickable} to false.
* <p>
* For more information about specifying how things get drawn, see the properties on the
* {@link Shape}, {@link TextBlock}, and {@link Picture} classes.
* <hr/>
* <p>
* GraphObject defines most of the properties that cause objects to size themselves differently.
* The most prominent ones include:
* <ul>
* <li>The {@link #desiredSize}, {@link #minSize}, and {@link #maxSize} properties are used to
* explicitly set or limit the size of visual elements. {@link #width} and {@link #height} are
* convenience properties that set the {@link #desiredSize} width and height, respectively.</li>
* <li>The {@link #angle} and {@link #scale} properties are used to transform visual elements.</li>
* <li>The {@link #stretch} property determines how a GraphObject will fill its visual space,
* contextually granted to it by its containing {@link Panel}. Top-level ({@link Part})
* GraphObjects are not affected by this property because they are always granted infinite space.</li>
* </ul>
* <p>
* All GraphObjects in a Diagram are measured and then arranged by their containing {@link Panel}s in a tree-like fashion.
* After measuring and arranging, a GraphObject will have valid values for the read-only
* properties {@link #naturalBounds}, {@link #measuredBounds}, and {@link #actualBounds}.
* <p>
* <ul>
* <li>The {@link #naturalBounds} of a GraphObject describe its local size,
* without any transformations ({@link #scale}, {@link #angle}) affecting it.</li>
* <li>The {@link #measuredBounds} of a GraphObject describe its size relative to its containing Panel.</li>
* <li>The {@link #actualBounds} of a GraphObject describe its position and given size inside of its panel.
* This size may be smaller than {@link #measuredBounds}, for instance if a GraphObject with a large {@link #desiredSize}
* is placed in a {@link Panel} of a smaller {@link #desiredSize}. Smaller {@link #actualBounds} than {@link #measuredBounds}
* typically means an object will be cropped.</li>
* </ul>
* <p class="box">
* See <a href="../../intro/sizing.html">the Introduction page on sizing</a>
* for usage information and examples.
* <hr/>
* Several GraphObject properties guide the containing {@link Panel} for how to size and position the object within the panel.
* <ul>
* <li>The {@link #alignment} specifies where the object should be relative to some area of the panel.
* For example, an alignment value of {@link Spot#BottomRight} means that the GraphObject should be at the bottom-right corner of the panel.</li>
* <li>The {@link #alignmentFocus} specifies precisely which point of the GraphObject should be aligned at the {@link #alignment} spot.</li>
* <li>The {@link #column} and {@link #row} properties are only used by {@link Panel#Table} panels, to indicate where the GraphObject should be.</li>
* <li>The {@link #columnSpan} and {@link #rowSpan} properties tell the {@link Panel#Table} panel how large the GraphObject should be.</li>
* <li>The {@link #isPanelMain} property indicates to some kinds of {@link Panel}s that the GraphObject is the "primary" object that other panel children should be measured with or positioned in.</li>
* <li>The {@link #margin} property tells the containing {@link Panel} how much extra space to put around this GraphObject.</li>
* <li>The {@link #position} property is used to determine the relative position of GraphObjects when they are elements of a {@link Panel#Position} panel.</li>
* </ul>
* <p class="box">
* See <a href="../../intro/panels.html">the Introduction page on Panels</a>
* and <a href="../../intro/tablePanels.html">Table Panels</a> for an overview of the capabilities.
* <hr/>
* <p>
* When a GraphObject is a top-level object, it will be a {@link Part}.
* The position of a Part determines the point of the Part's top-left corner in document coordinates.
* See also {@link Part#location}, which supports an way to specify the position based on a different
* spot of a different element within the Part.
* <p>
* There are several read-only properties that help navigate up the visual tree.
* <ul>
* <li>{@link #panel} returns the {@link Panel} that directly contains this GraphObject</li>
* <li>{@link #part} returns the {@link Part} that this GraphObject is in, perhaps via intervening Panels; this is frequently used in order to get to the model data, {@link Panel#data}</li>
* <li>{@link #layer} returns the {@link Layer} that this GraphObject's Part is in</li>
* <li>{@link #diagram} returns the {@link Diagram} that this GraphObject's Part's Layer is in</li>
* </ul>
* <p class="box">
* See <a href="../../samples/visualTree.html">the Visual Tree sample</a>
* for a diagram displaying the visual tree of a simple diagram.
* <hr/>
* GraphObjects have several properties enabling dynamic customizable interaction.
* There are several definable functions that execute on input events: {@link #mouseDragEnter},
* {@link #mouseDragLeave}, {@link #mouseDrop}, {@link #mouseEnter}, {@link #mouseHold},
* {@link #mouseHover}, {@link #mouseLeave}, and {@link #mouseOver}.
* For example, you could define mouse enter-and-leave event handlers to modify the appearance of a link
* as the mouse passes over it:
* <pre>
* myDiagram.linkTemplate =
*   $(go.Link,
*     $(go.Shape,
*       { strokeWidth: 2, stroke: "gray" },  // default color is "gray"
*       { // here E is the InputEvent and OBJ is this Shape
*         mouseEnter: function(e, obj) { obj.strokeWidth = 4; obj.stroke = "dodgerblue"; },
*         mouseLeave: function(e, obj) { obj.strokeWidth = 2; obj.stroke = "gray"; }
*       }));
* </pre>
* <p>
* There are {@link #click}, {@link #doubleClick}, and {@link #contextClick} functions
* that execute when a user appropriately clicks the GraphObject.
* These click functions are called with the {@link InputEvent} as the first argument
* and this GraphObject as the second argument.
* For example, you could define a click event handler on a Node that goes to another page:
* <pre>
* myDiagram.nodeTemplate =
*   $(go.Node, "Auto",
*     $(go.Shape, "RoundedRectangle",
*       new go.Binding("fill", "color")),
*     $(go.TextBlock,
*       { name: "TB", margin: 3 },
*       new go.Binding("text", "key")),
*     { // second arg will be this GraphObject, which in this case is the Node itself:
*       click: function(e, node) {
*         window.open("http://en.wikipedia.org/Wiki/" + node.data.key);
*       }
*     });
* </pre>
* <p>
* Note: you may prefer defining {@link DiagramEvent} listeners on the {@link Diagram}
* rather than on individual GraphObjects.  DiagramEvents also include more general events that
* do not necessarily correspond to input events.
* <p>
* The properties {@link #actionCancel}, {@link #actionDown}, {@link #actionMove },
* and {@link #actionUp} define functions to execute when the GraphObject's {@link #isActionable} property
* is set to true (default false). See the {@link ActionTool} for more detail.
* <p class="box">
* See <a href="../../intro/events.html">the Introduction page on Events</a> for a more general discussion.
* <hr/>
* <p>
* GraphObjects have several properties that are only relevant when they are acting as "ports" within a {@link Node}.
* These port-related properties are:
* <ul>
* <li>{@link #portId}, which must be set to a string that is unique within the {@link Node},
*     in order for this GraphObject to be treated as a "port", rather than the whole node</li>
* <li>{@link #fromSpot} and {@link #toSpot}, where a link should connect with this port</li>
* <li>{@link #fromEndSegmentLength} and {@link #toEndSegmentLength}, the length of the link segment adjacent to this port</li>
* <li>{@link #fromEndSegmentDirection} and {@link #toEndSegmentDirection}, the orientation of the link when connecting to this port</li>
* <li>{@link #fromShortLength} and {@link #toShortLength}, the distance the link should terminate before touching this port</li>
* <li>{@link #fromLinkable} and {@link #toLinkable}, whether the user may draw links connecting with this port<li>
* <li>{@link #fromLinkableDuplicates} and {@link #toLinkableDuplicates}, whether the user may draw multiple links between the same pair of ports<li>
* <li>{@link #fromLinkableSelfNode} and {@link #toLinkableSelfNode}, whether the user may draw a link between ports on the same node<li>
* <li>{@link #fromMaxLinks} and {@link #toMaxLinks}, to limit the number of links connecting with this port in a particular direction<li>
* </ul>
* <p class="box">
* See <a href="../../intro/ports.html">the Introduction page on ports</a>
* for port usage information and examples.
* <hr/>
* GraphObjects can also be used as "labels" on a {@link Link}.
* In addition to the {@link #alignmentFocus} property, these properties direct a Link Panel
* to position a "label" at a particular point along the route of the link, in a particular manner:
* <ul>
* <li>{@link #segmentIndex}, which segment the label should be on<li>
* <li>{@link #segmentFraction}, how far along the segment the label should be<li>
* <li>{@link #segmentOffset}, where the label should be positioned relative to the segment<li>
* <li>{@link #segmentOrientation}, how the label should be rotated relative to the angle of the segment<li>
* </ul>
* <p class="box">
* See <a href="../../intro/linkLabels.html">the Introduction page on link labels</a>
* for examples of how to make use of labels on Links.
* <hr/>
* Finally, there are several properties that specify fairly high-level interactive behavior:
* <ul>
* <li>{@link #cursor}, a CSS string specifying a cursor</li>
* <li>{@link #contextMenu}, an {@link Adornment}</li>
* <li>{@link #toolTip}, an {@link Adornment}</li>
* </ul>
* <p class="box">
* For more information, please read <a href="../../intro/contextMenus.html">the Introduction page about Context Menus</a>
* and <a href="../../intro/toolTips.html">the page about ToolTips</a>.
* Also see <a href="../../samples/basic.html">the Basic sample</a>
* for examples of how to show context menus and tooltips.
*/
function GraphObject() {
  Util.uniqueHash(this);

  // BIT FLAGS:
  // GraphObject:
  //    0x00000001 this._visible = true;
  //    0x00000002 this._pickable = true;
  //    0x00000004 this._fromLinkableDuplicates = false;
  //    0x00000008 this._fromLinkableSelfNode = false;
  //    0x00000010 this._toLinkableDuplicates = false;
  //    0x00000020 this._toLinkableSelfNode = false;
  //    0x00000040 this._isPanelMain = false;
  //    0x00000080 this._isActionable = false;
  //    0x00000100 this._clipFlag = false; // internal flag set by panels. Tells whether or not object ought to be clipped
  //    0x00000200 this._alreadyShadowed = false; // Internal flag that stops the propogation of shadows if set to true
  //    0x00000400 this._bindsTwoWay = false; // Used in graphObject and panel
  //    0x00000800 this._invalidTransform = true;
  //    0x00001000 this._invalidAllTransforms = true;
  //    0x00002000 this._invalidMeasure = true;
  //    0x00004000 this._invalidArrange = true;

  // 0x00000001|0x00000002|0x00000800|0x00001000|0x00002000|0x00004000
  this._flags = 30723;

  /** @type {Panel} */
  this._panel = null;
  /** @type {string} */
  this._name = '';

  /** @type {string|Brush} */
  this._background = null;
  /** @type {string|Brush} */
  this._areaBackground = null;

  /** @type {Point} */
  this._position = new Point(NaN, NaN).freeze();
  /** @type {Size} */
  this._desiredSize = new Size(NaN, NaN).freeze();
  /** @type {Size} */
  this._minSize = Geo.ZeroSize;
  /** @type {Size} */
  this._maxSize = Geo.UnlimitedSize;

  /** @type {Transform} */
  this._transform = new Transform();
  /** @type {Transform} */
  this._allTransforms = new Transform();
  /** @type {Transform} */
  this._localTransform = new Transform();

  /** @type {number} */
  this._scale = 1;
  /** @type {number} */
  this._angle = 0;
  /** @type {EnumValue} */
  this._stretch = GraphObject.Default;

  /** @type {Margin} */
  this._margin = Geo.ZeroMargin;
  /** @type {Rect} */
  this._measuredBounds = new Rect(NaN, NaN, NaN, NaN).freeze();
  /** @type {Rect} */
  this._actualBounds = new Rect(NaN, NaN, NaN, NaN).freeze();
  /** @type {Rect} */
  this._naturalBounds = new Rect(0, 0, NaN, NaN).freeze();

  /** @ignore @type {Knot} */
  this._portInfo = null;

  /** @type {?string} */
  this._portId = null;

  // In both GraphObject and Link:
  /** @type {Object} */
  this._linkSettings = null;

  // Only in GraphObject:
  this._fromLinkable = null;
  this._toLinkable = null;
  this._fromMaxLinks = Infinity;
  this._toMaxLinks = Infinity;



  // for most Panel types:
  /** @type {Spot} */
  this._alignment = Spot.Default;
  /** @type {Spot} */
  this._alignmentFocus = Spot.Default;

  // for Table Panel:
  /** @type {number} */
  this._row = 0;
  /** @type {number} */
  this._rowSpan = 1;
  /** @type {number} */
  this._column = 0;
  /** @type {number} */
  this._columnSpan = 1;

  // for Link Panel:
  /** @type {number} */
  this._segmentIndex = -Infinity; // ???
  /** @type {number} */
  this._segmentFraction = 0;
  /** @type {Point} */
  this._segmentOffset = Geo.Origin;
  /** @type {EnumValue} */
  this._segmentOrientation = Link.None;

  // event handling

  /** @type {string} */
  this._cursor = '';

  // Virtualized attributes
  /** @type {Object} */
  this._eventHandlers = null;

  /** @type {List} */
  this._binds = null;

  /** @type {?Array} */
  this._copyProperties = null;

  /** @type {Rect} */
  this._clipRect = null;
  // cache
  /** @type {Part} */
  this._part = null;
}

Util.publish('GraphObject', GraphObject);

/**
* @ignore
* Copies properties from this object to the given object, which is of the same class.
* This is called by {@link #clone}.
* @this {GraphObject}
* @param {GraphObject} copy
*/
GraphObject.prototype.cloneProtected = function(copy) {
  // BIT FLAGS:
  //     0x00000001 copy._visible = this._visible;
  //     0x00000002 copy._pickable = this._pickable;
  //     0x00000004 copy._fromLinkableDuplicates = this._fromLinkableDuplicates;
  //     0x00000008 copy._fromLinkableSelfNode = this._fromLinkableSelfNode;
  //     0x00000010 copy._toLinkableDuplicates = this._toLinkableDuplicates;
  //     0x00000020 copy._toLinkableSelfNode = this._toLinkableSelfNode;
  //     0x00000040 copy._isPanelMain = this._isPanelMain;
  //     0x00000080 copy._isActionable = this._isActionable;
  //     0x00000100 copy._clipFlag = this._clipFlag;
  //     0x00000200 copy._alreadyShadowed = this._alreadyShadowed;
  //     0x00000400 copy._bindsTwoWay = this._bindsTwoWay;

  //   DONT COPY - Default true:
  //     0x00000800 copy._invalidTransform = this._invalidTransform;
  //   DONT COPY - Default true:
  //     0x00001000 copy._invalidAllTransforms = this._invalidAllTransforms;

  //     0x00002000 copy._invalidMeasure = this._invalidMeasure;
  //     0x00004000 copy._invalidArrange = this._invalidArrange;

  copy._flags = this._flags|0x00000800|0x00001000;

  // new owner needs to set this backpointer: _panel
  copy._name = this._name;

  copy._background = this._background;  // Brushes can be shared
  copy._areaBackground = this._areaBackground;

  copy._position.assign(this._position);  // always copy into local storage
  copy._desiredSize.assign(this._desiredSize);
  copy._minSize = this._minSize.copyFrozen();  // may be shared if the Spot is constant
  copy._maxSize = this._maxSize.copyFrozen();

  /* Not copying:
  copy._transform = this._transform;
  copy._allTransforms = this._allTransforms;
  */
  copy._localTransform = this._localTransform.copy();

  copy._scale = this._scale;
  copy._angle = this._angle;
  copy._stretch = this._stretch;

  copy._margin = this._margin.copyFrozen();
  copy._measuredBounds.assign(this._measuredBounds);
  copy._actualBounds.assign(this._actualBounds);
  copy._naturalBounds.assign(this._naturalBounds);

  copy._portId = this._portId;

  // don't copy Knot _portInfo

  // for most Panel types:
  copy._alignment = this._alignment.copyFrozen();
  copy._alignmentFocus = this._alignmentFocus.copyFrozen();

  // for Table Panel:
  copy._row = this._row;
  copy._rowSpan = this._rowSpan;
  copy._column = this._column;
  copy._columnSpan = this._columnSpan;

  // for Link Panel:
  copy._segmentIndex = this._segmentIndex;
  copy._segmentFraction = this._segmentFraction;
  copy._segmentOffset = this._segmentOffset.copyFrozen();
  copy._segmentOrientation = this._segmentOrientation;

  // event handling; the functions are shared
  copy._cursor = this._cursor;

  // Virtualized attributes:
  if (this._eventHandlers !== null) {
    var evt = this._eventHandlers;
    copy._eventHandlers = {
      _click: evt._click,
      _doubleClick: evt._doubleClick,
      _contextClick: evt._contextClick,
      _mouseEnter: evt._mouseEnter,
      _mouseLeave: evt._mouseLeave,
      _mouseOver: evt._mouseOver,
      _mouseHover: evt._mouseHover,
      _mouseHold: evt._mouseHold,
      _mouseDragEnter: evt._mouseDragEnter,
      _mouseDragLeave: evt._mouseDragLeave,
      _mouseDrop: evt._mouseDrop,
      _actionDown: evt._actionDown,
      _actionMove: evt._actionMove,
      _actionUp: evt._actionUp,
      _actionCancel: evt._actionCancel,
      _toolTip: evt._toolTip,
      _contextMenu: evt._contextMenu
    }
  }

  if (this._linkSettings !== null) {
    var evt = this._linkSettings;
    copy._linkSettings = {
      _fromSpot: evt._fromSpot.copyFrozen(),
      _toSpot: evt._toSpot.copyFrozen(),
      _fromEndSegmentLength: evt._fromEndSegmentLength,
      _toEndSegmentLength: evt._toEndSegmentLength,
      _fromEndSegmentDirection: evt._fromEndSegmentDirection,
      _toEndSegmentDirection: evt._toEndSegmentDirection,
      _fromShortLength: evt._fromShortLength,
      _toShortLength: evt._toShortLength
    }
  }

  copy._fromLinkable = this._fromLinkable;
  copy._fromMaxLinks = this._fromMaxLinks;
  copy._toLinkable = this._toLinkable;
  copy._toMaxLinks = this._toMaxLinks;

  // local bindings are shared
  copy._binds = this._binds;

  // copy those properties named in _copyProperties
  if (Array.isArray(this._copyProperties)) {
    copy._copyProperties = this._copyProperties.slice(0);
    for (var i = 0; i < this._copyProperties.length; i++) {
      var pname = this._copyProperties[i];
      copy[pname] = this[pname];
    }
  }

  if (this._clipRect !== null) copy._clipRect = this._clipRect.copy();

  // cannot copy this._part
};

/**
* @ignore
* Fix up references in the argument object so that the argument object can displace this object in the visual tree.
* @this {GraphObject}
* @param {GraphObject} copy  This might be a copy of this object,
* but more likely is a separately created object of the same class with completely different internals.
*/
GraphObject.prototype.displaceProtected = function(copy) {
  copy._portInfo = null;  // don't copy Knot
  copy._part = null;  // recompute this cached reference
  copy.invalidateMeasure();
};

/**
* @ignore
* Creates a shallow copy of this GraphObject and returns it.
* This calls {@link #cloneProtected} with a new object of the same class as this object.
* This is called by {@link #copy}.
* @this {GraphObject}
* @return {GraphObject} the newly copied object.
*/
GraphObject.prototype.clone = function() {
  var copy = new this.constructor;
  this.cloneProtected(copy);
  return copy;
};

/**
* Creates a deep copy of this GraphObject and returns it.
* This method is the same as a clone for simple GraphObjects
* such as {@link Shape}, {@link TextBlock}, and {@link Picture}.
* For {@link Panel} this method copies the visual tree of GraphObjects that it contains.
* @expose
* @this {GraphObject}
* @return {GraphObject}
*/
GraphObject.prototype.copy = function() {
  // no children, shallow clone is equivalent
  return this.clone();
};

/**
* @ignore
* @this {GraphObject}
* @return {string}
*/
GraphObject.prototype.toString = function() {
  return Util.getClassName(Object.getPrototypeOf(this)) + '#' + Util.hashId(this);
};


/**
* GraphObjects with this enumeration as the value of {@link GraphObject#stretch}
* are not automatically scaled to fit in the given bounds;
* there may be clipping in one or both directions if the available dimensions are too small.
* @name GraphObject#None
* @constant
* @static
* @return {EnumValue}
*/
GraphObject['None'] = GraphObject.None = Util.defineEnumValue(GraphObject, 'None', 0);

/**
* GraphObjects with this enumeration as the value of {@link GraphObject#stretch}
* are stretched depending on the context they are used. For instance a 'Circle' figure might
* be uniformly stretched whereas an 'Ellipse' figure might be non-uniformly stretched.
* @name GraphObject#Default
* @constant
* @static
* @return {EnumValue}
*/
GraphObject['Default'] = GraphObject.Default = Util.defineEnumValue(GraphObject, 'Default', 0);

/**
* GraphObjects with this enumeration as the value of {@link GraphObject#stretch}
* are scaled as much as possible in the y-axis.
* @name GraphObject#Vertical
* @constant
* @static
* @return {EnumValue}
*/
GraphObject['Vertical'] = GraphObject.Vertical = Util.defineEnumValue(GraphObject, 'Vertical', 4);

/**
* GraphObjects with this enumeration as the value of {@link GraphObject#stretch}
* are scaled as much as possible in the x-axis.
* @name GraphObject#Horizontal
* @constant
* @static
* @return {EnumValue}
*/
GraphObject['Horizontal'] = GraphObject.Horizontal = Util.defineEnumValue(GraphObject, 'Horizontal', 5);

/**
* GraphObjects with this enumeration as the value of {@link GraphObject#stretch}
* are scaled in both directions so as to fit exactly in the given bounds;
* there is no clipping but the aspect ratio may change, causing the object to appear stretched.
* @name GraphObject#Fill
* @constant
* @static
* @return {EnumValue}
*/
GraphObject['Fill'] = GraphObject.Fill = Util.defineEnumValue(GraphObject, 'Fill', 3);

/**
* Pictures with this enumeration as the value of {@link Picture#imageStretch} are drawn with equal
* scale in both directions to fit the arranged (actual) bounds;
* Panels of type Viewbox with this as the value of {@link Panel#viewboxStretch}
* are scaled equally in both directions to fit in the given bounds.
* @name GraphObject#Uniform
* @constant
* @static
* @return {EnumValue}
*/
GraphObject['Uniform'] = GraphObject.Uniform = Util.defineEnumValue(GraphObject, 'Uniform', 1);

/**
* Pictures with this enumeration as the value of {@link Picture#imageStretch} are drawn with equal
* scale in both directions to fit the larger side of the image bounds;
* Panels of type Viewbox with this as the value of {@link Panel#viewboxStretch}
* are scaled equally in both directions to fit the larger side of the element's bounds.
* there may be clipping in one dimension.
* @name GraphObject#UniformToFill
* @constant
* @static
* @return {EnumValue}
*/
GraphObject['UniformToFill'] = GraphObject.UniformToFill = Util.defineEnumValue(GraphObject, 'UniformToFill', 2);

/**
* @ignore
* @this {GraphObject}
*/
GraphObject.prototype.initEventHandlers = function() {
  this._eventHandlers = {
    _click: null,
    _doubleClick: null,
    _contextClick: null,
    _mouseEnter: null,
    _mouseLeave: null,
    _mouseOver: null,
    _mouseHover: null,
    _mouseHold: null,
    _mouseDragEnter: null,
    _mouseDragLeave: null,
    _mouseDrop: null,

    _actionDown: null,
    _actionMove: null,
    _actionUp: null,
    _actionCancel: null,

    _toolTip: null,
    _contextMenu: null
  }
};

/**
* @ignore
* @this {GraphObject}
*/
GraphObject.prototype.initLinkSettings = function() {
  this._linkSettings = {
    _fromSpot: Spot.None,
    _toSpot: Spot.None,
    _fromEndSegmentLength: 10,
    _toEndSegmentLength: 10,
    _fromEndSegmentDirection: Node.DirectionRotatedNodeOrthogonal,
    _toEndSegmentDirection: Node.DirectionRotatedNodeOrthogonal,
    _fromShortLength: 0,
    _toShortLength: 0
  }
};

/**
* @ignore
* Static method for drawing dashed lines on a context
* @this {GraphObject}
* @param {CanvasRenderingContext2D} context
* @param {number} x
* @param {number} y
* @param {number} x2
* @param {number} y2
* @param {Array.<number>} strokeDashArray
* @param {number} offset
*/
GraphObject.drawDash = function(context, x, y, x2, y2, strokeDashArray, offset) {
  var dashLength = 0.001;
  var dashCount = strokeDashArray.length;
  // ??? if dashCount odd, double the array?
  context.moveTo(x, y);
  var dx = (x2 - x), dy = (y2 - y);
  if (dx === 0) dx = 0.001;
  var slope = dy / dx;
  var distRemaining = Math.sqrt(dx * dx + dy * dy);
  var dashIndex = 0;
  var draw = true;
  dashLength = strokeDashArray[dashIndex % dashCount];

  var first = (offset === 0) ? false : true; // first line is different if there is an offset
  while (distRemaining >= 0.1) {
    if (first) {
      dashLength = strokeDashArray[dashIndex++ % dashCount];
      dashLength -= offset;
      while (dashLength < 0) {
        dashLength += strokeDashArray[dashIndex++ % dashCount];
        draw = !draw;
      }
      first = false;
    } else {
      dashLength = strokeDashArray[dashIndex++ % dashCount];
    }
    if (dashLength > distRemaining) dashLength = distRemaining;
    var xStep = Math.sqrt(dashLength * dashLength / (1 + slope * slope));
    if (dx < 0) xStep = -xStep;
    x += xStep;
    y += slope * xStep;
    if (draw) context.lineTo(x, y);
    else context.moveTo(x, y);
    distRemaining -= dashLength;
    draw = !draw;
  }
};

/**
* @ignore
* Call this method to notify that some state has changed.
* This just calls the {@link #part}'s {@link Part#raiseChangedEvent} method.
* <p/>
* A simpler version of this method is {@link #raiseChanged}.
* @this {GraphObject}
* @param {EnumValue} change specifies the general nature of the change;
* permissible values include {@link ChangedEvent#Property}, {@link ChangedEvent#Insert},
* {@link ChangedEvent#Remove}, and {@link ChangedEvent#Transaction}.
* @param {string} propertyname names the property that was modified.
* @param {Object} obj the object that was modified.
* @param {*} oldval the previous or older value.
* @param {*} newval the next or newer value.
* @param {*=} oldparam an optional value that helps describe the older value.
* @param {*=} newparam an optional value that helps describe the newer value.
*/
GraphObject.prototype.raiseChangedEvent = function(change, propertyname, obj, oldval, newval, oldparam, newparam) {
  var part = this.part;
  if (part !== null) {
    part.raisePartChangedEvent(change, propertyname, obj, oldval, newval, oldparam, newparam);
    if (this.getBindsTwoWay() && obj === this && change === ChangedEvent.Property) {
      var binder = this.findTemplateBinder();
      if (binder !== null) {
          var it = this._binds.iterator;
          while (it.next()) {
            var bind = it.value;
            // normally bound to DATA, but use a named GraphObject if sourceName
            var data = binder.data;
            var srcname = bind.sourceName;
            if (srcname !== null) data = binder.findObject(srcname);
            if (data === null) continue;

            // maybe transfer from this GraphObject to data
            bind.updateSource(this, data, propertyname, (srcname !== null ? null : part.diagram));

            // maybe transfer from a named GraphObject to another GraphObject
            if (srcname !== null) {
              var srcelt = binder;
              if (srcname !== '') srcelt = binder.findObject(srcname);
              if (srcelt !== null) {
                var dstname = bind.targetId;
                var dstelt = binder;
                if (dstname !== '') dstelt = binder.findObject(dstname);
                if (dstelt !== null) {
                  bind.updateTarget(dstelt, srcelt, propertyname);
                }
              }
            }
          }
      }
    }
  }
};

/**
* @ignore
* Call this method to notify about a property having changed value.
* This just calls the {@link #part}'s {@link Part#raiseChangedEvent} method.
* @this {GraphObject}
* @param {string} propertyname the name of the property.
* @param {*} oldval the previous or old value for the property.
* @param {*} newval the next or new value for the property.
*/
GraphObject.prototype.raiseChanged = function(propertyname, oldval, newval) {
  this.raiseChangedEvent(ChangedEvent.Property, propertyname, this, oldval, newval);
};

/**
* @ignore
* Shared code among each measureProtected routine. Sets measuredBounds.
* @this {GraphObject}
* @param {number} x
* @param {number} y
* @param {number} w
* @param {number} h
*/
GraphObject.prototype._measureRect = function(x, y, w, h) {
  var rect = this._measuredBounds;
  var tt = this._localTransform;
  tt.reset();
  this._setTransformAngle(tt, x, y, w, h);
  this._localTransform = tt;
  rect.x = x;
  rect.y = y;
  rect.width = w;
  rect.height = h;
  if (!tt.isIdentity()) {
    tt.transformRect(rect);
  }
};

/**
* @ignore
* @this {GraphObject}
* @param {Rect} r A Rect in container coordinates.
* @param {boolean} partialInclusion True if objects are to be included when they
* intersect.
* @param {Transform} transform
* @return {boolean} Whether or not this object is included.
*/
GraphObject.prototype.findObjectIn = function(r, partialInclusion, transform) {
  if (this.pickable === false) return false;
  transform.multiply(this.transform);
  if (partialInclusion) {
    return this.intersectsRect(r, transform);
  } else {
    return this.containedInRect(r, transform);
  }
};

/**
* @ignore
* @this {GraphObject}
* @param {Point} p A Point in container coordinates.
* @param {Point} distp A Point representing the distance from the point p.
* @param {boolean} partialInclusion
* @return {boolean} Whether or not this object is included.
*/
GraphObject.prototype.findObjectNear = function(p, distp, partialInclusion) {
  if (this.pickable === false) return false;
  var ns = this.naturalBounds;
  var dist = p.distanceSquaredPoint(distp);
  var hit = false;
  if (partialInclusion) hit = (Point.distanceLineSegmentSquared(p.x, p.y, 0, 0, 0, ns.height) < dist) ||
    (Point.distanceLineSegmentSquared(p.x, p.y, 0, ns.height, ns.width, ns.height) < dist) ||
    (Point.distanceLineSegmentSquared(p.x, p.y, ns.width, ns.height, ns.width, 0) < dist) ||
    (Point.distanceLineSegmentSquared(p.x, p.y, ns.width, 0, 0, 0) < dist);
  if (!partialInclusion) hit = (Point.distanceLineSegmentSquared(p.x, p.y, 0, 0, 0, ns.height) < dist) &&
    (Point.distanceLineSegmentSquared(p.x, p.y, 0, ns.height, ns.width, ns.height) < dist) &&
    (Point.distanceLineSegmentSquared(p.x, p.y, ns.width, ns.height, ns.width, 0) < dist) &&
    (Point.distanceLineSegmentSquared(p.x, p.y, ns.width, 0, 0, 0) < dist);

  return hit;
};

/**
* @ignore
* @this {GraphObject}
* Determine if an object's transform should or should not affect its children
* This is only meaningful on Panel right now, and only for TableRow/TableColumn
* If this method returns true then the transform should not be applied to children,
* and calculations made with the object in question might need to substitute actual bounds for natural bounds,
* to simulate the transformation that is not occurring
* @return {boolean}
*/
GraphObject.prototype.trueTransform = function() {
  return true;
};

GraphObject.prototype['containsPoint'] =
/**
* @ignore
* Determine if a given point is inside and on this GraphObject.
* <p/>
* This method tries to return true for points near a stroke or near or
* inside a possibly filled object such as an ellipse or a polygon.
* This method ignores any drop shadow, but normally includes the
* width of any line/stroke.
* <p/>
* The default behavior of this method is to return true if the
* point p is within this object's Bounds.
* If this object's width or height are zero,
* the given point p has to be exactly on for this predicate to return true.
* <p/>
* However, some classes that are inherently somewhat "one dimensional",
* may intentionally be more forgiving by supporting some margin nearby
* where a point can be considered to be "inside" the object.
* @this {GraphObject}
* @param {Point} p A Point in container coordinates.
* @return {boolean} true if the argument p is considered to be "in"
* this object.
*/
GraphObject.prototype.containsPoint = function(p) {
  if (Debug) Util.checkClass(p, Point, GraphObject, 'containsPoint:p');

  // Make sure the point is in its actualBounds in case it was clipped
  var parentsCoords = Util.tempPoint();
  parentsCoords.assign(p);
  this.transform.transformPoint(parentsCoords);
  var ab = this.actualBounds;

  if (!ab.isReal()) return false;

  if (Util.supportsTouch) {
    var sz = this.naturalBounds;
    var docscale = this.getDocumentScale() * ((this.diagram !== null) ? this.diagram.scale : 1);
    var sc = 1 / docscale;
    // if its in the bounds, iterate over this panel's collection in reverse order, calling containsPoint
    if (sz.width * docscale < 10 && sz.height * docscale < 10) {
      var result = (Rect.contains(
            ab.x - (5 * sc), ab.y - (5 * sc),
            ab.width + (10 * sc), ab.height + (10 * sc),
            parentsCoords.x, parentsCoords.y));
      Util.freePoint(parentsCoords);
      return result;
    }
  }

  // ??? if its an adornment, it can skip this first check
  if (this.adornedObject !== undefined || (this instanceof Shape) ? Rect.contains(ab.x - 5, ab.y - 5, ab.width + 10, ab.height + 10, parentsCoords.x, parentsCoords.y) : ab.containsPoint(parentsCoords)) {
    if (this._clipRect && !this._clipRect.containsPoint(parentsCoords)) return false;
    if (this._areaBackground !== null && ab.containsPoint(parentsCoords)) return true;
    if (this._background !== null && this._naturalBounds.containsPoint(p)) return true;
    Util.freePoint(parentsCoords);
    return this.containsPointProtected(p);
  }
  Util.freePoint(parentsCoords);
  return false;
};

/**
* @ignore
* Determine if a point is within local bounds.
* The default checks to see if the contained point is within the measured
* bounds. Most classes override this functionality.
* @this {GraphObject}
* @param {Point} p A Point in local coordinates.
* @param {boolean=} precise optional argument that forces the strokewidth to stay small.
* @return {boolean} true if the argument p is considered to be "in"
* this object.
*/
GraphObject.prototype.containsPointProtected = function(p, precise) {
  // this is set up so that the point coming in should be in local
  // co-ordinates and already transformed, so naturalBounds must be used instead
  // of measuredSize.
  var sz = this.naturalBounds;
  return Rect.contains(0, 0, sz.width, sz.height, p.x, p.y);
};

//??? not used anywhere except test system
GraphObject.prototype['containsRect'] =
/**
* @ignore
* Determine if a given Rect is entirely contained within this GraphObject.
* @this {GraphObject}
* @param {Rect} r A Rect in container coordinates.
* @return {boolean} true if the argument r is considered to be "in" this object.
*/
GraphObject.prototype.containsRect = function(r) {
  if (Debug) Util.checkClass(r, Rect, GraphObject, 'containsRect:r');

  if (this.angle === 0) {
    return this.actualBounds.containsRect(r);
  }

  // See if all of the 4 r points are inside the container
  var ns = this.naturalBounds;
  var nb = Util.tempRectAt(0, 0, ns.width, ns.height);
  var at = this.transform;
  var result = false;
  var tp = Util.tempPointAt(r.x, r.y);
  if (nb.containsPoint(at.invertedTransformPoint(tp))) {
    tp._set(r.x, r.bottom);
    if (nb.containsPoint(at.invertedTransformPoint(tp))) {
      tp._set(r.right, r.bottom);
      if (nb.containsPoint(at.invertedTransformPoint(tp))) {
        tp._set(r.right, r.y);
        if (nb.containsPoint(at.invertedTransformPoint(tp))) {
          result = true;
        }
      }
    }
  }
  Util.freePoint(tp);
  Util.freeRect(nb);
  return result;
};

GraphObject.prototype['containedInRect'] =
/**
* @ignore
* Determine if a given Rect is large enough to entirely contain this
* GraphObject.
* @this {GraphObject}
* @param {Rect} r A Rect in container coordinates.
* @param {Transform=} transform A transform to use if something other than the GraphObject's own transform is desired.
* @return {boolean} true if rect r contains the entire object.
*/
GraphObject.prototype.containedInRect = function(r, transform) {
  if (Debug) Util.checkClass(r, Rect, GraphObject, 'containedInRect:r');

  // using its own transform means we can just check the actualBounds
  if (transform === undefined/*notpresent*/) {
    return r.containsRect(this.actualBounds);
  }

  // see if all of the four points are inside the rect
  var ns = this.naturalBounds;
  var at = transform;
  var result = false;
  var tp = Util.tempPointAt(0, 0);
  if (r.containsPoint(at.transformPoint(tp))) {
    tp._set(0, ns.height);
    if (r.containsPoint(at.transformPoint(tp))) {
      tp._set(ns.width, ns.height);
      if (r.containsPoint(at.transformPoint(tp))) {
        tp._set(ns.width, 0);
        if (r.containsPoint(at.transformPoint(tp))) {
          result = true;
        }
      }
    }
  }
  return result;
};

GraphObject.prototype['intersectsRect'] =
/**
* @ignore
* Determines if a given rectangle intersects the GraphObject's drawn bounds.
* @this {GraphObject}
* @param {Rect} r a rectangle in container coordinates.
* @param {Transform=} transform
* @return {boolean}
*/
GraphObject.prototype.intersectsRect = function(r, transform) {
  if (Debug) Util.checkClass(r, Rect, GraphObject, 'intersectsRect:r');

  if (transform === undefined/*notpresent*/) {
    transform = this.transform;
    // We can do this if there is no transform
    if (this.angle === 0) {
      return r.intersectsRect(this.actualBounds);
    }
  }

  // see if any of the four points are inside r
  // ??? possibly reundant because of intersectsLineSegment tests?
  var ns = this.naturalBounds;
  var at = transform;
  var r1 = Util.tempPointAt(0, 0);
  var r2 = Util.tempPointAt(0, ns.height);
  var r3 = Util.tempPointAt(ns.width, ns.height);
  var r4 = Util.tempPointAt(ns.width, 0);

  var result = false;
  if (r.containsPoint(at.transformPoint(r1)) ||
      r.containsPoint(at.transformPoint(r2)) ||
      r.containsPoint(at.transformPoint(r3)) ||
      r.containsPoint(at.transformPoint(r4))) {
    result = true;
  } else {
    // See if any of the 4 r points are inside the container
    var nb = Util.tempRectAt(0, 0, ns.width, ns.height);
    var tp = Util.tempPointAt(r.x, r.y);
    if (nb.containsPoint(at.invertedTransformPoint(tp))) {
      result = true;
    } else {
      tp._set(r.x, r.bottom);
      if (nb.containsPoint(at.invertedTransformPoint(tp))) {
        result = true;
      } else {
        tp._set(r.right, r.bottom);
        if (nb.containsPoint(at.invertedTransformPoint(tp))) {
          result = true;
        } else {
          tp._set(r.right, r.y);
          if (nb.containsPoint(at.invertedTransformPoint(tp))) {
            result = true;
          }
        }
      }
    }
    Util.freePoint(tp);
    Util.freeRect(nb);

    if (!result) {
      // ??? see if any of 4 lines intersect the rect. Is there no better way?
      if (Geo.intersectsLineSegment(r, r1, r2) ||
          Geo.intersectsLineSegment(r, r2, r3) ||
          Geo.intersectsLineSegment(r, r3, r4) ||
          Geo.intersectsLineSegment(r, r4, r1)) {
        result = true;
      }
    }
  }

  Util.freePoint(r1);
  Util.freePoint(r2);
  Util.freePoint(r3);
  Util.freePoint(r4);
  return result;
};

GraphObject.prototype['getDocumentPoint'] =
/**
* Returns the Point in document coordinates for a given Spot in this object's bounds.
* <p/>
* For example, for an instance of a Node like this:
* <pre>
* myDiagram.nodeTemplate =
*   $(go.Node, "Auto",
*     $(go.Shape, "RoundedRectangle",
*       new go.Binding("fill", "color")),
*     $(go.TextBlock,
*       { name: "TB", margin: 3 },
*       new go.Binding("text", "key")));
* </pre>
* where the Node is positioned at <code>100, 200</code>,
* <pre>
*   node.findObject("TB").getDocumentPoint(go.Spot.Center)
* </pre>
* could return a Point that is approximately at <code>122, 213</code>.
* @this {GraphObject}
* @param {Spot} s a real Spot describing a location relative to the GraphObject.
* @param {Point=} result an optional Point that is modified and returned.
* @return {Point} in document coordinates.
*/
GraphObject.prototype.getDocumentPoint = function(s, result) {
  if (result === undefined/*notpresent*/) result = new Point();
  if (s.isNoSpot()) Util.throwError('Spot must be real');
  var ns = this.naturalBounds;
  result._set((s.x * ns.width) + s.offsetX, (s.y * ns.height) + s.offsetY);
  this.allTransforms.transformPoint(result);
  return result;
};

GraphObject.prototype['getDocumentAngle'] =
/**
* Returns the effective angle that the object is drawn at, in document coordinates, normalized to between 0 and 360.
* <p/>
* Basically this adds together all of the rotation declared by this {@link #angle} and the angles of all of its containing Panels, including the Part.
* @this {GraphObject}
* @return {number}
*/
GraphObject.prototype.getDocumentAngle = function() {
  var at = this.allTransforms;
  var atan = Math.atan2(at.m12, at.m11) * (180 / Math.PI);
  if (atan < 0) atan += 360;
  return atan;
};

GraphObject.prototype['getDocumentScale'] =
/**
* Returns the total scale that the object is drawn at, in document coordinates.
* <p/>
* Basically this multiplies together this {@link #scale} with the scales of all of its containing Panels, including the Part.
* @this {GraphObject}
* @return {number}
*/
GraphObject.prototype.getDocumentScale = function() {
  var scale = this._scale;
  if (this.panel !== null) return scale * this.panel.getDocumentScale();
  return scale;
};

GraphObject.prototype['getLocalPoint'] =
/**
* Given a Point in document coordinates, returns a new Point in local coordinates.
* <p/>
* For example, if you have a mouse event whose {@link InputEvent#documentPoint} is at <code>122, 213</code>,
* and if you have a Node whose {@link #position} is at <code>100, 200</code>,
* <code>node.getLocalPoint(e.documentPoint)</code> could return a Point that is at <code>22, 13</code>.
* For a GraphObject within the Node named "TB",
* <pre>
*   node.findObject("TB").getLocalPoint(e.documentPoint)
* </pre>
* could return a Point that is at <code>15.7, 6.7</code>,
* if that "TB" object is positioned somewhat inside the bounds of the Node.
* @this {GraphObject}
* @param {Point} p a Point in document coordinates.
* @param {Point=} result an optional Point that is modified and returned.
* @return {Point} The corresponding Point in local coordinates.
*/
GraphObject.prototype.getLocalPoint = function(p, result) {
  if (result === undefined/*notpresent*/) result = new Point();
  result.assign(p);
  this.allTransforms.invertedTransformPoint(result);
  return result;
};

GraphObject.prototype['getNearestIntersectionPoint'] =
/**
* @ignore
* Find the closest point in this object to the given point p1 that is on the
* line p1-p2.
* @this {GraphObject}
* @param {Point} p1 the point we are looking to be closest to, on the line formed with p2.
* @param {Point} p2 forms a line with p1.
* @param {Point} result (reference) the point of this object that is closest to p1 and that is on the infinite line from p1 to p2.
* @return {boolean} true if the infinite line does intersect with this object; false otherwise.
*/
GraphObject.prototype.getNearestIntersectionPoint = function(p1, p2, result) {
  return this.getNearestIntersectionPoint2(p1.x, p1.y, p2.x, p2.y, result);
};

// getNearestIntersectionPoint without using Points or calling transform methods
/**
* @ignore
* Find the closest point in this object to the given point p1 that is on the
* line p1-p2.
* @this {GraphObject}
* @param {number} p1x
* @param {number} p1y
* @param {number} p2x
* @param {number} p2y
* @param {Point} result (reference) the point of this object that is closest to p1 and that is on the infinite line from p1 to p2.
* @return {boolean} true if the infinite line does intersect with this object; false otherwise.
*/
GraphObject.prototype.getNearestIntersectionPoint2 = function(p1x, p1y, p2x, p2y, result) {
  var tt = this.transform;
  var d = 1 / (tt.m11 * tt.m22 - tt.m12 * tt.m21);
  var m0 = tt.m22 * d;
  var m1 = -tt.m12 * d;
  var m2 = -tt.m21 * d;
  var m3 = tt.m11 * d;
  var m4 = d * (tt.m21 * tt.dy - tt.m22 * tt.dx);
  var m5 = d * (tt.m12 * tt.dx - tt.m11 * tt.dy);

  if (this.areaBackground !== null) {
    // find intersection with transformed bounds
    var ab = this.actualBounds;
    return Geo.getNearestIntersectionPoint(ab.left, ab.top, ab.right, ab.bottom, p1x, p1y, p2x, p2y, result);
  } else if (!(this instanceof Panel) || (this instanceof Panel && this.background !== null)) {
    // Inverted transform point
    var p12x = p1x * m0 + p1y * m2 + m4;
    var p12y = p1x * m1 + p1y * m3 + m5;

    var p22x = p2x * m0 + p2y * m2 + m4;
    var p22y = p2x * m1 + p2y * m3 + m5;
    result._set(0, 0);
    var nb = this.naturalBounds;
    var found = Geo.getNearestIntersectionPoint(0, 0, nb.width, nb.height, p12x, p12y, p22x, p22y, result);
    result.transform(tt);
    return found;
  } else if (this instanceof Panel && (this.areaBackground === null || this.areaBackground === undefined)) {
    // recurse on the children

    // Inverted transform point
    var q1x = p1x * m0 + p1y * m2 + m4;
    var q1y = p1x * m1 + p1y * m3 + m5;

    var q2x = p2x * m0 + p2y * m2 + m4;
    var q2y = p2x * m1 + p2y * m3 + m5;

    result._set(q2x, q2y);
    var closestdist = (q2x - q1x) * (q2x - q1x) + (q2y - q1y) * (q2y - q1y);
    var found = false;
    var arr = this._elements._arr;
    var l = arr.length;
    var point = Util.tempPoint();
    for (var i = 0; i < l; i++) {
      var child = arr[i];
      if (!child.visible) continue;
      if (!child.getNearestIntersectionPoint2(q1x, q1y, q2x, q2y, point)) continue;
      found = true;
      var dist = (q1x - point.x) * (q1x - point.x) + (q1y - point.y) * (q1y - point.y);
      if (dist < closestdist) {
        closestdist = dist;
        result.set(point);
      }
    }
    Util.freePoint(point);
    result.transform(tt); // convert back to container coords.
    return found;
  } else {
    // ???
    Util.throwError('Unknown GraphObject case');
    return false;
  }
};


/**
* @ignore
* Given the available size and desired size, measure this GraphObject and
* determine its expected drawing size. Sets the measuredBounds of the object.
* This sets {@link #measuredBounds}.
* @this {GraphObject}
* @param {number} width The available width in panel coordinates.
* @param {number} height The available height in panel coordinates.
* @param {number=} minw
* @param {number=} minh
*/
GraphObject.prototype.measure = function(width, height, minw, minh) {
  // don't measure unless invalid
  if (this.getInvalidMeasure() === false) return;
  var marg = this.margin;
  var margw = marg.right + marg.left;
  var margh = marg.top + marg.bottom;
  width = Math.max(width - margw, 0);
  height = Math.max(height - margh, 0);

  // ????
  // width and height need to be expressed
  /*
  var tt = Util.tempTransform(); ??? Util.freeTransform(tt) needed later
  tt.reset();
  if (this.scale !== 1) {
    tt.scale(this.scale);
  }
  if (this.angle !== 0) {

    //var pt = Util.tempPoint();
    //pt.setSpot(0,0, // can't be x/y
    //  width, height,
    //  Spot.Center);
    //tt.rotate(this.angle, pt.x, pt.y);
    //Util.freePoint(pt);

    // can probably just use this instead of the above:
    tt.rotate(this.angle, 0, 0);
  }
  */

  /*
  // not yet accounting for scale
  if (this.angle !== 0 && !(width === Infinity && height === Infinity)) {
    var cos = 1;
    var sin = 0;
    if (this.angle !== 0) {
      var rad = (this.angle % 90) * (Math.PI/180);
      cos = Math.cos(rad);
      sin = Math.sin(rad);
    }

    var a = rad/2;
    var cx = 2 * width * Math.sin(a);
    var cx2 = 2 * height * Math.sin(a);

    var cy = 2 * height * Math.cos(a);
    var cy2 = 2 * width * Math.cos(a);

    var wr = 1;
    var hr = 1;
    var bigsideratio = Math.max(width*cos + height*sin, width*sin + height*cos);
    wr = width / bigsideratio;
    hr = height /  bigsideratio;
    var maxscale = Math.max(wr, hr)// / scale;
    var oldw = width;
    width = cx
    height = cx
  }*/

  var des = this.desiredSize;
  // desiredSize for shapes represents just the geometry size
  // If desired size dictates the available width/height make sure its really desired+sw
  var sw = 0;
  if (this.strokeWidth) sw = this.strokeWidth;
  // A desiredSize always overrides any fill
  width = isFinite(des.width) ? des.width + sw : width;
  height = isFinite(des.height) ? des.height + sw : height;
  var tempminw = minw;
  var tempminh = minh;
  var panel = (this instanceof Panel);
  var stretch = this.getEffectiveStretch();
  switch (stretch) {
    case GraphObject.None:
      // We don't care if its not stretching
      tempminw = 0;
      tempminh = 0;
      if (panel) {
        width = Infinity;
        height = Infinity;
      }
      break;
    case GraphObject.Fill:
      if (isFinite(width) && width > minw) tempminw = width;
      if (isFinite(height) && height > minh) tempminh = height;
      break;
    case GraphObject.Horizontal:
      if (isFinite(width) && width > minw) tempminw = width;
      // We don't care if its not stretching
      tempminh = 0;
      if (panel) height = Infinity;
      break;
    case GraphObject.Vertical:
      if (isFinite(height) && height > minh) tempminh = height;
      // We don't care if its not stretching
      tempminw = 0;
      if (panel) width = Infinity;
      break;
  }
  var max = this.maxSize;
  var min = this.minSize;
  if (tempminw > max.width && min.width < max.width) tempminw = max.width;
  if (tempminh > max.height && min.height < max.height) tempminh = max.height;
  minw = Math.max(tempminw / this.scale, min.width); // scale is needed here but not in subclass' measureProtected
  minh = Math.max(tempminh / this.scale, min.height);
  // If the projected minimum is more than the maximum, bring it down to the smallest minimum possible
  if (max.width < minw) minw = Math.min(min.width, minw);
  if (max.height < minh) minh = Math.min(min.height, minh);
  width = Math.min(max.width, width);
  height = Math.min(max.height, height);
  width = Math.max(minw, width);
  height = Math.max(minh, height);

  // ???? this is not a long term solution:
  var ang = this.angle;
  var tempw;
  if (ang === 90 || ang === 270) {
    tempw = width;
    width = height;
    height = tempw;
    tempw = minw;
    minw = minh;
    minh = tempw;
  }


  this._measuredBounds.thaw();
  this.measureProtected(width, height, minw, minh);

  this._measuredBounds.freeze();
  if (!this._measuredBounds.isReal()) Util.throwError('Non-real measuredBounds has been set');
  this.setInvalidMeasure(false);
};

/**
* @ignore
* Arranges the GraphObject onto its parent.
* This sets {@link #actualBounds}.
* @this {GraphObject}
* @param {number} fx The final x value of actualBounds that the Panel computes for the GraphObject.
* @param {number} fy The final y value of actualBounds that the Panel computes for the GraphObject.
* @param {number} fw The final width value of actualBounds that the Panel computes for the GraphObject.
* @param {number} fh The final height value of actualBounds that the Panel computes for the GraphObject.
* @param {Rect=} clipRect an optional area to constrain this actualBounds to when hit testing/drawing. Used with Fixed/Table panels
* element, provided as a Rect.
*/
GraphObject.prototype.arrange = function(fx, fy, fw, fh, clipRect) {
  this._invalidateTransform();

  var oldActual = Util.tempRect();
  oldActual.assign(this._actualBounds);

  this._actualBounds.thaw();
  if (this.getInvalidArrange() === false) { // if the arrange is valid just update the actualBounds
    var ab = this._actualBounds;
    ab.x = fx;
    ab.y = fy;
    ab.width = fw;
    ab.height = fh;
  } else {
    this.arrangeProtected(fx, fy, fw, fh);
  }
  this._actualBounds.freeze();

  if (clipRect === undefined/*notpresent*/)
    this._clipRect = null;
  else
    this._clipRect = clipRect;
  var clipFlag = false;
  if (clipRect !== undefined/*notpresent*/) {
    clipFlag = true;
  } else if (this.panel) {
    var nb = this.panel._naturalBounds;
    var m = this.measuredBounds;
    // If there's an areaBackground then the drawn space is potentially
    // larger than the measured Bounds, so we have to clip more
    if (this.areaBackground !== null) m = this._actualBounds;
    var height = fy + m.height;
    var width = fx + m.width;
    clipFlag = !(
      0 <= fx &&
      width <= nb.width &&
      0 <= fy &&
      height <= nb.height);
    if (this instanceof TextBlock) {
      if (this._maxPosition > m.height || this._lines.maxLineWidth > m.width) {
        clipFlag = true;
      }
    }
  }
  if (clipFlag) {
    this._flags |= 0x00000100;
  } else {
    this._flags &= ~0x00000100;
  }

  if (!this._actualBounds.isReal()) Util.throwError('Non-real actualBounds has been set');

  this.onBoundsChanged(oldActual, this._actualBounds);
  Util.freeRect(oldActual);
};

/**
* @ignore
* @this {GraphObject}
* @param {number} fx
* @param {number} fy
* @param {number} fw
* @param {number} fh
*/
GraphObject.prototype.arrangeProtected = function(fx, fy, fw, fh) {
  //  Util.throwError('arrangeProtected not implemented for this class');
};

/**
* @ignore
* @this {GraphObject}
* @param {number} fx
* @param {number} fy
* @param {number} fw
* @param {number} fh
*/
GraphObject.prototype.commonArrange = function(fx, fy, fw, fh) {
  var ab = this.actualBounds;
  ab.x = fx;
  ab.y = fy;
  ab.width = fw;
  ab.height = fh;
  if (this.desiredSize.isReal()) return;

  var mb = this._measuredBounds;
  var marg = this.margin;
  var margw = marg.right + marg.left;
  var margh = marg.top + marg.bottom;
  var mbwidth = mb.width + margw;
  var mbheight = mb.height + margh;
  fw += margw;
  fh += margh;

  var effectivestretch = this.getEffectiveStretch();
  if (mbwidth === fw && mbheight === fh) effectivestretch = GraphObject.None;
  switch (effectivestretch) {
    case GraphObject.None: // if fw or fh are smaller than our size, we have to remeasure
      if (mbwidth > fw || mbheight > fh) {
        this.setInvalidMeasure(true);
        this.measure(mbwidth > fw ? fw : mbwidth, mbheight > fh ? fh : mbheight);
      }
      break;
    case GraphObject.Fill: // fill the space completely, ignoring desired aspect ratio
      this.setInvalidMeasure(true);
      this.measure(fw, fh, 0, 0);
      break;
    case GraphObject.Horizontal:
      this.setInvalidMeasure(true);
      this.measure(fw, mbheight, 0, 0);
      break;
    case GraphObject.Vertical:
      this.setInvalidMeasure(true);
      this.measure(mbwidth, fh, 0, 0);
      break;
  } // end stretch switch
};

/**
* @ignore
* @this {GraphObject}
* @param {Rect} oldb
* @param {Rect} newb
*/
GraphObject.prototype.onBoundsChanged = function(oldb, newb) {
  // we should check to see if oldb equals newb
  // the rest can be skipped if that is true?
  this.setInvalidArrange(false);
  var gp = this.part;
  if (gp === null) return;
  var diagram = gp.diagram;
  if (diagram === null) return;

  // invalidate any group
  gp.invalidateContainingGroup();

  if (this instanceof Part) {
    var inside = false;
    // only do if the document bounds are valid.
    var realold = oldb.isReal();
    if (diagram._invalidDocBounds === false) {
      var docb = diagram.documentBounds;
      var pad = diagram.padding;

      var docbx = docb.x + pad.left;
      var docby = docb.y + pad.top;
      var docbw = docb.width - pad.right * 2;
      var docbh = docb.height - pad.bottom * 2;

      // are both the oldb and newb inside the docb by at least a pixel?
      if (realold && oldb.x > docbx && oldb.y > docby && oldb.right < docbw && oldb.bottom < docbh &&
          newb.x > docbx && newb.y > docby && newb.right < docbw && newb.bottom < docbh) {
        inside = true;
      }
    }

    if (this.getNotifyLater() === true || !oldb.equals(newb)) {
      this.notifyDiagram(inside, diagram);
    }

    if (!diagram._rectOptimizations || diagram._drawingRects === null) {
      diagram.invalidateDraw();
    } else {
      var olddrawn = null;
      if (realold) {
        olddrawn = Util.tempRect();
        this.getDrawnSize(oldb, olddrawn);
      }
      diagram.invalidateDraw(newb.isReal() ? this.getDrawnSize(newb) : null, olddrawn);
      if (olddrawn !== null) Util.freeRect(olddrawn);
    }
  } else {
    this._notifyPorts(gp);
    this.invalidateDraw();

    var part = this.part;
    if (part !== null) {
      if (part.selectionObject === this ||
          part.resizeObject === this ||
          part.rotateObject === this) part.setNotifyLater(true);
    }

  }
};

/**
* @ignore
* @this {GraphObject}
* @param {Part} part
*/
GraphObject.prototype._notifyPorts = function(part) {
  if (this.portId !== null) part.setNotifyLater(true);
  if (this instanceof Panel) {
    var children = this._elements;
    var l = children.length;
    for (var i = 0; i < l; i++) {
      children._arr[i]._notifyPorts(part);
    }
  }
};

/**
* @ignore
* The draw function. Handles translation and rotation, then calls the
* internal draw for the specific GraphObject.
* @this {GraphObject}
* @param {CanvasRenderingContext2D} context a canvas drawing context.
* @param {Diagram} diagram
*/
GraphObject.prototype.draw = function(context, diagram) {
  if (!this.visible) return;
  // @@@ could redo now that transforms are on the table for TableRow/Column
  if (this instanceof Panel && (this.type === Panel.TableRow || this.type === Panel.TableColumn)) {
    var ab = this._actualBounds;
    if (ab.width === 0 || ab.height === 0 || isNaN(ab.x) || isNaN(ab.y)) return;
    // areaBackground is in the parent's transform space
    if (this._areaBackground !== null) {
      this.setBrush(context, this._areaBackground, true, true);
      context.fillRect(ab.x, ab.y, ab.width, ab.height);
    }

    // background is in local space
    if (this._background !== null) {
      this.setBrush(context, this._background, true);
      context.fillRect(ab.x, ab.y, ab.width, ab.height);
    }
    this.drawProtected(context, diagram);
    return;
  }

  var ab = this._actualBounds;
  if (ab.width === 0 || ab.height === 0 || isNaN(ab.x) || isNaN(ab.y)) return;

  if (Debug && Debug.boundsInfoEnabled && !(this instanceof Adornment)) { Debug.drawBoundsInfoActual(context, this); }

  // Make sure it exists
  var tt = this.transform;
  var myPanel = this.panel;
  // ??? might not be a good place to do this, but it is a place where all the info is known
  // construct the allTransforms for this object
  var t2 = this._allTransforms;
  t2.reset();
  if (myPanel !== null) {
    if (myPanel.trueTransform()) {
      t2.multiply(myPanel.allTransforms);
    } else if (myPanel.panel !== null) {
      t2.multiply(myPanel.panel.allTransforms);
    }
  }
  t2.multiply(this._transform);

  var clip = (this._flags & 0x00000100) !== 0; // clipFlag;
  if (clip) {
    if (Debug && Debug.drawClipEnabled) Debug.trace('clip' + this.toString());
    var nb = myPanel.trueTransform() ? myPanel.naturalBounds : myPanel.actualBounds;

    if (this._clipRect) {
      var cr = this._clipRect;
      var cx = cr.x;
      var cy = cr.y;
      var cwidth = cr.width;
      var cheight = cr.height;
    } else {
      var cx = Math.max(ab.x, nb.x);
      var cy = Math.max(ab.y, nb.y);
      var cwidth = Math.min(ab.right, nb.right) - cx;
      var cheight = Math.min(ab.bottom, nb.bottom) - cy;
    }
    if (cx > ab.width + ab.x || ab.x > nb.width + nb.x) return;
    if (cy > ab.height + ab.y || ab.y > nb.height + nb.y) return;


    if (Debug && Debug.drawClipEnabled) Debug.drawClip(context, cx, cy, cwidth, cheight);
    context.save();
    context.beginPath();
    context.rect(cx, cy, cwidth, cheight);
    context.clip();
  }

  var isPart = false;
  if (this instanceof Part) {
    isPart = true;
    if (!this.isVisible()) return;
    if (this.isShadowed) {
      var shad = this._shadowOffset;
      context.shadowOffsetX = shad.x * diagram.scale;
      context.shadowOffsetY = shad.y * diagram.scale;
      context.shadowColor = this._shadowColor;
      context.shadowBlur = this._shadowBlur;
    }
  }
  var isShadowed = false;
  if (this.part) isShadowed = this.part.isShadowed;

  // areaBackground is in the parent's transform space
  if (this._areaBackground !== null) {
    this.setBrush(context, this._areaBackground, true, true);
    context.fillRect(ab.x, ab.y, ab.width, ab.height);
  }

  if (!tt.isIdentity()) {
    context.transform(tt.m11, tt.m12, tt.m21, tt.m22, tt.dx, tt.dy);
  }

  // background is in local space
  if (this._background !== null) {
    var ns = this.naturalBounds;
    var nx = 0;
    var ny = 0;
    var nw = ns.width;
    var nh = ns.height;
    var sw = 0;
    if (this instanceof Shape) {
      ns = this._geometry.bounds;
      nx = ns.x;
      ny = ns.y;
      nw = ns.width;
      nh = ns.height;
      sw = this._strokeWidth;
    }
    this.setBrush(context, this._background, true);
    context.fillRect(
      nx - (sw / 2),
      ny - (sw / 2),
      nw + sw, nh + sw);
  }

  if (Debug && Debug.boundsInfoEnabled) { Debug.drawBoundsInfoNatural(context, this); }

  // Before we draw protected we must see if we or our parent has a background or areaBackground
  if (isShadowed &&
    (this._background !== null ||
    this._areaBackground !== null ||
    (myPanel !== null && myPanel.getAlreadyShadowed()) ||
    (myPanel !== null && myPanel.type === Panel.Auto && myPanel._tempMain !== this))) {
    this.setAlreadyShadowed(true); // no more shadows
    var shadowState = [context.shadowOffsetX, context.shadowOffsetY, context.shadowBlur];
    context.shadowOffsetX = 0;
    context.shadowOffsetY = 0;
    context.shadowBlur = 0;
  } else {
    this.setAlreadyShadowed(false); // continue with shadows
  }
  this.drawProtected(context, diagram);

  // Reset things for the next sibling
  if (isShadowed && this.getAlreadyShadowed() === true) {
    context.shadowOffsetX = shadowState[0];
    context.shadowOffsetY = shadowState[1];
    context.shadowBlur = shadowState[2];
  }

  // If the part had a shadow, reset it
  if (isPart && isShadowed) {
    context.shadowOffsetX = 0;
    context.shadowOffsetY = 0;
    //context.shadowColor = 0;
    context.shadowBlur = 0;
  }

  if (clip) {
    context.restore();
    diagram.clearContextCache(context);
  } else {
    //for when not saving+clipping+restoring
    if (!tt.isIdentity()) {
      var d = 1 / (tt.m11 * tt.m22 - tt.m12 * tt.m21);
      var m0 = tt.m22 * d;
      var m1 = -tt.m12 * d;
      var m2 = -tt.m21 * d;
      var m3 = tt.m11 * d;
      var m4 = d * (tt.m21 * tt.dy - tt.m22 * tt.dx);
      var m5 = d * (tt.m12 * tt.dx - tt.m11 * tt.dy);
      context.transform(m0, m1, m2, m3, m4, m5);
    }
  }

}; // end draw

/**
* @ignore
* @this {GraphObject}
* @param {CanvasRenderingContext2D} context
* @param {Diagram} diagram
*/
GraphObject.prototype.drawProtected = function(context, diagram) {
  // do nothing
};

/**
* @ignore
* @this {GraphObject}
* @param {CanvasRenderingContext2D} context
* @param {Brush|string} brush
* @param {boolean} fill
* @param {boolean=} parent coordinate system. Local by default.
*/
GraphObject.prototype.setBrush = function(context, brush, fill, parent) {
  if (brush !== null) {
    if (typeof brush === 'string') {
      if (fill) {
        if (context.__cachedFillStyle !== brush) {
          context.fillStyle = brush;
          context.__cachedFillStyle = brush;
        }
      } else { // stroke
        if (context.__cachedStrokeStyle !== brush) {
          context.strokeStyle = brush;
          context.__cachedStrokeStyle = brush;
        }
      }
    } else if (brush.type === Brush.Solid) {
      var br = brush.color;
      if (fill) {
        if (context.__cachedFillStyle !== br) {
          context.fillStyle = br;
          context.__cachedFillStyle = br;
        }
      } else { // stroke
        if (context.__cachedStrokeStyle !== br) {
          context.strokeStyle = br;
          context.__cachedStrokeStyle = br;
        }
      }
    } else { // its a Brush
      var grad;
      var nb = this.naturalBounds;
      var w = nb.width;
      var h = nb.height;
      // We can only use the last constructed brush if the width and height are the same
      if (brush._constructed && brush.type === Brush.Pattern || (brush._constructedWidth === w && brush._constructedHeight === h)) {
        grad = brush._constructed;
      } else {
        // setup for both Linear and Radial
        var x0, y0, x1, y1, r0, r1;
        var x = 0;
        var y = 0;
        if (parent) {
          // parent coordinates, like for areaBackground
          var ab = this.actualBounds;
          w = ab.width;
          h = ab.height;
          x = ab.x;
          y = ab.y;
        }

        if (brush.start instanceof Point) {
          x0 = brush.start.x;
          y0 = brush.start.y;
        } else if (brush.start instanceof Spot) {
          x0 = brush.start.x * w;
          y0 = brush.start.y * h;
        } else {
          x0 = Spot.Center.x * w;
          y0 = Spot.Center.y * h;
        }

        if (brush.end instanceof Point) {
          x1 = brush.end.x;
          y1 = brush.end.y;
        } else if (brush.end instanceof Spot) {
          x1 = brush.end.x * w;
          y1 = brush.end.y * h;
        } else { // defaults
          if (brush.type === Brush.Linear) {
            x1 = Spot.BottomCenter.x * w;
            y1 = Spot.BottomCenter.y * h;
          } else { // Radial
            x1 = Spot.Center.x * w;
            y1 = Spot.Center.y * h;
          }
        }

        // If we are working in the panel's coordinates we must shift the values by
        // the actualBounds x/y
        x0 += x;
        x1 += x;
        y0 += y;
        y1 += y;

        // Specific setup
        if (brush.type === Brush.Linear) {
          grad = context.createLinearGradient(x0, y0, x1, y1);
        } else if (brush.type === Brush.Radial) {
          if (isNaN(brush.endRadius)) {
            r1 = Math.max(w, h) / 2;
          } else {
            r1 = brush.endRadius;
          }

          if (isNaN(brush.startRadius)) {
            //if there's no startRadius, assume there's no endRadius either
            r0 = 0;
            r1 = Math.max(w, h) / 2;
          } else {
            r0 = brush.startRadius;
          }

          grad = context.createRadialGradient(x0, y0, r0, x1, y1, r1);
        } else if (brush.type === Brush.Pattern) {
          grad = context.createPattern(brush.pattern, 'repeat');
        } else {
          Util.throwTypeError(brush.type, 'Brush type');
        }

        if (brush.type !== Brush.Pattern) {
          var stops = brush.colorStops;
          if (stops) {
            var it = stops.iterator;
            while (it.next()) {
              grad.addColorStop(it.key, it.value);
            }
          }
        }
        brush._constructed = grad;
        brush._constructedWidth = w;
        brush._constructedHeight = h;
      } // end construction

      if (fill) {
        if (context.__cachedFillStyle !== grad) {
          context.fillStyle = grad;
          context.__cachedFillStyle = grad;
        }
      } else { // stroke
        if (context.__cachedStrokeStyle !== grad) {
          context.strokeStyle = grad;
          context.__cachedStrokeStyle = grad;
        }
      }
    }
  }
}; // end setBrush

GraphObject.prototype['isContainedBy'] =
/**
* This predicate is true if this object is an element, perhaps indirectly,
* of the given panel.
* <p/>
* For example, if this GraphObject is inside a Part but is not itself the Part,
* <code>obj.isContainedBy(obj.part)</code> should be true.
* @this {GraphObject}
* @param {GraphObject} panel
* @return {boolean} true if this object is contained by the given panel,
* or if it is contained by another panel that is contained by the given panel,
* to any depth; false if the argument is null or is not a {@link Panel}.
*/
GraphObject.prototype.isContainedBy = function(panel) {
  if (panel instanceof Panel) return this._isContainedBy(this, panel);
  return false;
};

/**
* @ignore
* @this {GraphObject}
* @param {GraphObject} obj
* @param {Panel} panel
* @return {boolean}
*/
GraphObject.prototype._isContainedBy = function(obj, panel) {
  if (obj === panel || panel === null) return false;
  var pan = obj.panel;
  while (pan !== null) {
    if (pan === panel) return true;
    pan = pan.panel;
  }
  return false;
};


GraphObject.prototype['isVisibleObject'] =
/**
* This predicate is true if this object is {@link #visible}
* and each of its visual containing panels are also visible.
* This ignores the actual location or appearance (except visibility)
* of the panel that this object is part of, as well as ignoring all
* properties of the {@link Layer} or {@link Diagram}.
* <p/>
* For {@link Part}s, you can call the {@link Part#isVisible} predicate to determine
* if not only the Part is visible but also any containing {@link Group} or {@link Link}.
* @this {GraphObject}
* @return {boolean}
*/
GraphObject.prototype.isVisibleObject = function() {
  if (!this.visible) return false;
  var p = this.panel;
  if (p !== null) return p.isVisibleObject();
  return true;
};


/**
* @ignore
* Only called when transform or allTransforms is asked for and invalidTransform is true.
* @this {GraphObject}
*/
GraphObject.prototype._validateTransforms = function() {
  if (this.getInvalidTransform() === true) { // if invalid, make it valid
    var tt = this._transform;
    tt.reset();

    if (!this._actualBounds.isReal() || !this._measuredBounds.isReal()) {
      this.setInvalidTransform(false);
      return;
    }

    tt.translate(this._actualBounds.x, this._actualBounds.y);

    // this is to move an object if its been rotated. For example, a square
    // rotated 45 degrees will need to be "pushed down" to fit where it once was
    tt.translate(-this.measuredBounds.x, -this.measuredBounds.y);

    var ns = this.naturalBounds;
    this._setTransformAngle(tt, ns.x, ns.y, ns.width, ns.height);

    // the normal transform is now valid
    this.setInvalidTransform(false);
    this.setInvalidAllTransforms(true);
  }

  if (this.getInvalidAllTransforms() === true) { // if invalid, make it valid

    // if this is the topmost object:
    if (this.panel === null) {
      this._allTransforms.set(this._transform);
      this.setInvalidAllTransforms(false);
      // else if object one above has a valid allTransforms:
    } else if (this.panel.allTransforms !== null) { // second condition?
      var t2 = this._allTransforms;
      t2.reset();
      t2.multiply(this.panel._allTransforms);
      t2.multiply(this._transform);
      this.setInvalidAllTransforms(false);
    }

  }
};

/**
* @ignore
* Shared code used by both measureRect and validateTransforms.
* @this {GraphObject}
* @param {Transform} tt
* @param {number} x
* @param {number} y
* @param {number} w
* @param {number} h
*/
GraphObject.prototype._setTransformAngle = function(tt, x, y, w, h) {
  if (this.scale !== 1) {
    tt.scale(this.scale);
  }
  if (this.angle !== 0) {
    var rspot = Spot.Center;
    if (this.locationSpot && this.locationSpot.isSpot()) {
      rspot = this.locationSpot;
    }

    var pt = Util.tempPoint();
    if (this instanceof Part && this.locationObject !== this) {
      var obj = this.locationObject;
      // if obj.transform were ready at this time we could use that
      // but it isn't because obj has no actualBounds
      // so instead we can localTransform + offset by measuredBounds
      var ns = obj.naturalBounds;
      pt.setSpot(ns.x, ns.y, ns.width, ns.height, rspot);
      obj._localTransform.transformPoint(pt);
      pt.offset(-obj.measuredBounds.x, -obj.measuredBounds.y);

      var parent = obj.panel;
      while (parent !== null && parent !== this) {
        parent._localTransform.transformPoint(pt);
        pt.offset(-parent.measuredBounds.x, -parent.measuredBounds.y);
        parent = parent.panel;
      }
    } else {
      pt.setSpot(x, y, w, h, rspot);
    }
    tt.rotate(this.angle, pt.x, pt.y);
    Util.freePoint(pt);
  }
};

/**
* @ignore
* @param {boolean=} parent flag, meaning the parent invalidated a child. Stops the child from trying to invalidate the parent.
* @this {GraphObject}
*/
GraphObject.prototype.invalidateMeasure = function(parent) {
  if (this.getInvalidMeasure() === true) return;
  this.setInvalidMeasure(true);
  this.setInvalidArrange(true);

  var panel = this.panel;
  if (panel !== null) { // invalidate parents
    if (!parent) {
      panel.invalidateMeasure();
    }
  } else {
    var diagram = this.diagram;
    if (diagram !== null) {
      diagram._invalidObjects.add(this);
      if (this instanceof Node) {
        if (!diagram.undoManager.isUndoingRedoing) this.invalidateConnectedLinks();
        if (this.labeledLink !== null) this.labeledLink.invalidateArrange();
      }
      diagram.requestUpdate();
    }
  }

  // Invalidate Children
  if (this instanceof Panel) {
    var auto = this._type === Panel.Auto;
    var mainchild = null;
    var children = this._elements;
    var l = children.length;
    // must invalidate main object?
    if (auto) {
      mainchild = this.getMainChild(children, l);
      if (mainchild) mainchild.invalidateMeasure(true);
    }
    children = children._arr;
    for (var i = 0; i < l; i++) {
      var child = children[i];

      // some conditions may allow children to skip invalidation
      if (child.getInvalidMeasure() === true) continue;

      // A real desired size means that the child does not need to be invalidated,
      // since its size cannot change
      if (child.desiredSize.isReal()) continue;
      // No stretch means that a parent's change of size will not affect a child,
      // so it does not need to be invalidated
      if (!(child instanceof Placeholder) &&
          !(child instanceof Panel) &&
          !(child instanceof TextBlock) &&
          child.getEffectiveStretch() === GraphObject.None) continue;

      child.invalidateMeasure(true);
    }
  }
};

/**
* @ignore
* Special invalidateMeasure for invalidating panels and their children only
* This does not notify the diagram nor any parent panels
* @this {GraphObject}
*/
GraphObject.prototype.invalidateMeasureChildren = function() {
  if (this.getInvalidMeasure() === false) {
    this.setInvalidMeasure(true);
    this.setInvalidArrange(true);
    // Invalidate Children
    if (this instanceof Panel) {
      var children = this._elements._arr;
      var l = children.length;
      for (var i = 0; i < l; i++) {
        // In the future we should only do this on specific children ??
        children[i].invalidateMeasureChildren();
      }
    }
  }
};

/**
* @ignore
* @this {GraphObject}
*/
GraphObject.prototype.invalidateArrange = function() {
  if (this.getInvalidArrange() === false) {
    var panel = this.panel;
    if (panel !== null) {
      this.panel.invalidateMeasure(); // invalidate parents
    } else {
      var diagram = this.diagram;
      if (diagram !== null) {
        diagram._invalidObjects.add(this);
        if (this instanceof Node) this.invalidateConnectedLinks();
        diagram.requestUpdate();
      }
    }
    this.setInvalidArrange(true);
  }
};

/**
* @ignore
* Invalidates an Object's transform and then recurses through the visual tree to invalidate the allTransforms for each object in collection.
* @this {GraphObject}
*/
GraphObject.prototype._invalidateTransform = function() {
  if (this.getInvalidTransform() === false) { // add || invalidAllTransforms?
    this.setInvalidTransform(true);
    this.setInvalidAllTransforms(true);
    if (this instanceof Panel) {
      var it = this.elements;
      while (it.next()) {
        var child = it.value;
        child.invalidateAllTransforms();
      }
    }
  }
};

/**
* @ignore
* Recurses through the visual tree to invalidate the allTransforms for each GraphObject.
* @this {GraphObject}
*/
GraphObject.prototype.invalidateAllTransforms = function() {
  this.setInvalidAllTransforms(true);
  if (this instanceof Panel) {
    var it = this.elements;
    while (it.next()) {
      var child = it.value;
      child.invalidateAllTransforms();
    }
  }
};

/**
* @ignore
* @this {GraphObject}
*/
GraphObject.prototype.invalidateDraw = function() {
  if (this instanceof Part) {
    var d = this.diagram;
    if (d !== null && !this.getInvalidArrange() &&
    !this.getInvalidPosition() && this.isVisible() &&
    this._actualBounds.isReal()) { // only if bounds are meaningful
      d.invalidateDraw(this.getDrawnSize(this._actualBounds));
    }
  } else if (this.part !== null) {
    this.part.invalidateDraw();
    return;
  }
};

/**
* @ignore
* @this {GraphObject}
*/
GraphObject.prototype.getEffectiveStretch = function() {
  var effectivestretch = this.stretch;
  var pan = this.panel;
  if (pan && pan._type === Panel.Table)
    return this.getEffectiveTableStretch(pan.getRowDefinition(this.row), pan.getColumnDefinition(this.column));
  // Auto panels have special stretch rules
  // The main object will be filled even if the stretch value is None,
  // but it will be filled to a different area
  if (pan && pan._type === Panel.Auto) {
    if (pan._tempMain === null) {
      var children = pan._elements;
      var l = children.length;
      var main = pan.getMainChild(children, l);
    }
    if (pan._tempMain === this) return GraphObject.Fill;
  }
  if (effectivestretch === GraphObject.Default) {
    if (pan) {
      if (pan._type === Panel.Spot && pan._tempMain === null) {
        var children = pan._elements;
        var l = children.length;
        var main = pan.getMainChild(children, l);
      }
      if (pan._tempMain === this) return GraphObject.Fill;
      var str = pan.defaultStretch;
      if (str === GraphObject.Default) return GraphObject.None;
      return str;
    }
    return GraphObject.None; // Everything else is none by default
  }
  return effectivestretch;
};

/**
* @ignore
* Only ever called from Table's measure and arrange
* @param {RowColumnDefinition} row
* @param {RowColumnDefinition} col
* @this {GraphObject}
*/
GraphObject.prototype.getEffectiveTableStretch = function(row, col) {
  var effectivestretch = this.stretch;
  if (effectivestretch !== GraphObject.Default) return effectivestretch;
  // which directions are we stretching?
  // undefined = default
  var horizontal = undefined;
  var vertical = undefined;
  switch (row.stretch) {
    case GraphObject.Default:
    case GraphObject.Horizontal: break;
    case GraphObject.Vertical: vertical = true; break;
    case GraphObject.Fill: vertical = true; break;
  }
  switch (col.stretch) {
    case GraphObject.Default:
    case GraphObject.Vertical: break;
    case GraphObject.Horizontal: horizontal = true; break;
    case GraphObject.Fill: horizontal = true; break;
  }

  var str = this.panel.defaultStretch;
  if (horizontal === undefined && (str === GraphObject.Horizontal || str === GraphObject.Fill)) {
    horizontal = true;
  } else {
    horizontal = false;
  }
  if (vertical === undefined && (str === GraphObject.Vertical || str === GraphObject.Fill)) {
    vertical = true;
  } else {
    vertical = false;
  }
  if (horizontal === true && vertical === true) return GraphObject.Fill;
  if (horizontal === true) return GraphObject.Horizontal;
  if (vertical === true) return GraphObject.Vertical;
  return GraphObject.None; // Everything else is none by default
};


/**
* Gets or sets the orientation of a GraphObject that is in a {@link Link}.
* This controls the automatic rotation of the object by the Link Panel.
* The only accepted values are the {@link Link} "Orient..." values of Link
* and the default value: {@link Link#None}.
* <p>
* When the value is Link.None, the {@link #angle} of this object is set to zero.
* A value of {@link Link#Along} sets the angle to be the angle of the segment that this object is on.
* Other values compute the angle somewhat differently.
* <p>
* For examples of how to use this property, see <a href="../../intro/linkLabels.html">Link Labels</a>.
* @name GraphObject#segmentOrientation
* @function.
* @return {EnumValue}
* @see #segmentFraction
* @see #segmentIndex
* @see #segmentOffset
*/
/** @type {EnumValue} */
GraphObject.prototype.segmentOrientation;
Util.exportProperty(GraphObject, 'segmentOrientation', GraphObject.prototype.segmentOrientation);
Util.defineProperty(GraphObject, { segmentOrientation: 'segmentOrientation' },
  /** @this {GraphObject} */
  function() { return this._segmentOrientation; },
  /** @this {GraphObject} */
  function(val) {
    var old = this._segmentOrientation;
    if (old !== val) {
      if (Debug) Util.checkEnumValue(val, Link, GraphObject, 'segmentOrientation');
      this._segmentOrientation = val;
      this.invalidateMeasure();
      this.raiseChanged('segmentOrientation', old, val);
    }
  }
);

/**
* Gets or sets the segment index of a GraphObject that is in a {@link Link}.
* Non-negative numbers count up from zero, which is the first segment, at the "from" end of the Link.
* Negative numbers count segments from the "to" end of the Link, where -1 means the last segment
* and -2 means the next-to-last segment.
* The value should be an integer.
* <p>
* If you do not set this property, the Link will choose a place that is approximately at the
* mid-point of the link's route.
* <p>
* For examples of how to use this property, see <a href="../../intro/linkLabels.html">Link Labels</a>.
* @name GraphObject#segmentIndex
* @function.
* @return {number}
* @see #segmentFraction
* @see #segmentOffset
* @see #segmentOrientation
*/
/** @type {number} */
GraphObject.prototype.segmentIndex;
Util.exportProperty(GraphObject, 'segmentIndex', GraphObject.prototype.segmentIndex);
Util.defineProperty(GraphObject, { segmentIndex: 'segmentIndex' },
  /** @this {GraphObject} */
  function() { return this._segmentIndex; },
  /** @this {GraphObject} */
  function(val) {
    if (Debug) Util.checkPrimitive(val, 'number', GraphObject, 'segmentIndex');
    val = Math.round(val);  // only integers
    var old = this._segmentIndex;
    if (old !== val) {
      this._segmentIndex = val;
      this.invalidateMeasure();
      this.raiseChanged('segmentIndex', old, val);
    }
  }
);

/**
* Gets or sets the fractional distance along a segment of a GraphObject that is in a {@link Link}.
* The value should be between zero and one, where zero is at the point at the start of the segment,
* and where one is at the point at the end of the segment.
* The default value is zero.
* <p>
* For examples of how to use this property, see <a href="../../intro/linkLabels.html">Link Labels</a>.
* @name GraphObject#segmentFraction
* @function.
* @return {number}
* @see #segmentIndex
* @see #segmentOffset
* @see #segmentOrientation
*/
/** @type {number} */
GraphObject.prototype.segmentFraction;
Util.exportProperty(GraphObject, 'segmentFraction', GraphObject.prototype.segmentFraction);
Util.defineProperty(GraphObject, { segmentFraction: 'segmentFraction' },
  /** @this {GraphObject} */
  function() { return this._segmentFraction; },
  /** @this {GraphObject} */
  function(val) {
    if (Debug) Util.checkPrimitive(val, 'number', GraphObject, 'segmentFraction');
    // Force it to be between 0 and 1. Maybe throw error instead?
    if (isNaN(val)) val = 0;
    else if (val < 0) val = 0;
    else if (val > 1) val = 1;
    var old = this._segmentFraction;
    if (old !== val) {
      this._segmentFraction = val; // only integers
      this.invalidateMeasure();
      this.raiseChanged('segmentFraction', old, val);
    }
  }
);

/**
* Gets or sets the offset of a GraphObject that is in a {@link Link} from a point on a segment.
* The X component of the Point indicates the distance along the route,
* with positive values going further toward the "to" end of the link.
* The Y component of the Point indicates the distance away from the route,
* with positive values towards the right as seen when facing further towards the "to" end of the link.
* The value defaults to the Point (0, 0).
* <p>
* For examples of how to use this property, see <a href="../../intro/linkLabels.html">Link Labels</a>.
* @name GraphObject#segmentOffset
* @function.
* @return {Point}
* @see #segmentFraction
* @see #segmentIndex
* @see #segmentOrientation
*/
/** @type {Point} */
GraphObject.prototype.segmentOffset;
Util.exportProperty(GraphObject, 'segmentOffset', GraphObject.prototype.segmentOffset);
Util.defineProperty(GraphObject, { segmentOffset: 'segmentOffset' },
  /** @this {GraphObject} */
  function() { return this._segmentOffset; },
  /** @this {GraphObject} */
  function(val) {
    var old = this._segmentOffset;
    if (!old.equals(val)) {
      if (Debug) Util.checkClass(val, Point, GraphObject, 'segmentOffset');
      val = val.copyFrozen();
      this._segmentOffset = val;
      this.invalidateMeasure();
      this.raiseChanged('segmentOffset', old, val);
    }
  }
);

// ??? "Objects with an angle..."
/**
* Gets or sets the stretch of the GraphObject.
* This controls whether the width and/or height of this object automatically adjusts to fill
* the area allotted by the containing Panel.
* <p>
* The only accepted values are listed as constant properties of GraphObject,
* such as {@link GraphObject#None}, {@link GraphObject#Fill}, {@link GraphObject#Horizontal}, or {@link GraphObject#Vertical}.
* The default value is Spot.Default, which allows the Panel to decide how to treat this object, depending on the type of Panel.
* <p>
* Objects with an angle that are stretched may look incorrect unless the angle is a multiple of 90.
* @name GraphObject#stretch
* @function.
* @return {EnumValue}
* @see Panel#defaultStretch
* @see #desiredSize
* @see #minSize
* @see #maxSize
* @see #measuredBounds
* @see #actualBounds
* @see #scale
* @see #angle
*/
/** @type {EnumValue} */
GraphObject.prototype.stretch;
Util.exportProperty(GraphObject, 'stretch', GraphObject.prototype.stretch);
Util.defineProperty(GraphObject, { stretch: 'stretch' },
  /** @this {GraphObject} */
  function() { return this._stretch; },
  /** @this {GraphObject} */
  function(val) {
    var old = this._stretch;
    if (old !== val) {
      if (Debug) Util.checkEnumValue(val, GraphObject, GraphObject, 'stretch');
      this._stretch = val;
      this.invalidateMeasure();
      this.raiseChanged('stretch', old, val);
    }
  }
);

/**
* Gets or sets the name for this object.
* The default value is the empty string.
* The name need not be unique within a {@link Panel}, although if it isn't,
* it reduces the usefulness of methods such as {@link Panel#findObject}.
* <p/>
* You must not modify the name of a GraphObject once it is in the visual tree of a Part.
* <p/>
* This is frequently needed to identify a particular GraphObject in the visual tree of a Part,
* for example as the value of the {@link Part#locationObjectName} or
* {@link Part#selectionObjectName} properties.
* @name GraphObject#name
* @function.
* @return {string}
*/
/** @type {string} */
GraphObject.prototype.name;
Util.exportProperty(GraphObject, 'name', GraphObject.prototype.name);
Util.defineProperty(GraphObject, { name: 'name' },
  /** @this {GraphObject} */
  function() { return this._name; },
  /** @this {GraphObject} */
  function(val) {
    var old = this._name;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'string', GraphObject, 'name');
      this._name = val;
      if (this.part) this.part.clearNameMap();
      this.raiseChanged('name', old, val);
    }
  }
);


/**
* Gets or sets whether a GraphObject is visible.
* The default value is true.
* A not visible object takes no space in the Panel that it is in.
* Making a Panel not visible causes all of its elements not to be seen or receive input events.
* Changing a Panel to become visible causes all of its elements to be seen and be active,
* unless those elements are themselves not visible.
* <p/>
* One can have a visible {@link Shape} that is not drawn by setting its {@link Shape#fill} and {@link Shape#stroke} to null or to "transparent".
* Similarly, one can set {@link TextBlock#stroke} to null or to "transparent".
* It is also possible make a {@link Panel}-full of GraphObjects transparent by setting {@link Panel#opacity} to 0.0.
* Finally, one can make a whole {@link Layer}-full of Parts invisible by setting {@link Layer#visible} to false.
* <p/>
* Use the {@link #isVisibleObject} predicate to see if this GraphObject is visible and is inside a {@link Panel}
* that is {@link #isVisibleObject}, and so forth up the chain of panels until reaching the {@link Part}.
* <p/>
* For {@link Part}s, you can call the {@link Part#isVisible} predicate to determine
* if not only the Part is visible but also any containing {@link Group} or {@link Link},
* and whether the {@link Layer} it is in is visible.
* @name GraphObject#visible
* @function.
* @return {boolean}
*/
/** @type {boolean} */
GraphObject.prototype.visible;
Util.exportProperty(GraphObject, 'visible', GraphObject.prototype.visible);
Util.defineProperty(GraphObject, { visible: 'visible' },
  /** @this {GraphObject} */
  function() { return (this._flags & 0x00000001) !== 0; },
  /** @this {GraphObject} */
  function(val) {
    var old = (this._flags & 0x00000001) !== 0;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', GraphObject, 'visible');
      this._flags = this._flags ^ 0x00000001;
      this.raiseChanged('visible', old, val);
      var panel = this.panel;
      if (panel !== null) {
        panel.invalidateMeasure();
      } else {
        if (this instanceof Part) {
          this.invalidateMeasure();
          this.invalidateContainingGroup();
          if (val) {
            this.invalidateLayout(Part.LayoutShown);  // no-op if isUndoingRedoing
            this.updateAdornments();
          } else {
            this.invalidateLayout(Part.LayoutHidden);  // no-op if isUndoingRedoing
            this.clearAdornments();
          }
        }
      }
      this.invalidateDraw();
      this._invalidateNodeLinks();
    }
  }
);

/**
* Gets or sets whether or not this GraphObject can be chosen by visual "find" methods such
* as {@link Diagram#findObjectAt}.
* <p/>
* The default value is true -- mouse events on this object will be noticed.
* If this is a {@link Panel}, not only is this Panel not "hittable", but all of the
* elements inside the Panel will be ignored.
* @name GraphObject#pickable
* @function.
* @return {boolean}
* @see Layer#pickable
* @since 1.2
*/
/** @type {boolean} */
GraphObject.prototype.pickable;
Util.exportProperty(GraphObject, 'pickable', GraphObject.prototype.pickable);
Util.defineProperty(GraphObject, { pickable: 'pickable' },
  /** @this {GraphObject} */
  function() { return (this._flags & 0x00000002) !== 0; },
  /** @this {GraphObject} */
  function(val) {
    var old = (this._flags & 0x00000002) !== 0;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', GraphObject, 'pickable');
      this._flags = this._flags ^ 0x00000002;
      this.raiseChanged('pickable', old, val);
    }
  }
);

/**
* Gets or sets whether the user may draw duplicate Links from this port.
* This property is used by {@link LinkingBaseTool#isValidLink}.
* The default value is false.
* @name GraphObject#fromLinkableDuplicates
* @function.
* @return {boolean}
* @see #fromLinkable
* @see #fromLinkableSelfNode
* @see #toLinkableDuplicates
*/
/** @type {boolean} */
GraphObject.prototype.fromLinkableDuplicates;
Util.exportProperty(GraphObject, 'fromLinkableDuplicates', GraphObject.prototype.fromLinkableDuplicates);
Util.defineProperty(GraphObject, {fromLinkableDuplicates: 'fromLinkableDuplicates'},
  /** @this {GraphObject} */
  function() { return (this._flags & 0x00000004) !== 0; },
  /** @this {GraphObject} */
  function(val) {
    var old = (this._flags & 0x00000004) !== 0;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', GraphObject, 'fromLinkableDuplicates');
      this._flags = this._flags ^ 0x00000004;
      this.raiseChanged('fromLinkableDuplicates', old, val);
    }
  }
);

/**
* Gets or sets whether the user may draw Links that connect from this port's Node.
* This property is used by {@link LinkingBaseTool#isValidLink}.
* The default value is false.
* @name GraphObject#fromLinkableSelfNode
* @function.
* @return {boolean}
* @see #fromLinkable
* @see #fromLinkableDuplicates
* @see #toLinkableSelfNode
*/
/** @type {boolean} */
GraphObject.prototype.fromLinkableSelfNode;
Util.exportProperty(GraphObject, 'fromLinkableSelfNode', GraphObject.prototype.fromLinkableSelfNode);
Util.defineProperty(GraphObject, {fromLinkableSelfNode: 'fromLinkableSelfNode'},
  /** @this {GraphObject} */
  function() { return (this._flags & 0x00000008) !== 0; },
  /** @this {GraphObject} */
  function(val) {
    var old = (this._flags & 0x00000008) !== 0;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', GraphObject, 'fromLinkableSelfNode');
      this._flags = this._flags ^ 0x00000008;
      this.raiseChanged('fromLinkableSelfNode', old, val);
    }
  }
);

/**
* Gets or sets whether the user may draw duplicate Links to this port.
* This property is used by {@link LinkingBaseTool#isValidLink}.
* The default value is false.
* @name GraphObject#toLinkableDuplicates
* @function.
* @return {boolean}
* @see #toLinkable
* @see #toLinkableSelfNode
* @see #fromLinkableDuplicates
*/
/** @type {boolean} */
GraphObject.prototype.toLinkableDuplicates;
Util.exportProperty(GraphObject, 'toLinkableDuplicates', GraphObject.prototype.toLinkableDuplicates);
Util.defineProperty(GraphObject, {toLinkableDuplicates: 'toLinkableDuplicates'},
  /** @this {GraphObject} */
  function() { return (this._flags & 0x00000010) !== 0; },
  /** @this {GraphObject} */
  function(val) {
    var old = (this._flags & 0x00000010) !== 0;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', GraphObject, 'toLinkableDuplicates');
      this._flags = this._flags ^ 0x00000010;
      this.raiseChanged('toLinkableDuplicates', old, val);
    }
  }
);

/**
* Gets or sets whether the user may draw Links that connect to this port's Node.
* This property is used by {@link LinkingBaseTool#isValidLink}.
* The default value is false.
* @name GraphObject#toLinkableSelfNode
* @function.
* @return {boolean}
* @see #toLinkable
* @see #toLinkableDuplicates
* @see #fromLinkableSelfNode
*/
/** @type {boolean} */
GraphObject.prototype.toLinkableSelfNode;
Util.exportProperty(GraphObject, 'toLinkableSelfNode', GraphObject.prototype.toLinkableSelfNode);
Util.defineProperty(GraphObject, {toLinkableSelfNode: 'toLinkableSelfNode'},
  /** @this {GraphObject} */
  function() { return (this._flags & 0x00000020) !== 0; },
  /** @this {GraphObject} */
  function(val) {
    var old = (this._flags & 0x00000020) !== 0;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', GraphObject, 'toLinkableSelfNode');
      this._flags = this._flags ^ 0x00000020;
      this.raiseChanged('toLinkableSelfNode', old, val);
    }
  }
);

/**
* Gets or sets whether a GraphObject is the "main" object for some types of {@link Panel}.
* Panels that use a "main" object include {@link Panel#Auto}, {@link Panel#Spot}, and {@link Panel#Link}.
* <p>
* Panels that use a "main" object will use the first object that has this property set to true,
* or else just the first object, if none have the property set.
* @name GraphObject#isPanelMain
* @function.
* @return {boolean}
*/
/** @type {boolean} */
GraphObject.prototype.isPanelMain;
Util.exportProperty(GraphObject, 'isPanelMain', GraphObject.prototype.isPanelMain);
Util.defineProperty(GraphObject, { isPanelMain: 'isPanelMain' },
  /** @this {GraphObject} */
  function() { return (this._flags & 0x00000040) !== 0; },
  /** @this {GraphObject} */
  function(val) {
    var old = (this._flags & 0x00000040) !== 0;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', GraphObject, 'isPanelMain');
      this._flags = this._flags ^ 0x00000040;
      this.invalidateMeasure();
      this.raiseChanged('isPanelMain', old, val);
    }
  }
);

/**
* This property determines whether or not this GraphObject's events occur
* before all other events, including selection. This enables the {@link #actionDown},
* {@link #actionMove}, {@link #actionUp}, and {@link #actionCancel} events,
* which are all handled by the {@link ActionTool}.
* <p>
* This property is infrequently used -- typically only when implementing objects
* that act as buttons or knobs or sliders.
* The default value is false.
* @name GraphObject#isActionable
* @function.
* @return {boolean}
* @see #actionDown
* @see #actionMove
* @see #actionUp
* @see #actionCancel
*/
/** @type {boolean} */
GraphObject.prototype.isActionable;
Util.exportProperty(GraphObject, 'isActionable', GraphObject.prototype.isActionable);
Util.defineProperty(GraphObject, { isActionable: 'isActionable' },
  /** @this {GraphObject} */
  function() { return (this._flags & 0x00000080) !== 0; },
  /** @this {GraphObject} */
  function(val) {
    var old = (this._flags & 0x00000080) !== 0;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', GraphObject, 'isActionable');
      this._flags = this._flags ^ 0x00000080;
      this.raiseChanged('isActionable', old, val);
    }
  }
);

/**
* Gets or sets the areaBackground Brush of this GraphObject.
* The areaBackground fills the rectangle described by this GraphObject's containing panel's coordinates.
* If the object is rotated, the area background will expand to fill the entire measured bounds of the object,
* without rotating the brush.
* <p>
* The value may be either a {@link Brush} object or a string that is a CSS color.
* The default value is null -- no area background is drawn.
* More information about the syntax of CSS color strings is available at:
* <a href="http://developer.mozilla.org/en-US/docs/Web/CSS/color">CSS colors</a>.
* @name GraphObject#areaBackground
* @function.
* @return {string|Brush}
* @see #background
* @see Shape#fill
*/
/** @type {string|Brush} */
GraphObject.prototype.areaBackground;
Util.exportProperty(GraphObject, 'areaBackground', GraphObject.prototype.areaBackground);
Util.defineProperty(GraphObject, { areaBackground: 'areaBackground' },
  /** @this {GraphObject} */
  function() { return this._areaBackground; },
  /** @this {GraphObject} */
  function(val) {
    var old = this._areaBackground;
    if (old !== val) {
      if (val === null || typeof val === 'string' || val instanceof Brush) {
        if (val instanceof Brush) val.freeze();
        this._areaBackground = val;
        this.invalidateDraw();
        this.raiseChanged('areaBackground', old, val);
      }
    }
  }
);

/**
* Gets or sets the background Brush of this GraphObject,
* filling the rectangle of this object's local coordinate space.
* If the object is rotated, the background will rotate with it.
* <p>
* The value may be either a {@link Brush} object or a string that is a CSS color.
* The default value is null -- no background is drawn.
* More information about the syntax of CSS color strings is available at:
* <a href="http://developer.mozilla.org/en-US/docs/Web/CSS/color">CSS colors</a>.
* @name GraphObject#background
* @function.
* @return {string|Brush}
* @see #areaBackground
* @see Shape#fill
*/
/** @type {string|Brush} */
GraphObject.prototype.background;
Util.exportProperty(GraphObject, 'background', GraphObject.prototype.background);
Util.defineProperty(GraphObject, { background: 'background' },
  /** @this {GraphObject} */
  function() { return this._background; },
  /** @this {GraphObject} */
  function(val) {
    var old = this._background;
    if (old !== val) {
      if (val === null || typeof val === 'string' || val instanceof Brush) {
        if (val instanceof Brush) val.freeze();
        this._background = val;
        this.invalidateDraw();
        this.raiseChanged('background', old, val);
      }
    }
  }
);

/** @ignore @this {GraphObject} */
GraphObject.prototype.getAlreadyShadowed = function() {
  return (this._flags & 0x00000200) !== 0;
};
/** @ignore @this {GraphObject}  @param {boolean} val */
GraphObject.prototype.setAlreadyShadowed = function(val) {
  if (val) {
    this._flags |= 0x00000200;
  } else {
    this._flags &= ~0x00000200;
  }
};

/** @ignore @this {GraphObject} */
GraphObject.prototype.getBindsTwoWay = function() {
  return (this._flags & 0x00000400) !== 0;
};
/** @ignore @this {GraphObject}  @param {boolean} val */
GraphObject.prototype.setBindsTwoWay = function(val) {
  if (val) {
    this._flags |= 0x00000400;
  } else {
    this._flags &= ~0x00000400;
  }
};

/** @ignore @this {GraphObject} */
GraphObject.prototype.getInvalidTransform = function() {
  return (this._flags & 0x00000800) !== 0;
};
/** @ignore @this {GraphObject}  @param {boolean} val */
GraphObject.prototype.setInvalidTransform = function(val) {
  if (val) {
    this._flags |= 0x00000800;
  } else {
    this._flags &= ~0x00000800;
  }
};

/** @ignore @this {GraphObject} */
GraphObject.prototype.getInvalidAllTransforms = function() {
  return (this._flags & 0x00001000) !== 0;
};
/** @ignore @this {GraphObject}  @param {boolean} val */
GraphObject.prototype.setInvalidAllTransforms = function(val) {
  if (val) {
    this._flags |= 0x00001000;
  } else {
    this._flags &= ~0x00001000;
  }
};

/** @ignore @this {GraphObject} */
GraphObject.prototype.getInvalidMeasure = function() {
  return (this._flags & 0x00002000) !== 0;
};
/** @ignore @this {GraphObject}  @param {boolean} val */
GraphObject.prototype.setInvalidMeasure = function(val) {
  if (val) {
    this._flags |= 0x00002000;
  } else {
    this._flags &= ~0x00002000;
  }
};

/** @ignore @this {GraphObject} */
GraphObject.prototype.getInvalidArrange = function() {
  return (this._flags & 0x00004000) !== 0;
};
/** @ignore @this {GraphObject}  @param {boolean} val */
GraphObject.prototype.setInvalidArrange = function(val) {
  if (val) {
    this._flags |= 0x00004000;
  } else {
    this._flags &= ~0x00004000;
  }
};





/**
* Gets the {@link Part} containing this object, if any.
* <p>
* It is common to refer to the containing Part of a GraphObject
* in order to refer to the data to which it is bound.
* <p>
* This property is not settable.
* If you want this GraphObject to belong to a Part, you will need to add it to a Part,
* or else add it to some visual tree structure that is added to a Part using {@link Panel#add}.
* <p>
* Note that for objects such as buttons that are in {@link Adornment}s such as tooltips or context menus,
* this property will return that Adornment, not the Node or Link that is adorned.
* @name GraphObject#part
* @function.
* @return {Part} a Part, perhaps this object itself.
*/
/** @type {Part} */
GraphObject.prototype.part;
Util.defineReadOnlyProperty(GraphObject, { part: 'part' },
  /** @this {GraphObject} */
  function() {
    if (this instanceof Part) return this;
    if (this._part) return this._part;
    var p = this;
    p = p.panel;
    while (p) {
      if (p instanceof Part) {
        this._part = p;
        return p;
      }
      p = p.panel;
    }
    return null;
  }
);

/**
* @ignore
* @this {GraphObject}
* @param {Panel} val
*/
GraphObject.prototype.setPanel = function(val) {
  this._panel = val;
};

/**
* Gets the GraphObject's containing {@link Panel}, or null if this object is not in a Panel.
* <p/>
* Although {@link Part} inherits from this class, a Part will never belong to a Panel.
* <p/>
* This property is not settable.
* Instead, call {@link Panel#add} in order to put a GraphObject in a Panel.
* @name GraphObject#panel
* @function.
* @return {Panel}
*/
/** @type {Panel} */
GraphObject.prototype.panel;
Util.defineReadOnlyProperty(GraphObject, { panel: 'panel' },
  /** @this {GraphObject} */
  function() { return this._panel; }
);

/**
* Gets the GraphObject's containing {@link Layer}, if there is any.
* A plain GraphObject cannot belong directly to a Layer -- only a {@link Part} can belong directly to a Layer.
* <p/>
* This property is not settable.
* Normally one changes which Layer that a GraphObject is in by setting {@link Part#layerName}.
* @name GraphObject#layer
* @function.
* @return {Layer}
*/
/** @type {Layer} */
GraphObject.prototype.layer;
Util.defineReadOnlyProperty(GraphObject, { layer: 'layer' },
  /** @this {GraphObject} */
  function() {
    var gp = this.part;
    if (gp !== null) return gp.layer;
    return null;
  }
);

/**
* Gets the {@link Diagram} that this GraphObject is in, if it is.
* <p/>
* This property is not settable.
* Although you cannot add any plain GraphObject to a Diagram, you can call {@link Diagram#add}
* to add a {@link Part} to a Diagram.
* @name GraphObject#diagram
* @function.
* @return {Diagram}
*/
/** @type {Diagram} */
GraphObject.prototype.diagram;
Util.defineReadOnlyProperty(GraphObject, { diagram: 'diagram' },
  /** @this {GraphObject} */
  function() {
    var gp = this.part;
    if (gp !== null) return gp.diagram;
    return null;
  },
  { 'configurable': true }
);

// Measurement and arrangement:

/**
* Gets or sets the position of this GraphObject in container coordinates
* (either a {@link Panel} or the document).
* Value must be of type Point.
* Default is Point(NaN, NaN).
* <p/>
* For {@link Part}s, see also {@link Part#location}.
* @name GraphObject#position
* @function.
* @return {Point}
*/
/** @type {Point} */
GraphObject.prototype.position;
Util.exportProperty(GraphObject, 'position', GraphObject.prototype.position);
Util.defineProperty(GraphObject, { position: 'position' },
  /** @this {GraphObject} */
  function() { return this._position; },
  /** @this {GraphObject} */
  function(val) {
    var old = this._position;
    if (!old.equals(val)) {
      if (Debug) Util.checkClass(val, Point, GraphObject, 'position');
      val = val.copyFrozen();

      if (this instanceof Part) {
        if (this instanceof Link) return;
        // no-op if you try to set position to NaN and there's a location
        if (!val.isReal()) return;
        var loc = this._location;

        this._position = val;
        // We don't need to invalidate arrange
        if (this.getInvalidArrange() === false) {
          var oldloc = loc.copy();

          var diagram = this.diagram;
          var offx = val.x - old.x;
          var offy = val.y - old.y;
          loc._set(oldloc.x + offx, oldloc.y + offy);

          // Instead of invalidating the arrange
          this._invalidatePosition();
          this._invalidateTransform(); // ??? is this needed?

          // This is needed for viewport optimizations
          // If the position is not validated right away,
          // it might get validated after the Diagram.position has changed, creating a mismatch
          this.validatePosition();
          if (!loc.equals(oldloc) && diagram) {
            //var skips = diagram.skipsUndoManager;
            //diagram.skipsUndoManager = true;
            this.raiseChanged('location', oldloc, loc);
            //diagram.skipsUndoManager = skips;
          }
        } else {
          loc._set(NaN, NaN);
        }
        this.raiseChanged('position', old, val);
        return;
      }
      this._position = val;
      this.invalidateArrange();
      this._invalidateTransform();
      this.raiseChanged('position', old, val);
    }
  }
);

/**
* Gets the bounds of this GraphObject in container coordinates. This means that
* the actualBounds are in the coordinate space of the GraphObject's {@link Panel},
* unless this is a {@link Part}, in which case they are in
* the {@link Diagram}'s coordinate system.
* <p>
* If the GraphObject is a Part,
* then the x and y values of the actualBounds are identical to that Part's {@link #position},
* and the width and height values of the actualBounds represent the rectangular space occupied
* by the Part in {@link Diagram#documentBounds} coordinates.
* <p>
* If the GraphObject is not a top-level object (not a {@link Part}), then the actualBounds
* x and y values represent that GraphObject's position within its Panel. In a Panel of type {@link Panel#Position}
* this is identical to the GraphObject's {@link #position}, but in other cases it is dependent on
* the unique workings of each Panel type. The actualBounds width and height
* of a GraphObject are relative to the compounded transformations of its Panel.
* <p>
* It is possible for a GraphObject (be it an GraphObject or a Panel containing several more GraphObjects)
* to have no containing Part, in which case these GraphObjects cannot possibly be in a Diagram.
* These GraphObjects are unlikely to have real-number values for their actualBounds, as they may
* never have had the chance to be measured and arranged.
* @name GraphObject#actualBounds
* @function.
* @return {Rect}
* @see #measuredBounds
* @see #desiredSize
*/
/** @type {Rect} */
GraphObject.prototype.actualBounds;
Util.defineReadOnlyProperty(GraphObject, { actualBounds: 'actualBounds' },
  /** @this {GraphObject} */
  function() { return this._actualBounds; }
);

/**
* Gets or sets the scale transform of this GraphObject.
* Value must be a number; larger values will make this object appear bigger.
* Default is 1.
* @name GraphObject#scale
* @function.
* @return {number}
* @see #angle
* @see #stretch
*/
/** @type {number} */
GraphObject.prototype.scale;
Util.exportProperty(GraphObject, 'scale', GraphObject.prototype.scale);
Util.defineProperty(GraphObject, { scale: 'scale' },
  /** @this {GraphObject} */
  function() { return this._scale; },
  /** @this {GraphObject} */
  function(val) {
    var old = this._scale;
    if (old !== val) {
      if (Debug) Util.checkRealNumber(val, GraphObject, 'scale');
      if (val <= 0) Util.throwError('GraphObject.scale must be greater than zero');
      this._scale = val;
      this._invalidateTransform();
      this.invalidateMeasure();
      this.raiseChanged('scale', old, val);
    }
  }
);

/**
* Gets or sets the angle transform, in degrees, of this GraphObject.
* Value must be a number. If the value is not between (0 <= val < 360),
* it will be normalized to be in that range.
* Zero is along the positive X-axis; 90 is along the positive Y-axis.
* Default is 0.
* @name GraphObject#angle
* @function.
* @return {number}
* @see #scale
* @see #stretch
*/
/** @type {number} */
GraphObject.prototype.angle;
Util.exportProperty(GraphObject, 'angle', GraphObject.prototype.angle);
Util.defineProperty(GraphObject, { angle: 'angle' },
  /** @this {GraphObject} */
  function() { return this._angle; },
  /** @this {GraphObject} */
  function(val) {
    var old = this._angle;
    if (old !== val) {
      if (Debug) Util.checkRealNumber(val, GraphObject, 'angle');
      val = val % 360;
      if (val < 0) val += 360;
      this._angle = val;
      this.invalidateMeasure();
      this._invalidateTransform();
      this.raiseChanged('angle', old, val);
    }
  }
);

/**
* Gets or sets the desired size of this GraphObject in local coordinates.
* Value must be of type {@link Size}.
* Default is Size(NaN, NaN).
* The size does not include any transformation due to {@link #scale} or {@link #angle},
* nor any pen thickness due to {@link Shape#strokeWidth} if this is a {@link Shape}.
* If there is a containing {@link Panel} the Panel will determine the actual size.
* <p/>
* Getting or setting {@link #width} or {@link #height} is equivalent to getting or setting the
* width or height of this property.
* @name GraphObject#desiredSize
* @function.
* @return {Size}
* @see #minSize
* @see #maxSize
* @see #naturalBounds
* @see #measuredBounds
* @see #actualBounds
*/
/** @type {Size} */
GraphObject.prototype.desiredSize;
Util.exportProperty(GraphObject, 'desiredSize', GraphObject.prototype.desiredSize);
Util.defineProperty(GraphObject, { desiredSize: 'desiredSize' },
  /** @this {GraphObject} */
  function() { return this._desiredSize; },
  /** @this {GraphObject} */
  function(val) {
    var old = this._desiredSize;
    if (!old.equals(val)) {
      if (Debug) Util.checkClass(val, Size, GraphObject, 'desiredSize');
      val = val.copyFrozen();
      this._desiredSize = val;
      this.invalidateMeasure();
      // let Geometry be reset
      if (this instanceof Shape) this.invalidateGeometry();
      this.raiseChanged('desiredSize', old, val);
    }
  }
);

/**
* Gets or sets the desired width of this GraphObject in local coordinates.
* This just gets or sets the width component of the {@link #desiredSize}.
* Default is NaN.
* The width does not include any transformation due to {@link #scale} or {@link #angle},
* nor any pen thickness due to {@link Shape#strokeWidth} if this is a {@link Shape}.
* If there is a containing {@link Panel} the Panel will determine the actual size.
* @name GraphObject#width
* @function.
* @return {number}
*/
/** @type {number} */
GraphObject.prototype.width;
Util.exportProperty(GraphObject, 'width', GraphObject.prototype.width);
Util.defineProperty(GraphObject, { width: 'width' },
  /** @this {GraphObject} */
  function() { return this._desiredSize.width; },
  /** @this {GraphObject} */
  function(val) {
    var old = this._desiredSize.width;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'number', GraphObject, 'width');
      var oldsz = this._desiredSize;
      var newsz = new Size(val, this._desiredSize.height).freeze();
      this._desiredSize = newsz;
      this.invalidateMeasure();
      // let Geometry be reset
      if (this instanceof Shape) this.invalidateGeometry();
      this.raiseChanged('desiredSize', oldsz, newsz);
    }
  }
);

/**
* Gets or sets the desired height of this GraphObject in local coordinates.
* This just gets or sets the height component of the {@link #desiredSize}.
* Default is NaN.
* The height does not include any transformation due to {@link #scale} or {@link #angle},
* nor any pen thickness due to {@link Shape#strokeWidth} if this is a {@link Shape}.
* If there is a containing {@link Panel} the Panel will determine the actual size.
* @name GraphObject#height
* @function.
* @return {number}
*/
/** @type {number} */
GraphObject.prototype.height;
Util.exportProperty(GraphObject, 'height', GraphObject.prototype.height);
Util.defineProperty(GraphObject, { height: 'height' },
  /** @this {GraphObject} */
  function() { return this._desiredSize.height; },
  /** @this {GraphObject} */
  function(val) {
    var old = this._desiredSize.height;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'number', GraphObject, 'height');
      var oldsz = this._desiredSize;
      var newsz = new Size(this._desiredSize.width, val).freeze();
      this._desiredSize = newsz;
      this.invalidateMeasure();
      // let Geometry be reset
      if (this instanceof Shape) this.invalidateGeometry();
      this.raiseChanged('desiredSize', oldsz, newsz);
    }
  }
);

/**
* Gets or sets the minimum size of this GraphObject in container coordinates
* (either a {@link Panel} or the document).
* Any new value must be of type Size; the width and height must not be NaN.
* The default value is zero by zero.
* A containing Panel will determine the actual size of this object.
* @name GraphObject#minSize
* @function.
* @return {Size}
* @see #maxSize
* @see #desiredSize
*/
/** @type {Size} */
GraphObject.prototype.minSize;
Util.exportProperty(GraphObject, 'minSize', GraphObject.prototype.minSize);
Util.defineProperty(GraphObject, { minSize: 'minSize' },
  /** @this {GraphObject} */
  function() { return this._minSize; },
  /** @this {GraphObject} */
  function(val) {
    var old = this._minSize;
    if (!old.equals(val)) {
      if (Debug) Util.checkClass(val, Size, GraphObject, 'minSize');
      val = val.copy();
      if (isNaN(val.width)) val.width = 0;
      if (isNaN(val.height)) val.height = 0;
      val.freeze();
      this._minSize = val;
      this.invalidateMeasure();
      this.raiseChanged('minSize', old, val);
    }
  }
);

/**
* Gets or sets the maximum size of this GraphObject in container coordinates
* (either a {@link Panel} or the document).
* Any new value must be of type Size; the width and height must not be NaN.
* The default value is Infinity by Infinity.
* A containing Panel will determine the actual size of this object.
* @name GraphObject#maxSize
* @function.
* @return {Size}
* @see #minSize
* @see #desiredSize
*/
/** @type {Size} */
GraphObject.prototype.maxSize;
Util.exportProperty(GraphObject, 'maxSize', GraphObject.prototype.maxSize);
Util.defineProperty(GraphObject, { maxSize: 'maxSize' },
  /** @this {GraphObject} */
  function() { return this._maxSize; },
  /** @this {GraphObject} */
  function(val) {
    var old = this._maxSize;
    if (!old.equals(val)) {
      if (Debug) Util.checkClass(val, Size, GraphObject, 'maxSize');
      val = val.copy();
      if (isNaN(val.width)) val.width = Infinity;
      if (isNaN(val.height)) val.height = Infinity;
      val.freeze();
      this._maxSize = val;
      this.invalidateMeasure();
      this.raiseChanged('maxSize', old, val);
    }
  }
);

/**
* Gets the measuredBounds of the GraphObject in container coordinates
* (either a {@link Panel} or the document).
* This describes the transformed bounds with margins excluded.
* Default is null.
* @name GraphObject#measuredBounds
* @function.
* @return {Rect}
* @see #naturalBounds
* @see #desiredSize
* @see #actualBounds
*/
/** @type {Rect} */
GraphObject.prototype.measuredBounds;
Util.defineReadOnlyProperty(GraphObject, { measuredBounds: 'measuredBounds' },
  /** @this {GraphObject} */
  function() { return this._measuredBounds; }
);

/**
* Gets the natural bounding rectangle of this GraphObject in local coordinates,
* before any transformation by {@link #scale} or {@link #angle},
* and before any resizing due to {@link #minSize} or {@link #maxSize} or {@link #stretch}.
* Defaults to unknown (NaN,NaN).
* Can only be changed by changing properties of the particular GraphObject,
* such as {@link Shape#geometry} or {@link TextBlock#font}.
* @name GraphObject#naturalBounds
* @function.
* @return {Rect}
* @see #desiredSize
* @see #measuredBounds
* @see #actualBounds
*/
/** @type {Rect} */
GraphObject.prototype.naturalBounds;
Util.defineReadOnlyProperty(GraphObject, { naturalBounds: 'naturalBounds' },
  /** @this {GraphObject} */
  function() { return this._naturalBounds; },
  { 'configurable': true }
);

/**
* Gets or sets the size of empty area around this GraphObject, as a {@link Margin},
* in the containing {@link Panel} coordinates.
* <p>
* Negative values are permitted but may cause overlaps with adjacent
* objects in a {@link Panel}.
* Default margin is Margin(0,0,0,0).
* <p>
* The property setter accepts a number instead of a Margin object: providing a
* number N will result in using a Margin(N, N, N, N).
* The property getter will always return a Margin.
* @name GraphObject#margin
* @function.
* @return {Margin|number}
* @see #desiredSize
* @see #measuredBounds
* @see #actualBounds
*/
/** @type {Margin|number} */
GraphObject.prototype.margin;
Util.exportProperty(GraphObject, 'margin', GraphObject.prototype.margin);
Util.defineProperty(GraphObject, { margin: 'margin' },
  /** @this {GraphObject} */
  function() { return this._margin; },
  /** @this {GraphObject} */
  function(val) {
    if (typeof val === 'number') {
      val = new Margin(val);
    } else {
      if (Debug) Util.checkClass(val, Margin, GraphObject, 'margin');
    }
    var old = this._margin;
    if (!old.equals(val)) {
      val = val.copyFrozen();
      this._margin = val;
      this.invalidateMeasure();
      this.raiseChanged('margin', old, val);
    }
  }
);

/**
* @ignore
* Gets the GraphObject's transformation matrix
* @name GraphObject#transform
* @function.
* @return {Transform}
*/
/** @type {Transform} */
GraphObject.prototype.transform;
Util.defineReadOnlyProperty(GraphObject, { transform: null },
  /** @this {GraphObject} */
  function() {
    if (this.getInvalidTransform() === true) { this._validateTransforms(); }
    return this._transform;
  }
);

/**
* @ignore
* Gets a transformation matrix with respect to document coordinates describing
* all transforms operated on the object's coordinates, including the
* GraphObject's own transform. Modified by changes to the position, scale,
* and angle properties.
* @name GraphObject#allTransforms
* @function.
* @return {Transform}
*/
/** @type {Transform} */
GraphObject.prototype.allTransforms;
Util.defineReadOnlyProperty(GraphObject, { allTransforms: null },
  /** @this {GraphObject} */
  function() {
    if (this.getInvalidAllTransforms() === true) { this._validateTransforms(); } // not guaranteed to validate allTransforms ?
    return this._allTransforms;
  }
);


/**********************************************************
Panel-specific properties:
***********************************************************/

/**
* Gets or sets the alignment {@link Spot} of this GraphObject used in {@link Panel} layouts,
* to determine where in the area allocated by the panel this object should be placed.
* <p>
* The default value is Spot.Default, which lets the Panel determine the Spot using
* {@link Panel#defaultAlignment}. If that property is also Spot.Default,
* then the alignment spot will be different depending on the Panel type.
* <p>
* The {@link #alignmentFocus} is often used along with this property to specify
* where this object should be positioned in a Panel.
* @name GraphObject#alignment
* @function.
* @return {Spot}
* @see #alignmentFocus
* @see Panel#defaultAlignment
*/
/** @type {Spot} */
GraphObject.prototype.alignment;
Util.exportProperty(GraphObject, 'alignment', GraphObject.prototype.alignment);
Util.defineProperty(GraphObject, { alignment: 'alignment' },
  /** @this {GraphObject} */
  function() { return this._alignment; },
  /** @this {GraphObject} */
  function(val) {
    var old = this._alignment;
    if (!old.equals(val)) {
      if (Debug) Util.checkClass(val, Spot, GraphObject, 'alignment');
      else if (val.isNoSpot() && !val.isDefault()) {
        Util.throwError('alignment must be a real Spot or Spot.Default');
      }
      val = val.copyFrozen();
      this._alignment = val;
      this.invalidateArrange();
      this.raiseChanged('alignment', old, val);
    }
  }
);


/**
* Gets or sets the column of this GraphObject if it is in a Table {@link Panel}.
* The value cannot be negative. The default is 0.
* @name GraphObject#column
* @function.
* @return {number}
*/
/** @type {number} */
GraphObject.prototype.column;
Util.exportProperty(GraphObject, 'column', GraphObject.prototype.column);
Util.defineProperty(GraphObject, { column: 'column' },
  /** @this {GraphObject} */
  function() { return this._column; },
  /** @this {GraphObject} */
  function(val) {
    if (Debug) Util.checkRealNumber(val, GraphObject, 'column');
    val = Math.round(val);
    var old = this._column;
    if (old !== val) {
      if (val < 0) Util.throwRangeError(val, '>= 0', GraphObject, 'column');
      this._column = val;
      this.invalidateMeasure();
      this.raiseChanged('column', old, val);
    }
  }
);

/**
* Gets or sets the number of columns spanned by this GraphObject if it is in a Table {@link Panel}.
* The value cannot be negative or zero. The default is 1.
* @name GraphObject#columnSpan
* @function.
* @return {number}
*/
/** @type {number} */
GraphObject.prototype.columnSpan;
Util.exportProperty(GraphObject, 'columnSpan', GraphObject.prototype.columnSpan);
Util.defineProperty(GraphObject, { columnSpan: 'columnSpan' },
  /** @this {GraphObject} */
  function() { return this._columnSpan; },
  /** @this {GraphObject} */
  function(val) {
    if (Debug) Util.checkRealNumber(val, GraphObject, 'columnSpan');
    val = Math.round(val);
    var old = this._columnSpan;
    if (old !== val) {
      if (val < 1) Util.throwRangeError(val, '>= 1', GraphObject, 'columnSpan');
      this._columnSpan = val;
      this.invalidateMeasure();
      this.raiseChanged('columnSpan', old, val);
    }
  }
);

/**
* Gets or sets the row of this GraphObject if it is in a Table {@link Panel}.
* The value cannot be negative. The default is 0.
* @name GraphObject#row
* @function.
* @return {number}
*/
/** @type {number} */
GraphObject.prototype.row;
Util.exportProperty(GraphObject, 'row', GraphObject.prototype.row);
Util.defineProperty(GraphObject, { row: 'row' },
  /** @this {GraphObject} */
  function() { return this._row; },
  /** @this {GraphObject} */
  function(val) {
    if (Debug) Util.checkRealNumber(val, GraphObject, 'row');
    val = Math.round(val);
    var old = this._row;
    if (old !== val) {
      if (val < 0) Util.throwRangeError(val, '>= 0', GraphObject, 'row');
      this._row = val;
      this.invalidateMeasure();
      this.raiseChanged('row', old, val);
    }
  }
);

/**
* Gets or sets the number of rows spanned by this GraphObject if it is in a Table {@link Panel}.
* The value cannot be negative or zero. The default is 1.
* @name GraphObject#rowSpan
* @function.
* @return {number}
*/
/** @type {number} */
GraphObject.prototype.rowSpan;
Util.exportProperty(GraphObject, 'rowSpan', GraphObject.prototype.rowSpan);
Util.defineProperty(GraphObject, { rowSpan: 'rowSpan' },
  /** @this {GraphObject} */
  function() { return this._rowSpan; },
  /** @this {GraphObject} */
  function(val) {
    if (Debug) Util.checkRealNumber(val, GraphObject, 'rowSpan');
    val = Math.round(val);
    var old = this._rowSpan;
    if (old !== val) {
      if (val < 1) Util.throwRangeError(val, '>= 1', GraphObject, 'rowSpan');
      this._rowSpan = val;
      this.invalidateMeasure();
      this.raiseChanged('rowSpan', old, val);
    }
  }
);

/**
* Gets or sets the spot on this GraphObject to be used as the alignment point
* in Spot and Fixed {@link Panel}s.
* Value must be of the Spot.
* <p>
* The default value is Spot.Default, which means that the Panel type can decide the effective alignment spot.
* <p>
* The {@link #alignment} is often used along with this property to specify
* where this object should be positioned in a Panel.
* @name GraphObject#alignmentFocus
* @function.
* @return {Spot}
*/
/** @type {Spot} */
GraphObject.prototype.alignmentFocus;
Util.exportProperty(GraphObject, 'alignmentFocus', GraphObject.prototype.alignmentFocus);
Util.defineProperty(GraphObject, { alignmentFocus: 'alignmentFocus' },
  /** @this {GraphObject} */
  function() { return this._alignmentFocus; },
  /** @this {GraphObject} */
  function(val) {
    var old = this._alignmentFocus;
    if (!old.equals(val)) {
      if (Debug) Util.checkClass(val, Spot, GraphObject, 'alignmentFocus');
      else if (val.isNoSpot() && !val.isDefault()) {
        Util.throwError('alignmentFocus must be a real Spot or Spot.Default');
      }
      val = val.copyFrozen();
      this._alignmentFocus = val;
      // ?? changing this to invalidateArrange broke tests
      this.invalidateMeasure();
      this.raiseChanged('alignmentFocus', old, val);
    }
  }
);


/**********************************************************
Port-specific properties:
***********************************************************/

/**
* Gets or sets an identifier for an object acting as a port on a Node.
* The default value is null -- this object is not a port.
* <p>
* A value that is the empty string is used by convention to mean the primary
* (and usually only) port of the node.
* <p>
* If a Node has no named ports, then the Node itself is the sole port.
* <p>
* The value should be unique within the {@link Node}.
* You must not modify this property once this GraphObject is in the visual tree of a Node.
* <p class="box">
* See <a href="../../intro/ports.html">the Introduction page on ports</a>
* for usage information and examples.
* @name GraphObject#portId
* @function.
* @return {string}
* @see #fromLinkable
* @see #toLinkable
* @see #fromSpot
* @see #toSpot
* @see Link#fromSpot
* @see Link#toSpot
*/
/** @type {string} */
GraphObject.prototype.portId;
Util.exportProperty(GraphObject, 'portId', GraphObject.prototype.portId);
Util.defineProperty(GraphObject, { portId: 'portId' },
  /** @this {GraphObject} */
  function() { return this._portId; },
  /** @this {GraphObject} */
  function(val) {
    var old = this._portId;
    if (old !== val) {
      if (Debug && val !== null) Util.checkPrimitive(val, 'string', GraphObject, 'portId');
      var node = this.part;
      if (node !== null && !(node instanceof Node)) {
        Util.throwError('portID being set on a Link: ' + val);
        node = null;
      }
      if (old !== null && node) {
        node.internalRemovePort(this);
      }
      this._portId = val;
      if (val !== null && node) {
        node._hasNamedPorts = true;
        // if the Node's cached Map of ports is invalid, rebuild it before adding this port
        if (node._ports === null) node._rebuildPorts();
        node.internalAddPort(this);
      }
      this.raiseChanged('portId', old, val);
    }
  }
);

/**
* @ignore
* Recurse to the Part and then return the deepest visible object all of whose panels are visible.
* @this {GraphObject}
* @return {GraphObject}
*/
GraphObject.prototype.findVisiblePort = function() {
  var refvis = { value: null };  // out reference parameter
  this.findVisiblePort1(refvis);
  return refvis.value;
};


/**
* @ignore
* Recurse to the Part and then return the deepest visible object all of whose panels are visible.
* @this {GraphObject}
* @param {Object} refvis  holds the return value.
* @return {boolean}
*/
GraphObject.prototype.findVisiblePort1 = function(refvis) {
  // terminate recursion at the Part, normally a Node
  var pan = this.panel;
  if (pan === null) {
    refvis.value = this;
    return false;
  }
  // recurse up the visual tree
  var found = pan.findVisiblePort1(refvis);
  if (found) return true;
  if (this.visible) {
    refvis.value = this;
    return false;
  } else {  // not visible: just return the REFVIS value
    return true;
  }
};

/**
* @ignore
* @this {GraphObject}
*/
GraphObject.prototype._invalidateNodeLinks = function() {
  // no-op if isUndoingRedoing checked in invalidateConnectedLinks
  var node = this.part;
  if (node instanceof Node) {
    var diagram = this.diagram;
    if (diagram && !diagram.undoManager.isUndoingRedoing) node.invalidateConnectedLinks();
  }
};

/// for links coming into a port:

/**
* Gets or sets where a link should connect to this port.
* The default value is {@link Spot#None}, meaning that the link routing
* must consider the shape of the port and connect to closest point.
* <p>
* For examples of how to use this property, see <a href="../../intro/connectionPoints.html">Link Connection Points</a>.
* @name GraphObject#toSpot
* @function.
* @return {Spot}
* @see #fromSpot
* @see Link#toSpot
* @see #portId
*/
/** @type {Spot} */
GraphObject.prototype.toSpot;
Util.exportProperty(GraphObject, 'toSpot', GraphObject.prototype.toSpot);
Util.defineProperty(GraphObject, {toSpot: 'toSpot'},
  /** @this {GraphObject} */
  function() { return this._linkSettings !== null ? this._linkSettings._toSpot : Spot.None; },
  /** @this {GraphObject} */
  function(val) {
    if (this._linkSettings === null) this.initLinkSettings();
    var old = this._linkSettings._toSpot;
    if (!old.equals(val)) {
      if (Debug) Util.checkClass(val, Spot, GraphObject, 'toSpot');
      val = val.copyFrozen();
      this._linkSettings._toSpot = val;
      this.raiseChanged('toSpot', old, val);
      this._invalidateNodeLinks();
    }
  }
);

/**
* Gets or sets the length of the last segment of a link going to this port.
* This value is used when the computed "to spot" is not Spot.None.
* The default value is 10.
* @name GraphObject#toEndSegmentLength
* @function.
* @return {number}
* @see #fromEndSegmentLength
* @see Link#toEndSegmentLength
* @see #portId
*/
/** @type {number} */
GraphObject.prototype.toEndSegmentLength;
Util.exportProperty(GraphObject, 'toEndSegmentLength', GraphObject.prototype.toEndSegmentLength);
Util.defineProperty(GraphObject, {toEndSegmentLength: 'toEndSegmentLength'},
  /** @this {GraphObject} */
  function() { return this._linkSettings !== null ? this._linkSettings._toEndSegmentLength : 10; },
  /** @this {GraphObject} */
  function(val) {
    if (this._linkSettings === null) this.initLinkSettings();
    var old = this._linkSettings._toEndSegmentLength;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'number', GraphObject, 'toEndSegmentLength');
      if (val < 0) Util.throwRangeError(val, '>= 0', GraphObject, 'toEndSegmentLength');
      this._linkSettings._toEndSegmentLength = val;
      this.raiseChanged('toEndSegmentLength', old, val);
      this._invalidateNodeLinks();
    }
  }
);

/**
* Gets or sets how the direction of the last segment of a link going to this port is computed when the node is rotated.
* This value is used by {@link Link#getLinkDirection}.
* <p>
* The value must be one of {@link Node#DirectionAbsolute},
* {@link Node#DirectionRotatedNode}, or {@link Node#DirectionRotatedNodeOrthogonal}.
* The default value is {@link Node#DirectionRotatedNodeOrthogonal}.
* @name GraphObject#toEndSegmentDirection
* @function.
* @return {EnumValue}
* @see #fromEndSegmentDirection
* @see Link#toEndSegmentDirection
* @see #portId
*/
/** @type {EnumValue} */
GraphObject.prototype.toEndSegmentDirection;
Util.exportProperty(GraphObject, 'toEndSegmentDirection', GraphObject.prototype.toEndSegmentDirection);
Util.defineProperty(GraphObject, {toEndSegmentDirection: 'toEndSegmentDirection'},
  /** @this {GraphObject} */
  function() { return this._linkSettings !== null ? this._linkSettings._toEndSegmentDirection : Node.DirectionRotatedNodeOrthogonal; },
  /** @this {GraphObject} */
  function(val) {
    if (this._linkSettings === null) this.initLinkSettings();
    var old = this._linkSettings._toEndSegmentDirection;
    if (old !== val) {
      if (Debug) Util.checkEnumValue(val, Node, GraphObject, 'toEndSegmentDirection');
      this._linkSettings._toEndSegmentDirection = val;
      this.raiseChanged('toEndSegmentDirection', old, val);
      this._invalidateNodeLinks();
    }
  }
);

/**
* Gets or sets how far the end segment of a link going to this port stops short of the actual port.
* Negative values cause the link to extend into the port.
* The default value is zero.
* <p/>
* This property is useful when you have a thick link and a pointy arrowhead.
* Normally the link Shape extends all the way to the end of the arrowhead.
* If the link Shape is wide, its edges will be seen behind the arrowhead.
* By setting this property to a small positive value, the link Shape can end within the
* body of the arrowhead, leaving only the point of the arrowhead visible at the end of the link.
* <p/>
* A negative value for this property can also be useful when you want the link Shape to continue
* into the port, perhaps because a portion of the port is transparent and you want the link to
* appear to connect visually with a different point on the node.
* @name GraphObject#toShortLength
* @function.
* @return {number}
* @see #fromShortLength
* @see Link#toShortLength
* @see #portId
*/
/** @type {number} */
GraphObject.prototype.toShortLength;
Util.exportProperty(GraphObject, 'toShortLength', GraphObject.prototype.toShortLength);
Util.defineProperty(GraphObject, {toShortLength: 'toShortLength'},
  /** @this {GraphObject} */
  function() { return this._linkSettings !== null ? this._linkSettings._toShortLength : 0; },
  /** @this {GraphObject} */
  function(val) {
    if (this._linkSettings === null) this.initLinkSettings();
    var old = this._linkSettings._toShortLength;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'number', GraphObject, 'toShortLength');
      this._linkSettings._toShortLength = val;
      this.raiseChanged('toShortLength', old, val);
      this._invalidateNodeLinks();
    }
  }
);

/**
* Gets or sets whether the user may draw Links to this port.
* This property is used by {@link LinkingBaseTool#isValidTo}.
* <p>
* The default value is null, which indicates that the real value is inherited from
* the parent {@link Panel}, or false if there is no containing panel.
* @name GraphObject#toLinkable
* @function.
* @return {?boolean}
* @see #fromLinkable
* @see #toMaxLinks
* @see #portId
* @see #cursor
*/
/** @type {?boolean} */
GraphObject.prototype.toLinkable;
Util.exportProperty(GraphObject, 'toLinkable', GraphObject.prototype.toLinkable);
Util.defineProperty(GraphObject, {toLinkable: 'toLinkable'},
  /** @this {GraphObject} */
  function() { return this._toLinkable; },
  /** @this {GraphObject} */
  function(val) {
    var old = this._toLinkable;
    if (old !== val) {
      if (Debug && val !== null) Util.checkPrimitive(val, 'boolean', GraphObject, 'toLinkable');
      this._toLinkable = val;
      this.raiseChanged('toLinkable', old, val);
    }
  }
);

/**
* Gets or sets the maximum number of links that may go into this port.
* This property is used by {@link LinkingBaseTool#isValidTo}.
* <p>
* The value must be non-negative.
* The default value is Infinity.
* @name GraphObject#toMaxLinks
* @function.
* @return {number}
* @see #toLinkable
* @see #fromMaxLinks
* @see #portId
*/
/** @type {number} */
GraphObject.prototype.toMaxLinks;
Util.exportProperty(GraphObject, 'toMaxLinks', GraphObject.prototype.toMaxLinks);
Util.defineProperty(GraphObject, {toMaxLinks: 'toMaxLinks'},
  /** @this {GraphObject} */
  function() { return this._toMaxLinks; },
  /** @this {GraphObject} */
  function(val) {
    var old = this._toMaxLinks;
    if (old !== val) {
      if (Debug) Util.checkRealNumber(val, GraphObject, 'toMaxLinks');
      if (val < 0) Util.throwRangeError(val, '>= 0', GraphObject, 'toMaxLinks');
      this._toMaxLinks = val;
      this.raiseChanged('toMaxLinks', old, val);
    }
  }
);

/// for links going out of a port:

/**
* Gets or sets where a link should connect from this port.
* The default value is {@link Spot#None}, meaning that the link routing
* must consider the shape of the port and connect at closest point.
* <p>
* For examples of how to use this property, see <a href="../../intro/connectionPoints.html">Link Connection Points</a>.
* @name GraphObject#fromSpot
* @function.
* @return {Spot}
* @see #toSpot
* @see Link#fromSpot
* @see #portId
*/
/** @type {Spot} */
GraphObject.prototype.fromSpot;
Util.exportProperty(GraphObject, 'fromSpot', GraphObject.prototype.fromSpot);
Util.defineProperty(GraphObject, {fromSpot: 'fromSpot'},
  /** @this {GraphObject} */
  function() { return this._linkSettings !== null ? this._linkSettings._fromSpot : Spot.None; },
  /** @this {GraphObject} */
  function(val) {
    if (this._linkSettings === null) this.initLinkSettings();
    var old = this._linkSettings._fromSpot;
    if (!old.equals(val)) {
      if (Debug) Util.checkClass(val, Spot, GraphObject, 'fromSpot');
      val = val.copyFrozen();
      this._linkSettings._fromSpot = val;
      this.raiseChanged('fromSpot', old, val);
      this._invalidateNodeLinks();
    }
  }
);

/**
* Gets or sets the length of the last segment of a link coming from this port.
* This value is used when the computed "from spot" is not Spot.None.
* The default value is 10.
* @name GraphObject#fromEndSegmentLength
* @function.
* @return {number}
* @see #toEndSegmentLength
* @see Link#fromEndSegmentLength
* @see #portId
*/
/** @type {number} */
GraphObject.prototype.fromEndSegmentLength;
Util.exportProperty(GraphObject, 'fromEndSegmentLength', GraphObject.prototype.fromEndSegmentLength);
Util.defineProperty(GraphObject, {fromEndSegmentLength: 'fromEndSegmentLength'},
  /** @this {GraphObject} */
  function() { return this._linkSettings !== null ? this._linkSettings._fromEndSegmentLength : 10; },
  /** @this {GraphObject} */
  function(val) {
    if (this._linkSettings === null) this.initLinkSettings();
    var old = this._linkSettings._fromEndSegmentLength;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'number', GraphObject, 'fromEndSegmentLength');
      if (val < 0) Util.throwRangeError(val, '>= 0', GraphObject, 'fromEndSegmentLength');
      this._linkSettings._fromEndSegmentLength = val;
      this.raiseChanged('fromEndSegmentLength', old, val);
      this._invalidateNodeLinks();
    }
  }
);

/**
* Gets or sets how the direction of the last segment of a link coming from this port is computed when the node is rotated.
* This value is used by {@link Link#getLinkDirection}.
* <p>
* The value must be one of {@link Node#DirectionAbsolute},
* {@link Node#DirectionRotatedNode}, or {@link Node#DirectionRotatedNodeOrthogonal}.
* The default value is {@link Node#DirectionRotatedNodeOrthogonal}.
* @name GraphObject#fromEndSegmentDirection
* @function.
* @return {EnumValue}
* @see #toEndSegmentDirection
* @see Link#fromEndSegmentDirection
* @see #portId
*/
/** @type {EnumValue} */
GraphObject.prototype.fromEndSegmentDirection;
Util.exportProperty(GraphObject, 'fromEndSegmentDirection', GraphObject.prototype.fromEndSegmentDirection);
Util.defineProperty(GraphObject, {fromEndSegmentDirection: 'fromEndSegmentDirection'},
  /** @this {GraphObject} */
  function() { return this._linkSettings !== null ? this._linkSettings._fromEndSegmentDirection : Node.DirectionRotatedNodeOrthogonal; },
  /** @this {GraphObject} */
  function(val) {
    if (this._linkSettings === null) this.initLinkSettings();
    var old = this._linkSettings._fromEndSegmentDirection;
    if (old !== val) {
      if (Debug) Util.checkEnumValue(val, Node, GraphObject, 'fromEndSegmentDirection');
      this._linkSettings._fromEndSegmentDirection = val;
      this.raiseChanged('fromEndSegmentDirection', old, val);
      this._invalidateNodeLinks();
    }
  }
);

/**
* Gets or sets how far the end segment of a link coming from this port stops short of the actual port.
* Negative values cause the link to extend into the port.
* The default value is zero.
* <p/>
* This property is useful when you have a thick link and a pointy arrowhead.
* Normally the link Shape extends all the way to the end of the arrowhead.
* If the link Shape is wide, its edges will be seen behind the arrowhead.
* By setting this property to a small positive value, the link Shape can end within the
* body of the arrowhead, leaving only the point of the arrowhead visible at the end of the link.
* <p/>
* A negative value for this property can also be useful when you want the link Shape to continue
* into the port, perhaps because a portion of the port is transparent and you want the link to
* appear to connect visually with a different point on the node.
* @name GraphObject#fromShortLength
* @function.
* @return {number}
* @see #toShortLength
* @see Link#fromShortLength
* @see #portId
*/
/** @type {number} */
GraphObject.prototype.fromShortLength;
Util.exportProperty(GraphObject, 'fromShortLength', GraphObject.prototype.fromShortLength);
Util.defineProperty(GraphObject, {fromShortLength: 'fromShortLength'},
  /** @this {GraphObject} */
  function() { return this._linkSettings !== null ? this._linkSettings._fromShortLength : 0; },
  /** @this {GraphObject} */
  function(val) {
    if (this._linkSettings === null) this.initLinkSettings();
    var old = this._linkSettings._fromShortLength;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'number', GraphObject, 'fromShortLength');
      this._linkSettings._fromShortLength = val;
      this.raiseChanged('fromShortLength', old, val);
      this._invalidateNodeLinks();
    }
  }
);

/**
* Gets or sets whether the user may draw Links from this port.
* This property is used by {@link LinkingBaseTool#isValidFrom}.
* <p>
* The default value is null, which indicates that the real value is inherited from
* the parent {@link Panel}, or false if there is no containing panel.
* @name GraphObject#fromLinkable
* @function.
* @return {?boolean}
* @see #toLinkable
* @see #fromMaxLinks
* @see #portId
* @see #cursor
*/
/** @type {?boolean} */
GraphObject.prototype.fromLinkable;
Util.exportProperty(GraphObject, 'fromLinkable', GraphObject.prototype.fromLinkable);
Util.defineProperty(GraphObject, {fromLinkable: 'fromLinkable'},
  /** @this {GraphObject} */
  function() { return this._fromLinkable; },
  /** @this {GraphObject} */
  function(val) {
    var old = this._fromLinkable;
    if (old !== val) {
      if (Debug && val !== null) Util.checkPrimitive(val, 'boolean', GraphObject, 'fromLinkable');
      this._fromLinkable = val;
      this.raiseChanged('fromLinkable', old, val);
    }
  }
);

/**
* Gets or sets the maximum number of links that may come out of this port.
* This property is used by {@link LinkingBaseTool#isValidFrom}.
* <p>
* The value must be non-negative.
* The default value is Infinity.
* @name GraphObject#fromMaxLinks
* @function.
* @return {number}
* @see #fromLinkable
* @see #toMaxLinks
* @see #portId
*/
/** @type {number} */
GraphObject.prototype.fromMaxLinks;
Util.exportProperty(GraphObject, 'fromMaxLinks', GraphObject.prototype.fromMaxLinks);
Util.defineProperty(GraphObject, {fromMaxLinks: 'fromMaxLinks'},
  /** @this {GraphObject} */
  function() { return this._fromMaxLinks; },
  /** @this {GraphObject} */
  function(val) {
    var old = this._fromMaxLinks;
    if (old !== val) {
      if (Debug) Util.checkRealNumber(val, GraphObject, 'fromMaxLinks');
      if (val < 0) Util.throwRangeError(val, '>= 0', GraphObject, 'fromMaxLinks');
      this._fromMaxLinks = val;
      this.raiseChanged('fromMaxLinks', old, val);
    }
  }
);


/**********************************************************
Event Handling:
***********************************************************/

/**
* Gets or sets the mouse cursor to use when the mouse is over this object with no mouse buttons pressed.
* The value is null when no particular cursor is specified for this object;
* the actual cursor is determined by any containing {@link Panel}.
* <p>
* The default value is the empty string, which means the
* current mouse cursor is determined by the Diagram.
* Other strings should be valid CSS strings that specify a cursor.
* This provides some more information about cursor syntax:
* <a href="http://developer.mozilla.org/en-US/docs/Web/CSS/cursor">CSS cursors</a>.
* @name GraphObject#cursor
* @function.
* @return {string}
* @see Diagram#defaultCursor
* @see Diagram#currentCursor
*/
/** @type {string} */
GraphObject.prototype.cursor;
Util.exportProperty(GraphObject, 'cursor', GraphObject.prototype.cursor);
Util.defineProperty(GraphObject, { cursor: 'cursor' },
  /** @this {GraphObject} */
  function() { return this._cursor; },
  /** @this {GraphObject} */
  function(val) {
    var old = this._cursor;
    if (old !== val) {
      Util.checkPrimitive(val, 'string', GraphObject, 'cursor');
      this._cursor = val;
      this.raiseChanged('cursor', old, val);
    }
  }
);

/**
* Gets or sets the function to execute when the user single-primary-clicks on this object.
* This typically involves a mouse-down followed by a prompt mouse-up
* at approximately the same position using the left (primary) mouse button.
* This property is used by the {@link ClickSelectingTool}
* when the user clicks on a {@link GraphObject}.
* The function is called in addition to the {@link DiagramEvent}
* that is raised with the name "ObjectSingleClicked".
* <p/>
* If this property value is a function, it is called with an {@link InputEvent}
* and this {@link GraphObject}.
* The {@link InputEvent#targetObject} provides the GraphObject that was found
* at the mouse point before looking up the visual tree of {@link GraphObject#panel}s
* to get to this object.
* By default this property is null.
* <p/>
* If you do provide a function that makes changes to the diagram or to its model,
* you should do so within a transaction -- call {@link Diagram#startTransaction} and
* {@link Diagram#commitTransaction}.
* <p/>
* An example of a click event handler is shown in the
* <a href="../../samples/arrowheads.html">Arrowheads sample</a>.
* @name GraphObject#click
* @function.
* @return {function(InputEvent, GraphObject) | null}
* @see #doubleClick
* @see #contextClick
* @see Diagram#click
*/
/** @type {function(InputEvent, GraphObject) | null} */
GraphObject.prototype.click;
Util.exportProperty(GraphObject, 'click', GraphObject.prototype.click);
Util.defineProperty(GraphObject, { click: 'click' },
  /** @this {GraphObject} */
  function() { return this._eventHandlers !== null ? this._eventHandlers._click : null; },
  /** @this {GraphObject} */
  function(val) {
    if (this._eventHandlers === null) this.initEventHandlers();
    var old = this._eventHandlers._click;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', GraphObject, 'click');
      this._eventHandlers._click = val;
      this.raiseChanged('click', old, val);
    }
  }
);

/**
* Gets or sets the function to execute when the user double-primary-clicks on this object.
* This typically involves a mouse-down/up/down/up in rapid succession
* at approximately the same position using the left (primary) mouse button.
* This property is used by the {@link ClickSelectingTool}
* when the user clicks on a {@link GraphObject}.
* The function is called in addition to the {@link DiagramEvent}
* that is raised with the name "ObjectDoubleClicked".
* <p/>
* If this property value is a function, it is called with an {@link InputEvent}
* and this {@link GraphObject}.
* The {@link InputEvent#targetObject} provides the GraphObject that was found
* at the mouse point before looking up the visual tree of {@link GraphObject#panel}s
* to get to this object.
* By default this property is null.
* <p/>
* If you do provide a function that makes changes to the diagram or to its model,
* you should do so within a transaction -- call {@link Diagram#startTransaction} and
* {@link Diagram#commitTransaction}.
* <p/>
* The <a href="../../samples/classHierarchy.html">Class Hierarchy sample</a>
* demonstrates the definition of a double-click event handler that opens up
* a web page with the documentation for that class:
* <pre>
* diagram.nodeTemplate =
*   $(go.Node, . . .,
*     {
*       doubleClick:  // here the second argument is this object, which is this Node
*         function(e, node) { window.open("../api/symbols/" + node.data.key + ".html"); }
*     },
*     . . .
*     );
* </pre>
* @name GraphObject#doubleClick
* @function.
* @return {function(InputEvent, GraphObject) | null}
* @see #click
* @see #contextClick
* @see Diagram#doubleClick
*/
/** @type {function(InputEvent, GraphObject) | null} */
GraphObject.prototype.doubleClick;
Util.exportProperty(GraphObject, 'doubleClick', GraphObject.prototype.doubleClick);
Util.defineProperty(GraphObject, { doubleClick: 'doubleClick' },
  /** @this {GraphObject} */
  function() { return this._eventHandlers !== null ? this._eventHandlers._doubleClick : null; },
  /** @this {GraphObject} */
  function(val) {
    if (this._eventHandlers === null) this.initEventHandlers();
    var old = this._eventHandlers._doubleClick;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', GraphObject, 'doubleClick');
      this._eventHandlers._doubleClick = val;
      this.raiseChanged('doubleClick', old, val);
    }
  }
);

/**
* Gets or sets the function to execute when the user single-secondary-clicks on this object.
* This typically involves a mouse-down followed by a prompt mouse-up
* at approximately the same position using the right (secondary) mouse button.
* This property is used by the {@link ClickSelectingTool}
* when the user clicks on a {@link GraphObject}.
* The function is called in addition to the {@link DiagramEvent}
* that is raised with the name "ObjectContextClicked".
* <p/>
* If this property value is a function, it is called with an {@link InputEvent}
* and this {@link GraphObject}.
* The {@link InputEvent#targetObject} provides the GraphObject that was found
* at the mouse point before looking up the visual tree of {@link GraphObject#panel}s
* to get to this object.
* By default this property is null.
* <p/>
* If you do provide a function that makes changes to the diagram or to its model,
* you should do so within a transaction -- call {@link Diagram#startTransaction} and
* {@link Diagram#commitTransaction}.
* @name GraphObject#contextClick
* @function.
* @return {function(InputEvent, GraphObject) | null}
* @see #click
* @see #doubleClick
* @see Diagram#contextClick
*/
/** @type {function(InputEvent, GraphObject) | null} */
GraphObject.prototype.contextClick;
Util.exportProperty(GraphObject, 'contextClick', GraphObject.prototype.contextClick);
Util.defineProperty(GraphObject, { contextClick: 'contextClick' },
  /** @this {GraphObject} */
  function() { return this._eventHandlers !== null ? this._eventHandlers._contextClick : null; },
  /** @this {GraphObject} */
  function(val) {
    if (this._eventHandlers === null) this.initEventHandlers();
    var old = this._eventHandlers._contextClick;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', GraphObject, 'contextClick');
      this._eventHandlers._contextClick = val;
      this.raiseChanged('contextClick', old, val);
    }
  }
);

/**
* Gets or sets the function to execute when the user moves the mouse
* into this object without holding down any buttons.
* This property is used by the {@link ToolManager}.
* <p/>
* If this property value is a function, it is called with an {@link InputEvent},
* this {@link GraphObject}, and any previous {@link GraphObject} that the mouse was in.
* The {@link InputEvent#targetObject} provides the GraphObject that was found
* at the mouse point before looking up the visual tree of {@link GraphObject#panel}s
* to get to this object.
* By default this property is null.
* <p/>
* This function is called with {@link Diagram#skipsUndoManager} temporarily set to true,
* so that any changes to {@link GraphObject}s are not recorded in the {@link UndoManager}.
* You do not need to start and commit any transaction in this function.
* After calling this function the diagram will be updated immediately.
* <p/>
* For example, consider the situation where one wants to display buttons that the user can click
* whenever the user passes the mouse over a node, and the buttons automatically disappear when the
* mouse leaves the node.  This can be implemented by showing an Adornment holding the buttons.
* <pre>
* var nodeContextMenu =
*   $(go.Adornment, "Spot",
*     { background: "transparent" },  // to help detect when the mouse leaves the area
*     $(go.Placeholder),
*     $(go.Panel, "Vertical",
*       { alignment: go.Spot.Right, alignmentFocus: go.Spot.Left },
*       $("Button",
*         $(go.TextBlock, "Command 1"),
*         {
*           click: function(e, obj) {
*             var node = obj.part.adornedPart;
*             alert("Command 1 on " + node.data.text);
*             node.removeAdornment("ContextMenuOver");
*           }
*         }),
*       $("Button",
*         $(go.TextBlock, "Command 2"),
*         {
*           click: function(e, obj) {
*             var node = obj.part.adornedPart;
*             alert("Command 2 on " + node.data.text);
*             node.removeAdornment("ContextMenuOver");
*           }
*         })
*       ));
* </pre>
* Then in the definition of the Node we can implement a mouseEnter event handler:
* <pre>
* myDiagram.nodeTemplate =
*   $(go.Node,
*     . . .
*     {
*       mouseEnter: function(e, node) {
*         nodeContextMenu.adornedObject = node;
*         nodeContextMenu.mouseLeave = function(ev, cm) {
*           node.removeAdornment("ContextMenuOver");
*         };
*         node.addAdornment("ContextMenuOver", nodeContextMenu);
*       }
*     });
* </pre>
* Note how it automatically defines a {@link #mouseLeave} event handler too.
* The context menu Adornment is removed either when the mouse leaves the area of the Adornment
* or when the user executes a button click event handler.
* @name GraphObject#mouseEnter
* @function.
* @return {function(InputEvent, GraphObject, GraphObject) | null}
* @see #mouseLeave
* @see #mouseOver
* @see #mouseHover
* @see #mouseDragEnter
*/
/** @type {function(InputEvent, GraphObject, GraphObject) | null} */
GraphObject.prototype.mouseEnter;
Util.exportProperty(GraphObject, 'mouseEnter', GraphObject.prototype.mouseEnter);
Util.defineProperty(GraphObject, { mouseEnter: 'mouseEnter' },
  /** @this {GraphObject} */
  function() { return this._eventHandlers !== null ? this._eventHandlers._mouseEnter : null; },
  /** @this {GraphObject} */
  function(val) {
    if (this._eventHandlers === null) this.initEventHandlers();
    var old = this._eventHandlers._mouseEnter;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', GraphObject, 'mouseEnter');
      this._eventHandlers._mouseEnter = val;
      this.raiseChanged('mouseEnter', old, val);
    }
  }
);

/**
* Gets or sets the function to execute when the user moves the mouse
* into this object without holding down any buttons.
* This property is used by the {@link ToolManager}.
* <p/>
* If this property value is a function, it is called with an {@link InputEvent},
* this {@link GraphObject}, and any previous {@link GraphObject} that the mouse had been in.
* The {@link InputEvent#targetObject} provides the GraphObject that was found
* at the mouse point before looking up the visual tree of {@link GraphObject#panel}s
* to get to this object.
* By default this property is null.
* <p/>
* This function is called with {@link Diagram#skipsUndoManager} temporarily set to true,
* so that any changes to {@link GraphObject}s are not recorded in the {@link UndoManager}.
* You do not need to start and commit any transaction in this function.
* After calling this function the diagram will be updated immediately.
* <p/>
* For example, the <a href="../../samples/flowchart.html">Flow Chart sample</a>
* automatically shows and hides the ports as the mouse passes over a node.
* The node template includes the following settings:
* <pre>
* myDiagram.nodeTemplate =
*   $(go.Node,
*     . . .
*     {
*       . . .
*       // handle mouse enter/leave events to show/hide the ports
*       mouseEnter: function (e, obj) { showPorts(obj.part, true); },
*       mouseLeave: function (e, obj) { showPorts(obj.part, false); }
*       . . .
*     });
* </pre>
* where the <code>showPorts</code> function is defined to set the {@link #visible}
* property of each of the port elements of the node.
* @name GraphObject#mouseLeave
* @function.
* @return {function(InputEvent, GraphObject, GraphObject) | null}
* @see #mouseEnter
* @see #mouseOver
* @see #mouseHover
* @see #mouseDragLeave
*/
/** @type {function(InputEvent, GraphObject, GraphObject) | null} */
GraphObject.prototype.mouseLeave;
Util.exportProperty(GraphObject, 'mouseLeave', GraphObject.prototype.mouseLeave);
Util.defineProperty(GraphObject, { mouseLeave: 'mouseLeave' },
  /** @this {GraphObject} */
  function() { return this._eventHandlers !== null ? this._eventHandlers._mouseLeave : null; },
  /** @this {GraphObject} */
  function(val) {
    if (this._eventHandlers === null) this.initEventHandlers();
    var old = this._eventHandlers._mouseLeave;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', GraphObject, 'mouseLeave');
      this._eventHandlers._mouseLeave = val;
      this.raiseChanged('mouseLeave', old, val);
    }
  }
);

/**
* Gets or sets the function to execute when the user moves the mouse
* over this object without holding down any buttons.
* This property is used by the {@link ToolManager}.
* This property is infrequently used -- it is more common to implement {@link #mouseEnter}
* and {@link #mouseLeave} functions.
* <p/>
* If this property value is a function, it is called with an {@link InputEvent}
* and this {@link GraphObject}.
* The {@link InputEvent#targetObject} provides the GraphObject that was found
* at the mouse point before looking up the visual tree of {@link GraphObject#panel}s
* to get to this object.
* By default this property is null.
* <p/>
* This function is called with {@link Diagram#skipsUndoManager} temporarily set to true,
* so that any changes to {@link GraphObject}s are not recorded in the {@link UndoManager}.
* You do not need to start and commit any transaction in this function.
* After calling this function the diagram will be updated immediately.
* @name GraphObject#mouseOver
* @function.
* @return {function(InputEvent, GraphObject) | null}
* @see #mouseHover
* @see #mouseEnter
* @see #mouseLeave
*/
/** @type {function(InputEvent, GraphObject) | null} */
GraphObject.prototype.mouseOver;
Util.exportProperty(GraphObject, 'mouseOver', GraphObject.prototype.mouseOver);
Util.defineProperty(GraphObject, { mouseOver: 'mouseOver' },
  /** @this {GraphObject} */
  function() { return this._eventHandlers !== null ? this._eventHandlers._mouseOver : null; },
  /** @this {GraphObject} */
  function(val) {
    if (this._eventHandlers === null) this.initEventHandlers();
    var old = this._eventHandlers._mouseOver;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', GraphObject, 'mouseOver');
      this._eventHandlers._mouseOver = val;
      this.raiseChanged('mouseOver', old, val);
    }
  }
);

/**
* Gets or sets the function to execute when the user holds the mouse still for a while
* over this object without holding down any buttons.
* This property is used by the {@link ToolManager}.
* <p/>
* If this property value is a function, it is called with an {@link InputEvent}.
* By default this property is null.
* <p/>
* If you do provide a function that makes changes to the diagram or to its model,
* you should do so within a transaction -- call {@link Diagram#startTransaction} and
* {@link Diagram#commitTransaction}.
* <p/>
* You can control how long the user must wait with a motionless mouse before
* a "mouse hover" event occurs, by setting {@link ToolManager#hoverDelay}.
* For example:
* <pre>
* myDiagram =
*   $(go.Diagram, "myDiagramDiv",
*     { "toolManager.hoverDelay": 500 });  // 500 milliseconds
* </pre>
* or:
* <pre>
* myDiagram.toolManager.hoverDelay = 500;  // 500 milliseconds
* </pre>
* @name GraphObject#mouseHover
* @function.
* @return {function(InputEvent, GraphObject) | null}
* @see #mouseOver
* @see #mouseEnter
* @see #mouseLeave
*/
/** @type {function(InputEvent, GraphObject) | null} */
GraphObject.prototype.mouseHover;
Util.exportProperty(GraphObject, 'mouseHover', GraphObject.prototype.mouseHover);
Util.defineProperty(GraphObject, { mouseHover: 'mouseHover' },
  /** @this {GraphObject} */
  function() { return this._eventHandlers !== null ? this._eventHandlers._mouseHover : null; },
  /** @this {GraphObject} */
  function(val) {
    if (this._eventHandlers === null) this.initEventHandlers();
    var old = this._eventHandlers._mouseHover;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', GraphObject, 'mouseHover');
      this._eventHandlers._mouseHover = val;
      this.raiseChanged('mouseHover', old, val);
    }
  }
);

/**
* Gets or sets the function to execute when the user holds the mouse still for a while
* over this object while holding down a button.
* This property is used by the {@link ToolManager}.
* <p/>
* If this property value is a function, it is called with an {@link InputEvent}.
* By default this property is null.
* <p/>
* If you do provide a function that makes changes to the diagram or to its model,
* you should do so within a transaction -- call {@link Diagram#startTransaction} and
* {@link Diagram#commitTransaction}.
* <p/>
* You can control how long the user must wait during a drag with a motionless mouse before
* a "mouse hold" event occurs, by setting {@link ToolManager#holdDelay}.
* For example:
* <pre>
* myDiagram =
*   $(go.Diagram, "myDiagramDiv",
*     { "toolManager.holdDelay": 500 });  // 500 milliseconds
* </pre>
* or:
* <pre>
* myDiagram.toolManager.holdDelay = 500;  // 500 milliseconds
* </pre>
* @name GraphObject#mouseHold
* @function.
* @return {function(InputEvent, GraphObject) | null}
* @see #mouseDragEnter
* @see #mouseDragLeave
* @see #mouseHover
*/
/** @type {function(InputEvent, GraphObject) | null} */
GraphObject.prototype.mouseHold;
Util.exportProperty(GraphObject, 'mouseHold', GraphObject.prototype.mouseHold);
Util.defineProperty(GraphObject, { mouseHold: 'mouseHold' },
  /** @this {GraphObject} */
  function() { return this._eventHandlers !== null ? this._eventHandlers._mouseHold : null; },
  /** @this {GraphObject} */
  function(val) {
    if (this._eventHandlers === null) this.initEventHandlers();
    var old = this._eventHandlers._mouseHold;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', GraphObject, 'mouseHold');
      this._eventHandlers._mouseHold = val;
      this.raiseChanged('mouseHold', old, val);
    }
  }
);

/**
* Gets or sets the function to execute when the user moves the mouse
* into this stationary object during a {@link DraggingTool} drag;
* this allows you to provide feedback during a drag based on where it might drop.
* <p/>
* If this property value is a function, it is called with an {@link InputEvent},
* this {@link GraphObject}, and any previous {@link GraphObject}.
* The {@link InputEvent#targetObject} provides the GraphObject that was found
* at the mouse point before looking up the visual tree of {@link GraphObject#panel}s
* to get to this object.
* By default this property is null.
* <p/>
* This function is called with {@link Diagram#skipsUndoManager} temporarily set to true,
* so that any changes to {@link GraphObject}s are not recorded in the {@link UndoManager}.
* You do not need to start and commit any transaction in this function.
* After calling this function the diagram will be updated immediately.
* <p/>
* For an example of a mouseDragEnter event handler, see the node template in the
* <a href="../../samples/orgChartEditor.html">Org Chart Editor sample</a>.
* @name GraphObject#mouseDragEnter
* @function.
* @return {function(InputEvent, GraphObject, GraphObject) | null}
* @see #mouseDragLeave
* @see #mouseHold
* @see #mouseDrop
* @see #mouseEnter
*/
/** @type {function(InputEvent, GraphObject, GraphObject) | null} */
GraphObject.prototype.mouseDragEnter;
Util.exportProperty(GraphObject, 'mouseDragEnter', GraphObject.prototype.mouseDragEnter);
Util.defineProperty(GraphObject, { mouseDragEnter: 'mouseDragEnter' },
  /** @this {GraphObject} */
  function() { return this._eventHandlers !== null ? this._eventHandlers._mouseDragEnter : null; },
  /** @this {GraphObject} */
  function(val) {
    if (this._eventHandlers === null) this.initEventHandlers();
    var old = this._eventHandlers._mouseDragEnter;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', GraphObject, 'mouseDragEnter');
      this._eventHandlers._mouseDragEnter = val;
      this.raiseChanged('mouseDragEnter', old, val);
    }
  }
);

/**
* Gets or sets the function to execute when the user moves the mouse
* out of this stationary object during a {@link DraggingTool} drag;
* this allows you to provide feedback during a drag based on where it might drop.
* <p/>
* If this property value is a function, it is called with an {@link InputEvent},
* this {@link GraphObject}, and any new {@link GraphObject} that the mouse is in.
* The {@link InputEvent#targetObject} provides the GraphObject that was found
* at the mouse point before looking up the visual tree of {@link GraphObject#panel}s
* to get to this object.
* By default this property is null.
* <p/>
* This function is called with {@link Diagram#skipsUndoManager} temporarily set to true,
* so that any changes to {@link GraphObject}s are not recorded in the {@link UndoManager}.
* You do not need to start and commit any transaction in this function.
* After calling this function the diagram will be updated immediately.
* <p/>
* For an example of a mouseDragLeave event handler, see the node template in the
* <a href="../../samples/orgChartEditor.html">Org Chart Editor sample</a>.
* @name GraphObject#mouseDragLeave
* @function.
* @return {function(InputEvent, GraphObject, GraphObject) | null}
* @see #mouseDragEnter
* @see #mouseHold
* @see #mouseDrop
* @see #mouseLeave
*/
/** @type {function(InputEvent, GraphObject, GraphObject) | null} */
GraphObject.prototype.mouseDragLeave;
Util.exportProperty(GraphObject, 'mouseDragLeave', GraphObject.prototype.mouseDragLeave);
Util.defineProperty(GraphObject, { mouseDragLeave: 'mouseDragLeave' },
  /** @this {GraphObject} */
  function() { return this._eventHandlers !== null ? this._eventHandlers._mouseDragLeave : null; },
  /** @this {GraphObject} */
  function(val) {
    if (this._eventHandlers === null) this.initEventHandlers();
    var old = this._eventHandlers._mouseDragLeave;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', GraphObject, 'mouseDragLeave');
      this._eventHandlers._mouseDragLeave = val;
      this.raiseChanged('mouseDragLeave', old, val);
    }
  }
);

/**
* Gets or sets the function to execute when a user drops the selection on this object
* at the end of a {@link DraggingTool} drag;
* this allows you to customize the behavior when a drop occurs on an object.
* <p>
* If this property value is a function, it is called with an {@link InputEvent},
* this {@link GraphObject}.
* The {@link InputEvent#targetObject} provides the GraphObject that was found
* at the mouse point before looking up the visual tree of {@link GraphObject#panel}s
* to get to this object.
* The function is called within the transaction performed by the {@link DraggingTool}.
* By default this property is null.
* <p/>
* For an example of a mouseDrop event handler, see the node template in the
* <a href="../../samples/orgChartEditor.html">Org Chart Editor sample</a>.
* @name GraphObject#mouseDrop
* @function.
* @return {function(InputEvent, GraphObject) | null}
* @see #mouseDragEnter
* @see #mouseDragLeave
* @see #mouseHold
*/
/** @type {function(InputEvent, GraphObject) | null} */
GraphObject.prototype.mouseDrop;
Util.exportProperty(GraphObject, 'mouseDrop', GraphObject.prototype.mouseDrop);
Util.defineProperty(GraphObject, { mouseDrop: 'mouseDrop' },
  /** @this {GraphObject} */
  function() { return this._eventHandlers !== null ? this._eventHandlers._mouseDrop : null; },
  /** @this {GraphObject} */
  function(val) {
    if (this._eventHandlers === null) this.initEventHandlers();
    var old = this._eventHandlers._mouseDrop;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', GraphObject, 'mouseDrop');
      this._eventHandlers._mouseDrop = val;
      this.raiseChanged('mouseDrop', old, val);
    }
  }
);


/**
* Gets or sets the function to execute on a mouse-down event when this GraphObject's {@link #isActionable}
* is set to true.
* This property is infrequently set.
* By default this property is null.
* <p>
* This functional property is only set on objects such as buttons, knobs, or sliders that want to handle all events,
* in conjunction with {@link ActionTool}, pre-empting the normal tool mechanisms.
* @name GraphObject#actionDown
* @function.
* @return {function(InputEvent, GraphObject) | null}
* @see #actionMove
* @see #actionUp
* @see #actionCancel
*/
/** @type {function(InputEvent, GraphObject) | null} */
GraphObject.prototype.actionDown;
Util.exportProperty(GraphObject, 'actionDown', GraphObject.prototype.actionDown);
Util.defineProperty(GraphObject, { actionDown: 'actionDown' },
  /** @this {GraphObject} */
  function() { return this._eventHandlers !== null ? this._eventHandlers._actionDown : null; },
  /** @this {GraphObject} */
  function(val) {
    if (this._eventHandlers === null) this.initEventHandlers();
    var old = this._eventHandlers._actionDown;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', GraphObject, 'actionDown');
      this._eventHandlers._actionDown = val;
      this.raiseChanged('actionDown', old, val);
    }
  }
);

/**
* Gets or sets the function to execute on a mouse-up event when this GraphObject's {@link #isActionable}
* is set to true.
* This property is infrequently set.
* By default this property is null.
* <p>
* This functional property is only set on objects such as buttons, knobs, or sliders that want to handle all events,
* in conjunction with {@link ActionTool}, pre-empting the normal tool mechanisms.
* <p>
* If you do provide a function that makes changes to the diagram or to its model,
* you should do so within a transaction -- call {@link Diagram#startTransaction} and
* {@link Diagram#commitTransaction}.
* @name GraphObject#actionUp
* @function.
* @return {function(InputEvent, GraphObject) | null}
* @see #actionDown
* @see #actionMove
* @see #actionCancel
*/
/** @type {function(InputEvent, GraphObject) | null} */
GraphObject.prototype.actionUp;
Util.exportProperty(GraphObject, 'actionUp', GraphObject.prototype.actionUp);
Util.defineProperty(GraphObject, { actionUp: 'actionUp' },
  /** @this {GraphObject} */
  function() { return this._eventHandlers !== null ? this._eventHandlers._actionUp : null; },
  /** @this {GraphObject} */
  function(val) {
    if (this._eventHandlers === null) this.initEventHandlers();
    var old = this._eventHandlers._actionUp;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', GraphObject, 'actionUp');
      this._eventHandlers._actionUp = val;
      this.raiseChanged('actionUp', old, val);
    }
  }
);

/**
* Gets or sets the function to execute on a mouse-move event when this GraphObject's {@link #isActionable}
* is set to true.
* This property is infrequently set.
* By default this property is null.
* <p>
* This functional property is only set on objects such as buttons, knobs, or sliders that want to handle all events,
* in conjunction with {@link ActionTool}, pre-empting the normal tool mechanisms.
* @name GraphObject#actionMove
* @function.
* @return {function(InputEvent, GraphObject) | null}
* @see #actionDown
* @see #actionUp
* @see #actionCancel
*/
/** @type {function(InputEvent, GraphObject) | null} */
GraphObject.prototype.actionMove;
Util.exportProperty(GraphObject, 'actionMove', GraphObject.prototype.actionMove);
Util.defineProperty(GraphObject, { actionMove: 'actionMove' },
  /** @this {GraphObject} */
  function() { return this._eventHandlers !== null ? this._eventHandlers._actionMove : null; },
  /** @this {GraphObject} */
  function(val) {
    if (this._eventHandlers === null) this.initEventHandlers();
    var old = this._eventHandlers._actionMove;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', GraphObject, 'actionMove');
      this._eventHandlers._actionMove = val;
      this.raiseChanged('actionMove', old, val);
    }
  }
);

/**
* Gets or sets the function to execute when the {@link ActionTool} is cancelled and this GraphObject's {@link #isActionable}
* is set to true.
* This property is infrequently set.
* By default this property is null.
* <p>
* This functional property is only set on objects such as buttons, knobs, or sliders that want to handle all events,
* in conjunction with {@link ActionTool}, pre-empting the normal tool mechanisms.
* @name GraphObject#actionCancel
* @function.
* @return {function(InputEvent, GraphObject) | null}
* @see #actionDown
* @see #actionMove
* @see #actionUp
*/
/** @type {function(InputEvent, GraphObject) | null} */
GraphObject.prototype.actionCancel;
Util.exportProperty(GraphObject, 'actionCancel', GraphObject.prototype.actionCancel);
Util.defineProperty(GraphObject, { actionCancel: 'actionCancel' },
  /** @this {GraphObject} */
  function() { return this._eventHandlers !== null ? this._eventHandlers._actionCancel : null; },
  /** @this {GraphObject} */
  function(val) {
    if (this._eventHandlers === null) this.initEventHandlers();
    var old = this._eventHandlers._actionCancel;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', GraphObject, 'actionCancel');
      this._eventHandlers._actionCancel = val;
      this.raiseChanged('actionCancel', old, val);
    }
  }
);



/**
* This {@link Adornment} is shown when the mouse hovers over this object.
* The default value is null, which means no tooltip is shown.
* <p>
* A typical tooltip is defined in the following manner, as taken from
* the <a href="../../samples/kittenMonitor.html">Kitten Monitor sample</a>:
* <pre>
* myDiagram.nodeTemplate =
*   $(go.Node,
*     . . .
*     { // this tooltip shows the name and picture of the kitten
*       toolTip:
*         $(go.Adornment, "Auto",
*           $(go.Shape, { fill: "lightyellow" }),
*           $(go.Panel, "Vertical",
*             $(go.Picture,
*               new go.Binding("source", "src", function(s) { return "images/" + s + ".png"; })),
*             $(go.TextBlock, { margin: 3 },
*               new go.Binding("text", "key"))))
*     });
* </pre>
* Note that this Adornment depends on having the same data binding as the adorned Part.
* <p>
* Tooltips are shown after a timed delay given by the {@link ToolManager#hoverDelay}.
* You can change the delay time by:
* <pre>
* myDiagram =
*   $(go.Diagram, "myDiagramDiv",
*     { "toolManager.hoverDelay": 500 });  // 500 milliseconds
* </pre>
* or:
* <pre>
* myDiagram.toolManager.hoverDelay = 500;  // 500 milliseconds
* </pre>
* <p>
* Changing this value will not modify or remove any existing tooltip that is being shown for this object.
* @name GraphObject#toolTip
* @function.
* @return {Adornment}
*/
/** @type {Adornment} */
GraphObject.prototype.toolTip;
Util.exportProperty(GraphObject, 'toolTip', GraphObject.prototype.toolTip);
Util.defineProperty(GraphObject, { toolTip: 'toolTip' },
  /** @this {GraphObject} */
  function() { return this._eventHandlers !== null ? this._eventHandlers._toolTip : null; },
  /** @this {GraphObject} */
  function(val) {
    if (this._eventHandlers === null) this.initEventHandlers();
    var old = this._eventHandlers._toolTip;
    if (old !== val) {
      if (val !== null) Util.checkClass(val, Adornment, GraphObject, 'toolTip');
      this._eventHandlers._toolTip = val;
      this.raiseChanged('toolTip', old, val);
    }
  }
);

/**
* This {@link Adornment} is shown upon a context click on this object.
* The default value is null, which means no context menu is shown.
* <p/>
* Changing this value will not modify or remove any existing menu that is being shown for this object.
* <p/>
* A typical context menu is implemented as an Adornment with several buttons in it.
* For example, this context menu is defined in the
* <a href="../../samples/dynamicPorts.html">Dynamic Port sample</a>:
* <pre>
* var nodeMenu =  // context menu for each Node
*  $(go.Adornment, "Vertical",
*     $("ContextMenuButton",
*       $(go.TextBlock, "Add top port"),
*       { click: function (e, obj) { addPort("top"); } }),
*     $("ContextMenuButton",
*       $(go.TextBlock, "Add left port"),
*       { click: function (e, obj) { addPort("left"); } }),
*     $("ContextMenuButton",
*       $(go.TextBlock, "Add right port"),
*       { click: function (e, obj) { addPort("right"); } }),
*     $("ContextMenuButton",
*       $(go.TextBlock, "Add bottom port"),
*       { click: function (e, obj) { addPort("bottom"); } }));
* </pre>
* and is used in the node template:
* <pre>
* myDiagram.nodeTemplate =
*   $(go.Node, "Table",
*     { . . .
*       contextMenu: nodeMenu
*     },
*     . . .);
* </pre>
* <p/>
* The <a href="../../samples/basic.html">Basic sample</a> also shows how
* to make context menu items invisible when the command is disabled.
* @name GraphObject#contextMenu
* @function.
* @return {Adornment}
*/
/** @type {Adornment} */
GraphObject.prototype.contextMenu;
Util.exportProperty(GraphObject, 'contextMenu', GraphObject.prototype.contextMenu);
Util.defineProperty(GraphObject, { contextMenu: 'contextMenu' },
  /** @this {GraphObject} */
  function() { return this._eventHandlers !== null ? this._eventHandlers._contextMenu : null; },
  /** @this {GraphObject} */
  function(val) {
    if (this._eventHandlers === null) this.initEventHandlers();
    var old = this._eventHandlers._contextMenu;
    if (old !== val) {
      if (val !== null) Util.checkClass(val, Adornment, GraphObject, 'contextMenu');
      this._eventHandlers._contextMenu = val;
      this.raiseChanged('contextMenu', old, val);
    }
  }
);

GraphObject.prototype['bind'] =
/**
* Add a data-binding of a property on this GraphObject to a property on a data object.
* <p/>
* Read more about {@link Binding}s at <a href="../../intro/dataBinding.html">the Introduction page about Data Bindings</a>.
* @this {GraphObject}
* @param {Binding} binding
*/
GraphObject.prototype.bind = function(binding) {
  binding._targetObject = this;  // remember so that Part.freezeBindings can generalize using name-lookup
  var binder = this.findTemplateBinder();
  if (binder !== null && binder.isTemplateBinderFrozen()) {
    Util.throwError('Cannot add a Binding to a template that has already been copied: ' + binding);
  }
  if (this._binds === null) this._binds = new List(Binding);
  this._binds.add(binding);
};

GraphObject.prototype['findTemplateBinder'] =
/**
* @ignore
* @this {GraphObject}
* @return {Panel}
*/
GraphObject.prototype.findTemplateBinder = function() {
  var elt = (this instanceof Panel) ? this : this.panel;
  while (elt !== null) {
    if (elt.isTemplateBinder() && elt instanceof Panel) return elt;
    elt = elt.panel;
  }
  return null;
};


GraphObject['fromSvg'] =
/**
* @ignore
* This static function builds an object from data in SVG format.
* @param {string|Document} svg either an XML DOM Node or a string that is parsed into XML DOM.
* @return {GraphObject}
*/
GraphObject.fromSvg = function(svg) {
  return new Svg().fromSvg(svg);
};


GraphObject['setProperties'] =
/**
* @ignore
* This method sets a collection of properties according to the property/value pairs that have been set on the given Object,
* in the same manner as {@link GraphObject#make} does for arguments that are simple JavaScript Objects.
* <p/>
* If this is a {@link Panel}, you can set properties on named elements within the panel by using a <i>name.property</i> syntax for the property name.
* For example, if a {@link Node} has a {@link Picture} that is named "ICON" (because its {@link #name} property has been set to "ICON")
* and a {@link TextBlock} whose name is "TB", one could set properties on the Node and on each of those named elements by:
* <pre>
* aNode.setProperties({
*     background: "red",
*     "ICON.source": "http://www.example.com/images/alert.jpg",
*     "TB.font": "bold 12pt sans-serif"
* });
* </pre>
* Note that the use of all-upper-case object names is simply a convention.
* @param {Object} props a plain JavaScript object with various property values to be set on this GraphObject.
*/
GraphObject.prototype.setProperties = function(props) {
  Util.setCheckedProperties(this, props);
};

GraphObject['make'] =
/**
* This static function builds an object given its class and additional arguments
* providing initial properties or {@link GraphObject}s that become {@link Panel} elements.
* <p/>
* The first argument must be the class type or the name of a class or the name of a predefined kind of Panel.
* The rest of the arguments are used to initialize the object being built.
* <p/>
* If an initializer argument is an enumerated value, this tries to set the property that seems most appropriate.
* <p/>
* If an initializer argument is a string, this sets a particular property depending on the type of object being built.
* <ul>
* <li>If the object is a {@link TextBlock}, it sets {@link TextBlock#text}.</li>
* <li>If the object is a {@link Shape}, it sets {@link Shape#figure}.</li>
* <li>If the object is a {@link Picture}, it sets {@link Picture#source}.</li>
* <li>If the object is a {@link Panel} (including {@link Part}, {@link Node}, or {@link Group}), it sets {@link Panel#type}.</li>
* </ul>
* <p/>
* If an initializer argument is a particular kind of object, this can add that object to the object being built.
* <ul>
* <li>{@link GraphObject}s and {@link RowColumnDefinition}s can only be added as elements of {@link Panel}s.</li>
* <li>{@link Binding}s can only be applied to {@link GraphObject}s and {@link RowColumnDefinition}s.</li>
* <li>{@link PathFigure}s can only be added to {@link Geometry} objects.</li>
* <li>{@link PathSegment}s can only be added to {@link PathFigure} objects.</li>
* <li>Regular JavaScript objects provide property/value pairs that are set on the object being built.</li>
* </ul>
* When the initializer argument is a plain JavaScript Object, there are several ways that that object's properties are applied.
* If the property name is a string with a period inside it, this has a special meaning if the object is a {@link Panel} or a {@link Diagram}.
* At the current time only a single period separator is valid syntax for a property string, and it is valid only on Panels and Diagrams.
* <p/>
* For Panels, the substring before the period is used as the name passed to {@link Panel#findObject}
* to get the actual object on which to set the property, which is the substring after the period.
* This is normally useful only on the predefined Panels:
* <ul>
* <li>a <b>"Button"</b> has a {@link Shape} named "ButtonBorder" surrounding the content of the Panel.</li>
* <li>a <b>"TreeExpanderButton"</b> has a "ButtonBorder" Shape and a "ButtonIcon" Shape that is the plus-or-minus sign.</li>
* <li>a <b>"SubGraphExpanderButton"</b> has a "ButtonBorder" Shape and a "ButtonIcon" Shape that is the plus-or-minus sign.</li>
* <li>a <b>"ContextMenuButton"</b> has a Shape named "ButtonBorder" surrounding the content of the Panel.</li>
* </ul>
* <p/>
* For Diagrams, the substring before the period is used as the name of a property on the Diagram itself
* to get the actual object on which to set the property.
* As a special case, if such a property value does not exist on the Diagram, it looks on the {@link Diagram#toolManager}.
* See some examples below.
* <p/>
* If the property name is a number and if the object being constructed is a {@link Brush},
* the number and value are added to the Brush by calling {@link Brush#addColorStop}.
* <p/>
* Otherwise the property name is used as a regular property name on the object being built.
* This tries to do some property name and value checking:
* when a property is not defined on the object being built, it will signal an error.
* Many typos can be found this way that would be ignored by JavaScript code.
* <p/>
* If the property name begins with an underscore, this will not complain about the property being undefined.
* Not only is that underscore property set on the object being built, but calls to {@link #copy}
* will also copy the values of such named properties to the new objects.
* <p/>
* In the samples and in the intro pages this function is called using the alias "$".
* You can use a different short name if you would like to preserve the use of "$" for another JavaScript library.
* <pre>
*  var $ = go.GraphObject.make;
*
*  var diagram =
*    $(go.Diagram, "myDiagramDiv",
*      {
*        initialContentAlignment: go.Spot.Center,
*        allowZoom: false,
*        "grid.visible": true,  // display a background grid for the whole diagram
*        "grid.gridCellSize": new go.Size(20, 20),
*        // allow double-click in background to create a new node
*        "clickCreatingTool.archetypeNodeData": { text: "Node" },
*        // allow Ctrl-G to call the groupSelection command
*        "commandHandler.archetypeGroupData":
*            { text: "Group", isGroup: true, color: "blue" },
*        "toolManager.hoverDelay": 100,  // how quickly tooltips are shown
*        // mouse wheel zooms instead of scrolls
*        "toolManager.mouseWheelBehavior": go.ToolManager.WheelZoom,
*        "commandHandler.copiesTree": true,  // for the copy command
*        "commandHandler.deletesTree": true, // for the delete command
*        "draggingTool.dragsTree": true,  // dragging for both move and copy
*        "draggingTool.isGridSnapEnabled": true,
*        layout: $(go.TreeLayout,
*                  { angle: 90, sorting: go.TreeLayout.SortingAscending })
*      });
*
*  diagram.nodeTemplate =
*    $(go.Node, "Auto",  // or go.Panel.Auto
*      new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
*      $(go.Shape, "RoundedRectangle",
*        { fill: $(go.Brush, go.Brush.Linear, { 0: "#FEC901", 1: "#FEA200" }),
*          stroke: "gray",
*          strokeWidth: 2,
*          strokeDashArray: [3, 3] }),
*      $(go.TextBlock,
*        { margin: 5, font: "bold 12pt sans-serif" },
*        new go.Binding("text", "key"))
*    );
* </pre>
* <p class="box">
* See <a href="../../intro/buildingObjects.html">the Introduction page on building objects</a>
* for usage information and examples of GraphObject.make.
* @param {function()|string} type a class function or the name of a class in the "go" namespace,
* or one of several predefined kinds of {@link Panel}s: "Button", "TreeExpanderButton",
* "SubGraphExpanderButton", or "ContextMenuButton".
* @param {...*} initializers zero or more values that initialize the new object,
* typically an Object with properties whose values are set on the new object,
* or a {@link GraphObject} that is added to a {@link Panel},
* or a {@link Binding} for one of the new object's properties,
* or an {@link EnumValue} as the initial value of a single property of the new object that
* is recognized to take that value,
* or a string that is used as the value of a commonly set property.
* @return {Object}
*/
GraphObject.make = function(type, initializers) {
  var obj = null;
  var classfunc = null;
  if (typeof type === 'function') {
    classfunc = type;
  } else if (typeof type === 'string') {
    var builder = GraphObject.Builders.getValue(type);
    if (typeof builder === 'function') {
      obj = builder();  // call the builder with no args
    } else {
      classfunc = go[type];
    }
  }
  if (obj === null) {
    if (classfunc === undefined) {
      var d = window['$'];
      if (d !== undefined && d['noop'] !== undefined) {
         Util.throwError('GraphObject.make failed to complete. Is it conflicting with another $ var? (such as jQuery)');
      }
      Util.throwError('GraphObject.make failed to complete, it may be conflicting with another var.');
    }
    if (classfunc === null || !classfunc.constructor) {
      Util.throwError('GraphObject.make requires a class function or class name, not: ' + type);
    }
    obj = new classfunc;
  }
  var firstarg = 1;
  // handle initialization of Diagram specially, using first arg as its DIV
  if (obj instanceof Diagram && arguments.length > 1) {
    var arg = arguments[1];
    if (typeof arg === 'string' || arg instanceof HTMLDivElement) {
      obj.div = null;  // get rid of temporary/default DIV
      obj._helper.setup(obj, arg);
      firstarg++;
    } else {
      Util.throwError('Unknown argument to Diagram constructor: ' + arg);
    }
  }
  // process all additional arguments
  for (var i = firstarg; i < arguments.length; i++) {
    var arg = arguments[i];
    if (arg === undefined) {
      Util.throwError('Undefined value at argument ' + i + ' for object being constructed by GraphObject.make: ' + obj);
    } else if (typeof arg === 'string') {
      if (obj instanceof TextBlock) {
        obj.text = arg;
      } else if (obj instanceof Shape) {
        obj.figure = arg;
      } else if (obj instanceof Picture) {
        obj.source = arg;
      } else if (obj instanceof Panel) {
        var enm = Util.findEnumValueForName(Panel, arg);
        if (enm !== null) {
          obj.type = enm;
        } else {
          Util.throwError('Unknown Panel type as an argument to GraphObject.make: ' + arg);
        }
      } else if (obj instanceof Brush) {
        var enm = Util.findEnumValueForName(Brush, arg);
        if (enm !== null) {
          obj.type = enm;
        } else {
          Util.throwError('Unknown Brush type as an argument to GraphObject.make: ' + arg);
        }
      } else if (obj instanceof Geometry) {
        var enm = Util.findEnumValueForName(Geometry, arg);
        if (enm !== null) {
          obj.type = enm;
        } else {
          Util.throwError('Unknown Geometry type as an argument to GraphObject.make: ' + arg);
        }
      } else if (obj instanceof PathSegment) {
        var enm = Util.findEnumValueForName(PathSegment, arg);
        if (enm !== null) {
          obj.type = enm;
        } else {
          Util.throwError('Unknown PathSegment type as an argument to GraphObject.make: ' + arg);
        }
      } else {
        Util.throwError('Unable to use a string as an argument to GraphObject.make: ' + arg);
      }
    } else if (arg instanceof GraphObject) {
      if (!(obj instanceof Panel)) {
        Util.throwError('A GraphObject can only be added to a Panel, not to: ' + obj);
      }
      obj.add(arg);
    } else if (arg instanceof RowColumnDefinition) {
      if (!(obj instanceof Panel)) {
        Util.throwError('A RowColumnDefinition can only be added to a Panel, not to: ' + obj);
      }
      // get the real RowColumnDefinition to be initialized
      var rcd;
      if (arg.isRow) {
        rcd = obj.getRowDefinition(arg.index);
      } else {
        rcd = obj.getColumnDefinition(arg.index);
      }
      // now can initialize the RowColumnDefinition properties
      rcd.copyFrom(arg);
    } else if (arg instanceof EnumValue) {
      if (obj instanceof Link && arg.classType === Link) {
        if (Link.isOrthogonalRouting(arg)) {
          obj.routing = arg;
        } else if (arg === Link.Bezier || arg === Link.JumpGap || arg === Link.JumpOver) {
          obj.curve = arg;
        } else if (arg === Link.End || arg === Link.Scale || arg === Link.Stretch) {
          obj.adjusting = arg;
        } else if (arg === Link.Normal || arg === Link.None) {
          // default values: don't set anything
        } else {
          Util.throwError('Unknown Link enum value for a Link property: ' + arg);
        }
      } else if (obj instanceof Panel && arg.classType === Panel) {
        obj.type = arg;
      } else if (obj instanceof TextBlock && arg.classType === TextBlock) {
        obj.wrap = arg;
      } else if (obj instanceof GraphObject && arg.classType === Link) {
        if (arg.name.indexOf('Orient') === 0) {
          obj.segmentOrientation = arg;
        } else {
          Util.throwError('Unknown Link enum value for GraphObject.segmentOrientation property: ' + arg);
        }
      } else if (obj instanceof GraphObject && arg.classType === GraphObject) {
        obj.stretch = arg;
      } else if (obj instanceof Diagram && arg.classType === Diagram) {
        obj.autoScale = arg;
      } else if (obj instanceof Brush && arg.classType === Brush) {
        obj.type = arg;
      } else if (obj instanceof Geometry && arg.classType === Geometry) {
        obj.type = arg;
      } else if (obj instanceof PathSegment && arg.classType === PathSegment) {
        obj.type = arg;
      } else if (obj instanceof Binding && arg.classType === Binding) {
        obj.mode = arg;
      } else if (obj instanceof ChangedEvent && arg.classType === ChangedEvent) {
        obj.change = arg;
      } else if (obj instanceof TreeLayout && arg.classType === TreeLayout) {
        if (arg.name.indexOf('Alignment') === 0) {
          obj.alignment = arg;
        } else if (arg.name.indexOf('Arrangement') === 0) {
          obj.arrangement = arg;
        } else if (arg.name.indexOf('Compaction') === 0) {
          obj.compaction = arg;
        } else if (arg.name.indexOf('Path') === 0) {
          obj.path = arg;
        } else if (arg.name.indexOf('Sorting') === 0) {
          obj.sorting = arg;
        } else if (arg.name.indexOf('Style') === 0) {
          obj.treeStyle = arg;
        } else {
          Util.throwError('Unknown enum value: ' + arg);
        }
      } else if (obj instanceof LayeredDigraphLayout && arg.classType === LayeredDigraphLayout) {
        if (arg.name.indexOf('Aggressive') === 0) {
          obj.aggressiveOption = arg;
        } else if (arg.name.indexOf('Cycle') === 0) {
          obj.cycleRemoveOption = arg;
        } else if (arg.name.indexOf('Init') === 0) {
          obj.initializeOption = arg;
        } else if (arg.name.indexOf('Layer') === 0) {
          obj.layeringOption = arg;
        } else {
          Util.throwError('Unknown enum value: ' + arg);
        }
      } else if (obj instanceof GridLayout && arg.classType === GridLayout) {
        if (arg === GridLayout.Ascending || arg === GridLayout.Descending ||
            arg === GridLayout.Forward || arg === GridLayout.Reverse) {
          obj.sorting = arg;
        } else if (arg === GridLayout.LeftToRight || arg === GridLayout.RightToLeft) {
          obj.arrangement = arg;
        } else if (arg === GridLayout.Location || arg === GridLayout.Position) {
          obj.alignment = arg;
        } else {
          Util.throwError('Unknown enum value: ' + arg);
        }
      } else if (obj instanceof CircularLayout && arg.classType === CircularLayout) {
        if (arg === CircularLayout.Ascending || arg === CircularLayout.Descending ||
            arg === CircularLayout.Forwards || arg === CircularLayout.Reverse || arg === CircularLayout.Optimized) {
          obj.sorting = arg;
        } else if (arg === CircularLayout.BidirectionalLeft || arg === CircularLayout.BidirectionalRight ||
                   arg === CircularLayout.Clockwise || arg === CircularLayout.Counterclockwise) {
          obj.direction = arg;
        } else if (arg === CircularLayout.ConstantAngle || arg === CircularLayout.ConstantDistance ||
                   arg === CircularLayout.ConstantSpacing || arg === CircularLayout.Packed) {
          obj.arrangement = arg;
        } else if (arg === CircularLayout.Circular || arg === CircularLayout.Pythagorean) {
          obj.nodeDiameterFormula = arg;
        } else {
          Util.throwError('Unknown enum value: ' + arg);
        }
      } else {
        Util.throwError('No property to set for this enum value: ' + arg);
      }
    } else if (arg instanceof Binding) {
      if (obj instanceof GraphObject || obj instanceof RowColumnDefinition) {
        obj.bind(arg);
      } else {
        Util.throwError('A Binding can only be applied to a GraphObject or RowColumnDefinition, not to: ' + obj);
      }
    } else if (arg instanceof PathFigure) {
      if (obj instanceof Geometry) {
        obj.figures.add(arg);
      } else {
        Util.throwError('A PathFigure can only be added to a Geometry, not to: ' + obj);
      }
    } else if (arg instanceof PathSegment) {
      if (obj instanceof PathFigure) {
        obj.segments.add(arg);
      } else {
        Util.throwError('A PathSegment can only be added to a PathFigure, not to: ' + obj);
      }
    } else if (Util.isObject(arg)) {  // plain JavaScript object: add its properties to the OBJ
      // don't check that the argument is a { prop1: value1, prop2: value2 } object, due to node.js problems
      //if (arg.constructor !== Object) { // only check for objects created within same frame
      //  Util.throwError('Can only get property values from a plain Object, not a: ' + arg);
      //}
      if (obj instanceof Brush) {
        // strip out any colorStop definitions in ARG and add them explicitly to the Brush
        var props = {};
        for (var p in arg) {
          var frac = parseFloat(p);
          if (!isNaN(frac)) {
            obj.addColorStop(frac, arg[p]);
          } else {
            props[p] = arg[p];
          }
        }
        Util.setCheckedProperties(obj, props);
      } else if (obj instanceof RowColumnDefinition) {
        if (arg['row'] !== undefined) {
          var idx = arg['row'];
          if (idx === undefined || idx === null || idx === Infinity || isNaN(idx) || idx < 0) {
            Util.throwError('Must specify non-negative integer row for RowColumnDefinition ' + arg);
          }
          obj.setIsRow(true);
          obj.setIndex(idx);
        } else if (arg['column'] !== undefined) {
          var idx = arg['column'];
          if (idx === undefined || idx === null || idx === Infinity || isNaN(idx) || idx < 0) {
            Util.throwError('Must specify non-negative integer column for RowColumnDefinition ' + arg);
          }
          obj.setIsRow(false);
          obj.setIndex(idx);
        } else {
          Util.throwError('Must specify row or column value in a RowColumnDefinition ' + arg);
        }
        var props = Util.copyExcluding(arg, 'row', 'column');
        Util.setCheckedProperties(obj, props);
      } else {
        Util.setCheckedProperties(obj, arg);
      }
    } else {
      Util.throwError('Unknown initializer "' + arg + '" for object being constructed by GraphObject.make: ' + obj);
    }
  }
  return obj;
};


/**
* @ignore
* @name GraphObject#Builders
* @const
* @static
* @return {Map}
*/
GraphObject['Builders'] = GraphObject.Builders = new Map('string', 'function');

/** @ignore */
GraphObject.Builders.add('Button', function() {

    // default brushes for 'Button' shape

    var buttonFillNormal = new Brush(Brush.Linear);
    buttonFillNormal.addColorStop(0, 'white');
    buttonFillNormal.addColorStop(1, 'lightgray');

    var buttonStrokeNormal = 'gray';

    var buttonFillOver = new Brush(Brush.Linear);
    buttonFillOver.addColorStop(0, 'white');
    buttonFillOver.addColorStop(1, 'dodgerblue');

    var buttonStrokeOver = 'blue';

    var button =
      GraphObject.make(Panel, Panel.Auto,
        { isActionable: true },
        GraphObject.make(Shape,  // the border
          { name: 'ButtonBorder',
            figure: 'RoundedRectangle',
            fill: buttonFillNormal,
            stroke: buttonStrokeNormal }));
    // There's no GraphObject inside the button shape --
    // it must be added as part of the button definition.
    // This way the object could be a TextBlock or a Shape or a Picture or whatever.

    // mouse-over behavior
    /** @ignore */
    button.mouseEnter = function(e, obj, prev) {
      var button = obj;
      var diagram = button.diagram;
      var shape = button.elt(0);  // the border Shape
      var brush = button['_buttonFillOver'];
      if (brush === undefined) brush = buttonFillOver;
      button['_buttonFillNormal'] = shape.fill;
      shape.fill = brush;
      brush = button['_buttonStrokeOver'];
      if (brush === undefined) brush = buttonStrokeOver;
      button['_buttonStrokeNormal'] = shape.stroke;
      shape.stroke = brush;
    };

    /** @ignore */
    button.mouseLeave = function(e, obj, prev) {
      var button = obj;
      var diagram = button.diagram;
      var shape = button.elt(0);  // the border Shape
      var brush = button['_buttonFillNormal'];
      if (brush === undefined) brush = buttonFillNormal;
      shape.fill = brush;
      brush = button['_buttonStrokeNormal'];
      if (brush === undefined) brush = buttonStrokeNormal;
      shape.stroke = brush;
    };

    return button;
  });

GraphObject.Builders.add('TreeExpanderButton', function() {
    var button =
      GraphObject.make('Button',
        GraphObject.make(Shape,  // the icon
          { name: 'ButtonIcon',
            figure: 'MinusLine',  // default value for isTreeExpanded is true
            desiredSize: Geo.SixSize },
          // bind the Shape.figure to the Node.isTreeExpanded value using this converter:
          new Binding('figure', 'isTreeExpanded',
                      function(exp, node) {
                        var fig = null;
                        var button = node.panel;
                        if (button) fig = exp ? button['_treeExpandedFigure'] : button['_treeCollapsedFigure'];
                        if (!fig) fig = exp ? 'MinusLine' : 'PlusLine';
                        return fig;
                      })
              .ofObject('')),
        // assume initially not visible because there are no links coming out
        { visible: false },
        // bind the button visibility to whether it's not a leaf node
        new Binding('visible', 'isTreeLeaf',
                    function(leaf) { return !leaf; })
            .ofObject(''));

    // tree expand/collapse behavior
    /** @ignore */
    button.click = function(e, obj) {
      var node = obj.part;  // OBJ is this button
      if (!(node instanceof Node)) return;
      var diagram = node.diagram;
      if (diagram === null || diagram.isReadOnly) return;
      e.handled = true;
      if (node.isTreeExpanded) {
        diagram.commandHandler.collapseTree(node);
      } else {
        diagram.commandHandler.expandTree(node);
      }
    };
    return button;
  });

GraphObject.Builders.add('SubGraphExpanderButton', function() {
    var button =
      GraphObject.make('Button',
        GraphObject.make(Shape,  // the icon
          { name: 'ButtonIcon',
            figure: 'MinusLine',  // default value for isSubGraphExpanded is true
            desiredSize: Geo.SixSize },
          // bind the Shape.figure to the Group.isSubGraphExpanded value using this converter:
          new Binding('figure', 'isSubGraphExpanded',
                      function(exp, group) {
                        var fig = null;
                        var button = group.panel;
                        if (button) fig = exp ? button['_subGraphExpandedFigure'] : button['_subGraphCollapsedFigure'];
                        if (!fig) fig = exp ? 'MinusLine' : 'PlusLine';
                        return fig;
                      })
              .ofObject('')));

    // subgraph expand/collapse behavior
    /** @ignore */
    button.click = function(e, obj) {
      var group = obj.part;  // OBJ is this button
      if (!(group instanceof Group)) return;
      var diagram = group.diagram;
      if (diagram === null || diagram.isReadOnly) return;
      e.handled = true;
      if (group.isSubGraphExpanded) {
        diagram.commandHandler.collapseSubGraph(group);
      } else {
        diagram.commandHandler.expandSubGraph(group);
      }
    };

    return button;
  });

GraphObject.Builders.add('ContextMenuButton', function() {
    var button = GraphObject.make('Button');
    button.stretch = GraphObject.Horizontal;
    var border = button.findObject('ButtonBorder');
    if (border instanceof Shape) {
      border.figure = 'Rectangle';
      border.spot1 = new Spot(0, 0, 2, 2);
      border.spot2 = new Spot(1, 1, -2, -2);
    }
    return button;
  });

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
Panel
RowColumnDefinition
*/

/**
* Constructs an empty Panel of the given {@link #type}. Default type is {@link Panel.Position}.
* The panel type must be one of the enumerated values defined on the {@link Panel} class, including:
* {@link Panel#Position}, {@link Panel#Vertical}, {@link Panel#Horizontal}, {@link Panel#Table},
* {@link Panel#Auto}, {@link Panel#Spot}, or {@link Panel#Viewbox}.
* @constructor
* @param {EnumValue=} type If not supplied, the default Panel type is {@link Panel#Position}.
* @extends GraphObject
* @class
* A Panel is a {@link GraphObject} that holds other GraphObjects as its elements.
* A Panel is responsible for sizing and positioning its elements.
* The elements of a panel are drawn in the order in which they appear in the {@link #elements} collection.
* <p>
* The {@link Part} class inherits from Panel; Part in turn is the base class of {@link Node} and {@link Link}.
* <p>
* Every Panel has a {@link #type} and establishes its own coordinate system. The type of a Panel
* determines how it will size and arrange its elements:
* <ul>
* <li>{@link Panel#Position} is used to arrange elements based on their absolute positions within the Panel's local coordinate system.</li>
* <li>{@link Panel#Vertical} and {@link Panel#Horizontal} are used to create linear "stacks" of elements.</li>
* <li>{@link Panel#Auto} is used to size the main element to fit around other elements in the Panel.</li>
* <li>{@link Panel#Spot} is used to arrange elements based on the {@link Spot} properties {@link GraphObject#alignment}
* and {@link GraphObject#alignmentFocus}, relative to a main element of the panel.</li>
* <li>{@link Panel#Table} is used to arrange elements into rows and columns, typically employing the different
* elements' {@link GraphObject#row}, {@link GraphObject#rowSpan}, {@link GraphObject#column},
* and {@link GraphObject#columnSpan} properties. This Panel type also makes use of {@link RowColumnDefinition}.</li>
* <li>{@link Panel#TableRow} and {@link Panel#TableColumn} can only be used immediately within a {@link Panel#Table} Panel
*     to organize a collection of elements as a row or as a column in a table.</li>
* <li>{@link Panel#Viewbox} is used to automatically resize a single element to fit inside the panel's available area.</li>
* <li>{@link Panel#Grid} is not used to house typical elements, but is used only to draw regular patterns of lines.
*     The elements must be {@link Shape}s used to describe the repeating lines.</li>
* <li>{@link Panel#Link} is only used by {@link Link} parts.</li>
* </ul>
* <p class="box">
* For an overview of all Panel types, please read the <a href="../../intro/panels.html">Introduction page on Panels</a>
* and <a href="../../intro/tablePanels.html">Table Panels</a>.
* <p>
* {@link Panel#Vertical} and {@link Panel#Horizontal} panels are frequently used to position two or more GraphObjects
* vertically above each other or horizontally next to each other.  Use the {@link GraphObject#alignment} or
* {@link GraphObject#stretch} properties on the individual elements to control their position and size.
* <p>
* {@link Panel#Spot} and {@link Panel#Auto} panels have a "main" element, signified by the Panel's first element
* with {@link GraphObject#isPanelMain} set to true.  If there is no such element, it uses the first element as the "main" one.
* Use the {@link GraphObject#alignment} property to position elements with respect to the main element.
* Use the {@link GraphObject#alignmentFocus} property to further specify the position within Spot Panels.
* <p>
* In {@link Panel#Table} panels you will want to set the {@link GraphObject#row} and {@link GraphObject#column}
* properties on each element.  The {@link GraphObject#alignment} and {@link GraphObject#stretch} properties are also
* useful when an element's table cell is larger than that element.
* Please read <a href="../../intro/tablePanels.html">Table Panels</a> for more examples and explanation.
* <p>
* {@link Panel#TableRow} and {@link Panel#TableColumn} panels can only be used as elements within a {@link Panel#Table} Panel.
* They are typically only used in item templates, e.g. for automatically creating rows in a Table Panel based on model data
* provided in an {@link #itemArray}. You will still need to specify properties on the individual elements within a TableRow
* or TableColumn as if they were immediate elements of the containing Table panel.
* For an example that uses TableRow Panels, see <a href="../../samples/records.html">Records sample</a>.
* <p>
* {@link Panel#Grid} panels are used for the Diagram's {@link Diagram#grid}, but can also stand alone:
* <pre>$(go.Node, go.Panel.Grid,
*   { gridCellSize: new go.Size(6, 6), width: 60, height: 60 },
*   $(go.Shape, "LineH", { stroke: "gray" }),
*   $(go.Shape, "LineV", { stroke: "gray" }))</pre>
* <p>
* A Grid Panel's elements do not participate in object picking.
* <hr/>
* <p>
* You can change the collection of {@link #elements} by calling {@link #add}, {@link #insertAt}, {@link #remove}, or {@link #removeAt}.
* You can get direct access to a particular element by calling {@link #elt}.
* <hr/>
* <p>
* Panels typically compute their own size based on their elements and Panel {@link #type},
* but can also be sized by setting {@link GraphObject#desiredSize}, {@link GraphObject#minSize}, and {@link GraphObject#maxSize}.
* Setting an explicit size on a Panel may cause nested elements of that panel to size themselves differently,
* especially in the cases of nested elements having a {@link GraphObject#stretch} value or {@link TextBlock}'s having word wrap.
* <p>
* Panels have no visual components of their own unless a {@link GraphObject#background} or {@link GraphObject#areaBackground} is specified
* or separators are specified either as defaults for the whole Table Panel or on individual {@link RowColumnDefinition}s.
* <p>
* In addition to the {@link GraphObject} properties on elements that are only used by certain types of panels,
* several Panel properties only apply to specific Panel types.
* <ul>
*   <li>Panels of {@link #type} {@link Panel#Table} use the {@link #rowCount}, {@link #rowSizing}, {@link #columnCount},
* {@link #columnSizing}, {@link #leftIndex}, {@link #topIndex}, and all of the "default" separator properties.</li>
*   <li>Panels of {@link #type} {@link Panel#Grid} use the {@link #gridCellSize} and {@link #gridOrigin} properties.</li>
*   <li>Panels of {@link #type} {@link Panel#Viewbox} use the {@link #viewboxStretch} property.</li>
* </ul>
* <p class="box">
* For live examples of all Panel types, see the <a href="../../intro/panels.html">Introduction page on Panels.</a>
* <hr/>
* <p>
* Panels also provide fundamental support for data binding.
* When a diagram gets a new model or when a diagram's model is augmented with additional data,
* the diagram automatically creates a new Node or Link whose {@link #data} property refers to the corresponding
* node data or link data object.
* <p class="box">
* For more discussion of data binding, please read the <a href="../../intro/usingModels.html">Introduction page on Models</a>
* and <a href="../../intro/dataBinding.html">Data Binding</a>.
* <p>
* In addition, Panels provide support for automatically creating elements within the Panel based on the
* items in a JavaScript Array.
* This is achieved by setting or binding the {@link #itemArray} property, which acts in a manner similar
* to the {@link Model#nodeDataArray} property.
* You can supply an {@link #itemTemplate}, which must itself be a simple Panel, which is copied to create the element
* in this container Panel corresponding to an item in the itemArray.
* This property is analogous to the {@link Diagram#nodeTemplate} property, although for the diagram the
* template must be a {@link Node}, {@link Group}, or simple {@link Part}.
* <p>
* And much like the {@link Diagram#nodeTemplateMap}, {@link #itemTemplateMap} supports having multiple templates,
* so that the actual structure of the element created for a data item can be chosen dynamically.
* Just as how the {@link Model#nodeCategoryProperty} determines which template in the {@link Diagram#nodeTemplateMap}
* is copied to create a {@link Node}, the {@link #itemCategoryProperty} names the data property whose value
* chooses the Panel in the itemTemplateMap to copy for the item.
* <p class="box">
* For more discussion and examples of item arrays, please read the <a href="../../intro/itemArrays.html">Introduction page on Item Arrays</a>.
*/
function Panel(type) {
  GraphObject.call(this);
  if (type === undefined/*notpresent*/) {
    if (arguments.length === 0) {
      /** @type {EnumValue} */
      this._type = Panel.Position;
    } else {
      Util.throwError('invalid argument to Panel constructor: undefined');
    }
  } else {
    Util.checkEnumValue(type, Panel, Panel, 'type');
    this._type = type;
  }

  /** @type {List} */
  this._elements = new List(GraphObject);
  /** @type {Margin} */
  this._padding = Geo.ZeroMargin;
  /** @type {boolean} */
  this._isAtomic = false;
  if (this._type === Panel.Grid) this._isAtomic = true;
  /** @type {number} */
  this._opacity = 1;

  /** @type {Spot} */
  this._defaultAlignment = Spot.Default;
  /** @type {EnumValue} */
  this._defaultStretch = GraphObject.Default;

  // ******** Table Panels: ********
  if (this._type === Panel.Table) {
    this.setTablePanelDefaults();
  }

  // ******** Viewbox Panels: ********

  /** @type {EnumValue} */
  this._viewboxStretch = GraphObject.Uniform;  // for Viewbox Panels

  // ******** Grid Panels: ********

  /** @type {Size} */
  this._gridCellSize = new Size(10, 10).freeze();
  /** @type {Point} */
  this._gridOrigin = Geo.Origin;

  // for data bound elements
  /** @type {Object} */
  this._data = null;
  /** @type {List} */
  this._bindings = null;  // all Bindings to _data for everything in this panel's visual tree
  /** @type {string} */
  this._itemCategory = '';  // for an element representing an item in the parent Panel's itemArray

  // for Panels bound to an array of item data
  /** @type {Array} */  // an Array-like object: must use Util methods for access!
  this._itemArray = null;  // this Panel's children correspond 1-to-1 to this array's data items
  /** @type {Map} */
  this._itemTemplateMap = null;  // holds Panel templates for items
  /** @type {string|function(*):string} */
  this._itemCategoryProperty = 'category';  // if the item is an object, the name of the property
  /** @type {Map} */
  this._itemElementMap = null;

  // Holds the "natural" size of the Panel
  /** @type {Rect} */
  this._union = new Rect(NaN, NaN, NaN, NaN);

  // keeps track of main object in Auto Panel
  /** @type {GraphObject} */
  this._tempMain = null;
  /** @type {boolean} */
  this._hasNamedPorts = false; // set to true if a graphobject with a port is added to this panel, or if a portId in this node changes
}

Util.publish('Panel', Panel);

Util.inherit(Panel, GraphObject);


/**
* @ignore
* @this {Panel}
*/
Panel.prototype.setTablePanelDefaults = function() {
  /** @type {Margin} */
  this._defaultSeparatorPadding = Geo.ZeroMargin;
  /** @type {number} */
  this._defaultRowSeparatorStrokeWidth = 1;
  /** @type {Brush|string} */
  this._defaultRowSeparatorStroke = null;
    /** @type {Array.<number>|null} */
  this._defaultRowSeparatorDashArray = null;
  /** @type {number} */
  this._defaultColumnSeparatorStrokeWidth = 1;
  /** @type {Brush|string} */
  this._defaultColumnSeparatorStroke = null;
    /** @type {Array.<number>|null} */
  this._defaultColumnSeparatorDashArray = null;

  /** @type {Array} */
  this._rowDefs = [];
  /** @type {Array} */
  this._colDefs = [];
  /** @type {EnumValue} */
  this._rowSizing = RowColumnDefinition.ProportionalExtra;
  /** @type {EnumValue} */
  this._columnSizing = RowColumnDefinition.ProportionalExtra;
  /** @type {number} */
  this._topIndex = 0;
  /** @type {number} */
  this._leftIndex = 0;
}

/**
* @ignore
* @this {Panel}
* @param {GraphObject} copy
*/
Panel.prototype.cloneProtected = function(copy) {
  GraphObject.prototype.cloneProtected.call(this, copy);
  copy._type = this._type;

  // constructor will allocate a new List(GraphObject) for copy._elements;
  // copy() will fill this list with new copies of objects
  copy._padding = this._padding.copyFrozen();
  copy._isAtomic = this._isAtomic;
  copy._opacity = this._opacity;

  copy._defaultAlignment = this._defaultAlignment.copyFrozen();
  copy._defaultStretch = this._defaultStretch;

  if (copy._type === Panel.Table) {
    copy._defaultSeparatorPadding = this._defaultSeparatorPadding.copyFrozen();
    copy._defaultRowSeparatorStrokeWidth = this._defaultRowSeparatorStrokeWidth;
    copy._defaultRowSeparatorStroke = this._defaultRowSeparatorStroke;
    copy._defaultRowSeparatorDashArray = this._defaultRowSeparatorDashArray;
    copy._defaultColumnSeparatorStrokeWidth = this._defaultColumnSeparatorStrokeWidth;
    copy._defaultColumnSeparatorStroke = this._defaultColumnSeparatorStroke;
    copy._defaultColumnSeparatorDashArray = this._defaultColumnSeparatorDashArray;

    // copy RowColumnDefinitions for all known rows and columns
    var defs = [];
    if (this._rowDefs.length > 0) {
      var cd = this._rowDefs;
      var l = cd.length;
      for (var i = 0; i < l; i++) {
        if (cd[i] === undefined) continue;
        var defcopy = cd[i].copy();
        defcopy.setPanel(copy);
        defs[i] = defcopy;
      }
    }
    copy._rowDefs = defs;

    defs = [];
    if (this._colDefs.length > 0) {
      var cd = this._colDefs;
      var l = cd.length;
      for (var i = 0; i < l; i++) {
        if (cd[i] === undefined) continue;
        var defcopy = cd[i].copy();
        defcopy.setPanel(copy);
        defs[i] = defcopy;
      }
    }
    copy._colDefs = defs;

    copy._rowSizing = this._rowSizing;
    copy._columnSizing = this._columnSizing;
    copy._topIndex = this._topIndex;
    copy._leftIndex = this._leftIndex;
  }

  copy._viewboxStretch = this._viewboxStretch;

  copy._gridCellSize.assign(this._gridCellSize);
  copy._gridOrigin = this._gridOrigin.copyFrozen();

  // for data bound elements
  copy._data = this._data;  // share the data reference, if any
  copy._bindings = this._bindings;  // shared
  copy._itemCategory = this._itemCategory;

  // for Panels bound to an array of item data
  copy._itemArray = this._itemArray;  // share the array, if any
  copy._itemTemplateMap = this._itemTemplateMap;
  copy._itemCategoryProperty = this._itemCategoryProperty;
  // don't copy this._itemElementMap -- needs to be built for copied elements

  copy._union.assign(this._union);

  // _tempMain not copied, always re-computed before being accessed
  copy._hasNamedPorts = this._hasNamedPorts;

  //??? copy hidden parameters used by 'Button'/'TreeExpanderButton'/'SubGraphExpanderButton' panels:
  if (this['_buttonFillNormal']) copy['_buttonFillNormal'] = this['_buttonFillNormal'];
  if (this['_buttonFillOver']) copy['_buttonFillOver'] = this['_buttonFillOver'];
  if (this['_buttonStrokeNormal']) copy['_buttonStrokeNormal'] = this['_buttonStrokeNormal'];
  if (this['_buttonStrokeOver']) copy['_buttonStrokeOver'] = this['_buttonStrokeOver'];
  if (this['_treeExpandedFigure']) copy['_treeExpandedFigure'] = this['_treeExpandedFigure'];
  if (this['_treeCollapsedFigure']) copy['_treeCollapsedFigure'] = this['_treeCollapsedFigure'];
  if (this['_subGraphExpandedFigure']) copy['_subGraphExpandedFigure'] = this['_subGraphExpandedFigure'];
  if (this['_subGraphCollapsedFigure']) copy['_subGraphCollapsedFigure'] = this['_subGraphCollapsedFigure'];
};

/**
* @ignore
* Fix up references in the argument object so that the argument object can displace this object in the visual tree.
* @this {Panel}
* @param {GraphObject} copy  This might be a copy of this object,
* but more likely is a separately created object of the same class with completely different internals.
*/
Panel.prototype.displaceProtected = function(copy) {
  GraphObject.prototype.displaceProtected.call(this, copy);
  copy._elements = this._elements;  // transfer this Panel's list of elements
  var et = copy._elements.iterator;  // and setup new back-pointers to that Panel
  while (et.next()) {
    et.value._panel = copy;
  }
};

/**
* Creates a deep copy of this Panel and returns it.
* @expose
* @this {Panel}
* @return {Panel}
*/
Panel.prototype.copy = function() {
  var copy = GraphObject.prototype.copy.call(this);
  if (copy instanceof Panel) {
    var elems = this._elements;
    if (elems.length > 0) {
      // all children
      var l = elems.length;
      for (var i = 0; i < l; i++) {
        var c = elems._arr[i].copy();
        copy.copyInsert(c); // sets copy as the panel
      }
    }
    return copy;
  } else {
    return null;
  }
};

/**
* @ignore
* @this {Panel}
* @return {string}
*/
Panel.prototype.toString = function() {
  return 'Panel(' + this.type + ')#' + Util.hashId(this);
};


/**
* The default {@link #type} arranges each element according to their {@link GraphObject#position}.
* @name Panel#Position
* @constant
* @static
* @return {EnumValue}
*/
Panel['Position'] = Panel.Position = Util.defineEnumValue(Panel, 'Position', 0);

/**
* This value for {@link #type} lays out the elements horizontally with
* their {@link GraphObject#alignment} property dictating their alignment on the Y-axis.
* @name Panel#Horizontal
* @constant
* @static
* @return {EnumValue}
*/
Panel['Horizontal'] = Panel.Horizontal = Util.defineEnumValue(Panel, 'Horizontal', 1);

/**
* This value for {@link #type} lays out the elements vertically with
* their {@link GraphObject#alignment} property dictating their alignment on the X-axis.
* @name Panel#Vertical
* @constant
* @static
* @return {EnumValue}
*/
Panel['Vertical'] = Panel.Vertical = Util.defineEnumValue(Panel, 'Vertical', 2);

/**
* This value for {@link #type} arranges GraphObjects about a main element using the {@link GraphObject#alignment} and {@link GraphObject#alignmentFocus} properties;
* the main element is the first GraphObject with {@link GraphObject#isPanelMain} set to true,
* or else the first GraphObject if none have that property set to true.
* @name Panel#Spot
* @constant
* @static
* @return {EnumValue}
*/
Panel['Spot'] = Panel.Spot = Util.defineEnumValue(Panel, 'Spot', 3);

/**
* This value for {@link #type} resizes the main element to fit around the other elements;
* the main element is the first GraphObject with {@link GraphObject#isPanelMain} set to true,
* or else the first GraphObject if none have that property set to true.
* @name Panel#Auto
* @constant
* @static
* @return {EnumValue}
*/
Panel['Auto'] = Panel.Auto = Util.defineEnumValue(Panel, 'Auto', 4);

/**
* This value for {@link #type} arranges GraphObjects into rows and columns;
* set the {@link GraphObject#row} and {@link GraphObject#column} properties on each element.
* @name Panel#Table
* @constant
* @static
* @return {EnumValue}
*/
Panel['Table'] = Panel.Table = Util.defineEnumValue(Panel, 'Table', 5);

/**
* This value for {@link #type} rescales a single GraphObject to fit inside the panel
* depending on the element's {@link GraphObject#stretch} property.
* @name Panel#Viewbox
* @constant
* @static
* @return {EnumValue}
*/
Panel['Viewbox'] = Panel.Viewbox = Util.defineEnumValue(Panel, 'Viewbox', 6);

/**
* Organizational Panel type that is only valid inside of a Table panel.
* @name Panel#TableRow
* @constant
* @static
* @return {EnumValue}
* @since 1.1
*/
Panel['TableRow'] = Panel.TableRow = Util.defineEnumValue(Panel, 'TableRow', 7);

/**
* Organizational Panel type that is only valid inside of a Table panel.
* @name Panel#TableColumn
* @constant
* @static
* @return {EnumValue}
* @since 1.1
*/
Panel['TableColumn'] = Panel.TableColumn = Util.defineEnumValue(Panel, 'TableColumn', 8);

/**
* This value for {@link #type} is used for {@link Link}s and adornments that act as {@link Link}s.
* @name Panel#Link
* @constant
* @static
* @return {EnumValue}
*/
Panel['Link'] = Panel.Link = Util.defineEnumValue(Panel, 'Link', 9);

/**
* This value for {@link #type} is used to draw regular patterns of lines.
* @name Panel#Grid
* @constant
* @static
* @return {EnumValue}
*/
Panel['Grid'] = Panel.Grid = Util.defineEnumValue(Panel, 'Grid', 10);


/**
* Gets or sets the type of the Panel, which controls how the Panel's elements are measured and arranged.
* The only accepted values are listed as constant properties of Panel, including:
* <ul>
* <li>{@link Panel#Position}</li>
* <li>{@link Panel#Vertical}</li>
* <li>{@link Panel#Horizontal}</li>
* <li>{@link Panel#Auto}</li>
* <li>{@link Panel#Spot}</li>
* <li>{@link Panel#Table}</li>
* <li>{@link Panel#Viewbox}</li>
* <li>{@link Panel#Link} (see also {@link Link}s, which are all Panels of type Link)</li>
* <li>{@link Panel#TableRow}</li>
* <li>{@link Panel#TableColumn}</li>
* <li>{@link Panel#Grid}</li>
* </ul>
* The default value is {@link Panel#Position}.
* <p>
* You must not modify this property once the Panel has been measured or the Panel has been added to another Panel.
* @name Panel#type
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
Panel.prototype.type;
Util.exportProperty(Panel, 'type', Panel.prototype.type);
Util.defineProperty(Panel, { type: 'type' },
  /** @this {Panel} */
  function() { return this._type; },
  /** @this {Panel} */
  function(val) {
    var old = this._type;
    if (old !== val) {
      if (Debug) Util.checkEnumValue(val, Panel, Panel, 'type');
      if (old === Panel.TableRow || old === Panel.TableColumn) Util.throwError('Cannot change Panel.type when it is already a TableRow or a TableColumn: ' + val);
      this._type = val;
      if (this._type === Panel.Grid) this._isAtomic = true;
      else if (this._type === Panel.Table) this.setTablePanelDefaults();
      this.invalidateMeasure();
      this.raiseChanged('type', old, val);
    }
  }
);


/**
* Gets an iterator over the collection of the {@link GraphObject}s that this panel manages.
* <p>
* You can change the collection by calling {@link #add}, {@link #insertAt}, {@link #remove}, or {@link #removeAt}.
* <p>
* You can also get direct access to individual elements by calling {@link #elt}.
* @name Panel#elements
* @function.
* @return {Iterator}
*/
/** @type {Iterator} */
Panel.prototype.elements;
Util.defineReadOnlyProperty(Panel, { elements: 'elements' },
  /** @this {Panel} */
  function() { return this._elements.iterator; }
);

/**
* @ignore
* Gets the natural bounds of this Panel.
* @name Panel#naturalBounds
* @function.
* @return {Rect}
*/
/** @type {Rect} */
Panel.prototype.naturalBounds;
Util.defineReadOnlyProperty(Panel, { naturalBounds: 'naturalBounds' },
  /** @this {Panel} */
  function() { return this._naturalBounds; }
);

/**
* Gets or sets the space between this Panel's border and its content, depending on the type of panel.
* Unlike {@link GraphObject#margin}, padding expands the area inside of the Panel's border.
* <p>
* Padding cannot contain negative numbers.
* The default value is a {@link Margin} of zero.
* @name Panel#padding
* @function.
* @return {Margin|number}
*/
/** @type {Margin|number} */
Panel.prototype.padding;
Util.exportProperty(Panel, 'padding', Panel.prototype.padding);
Util.defineProperty(Panel, { padding: 'padding' },
  /** @this {Panel} */
  function() { return this._padding; },
  /** @this {Panel} */
  function(val) {
    if (typeof val === 'number') {
      if (val < 0) Util.throwRangeError(val, '>= 0', Panel, 'padding');
      val = new Margin(val);
    } else {
      Util.checkClass(val, Margin, Panel, 'padding');
      if (val.left < 0) Util.throwRangeError(val.left, '>= 0', Panel, 'padding:val.left');
      if (val.right < 0) Util.throwRangeError(val.right, '>= 0', Panel, 'padding:val.right');
      if (val.top < 0) Util.throwRangeError(val.top, '>= 0', Panel, 'padding:val.top');
      if (val.bottom < 0) Util.throwRangeError(val.bottom, '>= 0', Panel, 'padding:val.bottom');
    }
    var old = this._padding;
    if (!old.equals(val)) {
      val = val.copyFrozen();
      this._padding = val;
      this.invalidateMeasure();
      this.raiseChanged('padding', old, val);
    }
  }
);

/**
* Gets or sets the default alignment spot of this Panel, used as
* the alignment for an element when its {@link GraphObject#alignment} value is {@link Spot#Default}.
* The default value is {@link Spot#Default}, which is interpreted by the Panel in whatever manner seems reasonable,
* depending on the Panel type.
* @name Panel#defaultAlignment
* @function.
* @return {Spot}
*/
/** @type {Spot} */
Panel.prototype.defaultAlignment;
Util.exportProperty(Panel, 'defaultAlignment', Panel.prototype.defaultAlignment);
Util.defineProperty(Panel, { defaultAlignment: 'defaultAlignment' },
  /** @this {Panel} */
  function() { return this._defaultAlignment; },
  /** @this {Panel} */
  function(val) {
    var old = this._defaultAlignment;
    if (!old.equals(val)) {
      if (Debug) Util.checkClass(val, Spot, Panel, 'defaultAlignment');
      val = val.copyFrozen();
      this._defaultAlignment = val;
      this.invalidateMeasure();
      this.raiseChanged('defaultAlignment', old, val);
    }
  }
);

/**
* Gets or sets the default stretch of this Panel, used as
* the stretch for an element when its {@link GraphObject#stretch} value is {@link GraphObject#Default}.
* The default value is {@link GraphObject#Default}, which typically resolves to {@link GraphObject#None}.
* @name Panel#defaultStretch
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
Panel.prototype.defaultStretch;
Util.exportProperty(Panel, 'defaultStretch', Panel.prototype.defaultStretch);
Util.defineProperty(Panel, { defaultStretch: 'defaultStretch' },
  /** @this {Panel} */
  function() { return this._defaultStretch; },
  /** @this {Panel} */
  function(val) {
    var old = this._defaultStretch;
    if (old !== val) {
      Util.checkEnumValue(val, GraphObject, Panel, 'defaultStretch');
      this._defaultStretch = val;
      this.invalidateMeasure();
      this.raiseChanged('defaultStretch', old, val);
    }
  }
);

/**
* Gets or sets the additional padding for rows and columns in a Table Panel.
* Padding is applied both before and after a row or column's contents.
* @name Panel#defaultSeparatorPadding
* @function.
* @return {Margin} the row or column spacing.
* @since 1.2
* @see RowColumnDefinition#separatorPadding
* @see #defaultColumnSeparatorStrokeWidth
* @see #defaultRowSeparatorStrokeWidth
*/
/** @type {Margin} */
Panel.prototype.defaultSeparatorPadding;
Util.exportProperty(Panel, 'defaultSeparatorPadding', Panel.prototype.defaultSeparatorPadding);
Util.defineProperty(Panel, { defaultSeparatorPadding: 'defaultSeparatorPadding' },
  /** @this {Panel} */
  function() { return this._defaultSeparatorPadding === undefined ? Geo.ZeroMargin : this._defaultSeparatorPadding; },
  /** @this {Panel} */
  function(val) {
    if (this._defaultSeparatorPadding === undefined) return;
    if (typeof val === 'number') {
      val = new Margin(val);
    } else {
      if (Debug) Util.checkClass(val, Margin, Panel, 'defaultSeparatorPadding');
    }
    var old = this._defaultSeparatorPadding;
    if (!old.equals(val)) {
      val = val.copyFrozen();
      this._defaultSeparatorPadding = val;
      this.raiseChanged('defaultSeparatorPadding', old, val);
    }
  }
);

/**
* Gets or sets the default stroke (color) for rows in a Table Panel
* provided a given row has a nonzero {@link RowColumnDefinition#separatorStrokeWidth}.
* {@link RowColumnDefinition#separatorStroke} can override this default value.
* The default value is null -- no line is drawn.
* @name Panel#defaultRowSeparatorStroke
* @function.
* @return {string|Brush}
* @since 1.2
* @see #defaultRowSeparatorStrokeWidth
* @see #defaultRowSeparatorDashArray
* @see RowColumnDefinition#separatorStroke
* @see #defaultColumnSeparatorStroke
*/
/** @type {string|Brush} */
Panel.prototype.defaultRowSeparatorStroke;
Util.exportProperty(Panel, 'defaultRowSeparatorStroke', Panel.prototype.defaultRowSeparatorStroke);
Util.defineProperty(Panel, { defaultRowSeparatorStroke: 'defaultRowSeparatorStroke' },
  /** @this {Panel} */
  function() { return this._defaultRowSeparatorStroke === undefined ? null : this._defaultRowSeparatorStroke; },
  /** @this {Panel} */
  function(val) {
    var old = this._defaultRowSeparatorStroke;
    if (old !== val) {
      if (val === null || typeof val === 'string' || val instanceof Brush) {
        if (val instanceof Brush) val.freeze();
        this._defaultRowSeparatorStroke = val;
        this.raiseChanged('defaultRowSeparatorStroke', old, val);
      }
    }
  }
);

/**
* Gets or sets the default stroke width for a row's separator in a Table Panel.
* {@link RowColumnDefinition#separatorStrokeWidth} can override this default value.
* The default value is 1.
* @name Panel#defaultRowSeparatorStrokeWidth
* @function.
* @return {number}
* @since 1.2
* @see RowColumnDefinition#separatorStrokeWidth
* @see #defaultColumnSeparatorStrokeWidth
*/
/** @type {number} */
Panel.prototype.defaultRowSeparatorStrokeWidth;
Util.exportProperty(Panel, 'defaultRowSeparatorStrokeWidth', Panel.prototype.defaultRowSeparatorStrokeWidth);
Util.defineProperty(Panel, { defaultRowSeparatorStrokeWidth: 'defaultRowSeparatorStrokeWidth' },
  /** @this {Panel} */
  function() { return this._defaultRowSeparatorStrokeWidth === undefined ? 1 : this._defaultRowSeparatorStrokeWidth; },
  /** @this {Panel} */
  function(val) {
    if (this._defaultRowSeparatorStrokeWidth === undefined) return;
    var old = this._defaultRowSeparatorStrokeWidth;
    if (old !== val) {
      this._defaultRowSeparatorStrokeWidth = val;
      this.raiseChanged('defaultRowSeparatorStrokeWidth', old, val);
    }
  }
);

/**
* Gets or sets the default dash array for a row's separator in a Table Panel.
* {@link RowColumnDefinition#separatorStrokeWidth} can override this default value.
* The default is null: the line is solid -- there is no dash pattern.
* @name Panel#defaultRowSeparatorDashArray
* @function.
* @return {Array.<number>}
* @since 1.2
* @see RowColumnDefinition#separatorDashArray
* @see #defaultColumnSeparatorDashArray
*/
/** @type {Array.<number>} */
Panel.prototype.defaultRowSeparatorDashArray;
Util.exportProperty(Panel, 'defaultRowSeparatorDashArray', Panel.prototype.defaultRowSeparatorDashArray);
Util.defineProperty(Panel, { defaultRowSeparatorDashArray: 'defaultRowSeparatorDashArray' },
  /** @this {Panel} */
  function() { return this._defaultRowSeparatorDashArray === undefined ? null : this._defaultRowSeparatorDashArray; },
  /** @this {Panel} */
  function(val) {
    if (this._defaultRowSeparatorDashArray === undefined) return;
    var old = this._defaultRowSeparatorDashArray;
    if (old !== val) {
      // make sure its an array of numbers?
      if (!(val instanceof Array)) Util.throwTypeError(val, 'Array', Panel, 'defaultRowSeparatorDashArray:val');
      this._defaultRowSeparatorDashArray = val;
      this.raiseChanged('defaultRowSeparatorDashArray', old, val);
    }
  }
);

/**
* Gets or sets the default stroke (color) for columns in a Table Panel
* provided a given column has a nonzero {@link RowColumnDefinition#separatorStrokeWidth}.
* {@link RowColumnDefinition#separatorStroke} can override this default value.
* The default value is null -- no line is drawn.
* @name Panel#defaultColumnSeparatorStroke
* @function.
* @return {string|Brush}
* @since 1.2
* @see #defaultColumnSeparatorStrokeWidth
* @see #defaultColumnSeparatorDashArray
* @see RowColumnDefinition#separatorStroke
* @see #defaultRowSeparatorStroke
*/
/** @type {string|Brush} */
Panel.prototype.defaultColumnSeparatorStroke;
Util.exportProperty(Panel, 'defaultColumnSeparatorStroke', Panel.prototype.defaultColumnSeparatorStroke);
Util.defineProperty(Panel, { defaultColumnSeparatorStroke: 'defaultColumnSeparatorStroke' },
  /** @this {Panel} */
  function() { return this._defaultColumnSeparatorStroke === undefined ? null : this._defaultColumnSeparatorStroke; },
  /** @this {Panel} */
  function(val) {
    if (this._defaultColumnSeparatorStroke === undefined) return;
    var old = this._defaultColumnSeparatorStroke;
    if (old !== val) {
      if (val === null || typeof val === 'string' || val instanceof Brush) {
        if (val instanceof Brush) val.freeze();
        this._defaultColumnSeparatorStroke = val;
        this.raiseChanged('defaultColumnSeparatorStroke', old, val);
      }
    }
  }
);

/**
* Gets or sets the default stroke width for a column's separator in a Table Panel.
* {@link RowColumnDefinition#separatorStrokeWidth} can override this default value.
* The default value is 1.
* @name Panel#defaultColumnSeparatorStrokeWidth
* @function.
* @return {number}
* @since 1.2
* @see RowColumnDefinition#separatorStrokeWidth
* @see #defaultRowSeparatorStrokeWidth
*/
/** @type {number} */
Panel.prototype.defaultColumnSeparatorStrokeWidth;
Util.exportProperty(Panel, 'defaultColumnSeparatorStrokeWidth', Panel.prototype.defaultColumnSeparatorStrokeWidth);
Util.defineProperty(Panel, { defaultColumnSeparatorStrokeWidth: 'defaultColumnSeparatorStrokeWidth' },
  /** @this {Panel} */
  function() { return this._defaultColumnSeparatorStrokeWidth === undefined ? 1 : this._defaultColumnSeparatorStrokeWidth; },
  /** @this {Panel} */
  function(val) {
    if (this._defaultColumnSeparatorStrokeWidth === undefined) return;
    var old = this._defaultColumnSeparatorStrokeWidth;
    if (old !== val) {
      this._defaultColumnSeparatorStrokeWidth = val;
      this.raiseChanged('defaultColumnSeparatorStrokeWidth', old, val);
    }
  }
);

/**
* Gets or sets the default dash array for a column's separator in a Table Panel.
* {@link RowColumnDefinition#separatorStrokeWidth} can override this default value.
* The default is null: the line is solid -- there is no dash pattern.
* @name Panel#defaultColumnSeparatorDashArray
* @function.
* @return {Array.<number>}
* @since 1.2
* @see RowColumnDefinition#separatorDashArray
* @see #defaultRowSeparatorDashArray
*/
/** @type {Array.<number>} */
Panel.prototype.defaultColumnSeparatorDashArray;
Util.exportProperty(Panel, 'defaultColumnSeparatorDashArray', Panel.prototype.defaultColumnSeparatorDashArray);
Util.defineProperty(Panel, { defaultColumnSeparatorDashArray: 'defaultColumnSeparatorDashArray' },
  /** @this {Panel} */
  function() { return this._defaultColumnSeparatorDashArray === undefined ? null : this._defaultColumnSeparatorDashArray; },
  /** @this {Panel} */
  function(val) {
    if (this._defaultColumnSeparatorDashArray === undefined) return;
    var old = this._defaultColumnSeparatorDashArray;
    if (old !== val) {
      // make sure its an array of numbers?
      if (!(val instanceof Array)) Util.throwTypeError(val, 'Array', Panel, 'defaultColumnSeparatorDashArray:val');
      this._defaultColumnSeparatorDashArray = val;
      this.raiseChanged('defaultColumnSeparatorDashArray', old, val);
    }
  }
);

/**
 * Gets or sets how a {@link #Viewbox} panel will resize its content.
 * <p>
 * Possible values are {@link GraphObject#Uniform} and {@link GraphObject#UniformToFill}.
 * The default is {@link GraphObject#Uniform}.
 * @name Panel#viewboxStretch
 * @function.
 * @return {EnumValue}
 */
/** @type {EnumValue} */
Panel.prototype.viewboxStretch;
Util.exportProperty(Panel, 'viewboxStretch', Panel.prototype.viewboxStretch);
Util.defineProperty(Panel, { viewboxStretch: 'viewboxStretch' },
  /** @this {Panel} */
  function() { return this._viewboxStretch; },
  /** @this {Panel} */
  function(val) {
    var old = this._viewboxStretch;
    if (old !== val) {
      Util.checkEnumValue(val, GraphObject, Panel, 'viewboxStretch');
      this._viewboxStretch = val;
      this.raiseChanged('viewboxStretch', old, val);
    }
  }
);

/**
 * Gets or sets the distance between lines in a {@link #Grid} panel.
 * The units are in local coordinates.
 * The default is 10x10.  Any new width or height must be a positive real number.
 * @name Panel#gridCellSize
 * @function.
 * @return {Size}
 */
/** @type {Size} */
Panel.prototype.gridCellSize;
Util.exportProperty(Panel, 'gridCellSize', Panel.prototype.gridCellSize);
Util.defineProperty(Panel, { gridCellSize: 'gridCellSize' },
  /** @this {Panel} */
  function() { return this._gridCellSize; },
  /** @this {Panel} */
  function(val) {
    var old = this._gridCellSize;
    if (!old.equals(val)) {
      Util.checkClass(val, Size, Panel, 'gridCellSize');
      if (!val.isReal() || val.width === 0 || val.height === 0) Util.throwError('Invalid Panel.gridCellSize: ' + val);
      this._gridCellSize = val.copyFrozen();
      if (this.diagram !== null && this === this.diagram.grid) {
        this.diagram._updateBackgroundGrid();
      }
      this.invalidateDraw();
      this.raiseChanged('gridCellSize', old, val);
    }
  }
);

/**
 * Gets or sets an origin point for the grid cells in a {@link #Grid} panel.
 * The units are in local coordinates.
 * The default is (0,0).  Any new value must use real numbers.
 * @name Panel#gridOrigin
 * @function.
 * @return {Point}
 */
/** @type {Point} */
Panel.prototype.gridOrigin;
Util.exportProperty(Panel, 'gridOrigin', Panel.prototype.gridOrigin);
Util.defineProperty(Panel, { gridOrigin: 'gridOrigin' },
  /** @this {Panel} */
  function() { return this._gridOrigin; },
  /** @this {Panel} */
  function(val) {
    var old = this._gridOrigin;
    if (!old.equals(val)) {
      Util.checkClass(val, Point, Panel, 'gridOrigin');
      if (!val.isReal()) Util.throwError('Invalid Panel.gridOrigin: ' + val);
      this._gridOrigin = val.copyFrozen();
      this.invalidateDraw();
      this.raiseChanged('gridOrigin', old, val);
    }
  }
);

/**
* @ignore
* @this {Panel}
* @param {CanvasRenderingContext2D} context
* @param {Diagram} diagram
*/
Panel.prototype.drawProtected = function(context, diagram) {
  var opacity = this.opacity;
  var old = 1;
  if (opacity !== 1) {
    old = context.globalAlpha;
    context.globalAlpha = old * opacity;
  }
  if (this._type === Panel.Grid) {
    this.drawProtectedGrid(context, diagram);
    return;
  }
  if (this._type === Panel.Table) {
    this.drawProtectedSpacers(context, diagram);
  }
  var l = this._elements.length;
  for (var i = 0; i < l; i++) {
    this._elements._arr[i].draw(context, diagram);
  }
  if (Debug && Debug.drawLinkpointsEnabled) {
    if (this instanceof Link)
    Debug.drawLinkpoints(context, diagram, this);
  }
  if (opacity !== 1) {
    context.globalAlpha = old;
  }
};

/**
* @ignore
* @this {Panel}
* @param {CanvasRenderingContext2D} context
* @param {Diagram} diagram
*/
Panel.prototype.drawProtectedGrid = function(context, diagram) {
  var scale = this.getDocumentScale() * diagram.scale;
  if (scale <= 0) scale = 1;
  var csz = this.gridCellSize;
  var cw = csz.width;
  var ch = csz.height;
  var nb = this.naturalBounds;
  var gw = nb.width;
  var gh = nb.height;
  var numx = Math.ceil(gw / cw);
  var numy = Math.ceil(gh / ch);
  var cpt = this.gridOrigin;

  context.save();
  context.beginPath();
  context.rect(0, 0, gw, gh);
  context.clip();

  var intsarr = this._collectIntervals();  //??? cache!
  var len = this._elements.length;
  for (var c = 0; c < len; c++) {
    var shape = this._elements._arr[c];
    // don't need to check for Shapes because .insertAt now checks
    //if (!(shape instanceof Shape)) continue;
    if (!shape.visible) continue;
    // use the properties of shape to draw relevant lines
    var ints = intsarr[c];
    var freq = shape.interval;

    var dash = false;
    var strokeDashArray = shape.strokeDashArray;
    if (strokeDashArray !== null) {
      dash = true;
      var nativeDash = true;
      if (context['setLineDash'] !== undefined) {
        context['setLineDash'](strokeDashArray);
        context['lineDashOffset'] = shape._strokeDashOffset;
      } else if (context['webkitLineDash'] !== undefined) {
        context['webkitLineDash'] = strokeDashArray;
        context['webkitLineDashOffset'] = shape._strokeDashOffset;
      } else if (context['mozDash'] !== undefined) {
        context['mozDash'] = strokeDashArray;
        context['mozDashOffset'] = shape._strokeDashOffset;
      } else {
        // no native support!
        nativeDash = false;
      }
    }


    context.lineWidth = shape.strokeWidth;
    this.setBrush(context, shape.stroke, false);
    context.beginPath();

    if (shape.figure === 'LineV') {
      var start = Math.floor(-cpt.x / cw);
      for (var i = start; i <= start + numx; i++) {
        var x = i * cw + cpt.x;
        if (0 <= x && x < gw && this._shouldDraw(i, freq, ints)) {
          //context.moveTo(x, 0);
          //context.lineTo(x, gh);
          if (dash && !nativeDash) {
            GraphObject.drawDash(context, x, 0, x, gh, strokeDashArray, shape._strokeDashOffset);
          } else {
            context.moveTo(x, 0);
            context.lineTo(x, gh);
          }
          if (cw * freq * scale < 2) break;
        }
      }
    } else /* if (shape.figure === 'LineH') */ {
      var start = Math.floor(-cpt.y / ch);
      for (var i = start; i <= start + numy; i++) {
        var y = i * ch + cpt.y;
        if (0 <= y && y <= gh && this._shouldDraw(i, freq, ints)) {
          //context.moveTo(0, y);
          //context.lineTo(gw, y);
          if (dash && !nativeDash) {
            GraphObject.drawDash(context, 0, y, gw, y, strokeDashArray, shape._strokeDashOffset);
          } else {
            context.moveTo(0, y);
            context.lineTo(gw, y);
          }
          if (ch * freq * scale < 2) break;
        }
      }
    }

    context.stroke();

    // Set dash back when done
    if (dash) {
      if (context['setLineDash'] !== undefined) {
        context['setLineDash'](Util.EmptyArray);
        context['lineDashOffset'] = 0;
      } else if (context['webkitLineDash'] !== undefined) {
        context['webkitLineDash'] = Util.EmptyArray;
        context['webkitLineDashOffset'] = 0;
      } else if (context['mozDash'] !== undefined) {
        context['mozDash'] = null;
        context['mozDashOffset'] = 0;
      } else {
        // no native support!
      }
    }

  }

  context.restore();
  diagram.clearContextCache(context);
};

/**
* @ignore
* @this {Panel}
* @param {CanvasRenderingContext2D} context
* @param {Diagram} diagram
*/
Panel.prototype.drawProtectedSpacers = function(context, diagram) {
  context.lineCap = 'butt';
  this.drawProtectedBackgrounds(context, diagram, true, this._rowDefs, true);
  this.drawProtectedBackgrounds(context, diagram, false, this._colDefs, true);

  this.drawProtectedSpacers2(context, diagram, true, this._rowDefs);
  this.drawProtectedSpacers2(context, diagram, false, this._colDefs);

  this.drawProtectedBackgrounds(context, diagram, true, this._rowDefs, false);
  this.drawProtectedBackgrounds(context, diagram, false, this._colDefs, false);
};

/**
* @ignore
* @this {Panel}
* @param {CanvasRenderingContext2D} context
* @param {Diagram} diagram
* @param {boolean} isRow
* @param {Array} rowColDefs
*/
Panel.prototype.drawProtectedSpacers2 = function(context, diagram, isRow, rowColDefs) {
  var l = rowColDefs.length;
  var def;
  var ab = this.actualBounds;
  var first = isRow ? this.getRowDefinition(0) : this.getColumnDefinition(0);
  for (var i = 0; i < l; i++) {
    def = rowColDefs[i];
    if (def === undefined) continue;
    if (def === first) continue;
    if (def.actual === 0) continue;
    var spacing = def.separatorStrokeWidth;
    if (isNaN(spacing)) spacing = isRow ? this._defaultRowSeparatorStrokeWidth : this._defaultColumnSeparatorStrokeWidth;
    var stroke = def.separatorStroke;
    if (stroke === null) stroke = isRow ? this._defaultRowSeparatorStroke : this._defaultColumnSeparatorStroke;
    if (spacing === 0 || stroke === null) continue;
    this.setBrush(context, stroke, false);

    var dash = false;
    var separatorDashArray = def.separatorDashArray;
    if (separatorDashArray !== null) {
      dash = true;
      var nativeDash = true;
      if (context['setLineDash'] !== undefined) {
        context['setLineDash'](separatorDashArray);
        context['lineDashOffset'] = this._strokeDashOffset;
      } else if (context['webkitLineDash'] !== undefined) {
        context['webkitLineDash'] = separatorDashArray;
        context['webkitLineDashOffset'] = this._strokeDashOffset;
      } else if (context['mozDash'] !== undefined) {
        context['mozDash'] = separatorDashArray;
        context['mozDashOffset'] = this._strokeDashOffset;
      } else {
        // no native support!
        nativeDash = false;
      }
    }

    context.beginPath();

    var bot = def.position + spacing; // "bottom" of the line to be drawn
    if (isRow) {
      if (bot > ab.height) spacing -= bot - ab.height;
    } else {
      if (bot > ab.width) spacing -= bot - ab.width;
    }
    var p = def.position + (spacing / 2); // middle of the line
    context.lineWidth = spacing;
    var padding = this.padding;

    if (isRow) {
      p += padding.top;
      var start = padding.left;
      var end = ab.width - padding.right;
      if (dash && !nativeDash) {
        GraphObject.drawDash(context, start, p, end, p, separatorDashArray, 0);
      } else {
        context.moveTo(start, p);
        context.lineTo(end, p);
      }
    } else {
      p += padding.left;
      var start = padding.top;
      var end = ab.height - padding.bottom;
      if (dash && !nativeDash) {
        GraphObject.drawDash(context, p, start, p, end, separatorDashArray, 0);
      } else {
        context.moveTo(p, start);
        context.lineTo(p, end);
      }
    }
    context.stroke();

    // Set dash back when done
    if (dash) {
      if (context['setLineDash'] !== undefined) {
        context['setLineDash'](Util.EmptyArray);
        context['lineDashOffset'] = 0;
      } else if (context['webkitLineDash'] !== undefined) {
        context['webkitLineDash'] = Util.EmptyArray;
        context['webkitLineDashOffset'] = 0;
      } else if (context['mozDash'] !== undefined) {
        context['mozDash'] = null;
        context['mozDashOffset'] = 0;
      } else {
        // no native support!
      }
    }
  }
};

/**
* @ignore
* @this {Panel}
* @param {CanvasRenderingContext2D} context
* @param {Diagram} diagram
* @param {boolean} isRow
* @param {Array} rowColDefs
* @param {boolean} behind
*/
Panel.prototype.drawProtectedBackgrounds = function(context, diagram, isRow, rowColDefs, behind) {
  var l = rowColDefs.length;
  var def;
  var ab = this.actualBounds;
  for (var i = 0; i < l; i++) {
    def = rowColDefs[i];
    if (def === undefined) continue;
    if (def.background === null) continue;
    if (def.coversSeparators === behind) continue;
    if (def.actual === 0) continue;

    var panelActual = isRow ? ab.height : ab.width;
    if (def.position > panelActual) continue;
    var spacing = def.getEffectiveSpacing();
    var sw = def.separatorStrokeWidth;
    if (isNaN(sw)) sw = isRow ? this._defaultRowSeparatorStrokeWidth : this._defaultColumnSeparatorStrokeWidth;
    var stroke = def.separatorStroke;
    if (stroke === null) stroke = isRow ? this._defaultRowSeparatorStroke : this._defaultColumnSeparatorStroke;
    if (stroke === null) sw = 0;

    spacing -= sw;
    var pos = def.position + sw;
    var amt = spacing + def.actual;
    if (pos + amt > panelActual) {
      amt = panelActual - pos;
    }
    if (amt <= 0) continue;
    var padding = this.padding;
    this.setBrush(context, def.background, true);
    if (isRow) {
      context.fillRect(padding.left, pos + padding.top, ab.width - (padding.left + padding.right), amt);
    } else {
      context.fillRect(pos + padding.left, padding.top, amt, ab.height - (padding.top + padding.bottom));
    }
  }
};

/**
* @ignore
* Return the size at which the grid pattern repeats.
* @param {Size} size
*/
Panel.prototype._computeTileSize = function(size) {
  var hlcm = 1;
  var vlcm = 1;
  var len = this._elements.length;
  for (var c = 0; c < len; c++) {
    var shape = this._elements._arr[c];
    var interval = shape.interval;
    if (interval < 2) continue;
    if (this._isVertical(shape.figure)) {
      vlcm = (vlcm * interval) / Geo.gcd(vlcm, interval);
    } else {
      hlcm = (hlcm * interval) / Geo.gcd(hlcm, interval);
    }
  }
  var csz = this.gridCellSize;
  size._set(vlcm * csz.width, hlcm * csz.height);
};

/**
* @ignore
* For now, just assume LineH and LineV Shape.figure values.
* Unlike GoXam, no support for Shape.offset, just Shape.interval.
* @return {Array}
*/
Panel.prototype._collectIntervals = function() {
  var list = [];  // Array of Array of number
  var paths = this._elements._arr;
  var len = this._elements.length;
  for (var i = 0; i < len; i++) {
    var ints = [];  // intervals for this element,
    list.push(ints);  // even if this Shape should be ignored (e.g., !visible)
    var path = paths[i];
    if (!path.visible) continue;
    var fig = path.figure;
    var vert = this._isVertical(fig);
    // iterate over other shapes in the same orientation and collect their intervals
    for (var j = i + 1; j < len; j++) {
      var q = paths[j];
      if (!q.visible) continue;
      var f = q.figure;
      if (this._isVertical(f) !== vert) continue;  // skip Shapes that are not the same orientation
      var v = q.interval;
      if (v >= 2) ints.push(v);  // save interval info if it isn't every time
    }
  }
  return list;
};

/**
* @ignore
* See if the Nth line should be drawn, considering both its frequency
* and whether any later (in Z order) lines would be drawn at this point
* @this {Panel}
* @param {number} i
* @param {number} freq
* @param {Array} ints
*/
Panel.prototype._shouldDraw = function(i, freq, ints) {
  // negative numerators don't matter when comparing with zero
  // assumes FREQ > 0
  if (i % freq !== 0) return false;
  var len = ints.length;
  for (var j = 0; j < len; j++) {
    // assumes interval > 0
    var fs = ints[j];
    if (i % fs === 0) return false;
  }
  return true;
};

/**
* @ignore
* @this {Panel}
* @return {boolean}
*/
Panel.prototype._isVertical = function(fig) {
  return (fig === 'LineV');
};


/**
* @ignore
* @this {Panel}
* @param {number} width
* @param {number} height
* @param {number} minw
* @param {number} minh
*/
Panel.prototype.measureProtected = function(width, height, minw, minh) {
  var union = this._union;
  union.width = 0;
  union.height = 0;

  var des = this.desiredSize;
  var min = this.minSize;
  if (minw === undefined) {
    minw = min.width;
    minh = min.height;
  }
  minw = Math.max(minw, min.width);
  minh = Math.max(minh, min.height);
  var max = this.maxSize;
  if (!isNaN(des.width)) width = Math.min(des.width, max.width);
  if (!isNaN(des.height)) height = Math.min(des.height, max.height);
  // height and width are affected by desired size and min size, but not max size
  // max size affects child objects only after they have been measured
  width = Math.max(minw, width);
  height = Math.max(minh, height);

  // Take out all padding from the available width and height
  // But don't let them fall below zero
  var padding = this.padding;
  width = Math.max(width - padding.left - padding.right, 0);
  height = Math.max(height - padding.top - padding.bottom, 0);

  var children = this._elements;
  var l = children.length;
  if (l === 0) {
    var nb = this._naturalBounds;
    nb.setWidthHeight(!isNaN(des.width) ? width : 0, !isNaN(des.height) ? height : 0);
    this._measureRect(0, 0, nb.width, nb.height);
    return;
  }

  var panel = this._type._name;
  switch (panel) {
    case 'Position':
      this.measurePosition(width, height, children, l, union, minw, minh);
      break;
    case 'Vertical':
      this.measureVertical(width, height, children, l, union, minw, minh);
      break;
    case 'Horizontal':
      this.measureHorizontal(width, height, children, l, union, minw, minh);
      break;
    case 'Spot':
      this.measureSpot(width, height, children, l, union, minw, minh);
      break;
    case 'Auto':
      this.measureAuto(width, height, children, l, union, minw, minh);
      break;
    case 'Table':
      this.measureTable(width, height, children, l, union, minw, minh);
      break;
    case 'Viewbox':
      this.measureViewbox(width, height, children, l, union, minw, minh);
      break;
    case 'Link':
      this.measureLink(width, height, children, l, union, minw, minh);
      break;
    case 'Grid':
      this.measureGrid(width, height, children, l, union, minw, minh);
      break;
    case 'TableRow':
    case 'TableColumn':
      Util.throwError(this.toString() + ' is not an element of a Table Panel. ' +
                      'TableRow and TableColumn Panels can only be elements of a Table Panel.');
      break;
    default:
      Util.throwError('Unknown panel type: ' + panel);
  }

  // constrain union to get true natural width/height
  var nw = union.width;
  var nh = union.height;

  var p = this.padding;
  var pw = p.left + p.right;
  var ph = p.top + p.bottom;

  nw += pw;
  nh += ph;
  if (isFinite(des.width)) { nw = des.width; }
  if (isFinite(des.height)) { nh = des.height; }
  nw = Math.min(max.width, nw);
  nh = Math.min(max.height, nh);
  nw = Math.max(min.width, nw);
  nh = Math.max(min.height, nh);

  nw = Math.max(minw, nw);
  nh = Math.max(minh, nh);

  union.width = nw;
  union.height = nh;

  var nb = this._naturalBounds;
  nb.setWidthHeight(nw, nh);

  this._measureRect(0, 0, nw, nh);
};    // end measure


Panel.prototype['findMainElement'] =
/**
* @ignore
* Return an immediate child element whose {@link GraphObject#isPanelMain} is true,
* or else just return the first child element.
* @this {Panel}
* @return {GraphObject}
*/
Panel.prototype.findMainElement = function() {
  if (this._tempMain === null) {
    this.getMainChild(this._elements, this._elements.length);
  }
  return this._tempMain;
};

/**
* @ignore
* @this {Panel}
* @return {GraphObject}
*/
Panel.prototype.getMainChild = function(children, l) {
  for (var i = 0; i < l; i++) {
    var child = children._arr[i];
    if (child.isPanelMain === true) {
      this._tempMain = child;
      return child;
    }
  }
  var main = children._arr[0];
  this._tempMain = main;
  return main;
};



//measure all children to get the bounding box of the panel
/** @ignore */
Panel.prototype.measurePosition = function(width, height, children, l, union, minw, minh) {
  union.x = 0;
  union.y = 0;
  union.width = 0;
  union.height = 0;
  for (var i = 0; i < l; i++) {
    var child = children._arr[i];
    if (!child.visible && child !== this.locationObject) continue;
    var marg = child.margin;
    var margw = marg.right + marg.left;
    var margh = marg.top + marg.bottom;
    child.measure(width, height, minw, minh);
    var m = child.measuredBounds;
    var mwidth = Math.max(m.width + margw, 0);
    var mheight = Math.max(m.height + margh, 0);

    var x = child.position.x;
    var y = child.position.y;
    if (!isFinite(x)) { x = 0; }
    if (!isFinite(y)) { y = 0; }
    if (child instanceof Shape && child.isGeometryPositioned) {
      var sw = child.strokeWidth / 2;
      x -= sw;
      y -= sw;
    }
    union.unionNoCheck(x, y, mwidth, mheight);
  }
}; // end Position Measure

// Children measured in a vertical stack
/** @ignore */
Panel.prototype.measureVertical = function(width, height, children, l, union, minw, minh) {
  var strchildren = Util.tempArray();
  for (var i = 0; i < l; i++) {
    var child = children._arr[i];
    if (!child.visible && child !== this.locationObject) continue;
    var stretch = child.getEffectiveStretch();
    if (stretch !== GraphObject.None && stretch !== GraphObject.Vertical) {
      strchildren.push(child);
      continue;
    }

    var marg = child.margin;
    var margw = marg.right + marg.left;
    var margh = marg.top + marg.bottom;
    child.measure(width, Infinity, minw, 0); // measure children with infinite height
    var m = child.measuredBounds;
    var mwidth = Math.max(m.width + margw, 0);
    var mheight = Math.max(m.height + margh, 0);

    union.width = Math.max(union.width, mwidth);
    union.height += mheight;
  }

  var len = strchildren.length;
  if (len === 0) return;
  // modify width for stretch children
  if (this.desiredSize.width) {
    width = Math.min(this.desiredSize.width, this.maxSize.width);
  } else if (union.width !== 0) {
    width = Math.min(union.width, this.maxSize.width);
  }

  for (var i = 0; i < len; i++) {
    var child = strchildren[i];
    if (!child.visible && child !== this.locationObject) continue;
    var marg = child.margin;
    var margw = marg.right + marg.left;
    var margh = marg.top + marg.bottom;
    child.measure(width, Infinity, minw, 0); // measure children with infinite height
    var m = child.measuredBounds;
    var mwidth = Math.max(m.width + margw, 0);
    var mheight = Math.max(m.height + margh, 0);

    union.width = Math.max(union.width, mwidth);
    union.height += mheight;
  }
  Util.freeArray(strchildren);
}; // end Vertical measure

// Children measured in a horizontal stack
/** @ignore */
Panel.prototype.measureHorizontal = function(width, height, children, l, union, minw, minh) {
  var strchildren = Util.tempArray();
  for (var i = 0; i < l; i++) {
    var child = children._arr[i];
    if (!child.visible && child !== this.locationObject) continue;
    var stretch = child.getEffectiveStretch();
    if (stretch !== GraphObject.None && stretch !== GraphObject.Horizontal) {
      strchildren.push(child);
      continue;
    }

    var marg = child.margin;
    var margw = marg.right + marg.left;
    var margh = marg.top + marg.bottom;
    child.measure(Infinity, height, 0, minh); // measure children with infinite width
    var m = child.measuredBounds;
    var mwidth = Math.max(m.width + margw, 0);
    var mheight = Math.max(m.height + margh, 0);

    union.width += mwidth;
    union.height = Math.max(union.height, mheight);
  }

  var len = strchildren.length;
  if (len === 0) return;
  // modify height for stretch children
  if (this.desiredSize.height) {
    height = Math.min(this.desiredSize.height, this.maxSize.height);
  } else if (union.height !== 0) {
    height = Math.min(union.height, this.maxSize.height);
  }

  for (var i = 0; i < len; i++) {
    var child = strchildren[i];
    if (!child.visible && child !== this.locationObject) continue;
    var marg = child.margin;
    var margw = marg.right + marg.left;
    var margh = marg.top + marg.bottom;
    child.measure(Infinity, height, 0, minh); // measure children with infinite width
    var m = child.measuredBounds;
    var mwidth = Math.max(m.width + margw, 0);
    var mheight = Math.max(m.height + margh, 0);

    union.width += mwidth;
    union.height = Math.max(union.height, mheight);
  }
  Util.freeArray(strchildren);
}; // end Horizontal measure

/** @ignore */
Panel.prototype.measureSpot = function(width, height, children, l, union, minw, minh) {
  var main = this.getMainChild(children, l);
  // If the panel isn't stretch this is fine.
  // If it is stretch, we will have to remeasure the main object and recreate the union
  var marg = main.margin;
  var margw, margh; // for children
  var mainmargw = marg.right + marg.left;
  var mainmargh = marg.top + marg.bottom;
  main.measure(width, height, minw, minh);
  var m = main.measuredBounds;
  var mainWidth = m.width;
  var mainHeight = m.height;
  var mwidth = Math.max(mainWidth + mainmargw, 0);
  var mheight = Math.max(mainHeight + mainmargh, 0);

  union.x = -marg.left; // we want union.x to be the main object's top left corner, not where its margin is
  union.y = -marg.top;
  union.width = mwidth;
  union.height = mheight;

  for (var i = 0; i < l; i++) {
    //measure children
    var child = children._arr[i];
    if (child === main) continue;
    if (!child.visible && child !== this.locationObject) continue;
    marg = child.margin;
    margw = marg.right + marg.left;
    margh = marg.top + marg.bottom;
    child.measure(width, height, 0, 0); // the minimum is not related to the panel for children of spot panels
    m = child.measuredBounds;
    mwidth = Math.max(m.width + margw, 0);
    mheight = Math.max(m.height + margh, 0);

    var align = child.alignment;
    if (align.isDefault()) align = this.defaultAlignment;
    if (!align.isSpot()) align = Spot.Center;
    var alignfocus = child.alignmentFocus;
    if (alignfocus.isDefault()) alignfocus = Spot.Center;

    union.unionNoCheck(align.x * mainWidth + align.offsetX - (alignfocus.x * m.width - alignfocus.offsetX) - marg.left,
                align.y * mainHeight + align.offsetY - (alignfocus.y * m.height - alignfocus.offsetY) - marg.top,
                mwidth, mheight);
  }


  // We might need to resize the main object and redo the union if there's a stretch.
  // Otherwise we are done
  var stretch = main.stretch;
  if (stretch === GraphObject.Default) stretch = main.getEffectiveStretch();
  switch (stretch) {
    case GraphObject.None:
      return; // we're done
    case GraphObject.Fill:
      if (!isFinite(width) && !isFinite(height)) return;
      break;
    case GraphObject.Horizontal:
      if (!isFinite(width)) return;
      break;
    case GraphObject.Vertical:
      if (!isFinite(height)) return;
      break;
  }

  m = main.measuredBounds;
  mainWidth = m.width;
  mainHeight = m.height;
  mwidth = Math.max(mainWidth + mainmargw, 0);
  mheight = Math.max(mainHeight + mainmargh, 0);

  marg = main.margin;
  union.x = -marg.left; // we want union.x to be the main object's top left corner, not where its margin is
  union.y = -marg.top;
  union.width = mwidth;
  union.height = mheight;

  //  Don't remeasure the children but do recreate the union
  for (var i = 0; i < l; i++) {
    //measure children
    var child = children._arr[i];
    if (child === main) continue;
    if (!child.visible && child !== this.locationObject) continue;
    marg = child.margin;
    margw = marg.right + marg.left;
    margh = marg.top + marg.bottom;
    m = child.measuredBounds;
    mwidth = Math.max(m.width + margw, 0);
    mheight = Math.max(m.height + margh, 0);

    var align = child.alignment;
    if (align.isDefault()) align = this.defaultAlignment;
    if (!align.isSpot()) align = Spot.Center;
    var alignfocus = child.alignmentFocus;
    if (alignfocus.isDefault()) alignfocus = Spot.Center;

    union.unionNoCheck(align.x * mainWidth + align.offsetX - (alignfocus.x * m.width - alignfocus.offsetX) - marg.left,
                align.y * mainHeight + align.offsetY - (alignfocus.y * m.height - alignfocus.offsetY) - marg.top,
                mwidth, mheight);
  }

}; // end Spot measure

// the main object is sized around all the other ones
/** @ignore */
Panel.prototype.measureAuto = function(width, height, children, l, union, minw, minh) {
  var main = this.getMainChild(children, l);

  // Main is only correctly measured after the others have been
  // but it must be dummy-measured first to get a basic size for spot1 and 2
  var marg = main.margin;
  var mainmargw = marg.right + marg.left;
  var mainmargh = marg.top + marg.bottom;
  main.measure(width, height, minw, minh);
  var m = main.measuredBounds;
  var mwidth = Math.max(m.width + mainmargw, 0);
  var mheight = Math.max(m.height + mainmargh, 0);
  // use the inner size for relevant width/height
  var spot = this.computeSpot1(main);
  var p1x = spot.x * mwidth + spot.offsetX;
  var p1y = spot.y * mheight + spot.offsetY;
  spot = this.computeSpot2(main);
  var p2x = spot.x * mwidth + spot.offsetX;
  var p2y = spot.y * mheight + spot.offsetY;

  var cw = width;
  var ch = height;
  if (isFinite(width)) cw = Math.abs(p1x - p2x);
  if (isFinite(height)) ch = Math.abs(p1y - p2y);

  // measure the children
  var totalsize = Util.tempSize();
  totalsize._set(0, 0);
  for (var i = 0; i < l; i++) {
    var child = children._arr[i];
    if (child === main) { continue; }
    if (!child.visible && child !== this.locationObject) continue;
    marg = child.margin;
    var margw = marg.right + marg.left;
    var margh = marg.top + marg.bottom;
    child.measure(cw, ch, minw, minh);
    m = child.measuredBounds;
    mwidth = Math.max(m.width + margw, 0);
    mheight = Math.max(m.height + margh, 0);

    // Keep track of the size we need to display all children
    totalsize._set(Math.max(mwidth, totalsize.width),
                   Math.max(mheight, totalsize.height));
  }

  if (l === 1) {
    m = main.measuredBounds;
    union.width = mwidth;
    union.height = mheight;
    Util.freeSize(totalsize);
    return;
  }

  var spot1 = this.computeSpot1(main);
  var spot2 = this.computeSpot2(main);
  var mainWidth, mainHeight;
  if (spot2.x !== spot1.x && spot2.y !== spot1.y) {
    mainWidth = totalsize.width / Math.abs(spot2.x - spot1.x);
    mainHeight = totalsize.height / Math.abs(spot2.y - spot1.y);
  }
  Util.freeSize(totalsize);
  var sw = 0;
  if (main instanceof Shape) {
    sw = main.strokeWidth * main.scale;
    if (main.getGeometryStretch() === GraphObject.Uniform) {
      mainWidth = Math.max(mainWidth, mainHeight);
      mainHeight = Math.max(mainWidth, mainHeight);
    }
  }
  mainWidth += Math.abs(spot1.offsetX) + Math.abs(spot2.offsetX) + sw;
  mainHeight += Math.abs(spot1.offsetY) + Math.abs(spot2.offsetY) + sw;

  // a stretch of None means that main will fit its contents
  // A stretch of fill means that main will
  var stretch = main.stretch;
  if (stretch === GraphObject.Default) stretch = main.getEffectiveStretch();
  switch (stretch) {
    case GraphObject.None: // The main will fill its contents
      minw = 0;
      minh = 0;
      break;
    case GraphObject.Fill: // The main will fill the panel
      if (isFinite(width)) mainWidth = width;
      if (isFinite(height)) mainHeight = height;
      break;
    case GraphObject.Horizontal:
      if (isFinite(width)) mainWidth = width;
      minh = 0;
      break;
    case GraphObject.Vertical:
      minw = 0;
      if (isFinite(height)) mainHeight = height;
      break;
  }

  // invalidate some state and remake the geometry
  if (main instanceof Shape && !main.desiredSize.isReal()) {
    if (!main._setGeometry)
      main._geometry = null;
    else
      main._constructedGeometry = null;
  }
  main.invalidateMeasureChildren();
  main.measure(mainWidth, mainHeight, minw, minh);
  // The union width and height merely max the size of the main object and the size of all other objects.
  union.width = main.measuredBounds.width + mainmargw;
  union.height = main.measuredBounds.height + mainmargh;
}; // end Auto measure

/** @ignore */
Panel.prototype.measureTable = function(width, height, children, l, union, minw, minh) {
  // "flatten" out the TableRow and TableColumns
  var flatChildren = Util.tempArray();
  var tableRowsCols = Util.tempArray();
  for (var i = 0; i < l; i++) {
    var child = children._arr[i];
    if (child instanceof Panel && (child.type === Panel.TableRow || child.type === Panel.TableColumn) && child.visible) {
      tableRowsCols.push(child);
      var childlist = child._elements;
      var ll = childlist.length;
      for (var j = 0; j < ll; j++) {
        var flatchild = childlist._arr[j];
        if (child.type === Panel.TableRow) { flatchild.row = child.row; }
        else if (child.type === Panel.TableColumn) { flatchild.column = child.column; }
        flatChildren.push(flatchild);
      }
    } else {
      flatChildren.push(child);
    }
  }
  l = flatChildren.length;

  // Make the array that holds [rows][cols] of the table
  var rowcol = []; // saved (so no temp array) starts as an array of rows, will end up [row][col][cell]
  for (var i = 0; i < l; i++) {
    var child = flatChildren[i];
    // ?? this could be optimized. Not all children have to be invalidated
    child.setInvalidMeasure(true);
    child.setInvalidArrange(true);

    if (!rowcol[child.row]) {
      rowcol[child.row] = []; // make new column for this row
    }
    if (!rowcol[child.row][child.column]) {
      rowcol[child.row][child.column] = []; // new list for this cell
    }
    rowcol[child.row][child.column].push(child); // push child into right cell
  }
  Util.freeArray(flatChildren);

  // Reset the row/col definitions because the ones from last measure are irrelevant
  var resetCols = Util.tempArray(); // keep track of which columns we've already reset

  // Objects that span multiple columns and
  var spanners = Util.tempArray();
  var nosize = Util.tempArray();
  // These hashes are used to tally the number of rows and columns that do not have a size
  var nosizeCols = {'count' : 0};
  var nosizeRows = {'count' : 0};

  var colleft = width;
  var rowleft = height;

  var defs = this._rowDefs;
  l = defs.length;
  for (var i = 0; i < l; i++) {
    var def = defs[i];
    if (def !== undefined) def.setActual(0);
  }

  defs = this._colDefs;
  l = defs.length;
  for (var i = 0; i < l; i++) {
    var def = defs[i];
    if (def !== undefined) def.setActual(0);
  }

  // Go through each cell (first pass)
  var def, amt;
  var lrow = rowcol.length; //number of rows
  for (var i = 0; i < lrow; i++) {
    if (!rowcol[i]) continue;
    var lcol = rowcol[i].length; // column length in this row
    var rowHerald = this.getRowDefinition(i);
    rowHerald.setActual(0); // Reset rows (only on first pass)
    for (var j = 0; j < lcol; j++) {
      //foreach column j in row i...
      if (!rowcol[i][j]) continue;
      var colHerald = this.getColumnDefinition(j);
      if (resetCols[j] === undefined) { // make sure we only reset these once
        colHerald.setActual(0);
        resetCols[j] = true;
      }

      var cell = rowcol[i][j];
      var len = cell.length;
      for (var k = 0; k < len; k++) {
        //foreach element in cell, measure
        var child = cell[k];
        if (!child.visible && child !== this.locationObject) continue;

        // Skip children that span more than one row or column or do not have a set size
        if (child._rowSpan > 1 || child._columnSpan > 1) {
          spanners.push(child);
          continue;
        }
        var stretch = child.getEffectiveTableStretch(rowHerald, colHerald);

        if (stretch !== GraphObject.None && !child.desiredSize.isReal()) {
          if (nosizeCols[j] === undefined) {
            nosizeCols[j] = -1; nosizeCols.count++;
          }
          if (nosizeRows[i] === undefined) {
            nosizeRows[i] = -1; nosizeRows.count++;
          }
          nosize.push(child);
          // we want the natural size of stretched panels
          // ?? Maybe there is a good way around doing this? It means we measure all panels twice
          // ??? we used to only do this with panels
          child.measure(Infinity, Infinity, minw, minh);
          continue;
        }

        // If there's a set column width/height we don't care about the given width/height
        var w = isFinite(colHerald.width) ? colHerald.width : width;
        var h = isFinite(rowHerald.height) ? rowHerald.height : height;

        var marg = child.margin;
        var margw = marg.right + marg.left;
        var margh = marg.top + marg.bottom;
        child.measure(Infinity, Infinity, minw, minh);
        var m = child.measuredBounds;
        var mwidth = Math.max(m.width + margw, 0);
        var mheight = Math.max(m.height + margh, 0);

        //  Make sure the heralds have the right layout size
        //    the row/column should use the largest meausured size of any
        //    GraphObject contained, constrained by mins and maxes
        def = this.getRowDefinition(i);
        amt = Math.max(mheight - def.actual, 0);
        if (amt > rowleft) amt = rowleft;
        def.setActual(def.actual + amt);
        rowleft = Math.max(rowleft - amt, 0);

        def = this.getColumnDefinition(j);
        amt = Math.max(mwidth - def.actual, 0);
        if (amt > colleft) amt = colleft;
        def.setActual(def.actual + amt);
        colleft = Math.max(colleft - amt, 0);
      } // end cell
    } // end col
  } //end row

  Util.freeArray(resetCols);

  // For objects of no desired size we allocate what is left as we go,
  // or else what is already in the column
  var totalColWidth = 0;
  var totalRowHeight = 0;
  l = this.columnCount;
  for (var i = 0; i < l; i++) {
    if (this._colDefs[i] === undefined) continue;
    totalColWidth += this.getColumnDefinition(i)._actual;
  }
  l = this.rowCount;
  for (var i = 0; i < l; i++) {
    if (this._rowDefs[i] === undefined) continue;
    totalRowHeight += this.getRowDefinition(i)._actual;
  }
  colleft = Math.max(width - totalColWidth, 0);
  rowleft = Math.max(height - totalRowHeight, 0);

  // Determine column sizes for the yet-to-be-sized columns
  l = nosize.length;
  for (var i = 0; i < l; i++) {
    var child = nosize[i];
    var rowHerald = this.getRowDefinition(child.row);
    var colHerald = this.getColumnDefinition(child.column);
    // We want to gather the largest difference between desired and expected col/row sizes
    var mb = child.measuredBounds;
    var marg = child.margin;
    var margw = marg.right + marg.left;
    var margh = marg.top + marg.bottom;
    nosizeCols[child.column] = Math.max(mb.width + margw - colHerald.actual, 0);
    nosizeRows[child.row] = Math.max(mb.height + margh - rowHerald.actual, 0);
  }
  // we now have the size that all these columns prefer to be
  // we also have the amount left over
  var desiredRowTotal = 0;
  var desiredColTotal = 0;
  for (i in nosizeRows) { if (i !== 'count') desiredRowTotal += nosizeRows[i] }
  for (i in nosizeCols) { if (i !== 'count') desiredColTotal += nosizeCols[i] }


  var allowedSize = Util.tempSize(); // used in stretch and span loops

  // Deal with objects that have a stretch
  for (var i = 0; i < l; i++) {
    var child = nosize[i];
    if (!child.visible && child !== this.locationObject) continue;
    var rowHerald = this.getRowDefinition(child.row);
    var colHerald = this.getColumnDefinition(child.column);

    var w;
    if (isFinite(colHerald.width)) {
      w = colHerald.width;
    } else {
      if (isFinite(colleft)) {
        w = colHerald.actual + ((nosizeCols[child.column] / desiredColTotal) * colleft);
      } else {
        w = colHerald.actual || colleft;
      }
    }
    var h;
    if (isFinite(rowHerald.height)) {
      h = rowHerald.height;
    } else {
      if (isFinite(rowleft)) {
        h = rowHerald.actual + ((nosizeRows[child.row] / desiredRowTotal) * rowleft);
      } else {
        h = rowHerald.actual || rowleft;
      }
    }

    allowedSize._set(
      Math.max(colHerald.minimum, Math.min(w, colHerald.maximum)),
      Math.max(rowHerald.minimum, Math.min(h, rowHerald.maximum)));

    // Which way do we care about fill:
    var stretch = child.getEffectiveTableStretch(rowHerald, colHerald);
    switch (stretch) {
      case GraphObject.Horizontal: // H stretch means it can be as large as its wants vertically
        allowedSize.height = Infinity;
        break;
      case GraphObject.Vertical: // vice versa
        allowedSize.width = Infinity;
        break;
    }

    var marg = child.margin;
    var margw = marg.right + marg.left;
    var margh = marg.top + marg.bottom;
    // ??? here I should be optimizing, if the allowed size is equal to the child's already measured size then we can do nothing
    child.invalidateMeasureChildren();
    child.measure(allowedSize.width, allowedSize.height, colHerald.minimum, rowHerald.minimum);
    var m = child.measuredBounds;
    var mwidth = Math.max(m.width + margw, 0);
    var mheight = Math.max(m.height + margh, 0);

    var oldAmount;

    oldAmount = rowHerald.actual;
    rowHerald.setActual(Math.max(rowHerald.actual, mheight));
    amt = rowHerald.actual - oldAmount;
    rowleft = Math.max(rowleft - amt, 0);

    oldAmount = colHerald.actual;
    colHerald.setActual(Math.max(colHerald.actual, mwidth));
    amt = colHerald.actual - oldAmount;
    colleft = Math.max(colleft - amt, 0);
  } // end no fixed size objects
  Util.freeArray(nosize);

  // Go through each object that spans multiple rows or columns
  var additionalSpan = Util.tempSize();
  l = spanners.length;
  for (var i = 0; i < l; i++) {
    var child = spanners[i];
    if (!child.visible && child !== this.locationObject) continue;
    var rowHerald = this.getRowDefinition(child.row);
    var colHerald = this.getColumnDefinition(child.column);

    // If there's a set column width/height we don't care about the given width/height
    allowedSize._set(
      Math.max(colHerald.minimum, Math.min(width, colHerald.maximum)),
      Math.max(rowHerald.minimum, Math.min(height, rowHerald.maximum)));

    // If it is a spanner and has a fill:
    var stretch = child.getEffectiveTableStretch(rowHerald, colHerald);
    switch (stretch) {
      case GraphObject.Fill:
        if (colHerald.actual !== 0) allowedSize.width = Math.min(allowedSize.width, colHerald.actual);
        if (rowHerald.actual !== 0) allowedSize.height = Math.min(allowedSize.height, rowHerald.actual);
        break;
      case GraphObject.Horizontal:
        if (colHerald.actual !== 0) allowedSize.width = Math.min(allowedSize.width, colHerald.actual);
        break;
      case GraphObject.Vertical:
        if (rowHerald.actual !== 0) allowedSize.height = Math.min(allowedSize.height, rowHerald.actual);
        break;
    }
    // If there's a set column width/height we don't care about any of the above:
    if (isFinite(colHerald.width)) allowedSize.width = colHerald.width;
    if (isFinite(rowHerald.height)) allowedSize.height = rowHerald.height;

    // take into account rowSpan and columnSpan
    additionalSpan._set(0, 0);
    for (var n = 1; n < child._rowSpan; n++) {
      if (child.row + n >= this.rowCount) break; // if the row exists at all
      def = this.getRowDefinition(child.row + n);
      additionalSpan.height += Math.max(def.minimum, isNaN(def._size) ? def.maximum : Math.min(def._size, def.maximum));
    }
    for (var n = 1; n < child._columnSpan; n++) {
      if (child.column + n >= this.columnCount) break; // if the col exists at all
      def = this.getColumnDefinition(child.column + n);
      additionalSpan.width += Math.max(def.minimum, isNaN(def._size) ? def.maximum : Math.min(def._size, def.maximum));
    }
    allowedSize.width += additionalSpan.width;
    allowedSize.height += additionalSpan.height;

    var marg = child.margin;
    var margw = marg.right + marg.left;
    var margh = marg.top + marg.bottom;
    child.measure(allowedSize.width, allowedSize.height, minw, minh);
    var m = child.measuredBounds;
    var mwidth = Math.max(m.width + margw, 0);
    var mheight = Math.max(m.height + margh, 0);

    var totalRow = 0;
    for (var n = 0; n < child._rowSpan; n++) {
      def = this.getRowDefinition(child.row + n);
      totalRow += def.total || 0;
    }
    // def is the last row definition
    if (totalRow < mheight) {
      var roomLeft = mheight - totalRow;
      while (roomLeft > 0) { // Add the extra to the first row that allows us to
        var act = def._actual || 0;
        if (isNaN(def.height) && def.maximum > act) {
          def.setActual(Math.min(def.maximum, act + roomLeft));
          if (def._actual !== act) roomLeft -= def._actual - act;
        }
        if (def.index - 1 === -1) break;
        def = this.getRowDefinition(def.index - 1);
      }
    }

    var totalCol = 0;
    for (var n = 0; n < child._columnSpan; n++) {
      def = this.getColumnDefinition(child.column + n);
      totalCol += def.total || 0;
    }
    // def is the last col definition
    if (totalCol < mwidth) {
      var roomLeft = mwidth - totalCol;
      while (roomLeft > 0) { // Add the extra to the first row that allows us to
        var act = def._actual || 0;
        if (isNaN(def.width) && def.maximum > act) {
          def.setActual(Math.min(def.maximum, act + roomLeft));
          if (def._actual !== act) roomLeft -= def._actual - act;
        }
        if (def.index - 1 === -1) break;
        def = this.getColumnDefinition(def.index - 1);
      }
    }
  } // end spanning objects
  Util.freeArray(spanners);
  Util.freeSize(additionalSpan);
  Util.freeSize(allowedSize);


  // the rest of this propotionally resizes rows and columns, but we only ever size them up

  var functionalWidth = 0;
  var functionalHeight = 0;
  var stretch = this.getEffectiveStretch();
  var des = this.desiredSize;
  var max = this.maxSize;
  var min = this.minSize;
  totalColWidth = 0;
  totalRowHeight = 0;

  // we cannot resize columns and rows with set width/height so we must exclude them
  var rigidwidth = 0;
  var rigidheight = 0;

  l = this.columnCount;
  for (var i = 0; i < l; i++) {
    if (this._colDefs[i] === undefined) continue;
    def = this.getColumnDefinition(i);
    if (isFinite(def.width)) {
      rigidwidth += def.width;
      continue;
    } else if (def.getEffectiveSizing() === RowColumnDefinition.None) {
      rigidwidth += def._actual;
      continue;
    }
    if (def._actual !== 0) {
      totalColWidth += def._actual;
      totalColWidth += def.getEffectiveSpacing();
    }
  }
  if (isFinite(des.width)) {
    functionalWidth = Math.min(des.width, max.width);
  } else {
    if (stretch !== GraphObject.None && isFinite(width)) functionalWidth = width;
    else functionalWidth = totalColWidth;
  }
  functionalWidth = Math.max(functionalWidth, this.minSize.width);
  functionalWidth = Math.max(functionalWidth - rigidwidth, 0);
  var colProportion = Math.max(functionalWidth / totalColWidth, 1);
  if (!isFinite(colProportion)) colProportion = 1;

  for (var i = 0; i < l; i++) {
    if (this._colDefs[i] === undefined) continue;
    def = this.getColumnDefinition(i);
    if (!isFinite(def.width) && def.getEffectiveSizing() !== RowColumnDefinition.None) def.setActual(def._actual * colProportion);
    def.setPosition(union.width);
    if (def._actual !== 0) {
      union.width += def._actual;
      union.width += def.getEffectiveSpacing();
    }
  }

  l = this.rowCount;
  for (var i = 0; i < l; i++) {
    if (this._rowDefs[i] === undefined) continue;
    def = this.getRowDefinition(i);
    if (isFinite(def.height)) {
      rigidheight += def.height;
      continue;
    } else if (def.getEffectiveSizing() === RowColumnDefinition.None) {
      rigidheight += def._actual;
      continue;
    }
    if (def._actual !== 0) {
      totalRowHeight += def._actual;
      totalRowHeight += def.getEffectiveSpacing();
    }
  }
  if (isFinite(des.height)) {
    functionalHeight = Math.min(des.height, max.height);
  } else {
    if (stretch !== GraphObject.None && isFinite(height)) functionalHeight = height;
    else functionalHeight = totalRowHeight;
  }
  functionalHeight = Math.max(functionalHeight, this.minSize.height);
  functionalHeight = Math.max(functionalHeight - rigidheight, 0);
  var rowProportion = Math.max(functionalHeight / totalRowHeight, 1);
  if (!isFinite(rowProportion)) rowProportion = 1;

  for (var i = 0; i < l; i++) {
    if (this._rowDefs[i] === undefined) continue;
    def = this.getRowDefinition(i);
    if (!isFinite(def.height) && def.getEffectiveSizing() !== RowColumnDefinition.None) def.setActual(def._actual * rowProportion);
    def.setPosition(union.height);
    if (def._actual !== 0) {
      union.height += def._actual;
      union.height += def.getEffectiveSpacing();
    }
  }


  l = tableRowsCols.length;
  for (var i = 0; i < l; i++) {
    var trc = tableRowsCols[i];
    var w, h;
    if (trc.type === Panel.TableRow) {
      w = union.width;
      def = this.getRowDefinition(trc.row);
      h = def.actual;
    } else { // TableColumn
      def = this.getColumnDefinition(trc.column);
      w = def.actual;
      h = union.height;
    }

    trc._measuredBounds._set(0, 0, w, h);
    trc.setInvalidMeasure(false);

    if (!rowcol[trc.row]) {
      rowcol[trc.row] = []; // make new column for this row
    }
    if (!rowcol[trc.row][trc.column]) {
      rowcol[trc.row][trc.column] = []; // new list for this cell
    }
    rowcol[trc.row][trc.column].push(trc);
  }
  Util.freeArray(tableRowsCols);

  // save these for arrange (destroy them or not? Possibly needed for drawing spacers)
  this._rowcol = rowcol;

}; // end Table measure


/** @ignore */
Panel.prototype.measureViewbox = function(width, height, children, l, union, minw, minh) {
  if (l > 1) Util.throwError('Viewbox Panel cannot contain more than one GraphObject.');
  var child = children._arr[0];
  // Always measure the child with Infinity and not the width and height given to Viewbox
  child._scale = 1;
  child.invalidateMeasureChildren();
  child.measure(Infinity, Infinity, minw, minh);
  var m = child.measuredBounds;
  var marg = child.margin;
  var margw = marg.right + marg.left;
  var margh = marg.top + marg.bottom;

  // If the width and height are infinte then we measure and quit
  if (isFinite(width) || isFinite(height)) {
    var oldscale = child.scale;
    var mwidth = m.width; // no margin here
    var mheight = m.height;
    var availWidth = Math.max(width - margw, 0);
    var availHeight = Math.max(height - margh, 0);
    if (this._viewboxStretch === GraphObject.Uniform) {
      // Resized accoring to the larger side
      child._scale *= Math.min((availWidth / mwidth), (availHeight / mheight));
    } else { /// UniformToFill
      // Resized accoring to the smaller side
      child._scale *= Math.max((availWidth / mwidth), (availHeight / mheight));
    }
    // if the scale changed, time to remeasure
    if (oldscale !== child.scale) {
      child.setInvalidMeasure(true);
      child.measure(Infinity, Infinity, minw, minh);
    }
  }
  m = child.measuredBounds;
  union.width = isFinite(width) ? width : Math.max(m.width + margw, 0);
  union.height = isFinite(height) ? height : Math.max(m.height + margh, 0);
}; // end Viewbox measure



/** @ignore */
Panel.prototype.measureLink = function(width, height, children, l, union, minw, minh) {
  // There are some methods we want to use the adorned part for if this is an adornment
  var link = this instanceof Adornment ? this.adornedPart : this;

  // no child elements?
  if (l === 0) {
    var ns = this._naturalBounds;
    ns.setWidthHeight(0, 0);
    var mb = this.measuredBounds;
    mb._set(0, 0, 0, 0);
    return;
  }

  var stroke = this._getPath();  // may be null
  var routeBounds = this._getRouteBounds();
  var linkBounds = this._union;
  linkBounds.assign(routeBounds); //geo.bounds.copy();  // will include all decorations
  // We want to repurpose these
  linkBounds.x = 0;
  linkBounds.y = 0;

  var numpts;
  var pts = this._getPoints();
  if (this.pointsCount !== undefined) { // Adornments such as ReshapeLink do not have a .pointsCount
    numpts = this.pointsCount;
  } else {
    numpts = pts.count;
  }

  // Don't want to set property, or at least we want this to skip undo
  this._location._set(routeBounds.x, routeBounds.y);

  this._childrenBounds.clear();
  if (stroke !== null) {
    stroke.measureSimple(routeBounds.width, routeBounds.height);
    var mb = stroke.measuredBounds;
    linkBounds.unionRect(mb);
    this._childrenBounds.add(mb);  // remember for Arrange
  }

  var et = Util.tempTransform();  // temporary Transform
  var alignpt = Util.tempPoint();
  var offsetpt = Util.tempPoint();

  // measure all other children
  for (var i = 0; i < l; i++) {
    var e = children._arr[i];
    if (e === stroke) continue;  // already measured the stroke, above

    // Take all shapes that have panelMain = true and give them a specific, shared geometry
    if (e.isPanelMain && e instanceof Shape) {
      e.measureSimple(routeBounds.width, routeBounds.height);
      var mb = e.measuredBounds;
      linkBounds.unionRect(mb);
      this._childrenBounds.add(mb);
      continue;
    }

    // if no route it's just a simple measurement
    if (numpts < 2) {
      e.measure(Infinity, Infinity);
      var mb = e.measuredBounds;
      linkBounds.unionRect(mb);
      this._childrenBounds.add(mb);
      continue;
    }

    // get the properties controlling where the "label" should be along the route
    var index = e.segmentIndex;
    var frac = e.segmentFraction;
    var align = e.alignmentFocus;
    if (align.isNoSpot()) align = Spot.Center;
    var orient = e.segmentOrientation;
    var offset = e.segmentOffset;

    // compute the point along the route at which the element must be positioned
    var itemX; // local coordinates
    var itemY;
    var labelangle = 0;
    if (index < -numpts || index >= numpts) {  // beyond range? assume at the MidPoint, with the MidAngle
      var mid = link.midPoint;  // in document coordinates
      var segangle = link.midAngle;
      // maybe rotate the label
      if (orient !== Link.None) {
        labelangle = link.computeAngle(e, orient, segangle);
        e.angle = labelangle;
      }
      itemX = mid.x - routeBounds.x;  // local coordinates
      itemY = mid.y - routeBounds.y;
    } else {  // on a particular segment, given by Index, at a point given by Fraction
      // negative index means start from last point, going "backwards"
      var a, b; // Points
      if (index >= 0) {
        a = pts._arr[index];
        b = (index < numpts - 1) ? pts._arr[index + 1] : a;
      } else {
        var idx = numpts + index;  // remember that index is negative here
        a = pts._arr[idx];
        b = (idx > 0) ? pts._arr[idx - 1] : a;
      }
      var segangle = (index >= 0 ? a.directionPoint(b) : b.directionPoint(a));
      // maybe rotate the label
      if (orient !== Link.None) {
        labelangle = link.computeAngle(e, orient, segangle);
        e._angle = labelangle; // _angle because we don't want it to be in the undo manager
      }
      // compute the fractional point along the line, in local coordinates
      itemX = a.x + (b.x - a.x) * frac - routeBounds.x;
      itemY = a.y + (b.y - a.y) * frac - routeBounds.y;
    }

    e.measure(Infinity, Infinity);
    var mb = e.measuredBounds;
    var ns = e.naturalBounds;
    var sw = 0;
    if (e instanceof Shape) sw = e.strokeWidth;
    var ew = ns.width + sw;
    var eh = ns.height + sw;

    // now determine the label/arrowhead's bounds
    et.reset();
    et.translate(-mb.x, -mb.y);
    et.scale(e.scale, e.scale);
    et.rotate(e.angle, ew / 2, eh / 2);

    // find the transformed alignment point inside the element
    var nb = new Rect(0, 0, ew, eh);
    alignpt.setRectSpot(nb, align);
    et.transformPoint(alignpt);
    var dx = -alignpt.x + sw / 2;
    var dy = -alignpt.y + sw / 2;

    // maybe the alignment point is away from the line
    offsetpt.assign(offset);
    if (isNaN(offsetpt.x)) {
      if (index >= 0) {
        offsetpt.x = alignpt.x + 3;
      } else {
        offsetpt.x = -(alignpt.x + 3);
      }
    }
    if (isNaN(offsetpt.y)) {
      offsetpt.y = -(alignpt.y + 3);
    }
    offsetpt.rotate(segangle);
    itemX += offsetpt.x;
    itemY += offsetpt.y;

    // reuse the temporary Rect NB to remember for arrangeProtected
    nb.set(mb);
    nb.x = itemX + dx;
    nb.y = itemY + dy;
    this._childrenBounds.add(nb);
    linkBounds.unionRect(nb);
  } // done measuring children

  if (this._labelNodes) { // Adornments such as ReshapeLink do not have labelNodes
    // LabelNodes are distinct top-level objects and as such don't have to obey any of the rules of the Link.
    var labels = this.labelNodes;
    while (labels.next()) {
      var lab = labels.value;
      lab.measure(Infinity, Infinity);
    }
  }

  this._union = linkBounds;

  // The location must be modified by the linkBounds
  // which was the union of all the link shape's bounds during measure
  var loc = this._location;
  if (loc) {
    loc._set(loc.x + linkBounds.x, loc.y + linkBounds.y);
  }

  // ignore any desired size
  union.setWidthHeight(linkBounds.width || 0, linkBounds.height || 0);

  Util.freeTransform(et);
  Util.freePoint(alignpt);
  Util.freePoint(offsetpt);
}; // end Link measure

/** @ignore */
Panel.prototype.measureGrid = function(width, height, children, l, union, minw, minh) {
  // TODO
}; // end Grid measure

/**
* @ignore
* Causes a Panel to arrange it's children.
* @this {Panel}
* @param {number} fx
* @param {number} fy
* @param {number} fw
* @param {number} fh
*/
Panel.prototype.arrangeProtected = function(fx, fy, fw, fh) {
  var union = this._union;
  var children = this._elements;
  var l = children.length;
  var ar = Util.tempRectAt(0, 0, 0, 0);

  if (l === 0) {
    var ab = this.actualBounds;
    ab.x = fx;
    ab.y = fy;
    ab.width = fw;
    ab.height = fh;
    return;
  }

  if (!this.desiredSize.isReal()) {
    var effectivestretch = this.getEffectiveStretch();
    var mb = this._measuredBounds;
    var mbwidth = mb.width;
    var mbheight = mb.height;
    var marg = this.margin;
    var margw = marg.left + marg.right;
    var margh = marg.top + marg.bottom;
    if (mbwidth === fw && mbheight === fh) effectivestretch = GraphObject.None;
    switch (effectivestretch) {
      case GraphObject.None: // if fw or fh are smaller than our size, we have to remeasure
        if (mbwidth > fw || mbheight > fh) {
          this.invalidateMeasure(); // test me with nested panels of varying desired size
          this.measure(mbwidth > fw ? fw : mbwidth, mbheight > fh ? fh : mbheight);
        }
        break;
      case GraphObject.Fill: // fill the space completely, ignoring desired aspect ratio
        this.setInvalidMeasure(true);
        this.measure(fw + margw, fh + margh, 0, 0);
        break;
      case GraphObject.Horizontal:
        this.setInvalidMeasure(true);
        this.measure(fw + margw, mbheight + margh, 0, 0);
        break;
      case GraphObject.Vertical:
        this.setInvalidMeasure(true);
        this.measure(mbwidth + margw, fh + margh, 0, 0);
        break;
    } // end stretch switch
  }

  var ab = this.actualBounds;
  ab.x = fx;
  ab.y = fy;
  ab.width = fw;
  ab.height = fh;

  var panel = this._type._name;
  switch (panel) {
    case 'Position':
      this.arrangePosition(ar, children, l, union);
      break;
    case 'Vertical':
      this.arrangeVertical(ar, children, l, union);
      break;
    case 'Horizontal':
      this.arrangeHorizontal(ar, children, l, union);
      break;
    case 'Spot':
      this.arrangeSpot(ar, children, l, union);
      break;
    case 'Auto':
      this.arrangeAuto(ar, children, l, union);
      break;
    case 'Table':
      this.arrangeTable(ar, children, l, union);
      break;
    case 'Viewbox':
      this.arrangeViewbox(ar, children, l, union);
      break;
    case 'Link':
      this.arrangeLink(ar, children, l, union);
      break;
    case 'Grid':
      this.arrangeGrid(ar, children, l, union);
      break;
    case 'TableRow':
    case 'TableColumn':
      Util.throwError(this.toString() + ' is not an element of a Table Panel.' +
                      'TableRow and TableColumn panels can only be elements of a Table Panel.');
      break;
    default:
      Util.throwError('Unknown panel type: ' + panel);
  }
  Util.freeRect(ar);
};   // end arrange

// arrange children according to their positions
/** @ignore */
Panel.prototype.arrangePosition = function(ar, children, l, union) {
  var ux = union.x - this.padding.left;
  var uy = union.y - this.padding.top;
  for (var i = 0; i < l; i++) {
    var child = children._arr[i];
    var m = child.measuredBounds;
    var marg = child.margin;
    var x = child.position.x;
    var y = child.position.y;
    ar.x = isNaN(x) ? -ux : x - ux;
    ar.y = isNaN(y) ? -uy : y - uy;
    if (child instanceof Shape && child.isGeometryPositioned) {
      var sw = child.strokeWidth / 2;
      ar.x -= sw;
      ar.y -= sw;
    }
    ar.x += marg.left;
    ar.y += marg.top;
    ar.width = m.width;
    ar.height = m.height;
    if (child.visible) {
      child.arrange(ar.x, ar.y, ar.width, ar.height);
    }
  }
}; // end Position arrange

/** @ignore */
Panel.prototype.arrangeVertical = function(ar, children, l, union) {
  var pl = this.padding.left;
  var y = this.padding.top; // y is incremented on each child
  for (var i = 0; i < l; i++) {
    var x = pl; // x must be reset each time
    var child = children._arr[i];
    var m = child.measuredBounds;
    var marg = child.margin;
    var margw = marg.left + marg.right;
    var padw = pl + this.padding.right;
    var width = m.width;
    var stretch = child.getEffectiveStretch();
    if (isNaN(child.desiredSize.width) && stretch === GraphObject.Fill || stretch === GraphObject.Horizontal)
      width = Math.max(union.width - margw - padw, 0);
    var widthtotal = width + margw + padw; // total horizontal space a child occupies

    var align = child.alignment;
    if (align.isDefault()) align = this.defaultAlignment;
    if (!align.isSpot()) align = Spot.Center;

    ar.x = (x + align.offsetX + marg.left) + (union.width * align.x - (widthtotal * align.x));
    ar.y = y + align.offsetY + marg.top;
    ar.width = width;
    ar.height = m.height;

    if (child.visible) {
      child.arrange(ar.x, ar.y, ar.width, ar.height);
      y += (m.height + marg.bottom + marg.top);
    }
  }
}; // end Vertical arrange

/** @ignore */
Panel.prototype.arrangeHorizontal = function(ar, children, l, union) {
  var pt = this.padding.top;
  var x = this.padding.left; // x is incremented on each child
  for (var i = 0; i < l; i++) {
    var y = pt; // y must be reset each time
    var child = children._arr[i];
    var m = child.measuredBounds;
    var marg = child.margin;
    var margh = marg.top + marg.bottom;
    var padh = pt + this.padding.bottom;
    var height = m.height;
    var stretch = child.getEffectiveStretch();
    if (isNaN(child.desiredSize.height) && stretch === GraphObject.Fill || stretch === GraphObject.Vertical)
      height = Math.max(union.height - margh - padh, 0);
    var heighttotal = height + margh + padh; // total vertical space a child occupies

    var align = child.alignment;
    if (align.isDefault()) align = this.defaultAlignment;
    if (!align.isSpot()) align = Spot.Center;

    ar.x = x + align.offsetX + marg.left;
    ar.y = (y + align.offsetY + marg.top) + (union.height * align.y - (heighttotal * align.y));
    ar.width = m.width;
    ar.height = height;

    if (child.visible) {
      child.arrange(ar.x, ar.y, ar.width, ar.height);
      x += (m.width + marg.left + marg.right);
    }
  }
}; // end Horizontal arrange

/** @ignore */
Panel.prototype.arrangeSpot = function(ar, children, l, union) {
  var main = this.getMainChild(children, l);
  var size = main.measuredBounds;
  var mainWidth = size.width;
  var mainHeight = size.height;
  var padding = this.padding;
  var pl = padding.left;
  var pt = padding.top;

  ar.x = pl - union.x;
  ar.y = pt - union.y;

  main.arrange(ar.x, ar.y, mainWidth, mainHeight);

  for (var i = 0; i < l; i++) {
    var child = children._arr[i];
    if (child === main) continue;
    var marg = child.margin;
    var margw = marg.right + marg.left;
    var margh = marg.top + marg.bottom;
    var m = child.measuredBounds;
    var width = m.width;
    var height = m.height;

    var align = child.alignment;
    if (align.isDefault()) align = this.defaultAlignment;
    if (!align.isSpot()) align = Spot.Center;
    var alignFocus = child.alignmentFocus;
    if (alignFocus.isDefault()) alignFocus = Spot.Center;

    ar.x = align.x * mainWidth + align.offsetX - (alignFocus.x * width - alignFocus.offsetX);
    ar.y = align.y * mainHeight + align.offsetY - (alignFocus.y * height - alignFocus.offsetY);
    ar.x -= union.x;
    ar.y -= union.y;

    if (child.visible) {
      child.arrange(pl + ar.x, pt + ar.y, width, height);
    }
  }
}; // end Spot arrange

/** @ignore */
Panel.prototype.arrangeAuto = function(ar, children, l, union) {
  var main = this.getMainChild(children, l);
  var mainSize = main.measuredBounds;
  var sw = 0;
  if (main instanceof Shape) sw = main.strokeWidth;

  // outer is 0, 0, mainSize
  var inner = Util.tempRect();
  inner._set(0, 0, 1, 1);

  var marg = main.margin;
  var mainOffsetX = marg.left;
  var mainOffsetY = marg.top;

  var padding = this.padding;
  var pl = padding.left;
  var pt = padding.top;

  ar.x = mainOffsetX;
  ar.y = mainOffsetY;
  ar.width = mainSize.width;
  ar.height = mainSize.height;
  main.arrange(pl + ar.x, pt + ar.y, ar.width, ar.height);
  var spot1 = this.computeSpot1(main);
  var spot2 = this.computeSpot2(main);
  // setting rect spot inline
  var p1x = 0 + spot1.x * mainSize.width + spot1.offsetX;
  var p1y = 0 + spot1.y * mainSize.height + spot1.offsetY;
  var p2x = 0 + spot2.x * mainSize.width + spot2.offsetX;
  var p2y = 0 + spot2.y * mainSize.height + spot2.offsetY;
  inner.x = p1x;
  inner.y = p1y;
  inner.unionNoCheck(p2x, p2y, 0, 0);
  inner.x += mainOffsetX + pl;
  inner.y += mainOffsetY + pt;

  for (var i = 0; i < l; i++) {
    var child = children._arr[i];
    if (child === main) continue;

    var m = child.measuredBounds;
    marg = child.margin;
    var mwidth = Math.max(m.width + marg.right + marg.left, 0);
    var mheight = Math.max(m.height + marg.top + marg.bottom, 0);

    var align = child.alignment;
    if (align.isDefault()) align = this.defaultAlignment;
    if (!align.isSpot()) align = Spot.Center;
    ar.x = inner.width * align.x + align.offsetX - (mwidth * align.x) + marg.left + inner.x;
    ar.y = inner.height * align.y + align.offsetY - (mheight * align.y) + marg.top + inner.y;
    ar.width = inner.width;
    ar.height = inner.height;

    if (child.visible) {
      if (Rect.contains(inner.x, inner.y, inner.width, inner.height, ar.x, ar.y, m.width, m.height)) {
        child.arrange(ar.x, ar.y, m.width, m.height);
      } else {
        child.arrange(ar.x, ar.y, m.width, m.height, new Rect(inner.x, inner.y, inner.width, inner.height));
      }
    }
  }
  Util.freeRect(inner);
}; // end Auto arrange

/** @ignore */
Panel.prototype.arrangeTable = function(ar, children, l, union) {
  var padding = this.padding;
  var pl = padding.left;
  var pt = padding.top;

  var rowcol = this._rowcol;
  var x, y;

  var lrow = rowcol.length; //number of rows
  var lcol = 0;
  for (var i = 0; i < lrow; i++) {
    if (!rowcol[i]) continue;
    lcol = Math.max(lcol, rowcol[i].length); // column length in this row
  }

  //
  var idxrow = Math.min(this._topIndex, lrow - 1);
  while (idxrow !== lrow && (this._rowDefs[idxrow] === undefined || this._rowDefs[idxrow]._actual === 0)) idxrow++;
  idxrow = Math.min(idxrow, lrow - 1);
  var rowIndexOffset = -this._rowDefs[idxrow]._position;

  var idxcol = Math.min(this._leftIndex, lcol - 1);
  while (idxcol !== lcol && (this._colDefs[idxcol] === undefined || this._colDefs[idxcol]._actual === 0)) idxcol++;
  idxcol = Math.min(idxcol, lcol - 1);
  var colIndexOffset = -this._colDefs[idxcol]._position;

  var additionalSpan = Util.tempSize();
  // Find cell space and arrange objects:
  for (var i = 0; i < lrow; i++) {
    if (!rowcol[i]) continue;
    lcol = rowcol[i].length; // column length in this row
    var rowHerald = this.getRowDefinition(i);
    y = rowHerald._position + rowIndexOffset + pt + rowHerald.getEffectiveSpacingTop();
    for (var j = 0; j < lcol; j++) {
      //foreach column j in row i...
      if (!rowcol[i][j]) continue;
      var colHerald = this.getColumnDefinition(j);
      x = colHerald._position + colIndexOffset + pl + colHerald.getEffectiveSpacingTop();
      var cell = rowcol[i][j];
      var len = cell.length;

      for (var k = 0; k < len; k++) {
        //foreach element in cell
        var child = cell[k];
        var m = child.measuredBounds;

        if (child instanceof Panel && (child.type === Panel.TableRow || child.type === Panel.TableColumn)) {
          child._actualBounds.thaw();
          var ab = child._actualBounds;
          ab.x = child.type === Panel.TableRow ? pl : x;
          ab.y = child.type === Panel.TableColumn ? pt : y;
          ab.width = m.width;
          ab.height = m.height;
          child._actualBounds.freeze();
          child.setInvalidArrange(false);
          continue;
        }

        // add to layoutWidth/Height any additional span
        additionalSpan._set(0, 0);

        for (var n = 1; n < child.rowSpan; n++) {
          // if the row exists at all
          if (i + n >= this.rowCount) break;
          var rh = this.getRowDefinition(i + n);
          additionalSpan.height += rh.total;
        }

        for (var n = 1; n < child.columnSpan; n++) {
          // if the col exists at all
          if (j + n >= this.columnCount) break;
          var ch = this.getColumnDefinition(j + n);
          additionalSpan.width += ch.total;
        }

        // Construct containing rect (cell):

        // total width and height of the cell that an object could possibly be created in
        var colwidth = colHerald._actual + additionalSpan.width;
        var rowheight = rowHerald._actual + additionalSpan.height;

        // construct a rect that represents the total cell size allowed for this object
        ar.x = x;
        ar.y = y;
        ar.width = colwidth;
        ar.height = rowheight;

        // Ending rows/col might have actual spaces that are larger than the remaining space
        // Modify them for clipping regions
        if (y + rowheight > union.height) rowheight = Math.max(union.height - y, 0);
        if (x + colwidth > union.width) colwidth = Math.max(union.width - y, 0);

        // Also keep them for clip values
        var cellx = x;
        var celly = y;
        var cellw = colwidth;
        var cellh = rowheight;

        // Construct alignment:
        var align = child.alignment;
        var alignx, aligny, alignoffsetX, alignoffsetY;
        if (align.isDefault()) {
          align = this.defaultAlignment;
          if (!align.isSpot()) align = Spot.Center;
          alignx = align.x;
          aligny = align.y;
          alignoffsetX = align.offsetX;
          alignoffsetY = align.offsetY;
          var ca = colHerald.alignment;
          var ra = rowHerald.alignment;
          if (ca.isSpot()) {
            alignx = ca.x;
            alignoffsetX = ca.offsetX;
          }
          if (ra.isSpot()) {
            aligny = ra.y;
            alignoffsetY = ra.offsetY;
          }
        } else {
          alignx = align.x;
          aligny = align.y;
          alignoffsetX = align.offsetX;
          alignoffsetY = align.offsetY;
        }

        // same as if (!align.isSpot()) align = Spot.Center;
        if (isNaN(alignx) || isNaN(aligny)) {
          alignx = 0.5;
          aligny = 0.5;
          alignoffsetX = 0;
          alignoffsetY = 0;
        }

        var width = m.width;
        var height = m.height;
        var max = child.maxSize;
        var min = child.minSize;
        width = Math.min(max.width, width);
        height = Math.min(max.height, height);
        width = Math.max(min.width, width);
        height = Math.max(min.height, height);

        var marg = child.margin;
        var margw = marg.left + marg.right;
        var margh = marg.top + marg.bottom;
        var stretch = child.getEffectiveTableStretch(rowHerald, colHerald);
        if (isNaN(child.desiredSize.width) && stretch === GraphObject.Fill || stretch === GraphObject.Horizontal)
          width = Math.max(colwidth - margw, 0);
        if (isNaN(child.desiredSize.height) && stretch === GraphObject.Fill || stretch === GraphObject.Vertical)
          height = Math.max(rowheight - margh, 0);
        var widthmarg = width + margw;
        var heightmarg = height + margh;

        ar.x += (ar.width * alignx) - (widthmarg * alignx) + alignoffsetX + marg.left;
        ar.y += (ar.height * aligny) - (heightmarg * aligny) + alignoffsetY + marg.top;

        if (child.visible) {
          if (Rect.contains(cellx, celly, cellw, cellh, ar.x, ar.y, width, height)) {
            child.arrange(ar.x, ar.y, width, height);
          } else {
            child.arrange(ar.x, ar.y, width, height, new Rect(cellx, celly, cellw, cellh));
          }
        }
      } // end cell
    } // end col
  } //end row
  Util.freeSize(additionalSpan);

  // Finally, duplicate actualBounds/measuredBounds/allTransforms onto any TableRows any TableColumns
  for (var i = 0; i < l; i++) {
    var child = children._arr[i];
    if (child instanceof Panel && (child.type === Panel.TableRow || child.type === Panel.TableColumn)) {
      var ab = child._actualBounds;
      child._naturalBounds.thaw();
      child._naturalBounds.setTo(0, 0, ab.width, ab.height);
      child._naturalBounds.freeze();
    }
  }
}; // end Table arrange

/** @ignore */
Panel.prototype.arrangeViewbox = function(ar, children, l, union) {
  var child = children._arr[0];
  var m = child.measuredBounds;
  var marg = child.margin;
  var margw = marg.right + marg.left;
  var margh = marg.top + marg.bottom;
  var mwidth = Math.max(m.width + margw, 0);
  var mheight = Math.max(m.height + margh, 0);

  var align = child.alignment;
  if (align.isDefault()) align = this.defaultAlignment;
  if (!align.isSpot()) align = Spot.Center;

  ar.x = union.width * align.x - (mwidth * align.x) + align.offsetX;
  ar.y = union.height * align.y - (mheight * align.y) + align.offsetY;
  ar.width = m.width;
  ar.height = m.height;
  child.arrange(ar.x, ar.y, ar.width, ar.height);
}; // end Viewbox arrange

/** @ignore */
Panel.prototype.arrangeLink = function(ar, children, l, union) {
  // First, we operate on the "path" object that was panelMain = true and a Shape
  var stroke = this._getPath();  // may be null
  var childidx = 0;
  if (stroke !== null) {
    if (childidx < this._childrenBounds.count) {
      var cb = this._childrenBounds._arr[childidx];
      childidx++;
      stroke.arrange(cb.x - this._union.x, cb.y - this._union.y, cb.width, cb.height);
    }
  }

  for (var i = 0; i < l; i++) {
    var e = children._arr[i];
    if (e === stroke) continue;
    if (childidx < this._childrenBounds.count) {
      var cb = this._childrenBounds._arr[childidx];
      childidx++;
      // cb is in the parent's coordinate system and not local,
      // change it to local:
      e.arrange(cb.x - this._union.x, cb.y - this._union.y, cb.width, cb.height);
    }
  }

  var pts = this._getPoints();
  var numpts = pts.count;
  if (numpts >= 2 && this._labelNodes) {
    var lnit = this.labelNodes;
    while (lnit.next()) {
      var lab = lnit.value;
      this._arrangeLabelNode(lab, numpts, pts);
    }
  }
  // Different depending on Link or Adornment:
  this.makeShapeGeometry();
}; // end Link arrange

/** @ignore */
Panel.prototype.arrangeGrid = function(ar, children, l, union) {
  // TODO
}; // end Grid arrange

// The only purpose of determineChildSize is to make sure children are correctly positioned (arranged x,y)
// It's possible we could do away with this is
/**
* @ignore
* @this {Panel}
* @param {GraphObject} child
* @param {Rect} m
* @param {number} maxwidth
* @param {number} maxheight
* @param {EnumValue} stretch
* @param {Size} sz
*/
Panel.prototype.determineChildSize = function(child, m, maxwidth, maxheight, stretch, sz) {
  var width = m.width;
  var height = m.height;
  switch (stretch) {
    case GraphObject.None: // arrange into its own space
      // already set
      if (width > maxwidth) width = maxwidth;
      if (height > maxheight) height = maxheight;
      break;
    case GraphObject.Fill: // fill the space completely, ignoring aspect ratio
      width = maxwidth;
      height = maxheight;
      break;
    case GraphObject.Vertical:
      height = maxheight;
      break;
    case GraphObject.Horizontal:
      width = maxwidth;
      break;
    default:
      Util.throwError('unsupported stretch');
  } // end switch

  width = Math.min(width, child._maxSize.width);
  height = Math.min(height, child._maxSize.height);

  width = Math.max(width, child._minSize.width);
  height = Math.max(height, child._minSize.height);

  sz.width = width;
  sz.height = height;
};

/**
* @ignore
* @this {Panel}
* @param {Point} p a Point in local coordinates.
* @return {boolean}
*/
Panel.prototype.containsPointProtected = function(p) {
  // get the natural size because the point p is already transformed
  var sz = this.naturalBounds;

  // if its in the bounds, iterate over this panel's collection in reverse order, calling containsPoint
  if (Rect.contains(0, 0, sz.width, sz.height, p.x, p.y)) {
    var l = this._elements.length;
    var newp = Util.tempPointAt(0, 0);
    for (var i = l; i--; ) {
      var child = this._elements._arr[0];
      if (!child.visible && child !== this.locationObject) continue;
      newp.set(p).transformInverted(child.transform);
      if (child.containsPoint(newp)) {
        Util.freePoint(newp);
        return true;
      }
    }
    Util.freePoint(newp);

    if (this._background === null && this._areaBackground === null) return false;
    return true; // No elements hit, but there was a background

  }
  return false; // Outside of the panel's bounds, even if it is inside the panel's arranged area.
};


/**
* @ignore
* @this {Panel}
* @param {GraphObject} obj
* @param {function(GraphObject, GraphObject)} func
*/
Panel.prototype.walkVisualTree = function(obj, func) {
  func(this, obj);
  if (obj instanceof Panel) {
    var it = obj.elements;
    while (it.next()) {
      this.walkVisualTree(it.value, func);
    }
  }
};

/**
* @ignore
* @this {Panel}
* @param {function(Panel)} func
*/
Panel.prototype.walkPanels = function(func) {
  this.walkPanels1(this, func);
};

/**
* @ignore
* @this {Panel}
* @param {Panel} panel
* @param {function(Panel)} func
*/
Panel.prototype.walkPanels1 = function(panel, func) {
  func(panel);
  var it = panel.elements;
  while (it.next()) {
    var p = it.value;
    if (p instanceof Panel) {
      this.walkPanels1(p, func);
    }
  }
};

/**
* @ignore
* @this {Panel}
* @param {function(GraphObject):boolean} func
* @return {GraphObject}
*/
Panel.prototype.searchVisualTree = function(func) {
  return this._searchVisualTree1(this, func);
};

/**
* @ignore
* @this {Panel}
* @param {GraphObject} g
* @param {function(GraphObject):boolean} func
* @return {GraphObject}
*/
Panel.prototype._searchVisualTree1 = function(g, func) {
  if (func(g)) return g;
  if (g instanceof Panel) {
    var it = g.elements;
    while (it.next()) {
      var found = this._searchVisualTree1(it.value, func);
      if (found !== null) {
        it._dispose();
        return found;
      }
    }
  }
  return null;
};

Panel.prototype['findObject'] =
/**
* Search the visual tree starting at this Panel for a GraphObject
* whose {@link GraphObject#name} is the given name.
* <p/>
* This does not recurse into the elements inside a Panel that holds elements for an {@link #itemArray}.
* @this {Panel}
* @param {string} name The name to search for, using a case-sensitive string comparison.
* @return {GraphObject} If no such named object can be found, this returns null.
*/
Panel.prototype.findObject = function(name) {
  if (this.name === name) return this;
  var elements = this._elements._arr;
  var l = elements.length;
  for (var i = 0; i < l; i++) {
    var elt = elements[i];
    if (elt.name === name) return elt;
    if (elt instanceof Panel && !elt.isItemPanel()) {
      var found = elt.findObject(name);
      if (found !== null) return found;
    }
  }
  return null;
};


/**
* @ignore
* Search the visual tree starting at this GraphObject for an object
* satisfying the given predicate.
* @this {Panel}
* @param {function(GraphObject):boolean} pred A function taking a GraphObject and returning a boolean.
* @return {GraphObject} If no object satisfying the predicate can be found, this returns null.
*/
Panel.prototype.findObjectByPred = function(pred) {
  if (pred(this)) return this;
  return this.findObjectByPred1(pred);
};

/**
* @ignore
* @this {Panel}
* @param {function(GraphObject):boolean} pred
* @return {GraphObject}
*/
Panel.prototype.findObjectByPred1 = function(pred) {
  var it = this.elements;
  while (it.next()) {
    var elt = it.value;
    if (pred(elt)) return elt;
    if (elt instanceof Panel) {
      var found = elt.findObjectByPred1(pred);
      if (found !== null) return found;
    }
  }
  return null;
};

/**
* @ignore
* Finds the largest miter of all children
* @this {Panel}
* @return {number}
*/
Panel.prototype.findMiter = function() {
  var elements = this._elements._arr;
  var l = elements.length;
  var max = 0;
  for (var i = 0; i < l; i++) {
    var elt = elements[i];
    if (elt instanceof Panel) {
      max = Math.max(max, elt.findMiter());
    } else if (elt instanceof Shape) {
      max = Math.max(max, elt.getMiterLength());
    }
  }
  return max;
};



/**
* @ignore
* @this {Panel}
* Determine if an object's transform should or should not affect its children
* This is only meaningful on Panel right now, and only for TableRow/TableColumn
* @return {boolean}
*/
Panel.prototype.trueTransform = function() {
  return !(this.type === Panel.TableRow || this.type === Panel.TableColumn);
};

/**
* @ignore
* @this {Panel}
* @param {Point} p A Point in local coordinates.
* @param {function(GraphObject):GraphObject | null=} navig A function taking a GraphObject and
* returning a GraphObject, defaulting to the identity.
* @param {function(GraphObject):boolean | null=} pred A function taking the GraphObject
* returned by navig and returning true if that object should be returned,
* defaulting to a predicate that always returns true.
* @return {GraphObject} The first GraphObject in the z-order, or else null.
*/
Panel.prototype.findObjectAt = function(p, navig, pred) {
  if (this.pickable === false) return null;
  if (navig === undefined/*notpresent*/) navig = null;
  if (pred === undefined/*notpresent*/) pred = null;
  if (this.getInvalidArrange()) return null;

  // get the natural size because the point p is already transformed
  var sz = this.naturalBounds;
  var sc = 1 / this.getDocumentScale();
  var tt = this.trueTransform();
  var self = tt ? p : Util.tempPointAt(p.x, p.y).transformInverted(this.transform);

  // if its in the bounds, iterate over this panel's collection in reverse order, calling containsPoint
  if (Rect.contains(-(5 * sc), -(5 * sc), sz.width + (10 * sc), sz.height + (10 * sc), self.x, self.y)) {
    if (!this._isAtomic) {
      // first check if any of the panel's elements are at the given point
      var l = this._elements.length;
      var newp = Util.tempPoint();
      for (var i = l; i--; ) {
        var child = this._elements._arr[i];
        if (!child.visible && child !== this.locationObject) continue;

        if (child.trueTransform()) {
          newp.set(p).transformInverted(child.transform);
        } else {
          newp.set(p);
        }

        var obj = null;
        if (child instanceof Panel) {
          obj = child.findObjectAt(newp, navig, pred);
        } else {
          // because containsPoint does not test pickable
          if (child.pickable === true && child.containsPoint(newp)) obj = child;
        }

        if (obj !== null) {
          if (navig !== null) obj = navig(obj);
          if (obj && (pred === null || pred(obj))) {
            Util.freePoint(newp);
            if (!tt) Util.freePoint(self);
            return obj;
          }
        }
      }
      Util.freePoint(newp);
    }


    if (this.background === null && this.areaBackground === null) {
      if (!tt) Util.freePoint(self);
      return null;
    }
    // there's a background: maybe can just return this panel
    var result = Rect.contains(0, 0, sz.width, sz.height, self.x, self.y) ? this : null; // No elements hit, but there was a background
    if (!tt) Util.freePoint(self);
    return result;
  }
  if (!tt) Util.freePoint(self);
  return null; // Outside of the panel's bounds, even if it is inside the panel's arranged area.
};


/**
* @ignore
* @this {Panel}
* @param {Point} p A Point in local coordinates.
* @param {function(GraphObject):GraphObject | null=} navig A function taking a GraphObject and
* returning a GraphObject, defaulting to the identity.
* @param {function(GraphObject):boolean | null=} pred A function taking the GraphObject
* returned by navig and returning true if that object should be returned,
* defaulting to a predicate that always returns true.
* @param {List|Set=} list An optional List (or Set) to add the results to.
* @return {boolean} Whether or not this object is included.
*/
Panel.prototype.findObjectsAt = function(p, navig, pred, list) {
  if (this.pickable === false) return false;
  if (navig === undefined/*notpresent*/) navig = null;
  if (pred === undefined/*notpresent*/) pred = null;
  if (!(list instanceof List) && !(list instanceof Set)) {
    list = new List(GraphObject);
  }
  // get the natural size because the point p is already transformed
  var sz = this.naturalBounds;
  var tt = this.trueTransform();
  var self = tt ? p : Util.tempPointAt(p.x, p.y).transformInverted(this.transform);


  // if its in the bounds, iterate over this panel's collection in reverse order, calling containsPoint
  if (Rect.contains(0, 0, sz.width, sz.height, self.x, self.y)) {
    if (!this._isAtomic) {
      // first check for all of the panel's elements at the given point
      var l = this._elements.length;
      var newp = Util.tempPoint();

      for (var i = l; i--; ) {
        var child = this._elements._arr[i];
        if (!child.visible && child !== this.locationObject) continue;
        if (child.trueTransform()) {
          newp.set(p).transformInverted(child.transform);
        } else {
          newp.set(p);
        }

        var obj = child;
        if ((obj instanceof Panel) ? obj.findObjectsAt(newp, navig, pred, list) : obj.containsPoint(newp)) {
          if (obj.pickable === false) continue; // because containsPoint does not test pickable
          if (navig !== null) obj = navig(obj);
          if (obj && (pred === null || pred(obj))) {
            list.add(obj);
          }
        }
      }
      Util.freePoint(newp);
    }

    // No elements hit, see if there was a background
    if (!tt) Util.freePoint(self);
    return (this.background !== null || this.areaBackground !== null);
  }
  if (!tt) Util.freePoint(self);
  return false;
};

/**
* @ignore
* @this {Panel}
* @param {Rect} r A Rect in container coordinates.
* @param {function(GraphObject):GraphObject | null} navig A function taking a GraphObject and
* returning a GraphObject, defaulting to the identity.
* @param {function(GraphObject):boolean | null} pred A function taking the GraphObject
* returned by navig and returning true if that object should be returned,
* defaulting to a predicate that always returns true.
* @param {boolean} partialInclusion True if objects are to be included when they
* intersect.
* @param {List|Set} list A List (or Set) to add the results to.
* @param {Transform=} txfm
* @return {boolean} Whether or not this object is included.
*/
Panel.prototype.findObjectsIn = function(r, navig, pred, partialInclusion, list, txfm) {
  if (this.pickable === false) return false;
  if (navig === undefined/*notpresent*/) navig = null;
  if (pred === undefined/*notpresent*/) pred = null;
  var transform = txfm;
  if (txfm === undefined/*notpresent*/) {
    transform = Util.tempTransform();
    transform.reset();
  }

  // ??? how do we ensure this works when trueTransform is false?

  transform.multiply(this.transform);
  if (this.containedInRect(r, transform)) { // first 'yes'
    // add to the list "part" and everything inside of "part",
    // going down the object tree using a special function that only tests pred and nothing geometrical,c
    // because by everything inside is already completely within r
    this.addObjs(navig, pred, list);
    if (txfm === undefined/*notpresent*/) Util.freeTransform(transform);
    return true;
  } else if (this.intersectsRect(r, transform)) { // first 'no'
    // 1. We have to go through all the children of "part", invoking "findObjectsIn" on each.
    // We do it regardless of partialInclusion or not, because "part" might have a child that is entirely included,
    // or it may not, and we have no way of knowing yet.
    if (!this._isAtomic) {
      var l = this._elements.length;
      for (var i = l; i--; ) {
        var child = this._elements._arr[i];
        if (!child.visible && child !== this.locationObject) continue;
        var cab = child.actualBounds;
        var ab = this.naturalBounds;
        if (cab.x > ab.width || cab.y > ab.height || cab.x + cab.width < 0 || cab.y + cab.height < 0) continue;

        var obj = child;
        var tt = Util.tempTransform();
        tt.set(transform);
        if ((obj instanceof Panel) ?
            obj.findObjectsIn(r, navig, pred, partialInclusion, list, tt) :
            obj.findObjectIn(r, partialInclusion, tt)) {
          if (navig !== null) obj = navig(obj);
          if (obj && (pred === null || pred(obj))) {
            list.add(obj);
          }
        }
        Util.freeTransform(tt);
      }
    }
    if (txfm === undefined/*notpresent*/) Util.freeTransform(transform);
    return partialInclusion;
  }
  // second 'no'
  // nothing added to the list, we are done.
  if (txfm === undefined/*notpresent*/) Util.freeTransform(transform);
  return false;
};

/**
* @ignore
* Used by Panel.findObjectsIn to place more objects into List that are wholly within the rect.
* @this {Panel}
* @param {function(GraphObject):GraphObject | null} navig
* @param {function(GraphObject):boolean | null} pred
* @param {List|Set} list
*/
Panel.prototype.addObjs = function(navig, pred, list) {
  var l = this._elements.length;
  for (var i = l; i--; ) {
    var child = this._elements._arr[i];
    if (!child.visible) continue;
    var cab = child.actualBounds;
    var ab = this.naturalBounds;
    if (cab.x > ab.width || cab.y > ab.height || cab.x + cab.width < 0 || cab.y + cab.height < 0) continue;
    if (child instanceof Panel) child.addObjs(navig, pred, list);
    var obj = child;
    if (navig !== null) obj = navig(obj);
    if (obj && (pred === null || pred(obj))) {
      list.add(obj);
    }
  }
};

/**
* @ignore
* @this {Panel}
* @param {Point} p A Point in container coordinates.
* @param {Point} distp A Point representing the distance from the point p.
* @param {function(GraphObject):GraphObject | null} navig A function taking a GraphObject and
* returning a GraphObject, defaulting to the identity.
* @param {function(GraphObject):boolean | null} pred A function taking the GraphObject
* returned by navig and returning true if that object should be returned,
* defaulting to a predicate that always returns true.
* @param {boolean} partialInclusion True if objects are to be included when they intersect.
* @param {List|Set} list An optional List (or Set) to add the results to.
* @return {boolean} Whether or not this object is included.
*/
Panel.prototype.findObjectsNear = function(p, distp, navig, pred, partialInclusion, list) {
  if (this.pickable === false) return false;
  if (navig === undefined/*notpresent*/) navig = null;
  if (pred === undefined/*notpresent*/) pred = null;

  var ns = this.naturalBounds;
  var tt = this.trueTransform();
  var self = tt ? p : Util.tempPointAt(p.x, p.y).transformInverted(this.transform);
  var selfdist = tt ? distp : Util.tempPointAt(distp.x, distp.y).transformInverted(this.transform);

  var dist = self.distanceSquaredPoint(selfdist);
  var hit;
  var partial = (self.x > 0 && self.x < ns.width && self.y > 0 && self.y < ns.height) ||
    (Point.distanceLineSegmentSquared(self.x, self.y, 0, 0, 0, ns.height) < dist) ||
    (Point.distanceLineSegmentSquared(self.x, self.y, 0, ns.height, ns.width, ns.height) < dist) ||
    (Point.distanceLineSegmentSquared(self.x, self.y, ns.width, ns.height, ns.width, 0) < dist) ||
    (Point.distanceLineSegmentSquared(self.x, self.y, ns.width, 0, 0, 0) < dist);

  var total = (self.x > 0 && self.x < ns.width && self.y > 0 && self.y < ns.height) &&
    (Point.distanceLineSegmentSquared(self.x, self.y, 0, 0, 0, ns.height) < dist) &&
    (Point.distanceLineSegmentSquared(self.x, self.y, 0, ns.height, ns.width, ns.height) < dist) &&
    (Point.distanceLineSegmentSquared(self.x, self.y, ns.width, ns.height, ns.width, 0) < dist) &&
    (Point.distanceLineSegmentSquared(self.x, self.y, ns.width, 0, 0, 0) < dist);
  if (!tt) { Util.freePoint(self); Util.freePoint(selfdist); }

  if (partial) {
    if (!this._isAtomic) {
      var newp = Util.tempPoint();
      var newdistp = Util.tempPoint();
      var l = this._elements.length;
      for (var i = l; i--; ) {
        var child = this._elements._arr[i];
        if (!child.visible && child !== this.locationObject) continue;
        var cab = child.actualBounds;
        var ab = this.naturalBounds;
        if (cab.x > ab.width || cab.y > ab.height || cab.x + cab.width < 0 || cab.y + cab.height < 0) continue;

        if (child.trueTransform()) {
          var ct = child.transform;
          newp.set(p).transformInverted(ct);
          newdistp.set(distp).transformInverted(ct);
        } else {
          newp.set(p);
          newdistp.set(distp);
        }

        var obj = child;
        if ((obj instanceof Panel) ? obj.findObjectsNear(newp, newdistp, navig, pred, partialInclusion, list) : obj.findObjectNear(newp, newdistp, partialInclusion)) {
          if (navig !== null) obj = navig(obj);
          if (obj && (pred === null || pred(obj))) {
            list.add(obj);
          }
        }
      }
      Util.freePoint(newp);
      Util.freePoint(newdistp);
    }
    if (partialInclusion)
      return partial;
    else
      return total;
  }
  return false;
};

/**
* @ignore
* @this {Panel}
* @param {GraphObject} elt
* @return {Spot}
*/
Panel.prototype.computeSpot1 = function(elt) {
  var spot = elt.spot1;
  if (spot === undefined || spot === Spot.Default) spot = null;
  if (spot === null && elt instanceof Shape) {
    var geo = elt.getConstructedGeometry();
    if (geo !== null) spot = geo.spot1;
  }
  if (spot === null) spot = Spot.TopLeft;
  return spot;
};

/**
* @ignore
* @this {Panel}
* @param {GraphObject} elt
* @return {Spot}
*/
Panel.prototype.computeSpot2 = function(elt) {
  var spot = elt.spot2;
  if (spot === undefined || spot === Spot.Default) spot = null;
  if (spot === null && elt instanceof Shape) {
    var geo = elt.getConstructedGeometry();
    if (geo !== null) spot = geo.spot2;
  }
  if (spot === null) spot = Spot.BottomRight;
  return spot;
};

// Adding

Panel.prototype['add'] =
/**
* Adds a GraphObject to the end of this Panel's list of elements, visually in front of all of the other elements.
* <p/>
* If the element to be added is already in this Panel's list of elements,
* the object is moved to the end of the list.
* You cannot add a GraphObject to a Panel if that GraphObject is already in a different Panel.
* @this {Panel}
* @param {GraphObject} element A GraphObject.
*/
Panel.prototype.add = function(element) {
  Util.checkClass(element, GraphObject, Panel, 'add:element');
  this.insertAt(this._elements.count, element);
};

Panel.prototype['elt'] =
/**
* Returns the GraphObject in this Panel's list of elements at the specified index.
* @this {Panel}
* @param {number} idx
* @return {GraphObject}
*/
Panel.prototype.elt = function(idx) {
  return this._elements.elt(idx);
};

Panel.prototype['insertAt'] =
/**
* Adds a GraphObject to the Panel's list of elements at the specified index.
* <p/>
* If the element to be added is already in this Panel's list of elements,
* the object is moved to the specified index.
* You cannot add a GraphObject to a Panel that if that GraphObject is already in a different Panel.
* @this {Panel}
* @param {number} index
* @param {GraphObject} element A GraphObject.
*/
Panel.prototype.insertAt = function(index, element) {
  if (element instanceof Part) Util.throwError('Cannot add a Part to a Panel: ' + element);
  if (this === element || this.isContainedBy(element)) {
    if (this === element) Util.throwError('Cannot make a Panel contain itself: ' + this.toString());
    Util.throwError('Cannot make a Panel indirectly contain itself: ' + this.toString() + ' already contains ' + element.toString());
  }
  var eltpanel = element.panel;
  if (eltpanel !== null && eltpanel !== this) {
    Util.throwError('Cannot add a GraphObject that already belongs to another Panel to this Panel: ' +
                    element.toString() + ', already contained by ' + eltpanel.toString() + ', cannot be shared by this Panel: ' + this.toString());
  }
  if (this._type === Panel.Grid && !(element instanceof Shape)) {
    Util.throwError('Can only add Shapes to a Grid Panel, not: ' + element);
  }
  element.setPanel(this);
  element._part = null;

  if (this.itemArray !== null) {
    var itemdata = element.data;
    if (itemdata !== null && typeof itemdata === 'object') {
      if (this._itemElementMap === null) this._itemElementMap = new Map(Object, Panel);
      this._itemElementMap.add(itemdata, element);  // keep track of existing items-elements
    }
  }

  var elements = this._elements;
  var wasRemoved = -1;
  if (eltpanel === this) {
    var idx = -1;
    var l = elements.count;
    for (var i = 0; i < l; i++) {
      if (elements._arr[i] === element) { idx = i; break; }
    }
    if (idx !== -1) {
      if (idx === index) return; // no-op, insert in place
      if (idx + 1 >= elements.count && index >= elements.count) return; // no-op, insert at end
      elements.removeAt(idx);
      wasRemoved = idx;
    } else {
      // This should never happen, but if it does, we'd really like to know
      Util.throwError('element ' + element.toString() + ' has panel ' +
                      eltpanel.toString() + ' but is not contained by it.');
    }
  }
  if (index < 0 || index > elements.count) index = elements.count;
  elements.insertAt(index, element);
  this.invalidateMeasure();
  element.invalidateMeasure();
  if (element.portId !== null) this._hasNamedPorts = true;
  if (element instanceof Panel && element._hasNamedPorts === true) this._hasNamedPorts = true;
  var part = this.part;
  if (part !== null) {
    part.clearNameMap();
    part.resetMaxMiter();
    if (element.portId !== null && part instanceof Node) part._hasNamedPorts = true;
    var diagram = this.diagram;
    if (diagram !== null && diagram.undoManager.isUndoingRedoing) return;
    if (wasRemoved !== -1) part.raiseChangedEvent(ChangedEvent.Remove, 'elements', this, element, null, wasRemoved, null);
    part.raiseChangedEvent(ChangedEvent.Insert, 'elements', this, null, element, null, index);
  }
};

/**
* @ignore
* Special insert for copying panels
* @this {Panel}
* @param {GraphObject} element A GraphObject.
*/
Panel.prototype.copyInsert = function(element) {
  element.setPanel(this);
  element._part = null;

  var elements = this._elements;
  var index = elements.count;
  elements.insertAt(index, element);

  //??? why is this raiseChangeEvent being done at all?
  var part = this.part;
  if (part !== null) {
    part.clearNameMap();
    // dont need to resetMaxMiter, it isn't copied
    if (element.portId !== null && part instanceof Node) part._hasNamedPorts = true;
    var diagram = this.diagram;
    if (diagram !== null && diagram.undoManager.isUndoingRedoing) return;
    part.raiseChangedEvent(ChangedEvent.Insert, 'elements', this, null, element, null, index);
  }
};

// Removing

Panel.prototype['remove'] =
/**
* Removes a GraphObject from this Panel's list of elements.
* @this {Panel}
* @param {GraphObject} element A GraphObject.
*/
Panel.prototype.remove = function(element) {
  Util.checkClass(element, GraphObject, Panel, 'remove:element');
  var elements = this._elements;
  var l = elements.count;
  var index = -1;
  for (var i = 0; i < l; i++) {
    if (elements._arr[i] === element) { index = i; break; }
  }
  if (index !== -1) {
    this.internalRemove(index);
  }
};

Panel.prototype['removeAt'] =
/**
* Removes an GraphObject from this Panel's list of elements at the specified index.
* @this {Panel}
* @param {number} idx
*/
Panel.prototype.removeAt = function(idx) {
  if (Debug) Util.checkRealNumber(idx, Panel, 'removeAt:idx');
  if (idx >= 0) {
    this.internalRemove(idx);
  }
};

/**
* @ignore
* @this {Panel}
* @param {number} index
*/
Panel.prototype.internalRemove = function(index) {
  var elements = this._elements;
  var element = elements.elt(index);
  element._part = null;
  element.setPanel(null);

  if (this._itemElementMap !== null) {
    var itemdata = element.data;
    if (typeof itemdata === 'object') {
      this._itemElementMap.remove(itemdata);
    }
  }

  elements.removeAt(index);
  this.setInvalidMeasure(false);
  this.invalidateMeasure();

  var part = this.part;
  if (part !== null) {
    part.clearNameMap();
    part.resetMaxMiter();
    var diagram = this.diagram;
    if (diagram !== null && diagram.undoManager.isUndoingRedoing) return;
    part.raiseChangedEvent(ChangedEvent.Remove, 'elements', this, element, null, index, null);
  }
};

/**
* Gets the number of rows in this Panel if it is of {@link #type} {@link Panel#Table}.
* This value is only valid after the Panel has been measured.
* @name Panel#rowCount
* @function.
* @return {number}
*/
/** @type {number} */
Panel.prototype.rowCount;
Util.defineReadOnlyProperty(Panel, { rowCount: 'rowCount' },
  /** @this {Panel} */
  function() { return this._rowDefs === undefined ? 0 : this._rowDefs.length; }
);

Panel.prototype['getRowDefinition'] =
/**
* Gets the {@link RowColumnDefinition} for a particular row in this Table Panel.
* If you ask for the definition of a row at or beyond the {@link #rowCount},
* it will automatically create one and return it.
* <p>
* If this Panel is not a Table Panel, this method returns null.
* @this {Panel}
* @param {number} idx the non-negative zero-based integer row index.
* @return {RowColumnDefinition}
*/
Panel.prototype.getRowDefinition = function(idx) {
  if (this._rowDefs === undefined) return null;
  if (Debug) Util.checkRealNumber(idx, Panel, 'getRowDefinition:idx');
  if (idx < 0) Util.throwRangeError(idx, '>= 0', Panel, 'getRowDefinition:idx');
  idx = Math.round(idx);
  var defs = this._rowDefs;

  if (defs[idx] === undefined) {
    var d = new RowColumnDefinition();
    d.setPanel(this);
    d.setIsRow(true);
    d.setIndex(idx);
    defs[idx] = d;
  }
  return defs[idx];
};

Panel.prototype['removeRowDefinition'] =
/**
* Removes the {@link RowColumnDefinition} for a particular row in this Table Panel.
* <p>
* If this Panel is not a Table Panel, this method does nothing.
* @this {Panel}
* @param {number} idx the non-negative zero-based integer row index.
*/
Panel.prototype.removeRowDefinition = function(idx) {
  if (this._rowDefs === undefined) return;
  if (Debug) Util.checkRealNumber(idx, Panel, 'removeRowDefinition:idx');
  if (idx < 0) Util.throwRangeError(idx, '>= 0', Panel, 'removeRowDefinition:idx');
  idx = Math.round(idx);
  var defs = this._rowDefs;
  if (defs[idx]) { defs[idx] = undefined; }
};


/**
* Gets the number of columns in this Panel if it is of {@link #type} {@link Panel#Table}.
* This value is only valid after the Panel has been measured.
* @name Panel#columnCount
* @function.
* @return {number}
*/
/** @type {number} */
Panel.prototype.columnCount;
Util.defineReadOnlyProperty(Panel, { columnCount: 'columnCount' },
  /** @this {Panel} */
  function() { return this._colDefs === undefined ? 0 : this._colDefs.length; }
);

Panel.prototype['getColumnDefinition'] =
/**
* Gets the {@link RowColumnDefinition} for a particular column in this Table Panel.
* If you ask for the definition of a column at or beyond the {@link #columnCount},
* it will automatically create one and return it.
* <p>
* If this Panel is not a Table Panel, this method returns null.
* @this {Panel}
* @param {number} idx the non-negative zero-based integer column index.
* @return {RowColumnDefinition}
*/
Panel.prototype.getColumnDefinition = function(idx) {
  if (this._colDefs === undefined) return null;
  if (Debug) Util.checkRealNumber(idx, Panel, 'getColumnDefinition:idx');
  if (idx < 0) Util.throwRangeError(idx, '>= 0', Panel, 'getColumnDefinition:idx');
  idx = Math.round(idx);
  var defs = this._colDefs;

  if (defs[idx] === undefined) {
    var d = new RowColumnDefinition();
    d.setPanel(this);
    d.setIsRow(false);
    d.setIndex(idx);
    defs[idx] = d;
  }
  return defs[idx];
};

Panel.prototype['removeColumnDefinition'] =
/**
* Removes the {@link RowColumnDefinition} for a particular row in this Table Panel.
* <p>
* If this Panel is not a Table Panel, this method does nothing.
* @this {Panel}
* @param {number} idx the non-negative zero-based integer row index.
*/
Panel.prototype.removeColumnDefinition = function(idx) {
  if (this._colDefs === undefined) return;
  if (Debug) Util.checkRealNumber(idx, Panel, 'removeColumnDefinition:idx');
  if (idx < 0) Util.throwRangeError(idx, '>= 0', Panel, 'removeColumnDefinition:idx');
  idx = Math.round(idx);
  var defs = this._colDefs;
  if (defs[idx]) { defs[idx] = undefined; }
};

/**
* Gets or sets how this Panel's rows deal with extra space
* if the Panel is of {@link #type} {@link Panel#Table}.
* Valid values are {@link RowColumnDefinition#ProportionalExtra} and {@link RowColumnDefinition#None}.
* The default is {@link RowColumnDefinition#ProportionalExtra}.
* @name Panel#rowSizing
* @function.
* @return {EnumValue}
* @see RowColumnDefinition#sizing
* @see #columnSizing
*/
/** @type {EnumValue} */
Panel.prototype.rowSizing;
Util.exportProperty(Panel, 'rowSizing', Panel.prototype.rowSizing);
Util.defineProperty(Panel, { rowSizing: 'rowSizing' },
  /** @this {Panel} */
  function() { return this._rowSizing === undefined ? RowColumnDefinition.ProportionalExtra : this._rowSizing; },
  /** @this {Panel} */
  function(val) {
    if (this._rowSizing === undefined) return;
    var old = this._rowSizing;
    if (old !== val) {
      if (val !== RowColumnDefinition.ProportionalExtra && val !== RowColumnDefinition.None)
        Util.throwError('rowSizing must be RowColumnDefinition.ProportionalExtra or RowColumnDefinition.None');
      this._rowSizing = val;
      this.invalidateMeasure();
      this.raiseChanged('rowSizing', old, val);
    }
  }
);

/**
* Gets or sets how this Panel's columns deal with extra space
* if the Panel is of {@link #type} {@link Panel#Table}.
* Valid values are {@link RowColumnDefinition#ProportionalExtra} and {@link RowColumnDefinition#None}.
* The default is {@link RowColumnDefinition#ProportionalExtra}.
* @name Panel#columnSizing
* @function.
* @return {EnumValue}
* @see RowColumnDefinition#sizing
* @see #rowSizing
*/
/** @type {EnumValue} */
Panel.prototype.columnSizing;
Util.exportProperty(Panel, 'columnSizing', Panel.prototype.columnSizing);
Util.defineProperty(Panel, { columnSizing: 'columnSizing' },
  /** @this {Panel} */
  function() { return this._columnSizing === undefined ? RowColumnDefinition.ProportionalExtra : this._columnSizing; },
  /** @this {Panel} */
  function(val) {
    if (this._columnSizing === undefined) return;
    var old = this._columnSizing;
    if (old !== val) {
      if (val !== RowColumnDefinition.ProportionalExtra && val !== RowColumnDefinition.None)
        Util.throwError('columnSizing must be RowColumnDefinition.ProportionalExtra or RowColumnDefinition.None');
      this._columnSizing = val;
      this.invalidateMeasure();
      this.raiseChanged('columnSizing', old, val);
    }
  }
);

/**
* Gets or sets the first row that this Panel of {@link #type} {@link Panel#Table} displays.
* The default value is 0.
* @name Panel#topIndex
* @function.
* @return {number}
* @see #leftIndex
*/
/** @type {number} */
Panel.prototype.topIndex;
Util.exportProperty(Panel, 'topIndex', Panel.prototype.topIndex);
Util.defineProperty(Panel, { topIndex: 'topIndex' },
  /** @this {Panel} */
  function() { return this._topIndex === undefined ? 0 : this._topIndex; },
  /** @this {Panel} */
  function(val) {
    if (this._topIndex === undefined) return;
    var old = this._topIndex;
    if (old !== val) {
      if (!isFinite(val) || val < 0) Util.throwError('topIndex must be greater than zero and a real number. Was ' + val);
      this._topIndex = val;
      this.invalidateArrange();
      this.raiseChanged('topIndex', old, val);
    }
  }
);

/**
* Gets or sets the first column that this Panel of {@link #type} {@link Panel#Table} displays.
* The default value is 0.
* @name Panel#leftIndex
* @function.
* @return {number}
* @see #topIndex
*/
/** @type {number} */
Panel.prototype.leftIndex;
Util.exportProperty(Panel, 'leftIndex', Panel.prototype.leftIndex);
Util.defineProperty(Panel, { leftIndex: 'leftIndex' },
  /** @this {Panel} */
  function() { return this._leftIndex === undefined ? 0 : this._leftIndex; },
  /** @this {Panel} */
  function(val) {
    if (this._leftIndex === undefined) return;
    var old = this._leftIndex;
    if (old !== val) {
      if (!isFinite(val) || val < 0) Util.throwError('leftIndex must be greater than zero and a real number. Was ' + val);
      this._leftIndex = val;
      this.invalidateArrange();
      this.raiseChanged('leftIndex', old, val);
    }
  }
);

Panel.prototype['findRowForLocalY'] =
/**
* Returns the row at a given y-coordinate in local coordinates.
* Call {@link GraphObject#getLocalPoint} to convert a Point in document coordinates into
* a Point in local coordinates.
* <p>
* If this Panel is not a Table Panel, this method returns -1.
* @this {Panel}
* @param {number} y
* @return {number} a zero-based integer
* @since 1.2
* @see #findColumnForLocalX
*/
Panel.prototype.findRowForLocalY = function(y) {
  if (y < 0) return -1;
  if (this.type !== Panel.Table) return NaN;
  var total = 0;
  var row = -1;
  var it = this._rowDefs;
  var l = it.length;
  for (var i = this._topIndex; i < l; i++) {
    var def = it[i];
    if (def === undefined) continue;
    total += def.total;
    if (y < total) {
      return i;
    }
  }
  return row;
};

Panel.prototype['findColumnForLocalX'] =
/**
* Returns the cell at a given x-coordinate in local coordinates.
* Call {@link GraphObject#getLocalPoint} to convert a Point in document coordinates into
* a Point in local coordinates.
* <p>
* If this Panel is not a Table Panel, this method returns -1.
* @this {Panel}
* @param {number} x
* @return {number} a zero-based integer
* @since 1.2
* @see #findRowForLocalY
*/
Panel.prototype.findColumnForLocalX = function(x) {
  if (x < 0) return -1;
  if (this.type !== Panel.Table) return NaN;
  var total = 0;
  var column = -1;
  var it = this._colDefs;
  var l = it.length;
  for (var i = this._leftIndex; i < l; i++) {
    var def = it[i];
    if (def === undefined) continue;
    total += def.total;
    if (x < total) {
      return i;
    }
  }
  return column;
};

/**
* Gets or sets the optional model data to which this panel is data-bound.
* The data must be a JavaScript Object if this is a {@link Part}.
* The data can be any JavaScript value if this is a {@link Panel} created for
* an item in an Array that was data-bound by the {@link #itemArray} property.
* The default value is null.
* <p/>
* Setting it to a new value automatically calls {@link #updateTargetBindings}
* in order to assign new values to all of the data-bound GraphObject properties.
* <p/>
* Once you set this property you cannot add, remove, or modify any data bindings
* on any of the GraphObjects in the visual tree of this Panel, including on
* this panel itself.
* <p/>
* You should not modify this property on a {@link Part} that is created automatically
* to represent model data, nor on a {@link Panel} that is created automatically for a data item
* in the containing Panel's {@link Panel#itemArray}.
* Call {@link Model#removeNodeData} and {@link Model#addNodeData} if you want to replace
* this Part with another one, or call {@link Model#removeArrayItem} and {@link Model#insertArrayItem}
* if you want to replace this Panel with another one.
* <p/>
* Although you might not be able to replace this data value if this Part was created
* automatically by the Diagram, you can still modify that data object's properties.
* Call the appropriate Model method for changing properties that affect the structure of the diagram.
* Call {@link Model#setDataProperty} for changing other properties that may be the sources
* of {@link Binding}s on {@link GraphObject} properties that are in the visual tree of this panel/part.
* @name Panel#data
* @function.
* @return {Object}
*/
/** @type {Object} */
Panel.prototype.data;
Util.exportProperty(Panel, 'data', Panel.prototype.data);
Util.defineProperty(Panel, {data: 'data'},
  /** @this {Panel} */
  function() { return this._data; },
  /** @this {Panel} */
  function(val) {
    var old = this._data;
    if (old !== val) {
      var ispart = (this instanceof Part) && !(this instanceof Adornment);
      if (ispart) Util.checkPrimitive(val, 'object', Panel, 'data');
      this.freezeBindings();
      this._data = val;
      var diagram = this.diagram;
      if (diagram !== null) {
        if (ispart) {
          if (this instanceof Link) {
            if (old !== null) diagram._dataLinkMap.remove(old);
            if (val !== null) diagram._dataLinkMap.add(val, this);
          } else {
            if (old !== null) diagram._dataPartMap.remove(old);
            if (val !== null) diagram._dataPartMap.add(val, this);
          }
        } else {
          var listcontainer = this.panel;
          if (listcontainer !== null && listcontainer._itemElementMap !== null) {
            if (old !== null) listcontainer._itemElementMap.remove(old);
            if (val !== null) listcontainer._itemElementMap.add(val, this);
          }
        }
      }
      this.raiseChanged('data', old, val);
      if (diagram !== null && diagram.undoManager.isUndoingRedoing) return;
      if (val !== null) this.updateTargetBindings();
    }
  }
);

/**
* @ignore
* @this {Panel}
* @return {boolean}
*/
Panel.prototype.isTemplateBinder = function() {
  return this._bindings !== null;
};

/**
* @ignore
* @this {Panel}
* @return {boolean}
*/
Panel.prototype.isTemplateBinderFrozen = function() {
  var allbinds = this._bindings;
  return allbinds !== null && allbinds._isFrozen;
};

/**
* @ignore
* Collect all of the Bindings in the visual tree, freeze them,
* and make sure there is a name association to the target object,
* so that they can be found in each copy of the visual tree.
* @this {Panel}
*/
Panel.prototype.freezeBindings = function() {
  var allbinds = this._bindings;
  if (allbinds === null) {
    if (this.data !== null) Util.throwError('Template cannot have .data be non-null: ' + this);
    this._bindings = allbinds = new List(Binding);
  } else if (allbinds._isFrozen) {
    return;
  }

  var srcbinds = new List(GraphObject);

  // collect all Bindings from the visual tree
  this.walkVisualTree(this,
      function(root, obj) {
        var locals = obj._binds;
        if (locals !== null) {
          obj.setBindsTwoWay(false);
          var bit = locals.iterator;
          while (bit.next()) {
            var b = bit.value;
            // If two-way binding, remember that, so GraphObject.raiseChangedEvent
            // can find and call Binding.updateSource.
            if (b.mode === Binding.TwoWay) obj.setBindsTwoWay(true);
            // If binding element to element, record binding in source GraphObject,
            // so that GraphObject.raiseChangedEvent can find it and update this GraphObject.
            var srcname = b.sourceName;
            if (srcname !== null) {
              var srcelt = root;
              if (srcname !== '') srcelt = root.findObject(srcname);
              if (srcelt !== null) {
                // postpone adding Bindings to the source element, to avoid concurrent modification of Lists
                srcbinds.add(srcelt);
                // remember the Bindings to be added on the source element itself, in _srcbinds
                if (srcelt._srcbinds === undefined) srcelt._srcbinds = new List(Binding);
                srcelt._srcbinds.add(b);
              }
            }
            allbinds.add(b);
          }
        }
        if (!(obj instanceof Panel)) return;
        if (obj.type === Panel.Table) {
          // handle RowColumnDefinitions, but don't need to record bindsTwoWay
          if (obj._rowDefs.length > 0) {
            var it = obj._rowDefs;
            var l = it.length;
            for (var i = 0; i < l; i++) {
              var def = it[i];
              if (def === undefined) continue;
              if (def._binds !== null) {
                var dit = def._binds.iterator;
                while (dit.next()) {
                  var b = dit.value;
                  b._targetObject = def;
                  b._targetKind = 2;
                  b._targetArg = def.index;
                  allbinds.add(b);
                }
              }
            }
          }
          if (obj._colDefs.length > 0) {
            var it = obj._colDefs;
            var l = it.length;
            for (var i = 0; i < l; i++) {
              var def = it[i];
              if (def === undefined) continue;
              if (def._binds !== null) {
                var dit = def._binds.iterator;
                while (dit.next()) {
                  var b = dit.value;
                  b._targetObject = def;
                  b._targetKind = 1;
                  b._targetArg = def.index;
                  allbinds.add(b);
                }
              }
            }
          }
        }
      });

  // Now iterate over all source elements (if any).
  // Make sure it's declared as TwoWay, to inform notification about side-effects via bindings,
  // and add all bindings using the source to the source's _binds list.
  var sbit = srcbinds.iterator;
  while (sbit.next()) {
    var srcelt = sbit.value;
    if (srcelt._srcbinds !== undefined) {
      srcelt.setBindsTwoWay(true);
      var sbbit = srcelt._srcbinds.iterator;
      while (sbbit.next()) {
        var b = sbbit.value;
        if (srcelt._binds === null) srcelt._binds = new List(Binding);
        srcelt._binds.add(b);
      }
    }
    delete srcelt._srcbinds;
  }

  // make sure each Binding and corresponding target have a name
  var bit = allbinds.iterator;
  while (bit.next()) {
    var bind = bit.value;
    var target = bind._targetObject;
    if (target !== null) {  // not yet setup to search by name
      bind._targetObject = null;
      if (target === this) {
        bind.targetId = '';
      } else if (target instanceof RowColumnDefinition) {
        var panel = target.panel;
        if (panel.name !== '') {
          bind.targetId = panel.name;
        } else {
          bind.targetId = panel.name = '_' + Util.hashId(panel);
        }
      } else if (target.name !== '') {  // use GraphObject.name
        bind.targetId = target.name;
      } else {  // generate unique name for GraphObject
        bind.targetId = target.name = '_' + Util.hashId(target);
      }
    }
  }
  allbinds.freeze();  // freeze the collection

  // We should try to measure and arrange all templates
  var n = this;
  if (n instanceof Part && n.isNodeLike()) { // ??? not Part?
    n.measure(Infinity, Infinity);
    n.arrange();
  }
};


Panel.prototype['updateTargetBindings'] =
/**
* Re-evaluate all data bindings on this panel,
* in order to assign new property values to the {@link GraphObject}s in this visual tree
* based on this object's {@link #data} property values.
* <p/>
* This method does nothing if {@link #data} is null.
* This method also will not detect changes in JavaScript Arrays -- you may need to replace
* the {@link #itemArray} with a new Array, or else call {@link Model#insertArrayItem}
* or {@link Model#removeArrayItem}.
* @this {Panel}
* @param {string=} srcprop An optional source data property name:
*   when provided, only evaluates those {@link Binding}s that use that particular property;
*   when not provided or when it is the empty string, all bindings are evaluated.
*/
Panel.prototype.updateTargetBindings = function(srcprop) {
  var allbinds = this._bindings;
  if (allbinds === null) return;
  if (srcprop === undefined/*notpresent*/) srcprop = '';
  var bit = allbinds.iterator;
  while (bit.next()) {
    var bind = bit.value;
    var sprop = bind.sourceProperty;
    if (srcprop !== '' && sprop !== srcprop) continue;
    var tprop = bind.targetProperty;
    var conv = bind.converter;
    if (conv === null && tprop === '') continue;  // can't replace GraphObject!

    // normally bound to DATA, but use a named GraphObject if sourceName
    var data = this.data;
    var srcnm = bind.sourceName;
    if (srcnm !== null) data = this.findObject(srcnm);
    if (data === null) {
      if (Debug) Util.trace('Binding error: missing GraphObject named ' + srcnm + ' in ' + this.toString());
      continue;
    }

    // Find the data-bound object
    var elt = this;
    var name = bind.targetId;
    // Find the named object; use THIS if name is empty
    if (name !== '') {
      elt = this.findObject(name);
      if (elt === null) continue;  // couldn't find named object
    } else if (bind._targetObject !== null) {
      elt = bind._targetObject;  // not being used in a template
    }

    // Find the target object, which might be a RowColumnDefinition instead
    var kind = bind._targetKind;
    if (kind !== 0) {
      if (!(elt instanceof Panel)) continue;  // and the object must be a Panel
      if (kind === 1) elt = elt.getColumnDefinition(bind._targetArg);
      else if (kind === 2) elt = elt.getRowDefinition(bind._targetArg);
    }

    if (elt === undefined) continue;
    bind.updateTarget(elt, data);
  }
};


/**
* Gets or sets a JavaScript Array of values or objects, each of which will be represented
* by a {@link Panel} as elements in this Panel.
* Replacing this array results all of this panel's child objects being replaced with
* a copy of the {@link Panel} found in {@link #itemTemplateMap} for each particular
* item in the Array.
* <p/>
* Because the software does not receive any notifications when an Array is modified,
* any insertions or removals or replacements of data in the Array will not be noticed
* unless you call {@link Model#insertArrayItem} or {@link Model#removeArrayItem}.
* @name Panel#itemArray
* @function.
* @return {Array}
*/
/** @type {Array} */
Panel.prototype.itemArray;
Util.exportProperty(Panel, 'itemArray', Panel.prototype.itemArray);
Util.defineProperty(Panel, { itemArray: 'itemArray' },
  /** @this {Panel} */
  function() { return this._itemArray; },
  /** @this {Panel} */
  function(val) {
    var old = this._itemArray;
    if (old !== val) {
      if (Debug && val !== null && !Util.isArray(val)) Util.throwError('Panel.itemArray must be an Array-like object or null, not: ' + val);
      var diagram = this.diagram;
      if (diagram !== null && old !== null) diagram.forgetItemArrayPanel(this);
      this._itemArray = val;
      if (diagram !== null && val !== null) diagram.rememberItemArrayPanel(this);
      this.raiseChanged('itemArray', old, val);
      if (diagram !== null && diagram.undoManager.isUndoingRedoing) return;
      this.rebuildItemElements();
    }
  }
);

Panel.prototype['rebuildItemElements'] =
/**
* Create and add new GraphObjects corresponding to and bound to the data in the {@link #itemArray},
* after removing all existing elements from this Panel.
* <p/>
* This uses {@link #itemCategoryProperty} to determine the category for an item data.
* That string is used to look up a template in {@link #itemTemplateMap}.
* The resulting template is copied, added to this panel, and data-bound to the item data.
* <p/>
* If {@link #itemArray} is null, this method just removes all elements from this panel.
* @this {Panel}
*/
Panel.prototype.rebuildItemElements = function() {
  // remove all existing elements
  var start = 0;
  if (this.type === Panel.Spot || this.type === Panel.Auto || this.type === Panel.Link) start = 1;  // skip first element
  while (this._elements.length > start) {
    this.internalRemove(start);
  }

  var arr = this.itemArray;
  if (arr === null) return;

  // add an element for each new data in the itemArray
  var len = Util.arrayLength(arr);
  for (var i = 0; i < len; i++) {
    this.addItemElement(Util.arrayElt(arr, i));
  }
};

/**
* @ignore
* @this {Panel}
* @param data
* @param {number=} idx
* @return {Panel}
*/
Panel.prototype.addItemElement = function(data, idx) {
  if (data === undefined || data === null) return null;
  var cat = this.getCategoryForItemData(data);
  var template = this.findTemplateForItemData(data, cat);
  if (template instanceof Panel) {
    template.freezeBindings();
    var elt = template.copy();
    if (typeof data === 'object') {
      if (this._itemElementMap === null) this._itemElementMap = new Map(Object, Panel);
      this._itemElementMap.add(data, elt);  // keep track of existing items-elements
    }
    if (typeof idx === 'number') {
      if (this.type === Panel.Spot || this.type === Panel.Auto) idx++;  // skip first element
      this.insertAt(idx, elt);
      elt.internalSetAllRowColumn(idx);
      this.updateTableIndexes(idx);
    } else {  // add at end of list
      this.add(elt);
      elt.internalSetAllRowColumn(this._elements.count - 1);
    }
    elt._itemCategory = cat;
    elt.data = data;
    return elt;
  }
  return null;
};

/**
* @ignore
* After removing or inserting an item into an items-array Panel,
* we need to update the row or column of all TableRow or TableColumn Panels
* that come after that index in this Panel.
* @this {Panel}
* @param {number} idx
*/
Panel.prototype.updateTableIndexes = function(idx) {
  var elts = this._elements;
  var i = idx + 1;
  while (i < elts.length) {
    var child = elts.elt(i);
    if (child instanceof Panel) {  // ought to always be true
      child.internalSetAllRowColumn(i);  // no-op if not of type TableRow or TableColumn
    }
    i++;
  }
};

/**
* @ignore
* Assume this is an item Panel generated for a data item in an itemsArray.
* Depending on whether this Panel is of type TableRow or TableColumn,
* make sure all of its elements have the given row or column index.
* @this {Panel}
* @param {number} idx
*/
Panel.prototype.internalSetAllRowColumn = function(idx) {
  if (this.type === Panel.TableRow) {
    this.row = idx;
  } else if (this.type === Panel.TableColumn) {
    this.column = idx;
  }
};


Panel.prototype['isItemPanel'] =
/**
* @ignore
* This predicate is true if this Panel is expected to hold elements corresponding to an {@link #itemArray}.
* @this {Panel}
* @return {boolean}
*/
Panel.prototype.isItemPanel = function() {
  return this._itemArray !== null || this._itemTemplateMap !== null;
};

/**
* Gets or sets the default {@link Panel} template used as the archetype
* for item data that are in {@link #itemArray}.
* Setting this property just modifies the {@link #itemTemplateMap}
* by replacing the entry named with the empty string.
* Any new value must be a {@link Panel} but not a {@link Part}.
* By default this property is null.
* @name Panel#itemTemplate
* @function.
* @return {Panel}
*/
/** @type {Panel} */
Panel.prototype.itemTemplate;
Util.exportProperty(Panel, 'itemTemplate', Panel.prototype.itemTemplate);
Util.defineProperty(Panel, { itemTemplate: 'itemTemplate' },
  /** @this {Panel} */
  function() {
    if (this._itemTemplateMap === null) return null;
    return this._itemTemplateMap.getValue('');
  },
  /** @this {Panel} */
  function(val) {
    if (this._itemTemplateMap === null) {
      if (val === null) return;  // don't allocate a Map unnecessarily
      this._itemTemplateMap = new Map('string', Panel);
    }
    var old = this._itemTemplateMap.getValue('');
    if (old !== val) {
      Util.checkClass(val, Panel, Panel, 'itemTemplate');
      if (val instanceof Part) Util.throwError('itemTemplate must not be a Part: ' + val);
      this._itemTemplateMap.add('', val);
      this.raiseChanged('itemTemplate', old, val);
      var diagram = this.diagram;
      if (diagram !== null && diagram.undoManager.isUndoingRedoing) return;
      this.rebuildItemElements();
    }
  }
);

/**
* Gets or sets a {@link Map} mapping template names to {@link Panel}s.
* One of these Panels is copied for each item data that is in the {@link #itemArray}.
* Replacing this map will automatically rebuild all of the elements in this Panel.
* <p/>
* By default this property is null.
* All values in the {@link Map} must be {@link Panel}s but not {@link Part}s.
* <p/>
* If you modify this {@link Map}, by replacing a {@link Panel} or by adding or
* removing a map entry, you need to explicitly call {@link #rebuildItemElements} afterwards.
* @name Panel#itemTemplateMap
* @function.
* @return {Map} mapping string to Panel.
*/
/** @type {Map} */
Panel.prototype.itemTemplateMap;
Util.exportProperty(Panel, 'itemTemplateMap', Panel.prototype.itemTemplateMap);
Util.defineProperty(Panel, {itemTemplateMap: 'itemTemplateMap'},
  /** @this {Panel} */
  function() { return this._itemTemplateMap; },
  /** @this {Panel} */
  function(val) {
    var old = this._itemTemplateMap;
    if (old !== val) {
      Util.checkClass(val, Map, Panel, 'itemTemplateMap');
      var it = val.iterator;
      while (it.next()) {
        var t = it.value;
        if (t instanceof Part) Util.throwError('Template in itemTemplateMap must not be a Part: ' + t);
      }
      this._itemTemplateMap = val;
      this.raiseChanged('itemTemplateMap', old, val);
      var diagram = this.diagram;
      if (diagram !== null && diagram.undoManager.isUndoingRedoing) return;
      this.rebuildItemElements();
    }
  }
);

/**
* Gets or sets the name of the item data property that returns a string describing that data's category,
* or a function that takes an item data object and returns that string;
* the default value is the name 'category'.
* This is used to distinguish between different
* kinds of items in the {@link #itemArray}.
* <p/>
* The name must not be null.
* If the value is an empty string, the category is assumed to be an empty string,
* the default category name, for all item data objects.
* You must not change this property when the {@link #itemArray} already has a value.
* @name Panel#itemCategoryProperty
* @function.
* @return {string|function(*):string}
*/
/** @type {string|function(*):string} */
Panel.prototype.itemCategoryProperty;
Util.exportProperty(Panel, 'itemCategoryProperty', Panel.prototype.itemCategoryProperty);
Util.defineProperty(Panel, {itemCategoryProperty: 'itemCategoryProperty'},
  /** @this {Panel} */
  function() { return this._itemCategoryProperty; },
  /** @this {Panel} */
  function(val) {
    var old = this._itemCategoryProperty;
    if (old !== val) {
      if (typeof val !== 'string' && typeof val !== 'function') {
        Util.throwTypeError(val, 'string or function', Panel, 'itemCategoryProperty');
      }
      this._itemCategoryProperty = val;
      this.raiseChanged('itemCategoryProperty', old, val);
    }
  }
);

/**
* @ignore
* Find the category of a given item data, a string naming the template
* in this {@link Panel}'s {@link Panel#itemTemplateMap} to use to
* represent the item data.
* By default this just returns the empty string, resulting in the use
* of the default {@link #itemTemplate}.
* @expose
* @this {Panel}
* @param {*} itemdata a value that is in the {@link Panel#itemArray}.
* @return {string}
* @see #itemCategoryProperty
*/
Panel.prototype.getCategoryForItemData = function(itemdata) {
  if (itemdata === null) return '';
  var cname = this._itemCategoryProperty;
  var cat;
  if (typeof cname === 'function') {
    cat = cname(itemdata);
  } else if (typeof cname === 'string' && typeof itemdata === 'object') {
    if (cname === '') return '';
    cat = Util.safePropertyValue(itemdata, cname);
  } else {  // give up
    return '';
  }
  if (cat === undefined) return '';
  if (typeof cat === 'string') return cat;
  if (Debug) Util.trace('Panel.getCategoryForItemData found a non-string category for ' + itemdata + ': ' + cat);
  return '';
};

//??? setCategoryForItemData

/**
* @ignore
* @expose
* @this {Panel}
* @param data, a data item in the itemArray, of any type.
* @param {string} cat the category.
* @return {Panel}
*/
Panel.prototype.findTemplateForItemData = function(data, cat) {
  var map = this.itemTemplateMap;
  var template = null;
  if (map !== null) template = map.getValue(cat);
  if (template === null) {
    if (!Util.warnedAboutNoItemTemplate) {
      Util.warnedAboutNoItemTemplate = true;
      Util.trace('No item template Panel found for category "' + cat + '" on ' + this);
      Util.trace('  Using default item template.');

      // build the shared default item template
      var architem = new Panel();
      var itemtxt = new TextBlock();
      itemtxt.bind(new Binding('text', '', Binding.toString));
      architem.add(itemtxt);
      Util.defaultItemTemplate = architem;
    }
    template = Util.defaultItemTemplate;
  }
  if (template instanceof Panel) return template;
  return null;
};


/**
* @ignore
* Determines whether or not this Panel's elements participate in object picking
* (findObjectAt, findObjectsIn, findObjectNear, etc)
* This is set to true if the Panel is of type {@link Panel#Grid}.
* @name Panel#isAtomic
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Panel.prototype.isAtomic;
Util.exportProperty(Panel, 'isAtomic', Panel.prototype.isAtomic);
Util.defineProperty(Panel, {isAtomic: 'isAtomic'},
  /** @this {Panel} */
  function() { return this._isAtomic; },
  /** @this {Panel} */
  function(val) {
    var old = this._isAtomic;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Panel, 'isAtomic');
      this._isAtomic = val;
      this.raiseChanged('isAtomic', old, val);
    }
  }
);

/**
* Gets or sets the multiplicative opacity for this Panel and all children.
* The value must be between 0.0 (fully transparent) and 1.0 (no additional transparency).
* This value is multiplicative with any existing transparency,
* for instance from {@link Layer#opacity} or a Panel's opacity higher in the visual tree,
* or from a {@link Brush} or image transparency.
* The default value is 1.
* <p/>
* This property, unlike {@link #visible}, does not change whether any objects are found by the "find..." methods.
* @name Panel#opacity
* @function.
* @return {number}
* @since 1.1
*/
/** @type {number} */
Panel.prototype.opacity;
Util.exportProperty(Panel, 'opacity', Panel.prototype.opacity);
Util.defineProperty(Panel, {opacity: 'opacity'},
  /** @this {Panel} */
  function() { return this._opacity; },
  /** @this {Panel} */
  function(val) {
    var old = this._opacity;
    if (old !== val) {
      Util.checkPrimitive(val, 'number', Panel, 'opacity');
      if (val < 0 || val > 1) Util.throwRangeError(val, '0 <= val <= 1', Panel, 'opacity');
      this._opacity = val;
      this.raiseChanged('opacity', old, val);
      // and make sure everything is re-drawn
      var diagram = this.diagram;
      var part = this.part;
      if (diagram !== null && part !== null) {
        diagram.invalidateDraw(part.getDrawnSize(part.actualBounds));
      }
    }
  }
);



/**
* You do not need to use this constructor, because calls to
* {@link Panel#getRowDefinition} or {@link Panel#getColumnDefinition}
* will automatically create and remember a RowColumnDefinition for you.
* @constructor
* @class
* The RowColumnDefinition class describes constraints on a row or a column
* in a {@link Panel} of type {@link Panel#Table}.
* It also provides information about the actual layout after the
* Table Panel has been arranged.
*/
function RowColumnDefinition() {
  Util.uniqueHash(this);
  /** @type {Panel} */
  this._panel = null;  // set only by Panel.getRow/ColumnDefinition
  /** @type {boolean} */
  this._isRow = true;  // set only by Panel.getRow/ColumnDefinition
  /** @type {number} */
  this._index = 0;  // set only by Panel.getRow/ColumnDefinition
  /** @type {number} */
  this._size = NaN;  // finite, >= 0
  /** @type {number} */
  this._minimum = 0;  // finite, >= 0
  /** @type {number} */
  this._maximum = Infinity;  // >= 0
  /** @type {Spot} */
  this._alignment = Spot.Default;
  /** @type {number} */
  this._actual = 0;  // valid after arrange
  /** @type {number} */
  this._position = 0;  // valid after arrange
  /** @type {List} */
  this._binds = null;
  /** @type {EnumValue} */
  this._sizing = RowColumnDefinition.Default;
  /** @type {EnumValue} */
  this._stretch = GraphObject.Default;

  /** @type {Margin} */
  this._separatorPadding = null;
  /** @type {string|Brush} */
  this._separatorStroke = null;
  /** @type {number} */
  this._separatorStrokeWidth = NaN;
  /** @type {Array.<number>|null} */
  this._separatorDashArray = null;

  /** @type {string|Brush} */
  this._background = null;
  /** @type {boolean} */
  this._coversSeparators = false;
}

Util.publish('RowColumnDefinition', RowColumnDefinition);

/**
* @ignore
* Create a copy of this RowColumnDefinition, with the same values.
* @this {RowColumnDefinition}
* @return {RowColumnDefinition}
*/
RowColumnDefinition.prototype.copy = function() {
  var copy = new RowColumnDefinition();
  // new Panel needs to set _panel
  copy._isRow = this._isRow;
  copy._index = this._index;
  copy._size = this._size;
  copy._minimum = this._minimum;
  copy._maximum = this._maximum;
  copy._alignment = this._alignment;
  copy._actual = this._actual;
  copy._position = this._position;
  copy._stretch = this._stretch;
  copy._sizing = this._sizing;
  if (this._separatorPadding === null) copy._separatorPadding = null;
  else copy._separatorPadding = this._separatorPadding.copyFrozen();

  copy._separatorStroke = this._separatorStroke; // OK to share, should be frozen
  copy._separatorStrokeWidth = this._separatorStrokeWidth;
  copy._separatorDashArray = null;
  if (this._separatorDashArray) copy._separatorDashArray = this._separatorDashArray.slice(0);
  copy._background = this._background; // OK to share, should be frozen
  copy._coversSeparators = this._coversSeparators; // OK to share, should be frozen
  copy._binds = this._binds;  // share any bindings
  return copy;
};

/**
* @ignore
* Modify this RowColumnDefinition by copying the settable properties from another RowColumnDefinition.
* This is only called by GraphObject.make.
* @this {RowColumnDefinition}
* @param {RowColumnDefinition} rcd The RowColumnDefinition whose properties should be copied into this one.
*/
RowColumnDefinition.prototype.copyFrom = function(rcd) {
  Util.checkClass(rcd, RowColumnDefinition, RowColumnDefinition, 'copyFrom:pd');
  // use setters to call raiseChanged!
  if (rcd.isRow) {
    this.height = rcd.height;
  } else {
    this.width = rcd.width;
  }
  this.minimum = rcd.minimum;
  this.maximum = rcd.maximum;
  this.alignment = rcd.alignment;
  this.sizing = rcd.sizing;
  this._separatorPadding = rcd._separatorPadding === null ? null : rcd._separatorPadding.copyFrozen();
  this.separatorStroke = rcd.separatorStroke; // OK to share, should be frozen
  this.separatorStrokeWidth = rcd.separatorStrokeWidth; // OK to share, should be frozen
  this._separatorDashArray = null;
  if (rcd._separatorDashArray) this._separatorDashArray = rcd._separatorDashArray.slice(0);
  this.background = rcd.background; // OK to share, should be frozen
  this.coversSeparators = rcd.coversSeparators;

  this._binds = rcd._binds;  // share any bindings
};

/**
* @ignore
* @this {RowColumnDefinition}
* @return {string}
*/
RowColumnDefinition.prototype.toString = function() {
  return 'RowColumnDefinition ' +
  (this.isRow ? '(Row ' : '(Column ') +
  this.index +
  ') #' + Util.hashId(this);
};

/**
* The default {@link #sizing}, which resolves to {@link RowColumnDefinition#None} or else
* the Table Panel's rowSizing and columnSizing if present.
* @name RowColumnDefinition#Default
* @constant
* @static
* @return {EnumValue}
*/
RowColumnDefinition['Default'] = RowColumnDefinition.Default = Util.defineEnumValue(RowColumnDefinition, 'Default', 0);

/**
* The default {@link #sizing} if none is specified on the Table Panel's rowSizing and columnSizing.
* @name RowColumnDefinition#None
* @constant
* @static
* @return {EnumValue}
*/
RowColumnDefinition['None'] = RowColumnDefinition.None = Util.defineEnumValue(RowColumnDefinition, 'None', 1);

/**
* If a Table Panel is larger than all the rows then this {@link #sizing}
* grants this row and any others with the same value the extra space, apportioned proportionally between them
* @name RowColumnDefinition#ProportionalExtra
* @constant
* @static
* @return {EnumValue}
*/
RowColumnDefinition['ProportionalExtra'] = RowColumnDefinition.ProportionalExtra = Util.defineEnumValue(RowColumnDefinition, 'ProportionalExtra', 2);


/**
* @ignore
* @this {RowColumnDefinition}
* @param {Panel} val
*/
RowColumnDefinition.prototype.setPanel = function(val) {
  this._panel = val;
};

/**
* @ignore
* @this {RowColumnDefinition}
* @param {boolean} val
*/
RowColumnDefinition.prototype.setIsRow = function(val) {
  this._isRow = val;
};

/**
* @ignore
* @this {RowColumnDefinition}
* @param {number} val
*/
RowColumnDefinition.prototype.setIndex = function(val) {
  this._index = val;
};

/**
* @ignore
* @this {RowColumnDefinition}
* @param {number} val
*/
RowColumnDefinition.prototype.setActual = function(val) {
  if (!isNaN(this._size))  // ignore any computed value if the width or height was specified
    this._actual = Math.max(Math.min(this._maximum, this._size), this._minimum);
  else
    this._actual = Math.max(Math.min(this._maximum, val), this._minimum);
};

/**
* @ignore
* @this {RowColumnDefinition}
* @param {number} val
*/
RowColumnDefinition.prototype.setTotal = function(val) {
  if (!isNaN(this._size))  // ignore any computed value if the width or height was specified
    this._actual = Math.max(Math.min(this._maximum, this._size), this._minimum);
  else
    this._actual = Math.max(Math.min(this._maximum, val), this._minimum);
  this._actual = Math.max(0, this._actual - this.getEffectiveSpacing());
};

/**
* @ignore
* @this {RowColumnDefinition}
* @param {number} val
*/
RowColumnDefinition.prototype.setPosition = function(val) {
  this._position = val;
};

/**
* @ignore
* Get the spacing at the top or left of the row/column
* @this {RowColumnDefinition}
*/
RowColumnDefinition.prototype.getEffectiveSpacingTop = function() {
  var panel = this._panel;
  var sk = this.separatorStroke;
  if (sk === null) sk = this.isRow ? panel._defaultRowSeparatorStroke : panel._defaultColumnSeparatorStroke;
  var sw = this.separatorStrokeWidth;
  if (isNaN(sw)) sw = this.isRow ? panel._defaultRowSeparatorStrokeWidth : panel._defaultColumnSeparatorStrokeWidth;
  sw = (sk !== null ? sw : 0);
  if (this.index === 0) sw = 0; // First rows/columns have no separator
  var t = this.separatorPadding;
  if (t === null) t = panel._defaultSeparatorPadding;
  return sw + (this.isRow ? t.top : t.left);
};

/**
* @ignore
* Get the total spacing for a row or column
* @this {RowColumnDefinition}
*/
RowColumnDefinition.prototype.getEffectiveSpacing = function() {
  var panel = this._panel;
  var sk = this.separatorStroke;
  if (sk === null) sk = this.isRow ? panel._defaultRowSeparatorStroke : panel._defaultColumnSeparatorStroke;
  var sw = this.separatorStrokeWidth;
  if (isNaN(sw)) sw = this.isRow ? panel._defaultRowSeparatorStrokeWidth : panel._defaultColumnSeparatorStrokeWidth;
  sw = (sk !== null ? sw : 0);
  if (this.index === 0) sw = 0; // First rows/columns have no separator
  var t = this.separatorPadding;
  if (t === null) t = panel._defaultSeparatorPadding;
  return sw + (this.isRow ? t.top + t.bottom : t.left + t.right);
};

/**
* @ignore
* @this {RowColumnDefinition}
* @param {string} pname names the property that was modified.
* @param {*} oldval the previous or older value.
* @param {*} newval the next or newer value.
* @param {*=} oldparam an optional value that helps describe the older value.
* @param {*=} newparam an optional value that helps describe the newer value.
*/
RowColumnDefinition.prototype._raiseChanged = function(pname, oldval, newval, oldparam, newparam) {
  var panel = this._panel;
  if (panel === null) return;
  panel.invalidateMeasure();
  // All of the child objects in this row or column must be remeasured
  var row = this.isRow;
  var itms = panel._elements;
  var l = itms.length;
  for (var i = 0; i < l; i++) {
    var obj = itms._arr[i];
    if ((row ? obj.row : obj.column) === this.index)
      obj.invalidateMeasure();
  }
  panel.raiseChangedEvent(ChangedEvent.Property, pname, this, oldval, newval, oldparam, newparam);
  if (this._binds !== null) {
    var binder = panel.findTemplateBinder();
    if (binder !== null) {
      var data = binder.data;
      if (data !== null) {
        var it = this._binds.iterator;
        while (it.next()) {
          var bind = it.value;
          bind.updateSource(this, data, pname, null);
          //??? no support for TwoWay Binding.ofObject(...)
        }
      }
    }
  }
};

/**
* Gets the {@link Panel} that this row or column definition is in.
* @name RowColumnDefinition#panel
* @function.
* @return {Panel}
*/
/** @type {Panel} */
RowColumnDefinition.prototype.panel;
Util.defineReadOnlyProperty(RowColumnDefinition, { panel: 'panel' },
  /** @this {RowColumnDefinition} */
  function() { return this._panel; }
);

/**
* Gets whether this describes a row or a column in the {@link #panel}.
* When this is true, the {@link #height}, {@link #minimum}, and {@link @maximum}
* all describe the row height.
* Otherwise {@link #width} and the other two properties describe the column width.
* @name RowColumnDefinition#isRow
* @function.
* @return {boolean}
*/
/** @type {boolean} */
RowColumnDefinition.prototype.isRow;
Util.defineReadOnlyProperty(RowColumnDefinition, { isRow: 'isRow' },
  /** @this {RowColumnDefinition} */
  function() { return this._isRow; }
);

/**
* Gets which row or column this RowColumnDefinition describes in the {@link #panel}.
* The value is a zero-based integer.
* @name RowColumnDefinition#index
* @function.
* @return {number}
* @see Panel#findColumnForLocalX
* @see Panel#findRowForLocalY
* @see Panel#leftIndex
* @see Panel#topIndex
* @see #position
*/
/** @type {number} */
RowColumnDefinition.prototype.index;
Util.defineReadOnlyProperty(RowColumnDefinition, { index: 'index' },
  /** @this {RowColumnDefinition} */
  function() { return this._index; }
);

/**
* Gets or sets the row height, in local coordinates.
* This describes the row height if {@link #isRow} is true;
* otherwise this property is meaningless.
* The value must be non-negative and finite.
* The default value is NaN, which means this row will get a height
* that is just big enough to hold all of the objects in the row.
* Setting this value to a number will mean that all of the objects
* of this {@link Panel} in this row will be allocated that
* amount of row height.
* Whether an object in the row is actually arranged to have that height
* depends on whether the {@link GraphObject#alignment} stretches vertically.
* @name RowColumnDefinition#height
* @function.
* @return {number} the row height, if {@link #isRow} is true.
* @see #width
* @see #minimum
* @see #maximum
* @see #sizing
*/
/** @type {number} */
RowColumnDefinition.prototype.height;
Util.exportProperty(RowColumnDefinition, 'height', RowColumnDefinition.prototype.height);
Util.defineProperty(RowColumnDefinition, { height: 'height' },
  /** @this {RowColumnDefinition} */
  function() { return this._size; },
  /** @this {RowColumnDefinition} */
  function(val) {
    var old = this._size;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'number', RowColumnDefinition, 'height');
      if (val < 0) Util.throwRangeError(val, '>= 0', RowColumnDefinition, 'height');
      this._size = val;
      this.setActual(this._actual);
      this._raiseChanged('size', old, val);
    }
  }
);

/**
* Gets or sets the column width, in local coordinates.
* The size describes the column width if {@link #isRow} is false;
* otherwise this property is meaningless.
* The value must be non-negative and finite.
* The default value is NaN, which means this column will get a width
* that is just big enough to hold all of the objects in the column.
* <p>
* Setting this value to a number will mean that all of the objects
* of this {@link Panel} in this column will be allocated that
* amount of column width.
* Whether an object in the column is actually arranged to have that width
* depends on whether the {@link GraphObject#alignment} stretches horizontally.
* @name RowColumnDefinition#width
* @function.
* @return {number} the column width, if {@link #isRow} is false.
* @see #height
* @see #minimum
* @see #maximum
* @see #sizing
*/
/** @type {number} */
RowColumnDefinition.prototype.width;
Util.exportProperty(RowColumnDefinition, 'width', RowColumnDefinition.prototype.width);
Util.defineProperty(RowColumnDefinition, { width: 'width' },
  /** @this {RowColumnDefinition} */
  function() { return this._size; },
  /** @this {RowColumnDefinition} */
  function(val) {
    var old = this._size;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'number', RowColumnDefinition, 'width');
      if (val < 0) Util.throwRangeError(val, '>= 0', RowColumnDefinition, 'width');
      this._size = val;
      this.setActual(this._actual);
      this._raiseChanged('size', old, val);
    }
  }
);

/**
* Gets or sets the minimum row height or column width, in local coordinates.
* The minimum describes the row height if {@link #isRow} is true;
* otherwise this describes the column width.
* The value must be non-negative and finite.
* The default value is zero.
* The arranged height of all objects in this row,
* or the arrange width of all objects in this column,
* will be no less than this value.
* @name RowColumnDefinition#minimum
* @function.
* @return {number}
* @see #width
* @see #height
* @see #maximum
* @see #sizing
*/
/** @type {number} */
RowColumnDefinition.prototype.minimum;
Util.exportProperty(RowColumnDefinition, 'minimum', RowColumnDefinition.prototype.minimum);
Util.defineProperty(RowColumnDefinition, { minimum: 'minimum' },
  /** @this {RowColumnDefinition} */
  function() { return this._minimum; },
  /** @this {RowColumnDefinition} */
  function(val) {
    var old = this._minimum;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'number', RowColumnDefinition, 'minimum');
      if (val < 0 || !isFinite(val)) Util.throwRangeError(val, '>= 0', RowColumnDefinition, 'minimum');
      this._minimum = val;
      this.setActual(this._actual);
      this._raiseChanged('minimum', old, val);
    }
  }
);

/**
* Gets or sets the maximum row height or column width, in local coordinates.
* The maximum describes the row height if {@link #isRow} is true;
* otherwise this describes the column width.
* The value must be non-negative.
* The default value is Infinity.
* The arranged height of all objects in this row,
* or the arrange width of all objects in this column,
* will be no greater than this value.
* @name RowColumnDefinition#maximum
* @function.
* @return {number}
* @see #width
* @see #height
* @see #minimum
* @see #sizing
*/
/** @type {number} */
RowColumnDefinition.prototype.maximum;
Util.exportProperty(RowColumnDefinition, 'maximum', RowColumnDefinition.prototype.maximum);
Util.defineProperty(RowColumnDefinition, { maximum: 'maximum' },
  /** @this {RowColumnDefinition} */
  function() { return this._maximum; },
  /** @this {RowColumnDefinition} */
  function(val) {
    var old = this._maximum;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'number', RowColumnDefinition, 'maximum');
      if (val < 0) Util.throwRangeError(val, '>= 0', RowColumnDefinition, 'maximum');
      this._maximum = val;
      this.setActual(this._actual);
      this._raiseChanged('maximum', old, val);
    }
  }
);

/**
* Gets or sets a default alignment for elements that are in this row or column.
* The value must be a {@link Spot}.
* The default value is {@link Spot#Default}, so that this RowColumnDefinition
* does not supply any alignment information for the row or column.
* <br/>
* When an element's {@link GraphObject#alignment} property is {@link Spot#Default},
* it gets the horizontal alignment from the element's column's {@link RowColumnDefinition}
* and the vertical alignment from the element's row's RowColumnDefinition.
* When that {@link RowColumnDefinition#alignment} property is also Default,
* it takes the value from the table panel's {@link Panel#defaultAlignment} property.
* @name RowColumnDefinition#alignment
* @function.
* @return {Spot}
* @see GraphObject#alignment
* @see Panel#defaultAlignment
*/
/** @type {Spot} */
RowColumnDefinition.prototype.alignment;
Util.exportProperty(RowColumnDefinition, 'alignment', RowColumnDefinition.prototype.alignment);
Util.defineProperty(RowColumnDefinition, { alignment: 'alignment' },
  /** @this {RowColumnDefinition} */
  function() { return this._alignment; },
  /** @this {RowColumnDefinition} */
  function(val) {
    var old = this._alignment;
    if (!old.equals(val)) {
      if (Debug) Util.checkClass(val, Spot, RowColumnDefinition, 'alignment');
      this._alignment = val.copyFrozen();
      this._raiseChanged('alignment', old, val);
    }
  }
);

/**
* Gets or sets the default stretch for elements that are in this row or column.
* The only accepted values are listed as constant properties of GraphObject:
* {@link GraphObject#None}, {@link GraphObject#Fill}, {@link GraphObject#Horizontal}, {@link GraphObject#Vertical}, or {@link GraphObject#Default}.
* <p/>
* When an element's {@link GraphObject#stretch} property is {@link GraphObject#Default},
* it gets the horizontal stretch from the element's column's {@link RowColumnDefinition}
* and the vertical stretch from the element's row's RowColumnDefinition.
* When that {@link RowColumnDefinition#stretch} property is also Default,
* it takes the value from the table panel's {@link Panel#defaultStretch} property.
* @name RowColumnDefinition#stretch
* @function.
* @return {EnumValue}
* @see GraphObject#stretch
* @see Panel#defaultStretch
* @see #sizing
* @see #width
* @see #height
*/
/** @type {EnumValue} */
RowColumnDefinition.prototype.stretch;
Util.exportProperty(RowColumnDefinition, 'stretch', RowColumnDefinition.prototype.stretch);
Util.defineProperty(RowColumnDefinition, { stretch: 'stretch' },
  /** @this {RowColumnDefinition} */
  function() { return this._stretch; },
  /** @this {RowColumnDefinition} */
  function(val) {
    var old = this._stretch;
    if (old !== val) {
      if (Debug) Util.checkEnumValue(val, GraphObject, RowColumnDefinition, 'stretch');
      this._stretch = val;
      this._raiseChanged('stretch', old, val);
    }
  }
);

/**
* Gets or sets the additional padding for a particular row or column, in local coordinates.
* Padding is applied on two sides - before and after a row or column's contents.
* The {@link #separatorStrokeWidth} comes before any padding.
* @name RowColumnDefinition#separatorPadding
* @function.
* @return {?Margin} the row or column spacing.
* @since 1.2
* @see Panel#defaultSeparatorPadding
* @see #separatorStroke
* @see #separatorStrokeWidth
* @see #separatorDashArray
* @see #background
*/
/** @type {?Margin} */
RowColumnDefinition.prototype.separatorPadding;
Util.exportProperty(RowColumnDefinition, 'separatorPadding', RowColumnDefinition.prototype.separatorPadding);
Util.defineProperty(RowColumnDefinition, { separatorPadding: 'separatorPadding' },
  /** @this {RowColumnDefinition} */
  function() { return this._separatorPadding; },
  /** @this {RowColumnDefinition} */
  function(val) {
    if (typeof val === 'number') {
      val = new Margin(val);
    } else if (val !== null) {
      if (Debug) Util.checkClass(val, Margin, RowColumnDefinition, 'separatorPadding');
    }
    var old = this._separatorPadding;
    if (val === null || old === null || !old.equals(val)) {
      if (val !== null) val = val.copyFrozen();
      this._separatorPadding = val;
      this._raiseChanged('separatorPadding', old, val);
    }
  }
);

/**
* Gets or sets the stroke (color) for a particular row or column,
* provided that row or column has a nonzero {@link RowColumnDefinition#separatorStrokeWidth}.
* @name RowColumnDefinition#separatorStroke
* @function.
* @return {string|Brush} the row or column separatorStroke.
* @since 1.2
* @see Panel#defaultColumnSeparatorStroke
* @see Panel#defaultRowSeparatorStroke
* @see #separatorPadding
* @see #separatorStrokeWidth
* @see #separatorDashArray
* @see #background
*/
/** @type {string|Brush} */
RowColumnDefinition.prototype.separatorStroke;
Util.exportProperty(RowColumnDefinition, 'separatorStroke', RowColumnDefinition.prototype.separatorStroke);
Util.defineProperty(RowColumnDefinition, { separatorStroke: 'separatorStroke' },
  /** @this {RowColumnDefinition} */
  function() { return this._separatorStroke; },
  /** @this {RowColumnDefinition} */
  function(val) {
    var old = this._separatorStroke;
    if (old !== val) {
      if (val === null || typeof val === 'string' || val instanceof Brush) {
        if (val instanceof Brush) val.freeze();
        this._separatorStroke = val;
        if (this.panel) this.panel.invalidateDraw();
        this._raiseChanged('separatorStroke', old, val);
      }
    }
  }
);

/**
* Gets or sets the stroke width for a particular row or column's separator, in local coordinates.
* @name RowColumnDefinition#separatorStrokeWidth
* @function.
* @return {number} the row or column separatorStrokeWidth.
* @since 1.2
* @see Panel#defaultColumnSeparatorStrokeWidth
* @see Panel#defaultRowSeparatorStrokeWidth
* @see #separatorPadding
* @see #separatorStroke
* @see #separatorDashArray
* @see #background
*/
/** @type {number} */
RowColumnDefinition.prototype.separatorStrokeWidth;
Util.exportProperty(RowColumnDefinition, 'separatorStrokeWidth', RowColumnDefinition.prototype.separatorStrokeWidth);
Util.defineProperty(RowColumnDefinition, { separatorStrokeWidth: 'separatorStrokeWidth' },
  /** @this {RowColumnDefinition} */
  function() { return this._separatorStrokeWidth; },
  /** @this {RowColumnDefinition} */
  function(val) {
    var old = this._separatorStrokeWidth;
    if (old !== val) {
      this._separatorStrokeWidth = val;
      if (this.panel) this.panel.invalidateDraw();
      this._raiseChanged('separatorStrokeWidth', old, val);
    }
  }
);

/**
* Gets or sets the dash array for dashing the spacing provided this
* row or column has a nonzero {@link RowColumnDefinition#separatorStrokeWidth} and non-null {@link RowColumnDefinition#separatorStroke}.
* An array of [5, 10] would create dashes of 5 pixels and spaces of 10 pixels.
* Default is null.
* @name RowColumnDefinition#separatorDashArray
* @function.
* @return {Array.<number>}
* @since 1.2
* @see Panel#defaultColumnSeparatorDashArray
* @see Panel#defaultRowSeparatorDashArray
* @see #separatorPadding
* @see #separatorStroke
* @see #separatorStrokeWidth
* @see #background
*/
/** @type {Array.<number>} */
RowColumnDefinition.prototype.separatorDashArray;
Util.exportProperty(RowColumnDefinition, 'separatorDashArray', RowColumnDefinition.prototype.separatorDashArray);
Util.defineProperty(RowColumnDefinition, { separatorDashArray: 'separatorDashArray' },
  /** @this {RowColumnDefinition} */
  function() { return this._separatorDashArray; },
  /** @this {RowColumnDefinition} */
  function(val) {
    var old = this._separatorDashArray;
    if (old !== val) {
      // make sure its an array of numbers?
      if (!(val instanceof Array)) Util.throwTypeError(val, 'Array', RowColumnDefinition, 'separatorDashArray:val');
      this._separatorDashArray = val;
      if (this.panel) this.panel.invalidateDraw();
      this._raiseChanged('separatorDashArray', old, val);
    }
  }
);

/**
* Gets or sets the background color for a particular row or column,
* which fills the entire span of the row or column, including any separatorPadding.
* @name RowColumnDefinition#background
* @function.
* @return {string|Brush} the row or column background.
* @since 1.2
* @see GraphObject#background
*/
/** @type {string|Brush} */
RowColumnDefinition.prototype.background;
Util.exportProperty(RowColumnDefinition, 'background', RowColumnDefinition.prototype.background);
Util.defineProperty(RowColumnDefinition, { background: 'background' },
  /** @this {RowColumnDefinition} */
  function() { return this._background; },
  /** @this {RowColumnDefinition} */
  function(val) {
    var old = this._background;
    if (old !== val) {
      if (val === null || typeof val === 'string' || val instanceof Brush) {
        if (val instanceof Brush) val.freeze();
        this._background = val;
        if (this.panel) this.panel.invalidateDraw();
        this._raiseChanged('background', old, val);
      }
    }
  }
);

/**
* Determines whether or not the {@link background}, if there is one, is in front of or behind the separators.
* Default is false.
* @name RowColumnDefinition#coversSeparators
* @function.
* @return {boolean}
* @since 1.2
*/
/** @type {boolean} */
RowColumnDefinition.prototype.coversSeparators;
Util.exportProperty(RowColumnDefinition, 'coversSeparators', RowColumnDefinition.prototype.coversSeparators);
Util.defineProperty(RowColumnDefinition, {coversSeparators: 'coversSeparators'},
  /** @this {RowColumnDefinition} */
  function() { return this._coversSeparators; },
  /** @this {RowColumnDefinition} */
  function(val) {
    var old = this._coversSeparators;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', RowColumnDefinition, 'coversSeparators');
      this._coversSeparators = val;
      this._raiseChanged('coversSeparators', old, val);
    }
  }
);

/**
* Gets or sets how this row or column deals with a Table Panel's extra space.
* The value must be one of: {@link RowColumnDefinition#None}, {@link RowColumnDefinition#ProportionalExtra},
* or {@link RowColumnDefinition#Default}.
* The default value is {@link RowColumnDefinition#Default}.
* @name RowColumnDefinition#sizing
* @function.
* @return {EnumValue}
* @see Panel#columnSizing
* @see Panel#rowSizing
* @see #actual
* @see #total
* @see #height
* @see #width
*/
/** @type {EnumValue} */
RowColumnDefinition.prototype.sizing;
Util.exportProperty(RowColumnDefinition, 'sizing', RowColumnDefinition.prototype.sizing);
Util.defineProperty(RowColumnDefinition, { sizing: 'sizing' },
  /** @this {RowColumnDefinition} */
  function() { return this._sizing; },
  /** @this {RowColumnDefinition} */
  function(val) {
    var old = this._sizing;
    if (old !== val) {
      if (Debug) Util.checkEnumValue(val, RowColumnDefinition, RowColumnDefinition, 'sizing');
      this._sizing = val;
      this._raiseChanged('sizing', old, val);
    }
  }
);

/**
* @ignore
* @this {RowColumnDefinition}
* @return {EnumValue}
*/
RowColumnDefinition.prototype.getEffectiveSizing = function() {
  if (this.sizing === RowColumnDefinition.Default) {
    var p = this._panel;
    if (this.isRow) return p.rowSizing;
    else return p.columnSizing;
  }
  return this.sizing;
};

/**
* Gets the usable row height or column width, after arrangement, in local coordinates,
* that objects in this row or column can be placed within.
* This does not include {@link #separatorPadding} or {@link #separatorStrokeWidth}, as {@link #total} does.
* <p>
* This value gives the row height if {@link #isRow} is true;
* otherwise this gives the column width.
* The value is meaningless until after the Table Panel using this
* RowColumnDefinition has been arranged.
* @name RowColumnDefinition#actual
* @function.
* @return {number}
* @see #total
* @see #height
* @see #width
* @see #sizing
*/
/** @type {number} */
RowColumnDefinition.prototype.actual;
Util.defineReadOnlyProperty(RowColumnDefinition, { actual: 'actual' },
  /** @this {RowColumnDefinition} */
  function() { return this._actual; }
);

/**
* Gets the total arranged row height or column width, after arrangement, in local coordinates.
* This value gives the {@link #actual} size plus the {@link #separatorPadding} and {@link #separatorStrokeWidth}.
* The value is meaningless until after the Table Panel using this
* RowColumnDefinition has been arranged.
* @name RowColumnDefinition#total
* @function.
* @return {number}
* @since 1.2
* @see #actual
* @see #height
* @see #width
* @see #sizing
*/
/** @type {number} */
RowColumnDefinition.prototype.total;
Util.defineReadOnlyProperty(RowColumnDefinition, { total: 'total' },
  /** @this {RowColumnDefinition} */
  function() { return this._actual + this.getEffectiveSpacing(); }
);

/**
* Gets the actual arranged row or column starting position, after arrangement, in local coordinates.
* This value gives the Y position if {@link #isRow} is true;
* otherwise this gives the X position.
* The value is meaningless until after the Table Panel using this
* RowColumnDefinition has been arranged.
* @name RowColumnDefinition#position
* @function.
* @return {number}
* @see Panel#findColumnForLocalX
* @see Panel#findRowForLocalY
* @see Panel#leftIndex
* @see Panel#topIndex
* @see #index
*/
/** @type {number} */
RowColumnDefinition.prototype.position;
Util.defineReadOnlyProperty(RowColumnDefinition, { position: 'position' },
  /** @this {RowColumnDefinition} */
  function() { return this._position; }
);

RowColumnDefinition.prototype['bind'] =
/**
* Add a data-binding of a property on this object to a property on a data object.
* @this {RowColumnDefinition}
* @param {Binding} binding
*/
RowColumnDefinition.prototype.bind = function(binding) {
  binding._targetObject = this;  // remember so that Panel.freezeBindings can generalize using name-lookup
  var panel = this.panel;
  if (panel !== null) {  // maybe in a visual tree already
    var binder = panel.findTemplateBinder();
    if (binder !== null && binder.isTemplateBinderFrozen()) {
      Util.throwError('Cannot add a Binding to a RowColumnDefinition that is already frozen: ' + binding);
    }
  }
  // just store here for later collection by freezeBindings
  if (this._binds === null) this._binds = new List(Binding);
  this._binds.add(binding);
};

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
Shape
*/

/**
* A newly constructed {@link Shape} has a default {@link #figure} of "None",
* which constructs a rectangular geometry, and is filled and stroked with a black brush.
* @constructor
* @extends GraphObject
* @this {Shape}
* @class
* A Shape is a {@link GraphObject} that shows a geometric figure.
* The {@link Geometry} determines what is drawn;
* the properties {@link #fill} and {@link #stroke}
* (and other stroke properties) determine how it is drawn.
* <p/>
* There are generally two types of shapes: Those that use a custom {@link Geometry} by setting
* {@link Shape#Geometry}, and those that receive an automatically generated Geometry using the value of
* {@link #figure}, {@link #toArrow}, or {@link #fromArrow}. An explicitly set Geometry always supersedes
* the figure and arrowhead properties.
* <p/>
* When automatically generating a Shape {@link Geometry}, the value of {@link #toArrow} takes precedence,
* then {@link #fromArrow}, then {@link #figure}. If the value of {@link #toArrow} or {@link #fromArrow} is none
* then it is ignored, and the "None" value of {@link #figure} is identical to "Rectangle".
* <p/>
* The Shape properties {@link #parameter1}, and {@link #parameter2} determine details of the
* construction of some {@link #figure} geometries.
* Specifically, they often set the {@link #spot1}, {@link #spot2} for the Shape.
* <p/>
* Shapes use their geometric bounds when determining hit testing,
* but use rectangular bounds when participating in (panel) layouts.
*/
function Shape() {
  GraphObject.call(this);
  /** @type {Geometry} */
  this._geometry = null;
  /** @type {string} */
  this._figure = 'None';
  /** @type {boolean} */
  this._setGeometry = false;

  /** @type {EnumValue} */
  this._geometryStretch = GraphObject.Default;
  /** @type {Geometry} */
  this._constructedGeometry = null;

  /** @type {string|Brush} */
  this._fill = 'black';
  /** @type {string|Brush} */
  this._stroke = 'black'; // color string any well-formed CSS color
  /** @type {number} */
  this._strokeWidth = 1.0;  // float > 0
  /** @type {string} */
  this._strokeCap = 'butt';  //string 'butt' 'round' 'square'
  /** @type {string} */
  this._strokeJoin = 'miter';  //string 'miter' 'bevel' 'round'
  /** @type {number} */
  this._strokeMiterLimit = 10;  // float > 0
  /** @type {Array.<number>|null} */
  this._strokeDashArray = null;
  /** @type {number} */
  this._strokeDashOffset = 0;

  /** @type {Spot} */
  this._spot1 = Spot.Default;
  /** @type {Spot} */
  this._spot2 = Spot.Default;
  /** @type {number} */
  this._parameter1 = 0;
  /** @type {number} */
  this._parameter2 = 0;
  /** @type {boolean} */
  this._isGeometryPositioned = false;

  /** @type {boolean} */
  this._isRectangular = true;

  /** @type {GraphObject} */
  this._pathObject = null;

  // For links
  /** @type {string} */
  this._toArrow = 'None';
  /** @type {string} */
  this._fromArrow = 'None';

  // for Grid Panel:
  /** @type {number} */
  this._interval = 1;
}

Util.publish('Shape', Shape);

Util.inherit(Shape, GraphObject);

/**
* @ignore
* Copies properties to a cloned Shape.
* @this {Shape}
* @param {GraphObject} copy
*/
Shape.prototype.cloneProtected = function(copy) {
  GraphObject.prototype.cloneProtected.call(this, copy);
  copy._geometry = this._geometry;  //??? shared
  copy._figure = this._figure;
  copy._setGeometry = this._setGeometry;

  copy._geometryStretch = this._geometryStretch;
  copy._constructedGeometry = this._constructedGeometry;  //??? shared

  copy._fill = this._fill;  // OK to share: should be frozen
  copy._stroke = this._stroke;  // OK to share: should be frozen
  copy._strokeWidth = this._strokeWidth;
  copy._strokeCap = this._strokeCap;
  copy._strokeJoin = this._strokeJoin;
  copy._strokeMiterLimit = this._strokeMiterLimit;
  copy._strokeDashArray = null;
  if (this._strokeDashArray) copy._strokeDashArray = this._strokeDashArray.slice(0);
  copy._strokeDashOffset = this._strokeDashOffset;

  copy._spot1 = this._spot1.copyFrozen();
  copy._spot2 = this._spot2.copyFrozen();
  copy._parameter1 = this._parameter1;
  copy._parameter2 = this._parameter2;
  copy._isGeometryPositioned = this._isGeometryPositioned;

  copy._isRectangular = this._isRectangular;
  copy._pathObject = this._pathObject;

  copy._toArrow = this._toArrow;
  copy._fromArrow = this._fromArrow;

  copy._interval = this._interval;
};

/**
* @ignore
* @this {Shape}
* @return {string}
*/
Shape.prototype.toString = function() {
  return 'Shape(' + (this.figure !== 'None' ? this.figure : (this.toArrow !== 'None' ? this.toArrow : this.fromArrow)) + ')#' + Util.hashId(this);
};

/**
* @ignore
* Draws a GraphObject along the path
* @this {Shape}
* @param {CanvasRenderingContext2D} context A Canvas 2D Context for drawing.
* @param {Diagram} diagram
*/
Shape.prototype.drawGraphObject = function(context, diagram) {
  var s = this.pathObject;
  s.measure(Infinity, Infinity);
  var mb = s.measuredBounds;
  s.arrange(0, 0, mb.width, mb.height);

  context.save();

  // For now just deal with the first figure @@@
  var fig = this.geometry.figures.first();

  context.beginPath();
  var allpaths = Util.tempArray();
  allpaths.push([fig.startX, fig.startY]);
  // lastPoint only needed for drawing dash approximations
  var lastpointX = fig.startX;
  var lastpointY = fig.startY;
  var lastSubX = lastpointX;
  var lastSubY = lastpointY;

  // for each segment of the PathFigure:
  var segments = fig.segments._arr;
  var sl = segments.length;
  for (var j = 0; j < sl; j++) {
    var seg = segments[j];
    switch (seg._type) {
      case PathSegment.Move:
        this.drawAlong(context, diagram, allpaths, s);
        allpaths.length = 0;  // restart
        allpaths.push([seg.endX, seg.endY]);

        lastpointX = seg.endX;
        lastpointY = seg.endY;
        lastSubX = lastpointX;
        lastSubY = lastpointY;
        break;
      case PathSegment.Line:
        allpaths.push([seg.endX, seg.endY]);
        lastpointX = seg.endX;
        lastpointY = seg.endY;
        break;
      case PathSegment.Bezier:
        Geo.bezierLines(lastpointX, lastpointY,
                        seg._point1X, seg._point1Y,
                        seg._point2X, seg._point2Y,
                        seg._pointX, seg._pointY,
                        0.5, allpaths);
        lastpointX = seg.endX;
        lastpointY = seg.endY;
        break;
      case PathSegment.QuadraticBezier:
        Geo.quadraticBezierLines(lastpointX, lastpointY,
                                seg._point1X, seg._point1Y,
                                seg._pointX, seg._pointY,
                                0.5, allpaths);
        lastpointX = seg.endX;
        lastpointY = seg.endY;
        break;
      case PathSegment.Arc:
        var curves = seg.buildBeziers(fig);
        var cl = curves.length;
        for (var cli = 0; cli < cl; cli++) {
          var cu = curves[cli];
          Geo.bezierLines(lastpointX, lastpointY,
                          cu.x2, cu.y2,
                          cu.x3, cu.y3,
                          cu.x4, cu.y4,
                          0.5, allpaths);
          lastpointX = cu.x4;
          lastpointY = cu.y4;
        }
        break;
      case PathSegment.SvgArc:
        var curves = seg.buildSVGBeziers(fig, lastpointX, lastpointY);
        var cl = curves.length;
        for (var cli = 0; cli < cl; cli++) {
          var cu = curves[cli];
          Geo.bezierLines(lastpointX, lastpointY,
                          cu.x2, cu.y2,
                          cu.x3, cu.y3,
                          cu.x4, cu.y4,
                          0.5, allpaths);
          lastpointX = cu.x4;
          lastpointY = cu.y4;
        }
        break;
      default:
        Util.throwError('Segment not of valid type');
    }
    if (seg._isClosed) {
      allpaths.push([lastSubX, lastSubY]);
      this.drawAlong(context, diagram, allpaths, s);
    }
  } // end segment iteration
  this.drawAlong(context, diagram, allpaths, s);
  Util.freeArray(allpaths);
  context.restore();
};

// This is a special implementation of drawDash used for drawing dashed curves
// It is slower, but it takes an array of points instead of a single point and
// faithfully dashes along the given chain of points,
// carrying over dash remainders properly from one segment to the next.
/**
* @ignore
* @this {Shape}
* @param {CanvasRenderingContext2D} context
* @param {Diagram} diagram
* @param {Array} arr
* @param {GraphObject} obj
*/
Shape.prototype.drawAlong = function(context, diagram, arr, obj) {
  var dashLength = 0.001;
  var dashCount = 2;

  var mb = obj.measuredBounds;
  var objWidth = mb.width;
  var objHeight = mb.height;

  var x, y, x2, y2;
  var len = arr.length;
  if (len < 2) return;
  x = arr[0][0];
  y = arr[0][1];


  // if the distance isn't enough, we must take an additional segment
  var segmentsTaken = 1;

  var dx, dy, slope, dist, angle, distRemaining;
  var distRemainingTotal = 0;
  var segData = Util.tempArray(); // an array of every line segment's dx, slope and distance [dx, slope, dist]
  for (var i = 1; i < len; i++) {
    var p = arr[i];
    x2 = p[0];
    y2 = p[1];
    dx = (x2 - x), dy = (y2 - y);
    if (dx === 0) dx = 0.001;
    slope = dy / dx;
    angle = Math.atan2(dy, dx);
    distRemaining = Math.sqrt(dx * dx + dy * dy);
    //distRemaining = Geo.sqrt((dx*dx + dy*dy)*100)/10;
    segData.push([dx, angle, slope, distRemaining]);
    distRemainingTotal += distRemaining;
    // for the next iteration:
    x = x2;
    y = y2;
  }

  // reset x/y to starting point values:
  x = arr[0][0];
  y = arr[0][1];

  var dashIndex = 0;
  dashLength = objWidth;//strokeDashArray[dashIndex % dashCount];

  // using midpoints, so we want to start in the middle of an object, ??? in the future also add user offset
  var offset = objWidth / 2;
  var first = (offset === 0) ? false : true; // first line is different if there is an offset

  var currSegNum = 0;
  // when currSeg changes the others must change with it to be consistent
  var currSeg = segData[currSegNum];
  dx = currSeg[0];
  angle = currSeg[1];
  slope = currSeg[2];
  dist = currSeg[3]; // Distance in the segment, also used as distance remaining in the segment

  // *********** Draw the rest

  // We dash a single segment for as long as possible until its distance runs out
  // then we create a "remainder" that is added to the start of the next segment before resuming dashing
  var remainder = 0; // amount of dash to add to next segment
  while (distRemainingTotal >= 0.1) {
    // If there's a remainder we don't increment the dash index and make a new dash length
    // the remainder is our last dash length and we must finish drawing that dash first
    if (remainder === 0) {
      if (first) {
        dashLength = objWidth;//strokeDashArray[dashIndex % dashCount];
        dashIndex++; // explicitly incremented!
        //offset = offset % dashLength;
        dashLength -= offset;
        distRemainingTotal -= offset;
        first = false;
      } else {
        dashLength = objWidth;//strokeDashArray[dashIndex % dashCount];
        dashIndex++; // explicitly incremented!
      }
      if (dashLength === 0) dashLength = 1;
    }

    // applicible to last dash in entire set:
    if (dashLength > distRemainingTotal) {
      dashLength = distRemainingTotal;
      Util.freeArray(segData);
      return; // we are done, we never draw the last pathObject in the set
    }
    // applicible to last dash in segment (must save remainder)
    if (dashLength > dist) {
      remainder = dashLength - dist;
      dashLength = dist;
    } else {
      remainder = 0;
    }

    var xStep = Math.sqrt(dashLength * dashLength / (1 + slope * slope));
    //var xStep = Geo.sqrt((dashLength*dashLength / (1 + slope*slope))*100)/10;
    if (dx < 0) xStep = -xStep;
    x += xStep;
    y += slope * xStep;

    //if (draw) context.lineTo(x, y);
    //else context.moveTo(x, y);

    //save:
    context.translate(x, y);
    context.rotate(angle);
    context.translate(-(objWidth / 2), -(objHeight / 2));

    if (remainder === 0) obj.drawProtected(context, diagram);

    //debug:
    //this.setBrush(context, 'blue', true);
    //context.fillRect((objWidth / 2)-2, (objHeight / 2)-2, 4, 4);

    //restore:
    context.translate((objWidth / 2), (objHeight / 2));
    context.rotate(-angle);
    context.translate(-x, -y);

    distRemainingTotal -= dashLength;
    dist -= dashLength;

    if (remainder !== 0) {
      // increment segment if possible
      currSegNum++;
      if (currSegNum === segData.length) { Util.freeArray(segData); return; }
      currSeg = segData[currSegNum];

      dx = currSeg[0];
      angle = currSeg[1];
      slope = currSeg[2];
      dist = currSeg[3]; // Also used as distance remaining
      dashLength = remainder;
    }
  }
  Util.freeArray(segData);
};


/**
* @ignore
* Draw the shape to a specified context.
* @this {Shape}
* @param {CanvasRenderingContext2D} context A Canvas 2D Context for drawing.
* @param {Diagram} diagram
*/
Shape.prototype.drawProtected = function(context, diagram) {
  if (this._stroke === null && this._fill === null) return;
  if (this._fill !== null) this.setBrush(context, this._fill, true);
  if (this._stroke !== null) this.setBrush(context, this._stroke, false);

  var logicalSW = this._strokeWidth;
  if (logicalSW === 0) {
    var part = this.part;
    if (part instanceof Adornment && part.type === Panel.Link && part.adornedObject instanceof Shape)
      logicalSW = part.adornedObject.strokeWidth;
  }

  context.lineWidth = logicalSW;
  context.lineJoin = this._strokeJoin;
  context.lineCap = this._strokeCap;
  context.miterLimit = this._strokeMiterLimit;
  var isShadowed = false;
  if (this.part) isShadowed = this.part.isShadowed;
  var hidestrokeshadow = true;
  // If the stroke exists and the fill does not, don't hide the stroke's shadow
  if (this._stroke !== null && this._fill === null) hidestrokeshadow = false;

  var dash = false;
  var strokeDashArray = this.strokeDashArray;
  if (strokeDashArray !== null) {
    dash = true;
    var nativeDash = true;
    if (context['setLineDash'] !== undefined) {
      context['setLineDash'](strokeDashArray);
      context['lineDashOffset'] = this._strokeDashOffset;
    } else if (context['webkitLineDash'] !== undefined) {
      context['webkitLineDash'] = strokeDashArray;
      context['webkitLineDashOffset'] = this._strokeDashOffset;
    } else if (context['mozDash'] !== undefined) {
      context['mozDash'] = strokeDashArray;
      context['mozDashOffset'] = this._strokeDashOffset;
    } else {
      // no native support!
      nativeDash = false;
    }
  }

  var g = this._geometry;
  if (g === null) return;
  if (g._type === Geometry.Line) {
    context.beginPath();
    if (dash && !nativeDash) {
      GraphObject.drawDash(context, g._startX, g._startY, g._endX, g._endY, strokeDashArray, this._strokeDashOffset);
    } else {
      context.moveTo(g._startX, g._startY);
      context.lineTo(g._endX, g._endY);
    }
    if (this._fill !== null) context.fill();
    if (this._stroke !== null) {
      context.stroke();
    }
  } else if (g._type === Geometry.Rectangle) {
    var x1 = g._startX;
    var y1 = g._startY;
    var x2 = g._endX;
    var y2 = g._endY;
    var x = Math.min(x1, x2);
    var y = Math.min(y1, y2);
    var w = Math.abs(x2 - x1);
    var h = Math.abs(y2 - y1);
    if (this._fill !== null) context.fillRect(x, y, w, h);
    if (this._stroke !== null) {
      if (hidestrokeshadow && isShadowed) {
        var ss = [context.shadowOffsetX, context.shadowOffsetY, context.shadowBlur];
        context.shadowOffsetX = 0;
        context.shadowOffsetY = 0;
        context.shadowBlur = 0;
      }
      if (dash && !nativeDash) {
        var arr = [[x, y], [x + w, y], [x + w, y + h], [x, y + h], [x, y]];
        context.beginPath();
        this.drawDash2(context, arr, strokeDashArray, this._strokeDashOffset);
        context.stroke();
      } else {
        context.strokeRect(x, y, w, h);
      }
      if (hidestrokeshadow && isShadowed) {
        context.shadowOffsetX = ss[0];
        context.shadowOffsetY = ss[1];
        context.shadowBlur = ss[2];
      }
    }
  } else if (g._type === Geometry.Ellipse) {
    var x1 = g._startX;
    var y1 = g._startY;
    var x2 = g._endX;
    var y2 = g._endY;
    var rx = Math.abs(x2 - x1) / 2;
    var ry = Math.abs(y2 - y1) / 2;
    var cx = Math.min(x1, x2) + rx;
    var cy = Math.min(y1, y2) + ry;
    context.beginPath();
    context.moveTo(cx, cy - ry);
    context.bezierCurveTo(cx + (Geo.KAPPA * rx), cy - ry, cx + rx, cy - (Geo.KAPPA * ry), cx + rx, cy);
    context.bezierCurveTo(cx + rx, cy + (Geo.KAPPA * ry), cx + (Geo.KAPPA * rx), cy + ry, cx, cy + ry);
    context.bezierCurveTo(cx - (Geo.KAPPA * rx), cy + ry, cx - rx, cy + (Geo.KAPPA * ry), cx - rx, cy);
    context.bezierCurveTo(cx - rx, cy - (Geo.KAPPA * ry), cx - (Geo.KAPPA * rx), cy - ry, cx, cy - ry);
    context.closePath();

    if (this._fill !== null) context.fill();

    if (dash && !nativeDash) {
      var arr = Util.tempArray();
      Geo.bezierLines(cx, cy - ry, cx + (Geo.KAPPA * rx), cy - ry, cx + rx, cy - (Geo.KAPPA * ry), cx + rx, cy, 0.5, arr);
      Geo.bezierLines(cx + rx, cy, cx + rx, cy + (Geo.KAPPA * ry), cx + (Geo.KAPPA * rx), cy + ry, cx, cy + ry, 0.5, arr);
      Geo.bezierLines(cx, cy + ry, cx - (Geo.KAPPA * rx), cy + ry, cx - rx, cy + (Geo.KAPPA * ry), cx - rx, cy, 0.5, arr);
      Geo.bezierLines(cx - rx, cy, cx - rx, cy - (Geo.KAPPA * ry), cx - (Geo.KAPPA * rx), cy - ry, cx, cy - ry, 0.5, arr);
      context.beginPath();
      this.drawDash2(context, arr, strokeDashArray, this._strokeDashOffset);
      Util.freeArray(arr);
    }

    if (this._stroke !== null) {
      if (hidestrokeshadow && isShadowed) {
        var ss = [context.shadowOffsetX, context.shadowOffsetY, context.shadowBlur];
        context.shadowOffsetX = 0;
        context.shadowOffsetY = 0;
        context.shadowBlur = 0;
      }
      context.stroke();
      if (hidestrokeshadow && isShadowed) {
        context.shadowOffsetX = ss[0];
        context.shadowOffsetY = ss[1];
        context.shadowBlur = ss[2];
      }
    }
  } else if (g._type === Geometry.Path) {
    var firstFigInSubPath = null;
    var figs = g._figures;
    // for each PathFigure:
    var l = figs.length;
    for (var i = 0; i < l; i++) {
      var fig = figs._arr[i];
      context.beginPath();
      context.moveTo(fig.startX, fig.startY);
      // for each segment of the PathFigure:
      var segments = fig.segments._arr;
      var sl = segments.length;
      var lastSeg = null;
      for (var j = 0; j < sl; j++) {
        var seg = segments[j];
        switch (seg._type) {
          case PathSegment.Move:
            context.moveTo(seg.endX, seg.endY);
            break;
          case PathSegment.Line:
            context.lineTo(seg.endX, seg.endY);
            break;
          case PathSegment.Bezier:
            context.bezierCurveTo(seg._point1X, seg._point1Y,
                                seg._point2X, seg._point2Y,
                                seg._pointX, seg._pointY);
            break;
          case PathSegment.QuadraticBezier:
            context.quadraticCurveTo(seg._point1X, seg._point1Y,
                                   seg._pointX, seg._pointY);
            break;
          case PathSegment.Arc:
            if (seg.radiusX === seg.radiusY) {
              var pi180 = Math.PI / 180;
              context.arc(
                seg._centerX,
                seg._centerY,
                seg.radiusX, // x and y are the same
                seg.startAngle * pi180,
                (seg.startAngle + seg.sweepAngle) * pi180,
                (seg.sweepAngle < 0));
            } else {
              var curves = seg.buildBeziers(fig);
              var cl = curves.length;
              for (var cli = 0; cli < cl; cli++) {
                var cu = curves[cli];
                if (cli === 0) context.lineTo(cu.x1, cu.y1);
                context.bezierCurveTo(cu.x2, cu.y2,
                                      cu.x3, cu.y3,
                                      cu.x4, cu.y4);
              }
            }
            break;
          case PathSegment.SvgArc:
            var lx, ly;
            if (lastSeg && lastSeg.type === PathSegment.Arc) {
              var curves = lastSeg.buildBeziers(fig);
              var clen = curves.length;
              var c = curves[clen - 1] || null;
              if (c !== null) {
                lx = c.x4;
                ly = c.y4;
              }
            } else {
              lx = lastSeg ? lastSeg.endX : fig.startX;
              ly = lastSeg ? lastSeg.endY : fig.startY;
            }
            var curves = seg.buildSVGBeziers(fig, lx, ly);
            var cl = curves.length;
            for (var cli = 0; cli < cl; cli++) {
              var cu = curves[cli];
              context.bezierCurveTo(cu.x2, cu.y2,
                                    cu.x3, cu.y3,
                                    cu.x4, cu.y4);
            }
            break;
          default:
            Util.throwError('Segment not of valid type');
        }
        if (seg._isClosed) context.closePath();
        lastSeg = seg;
      } // end segment iteration
      // Time to stroke+fill the PathFigure
      // ??? needs cleanup at some point
      if (isShadowed) {
        if (fig._isShadowed) {
          if (fig._isFilled === true && this._fill !== null) {
            context.fill();
            hidestrokeshadow = true;
          } else {
            hidestrokeshadow = false;
          }
          if (this._stroke !== null) {
            if (hidestrokeshadow) {
              var ss = [context.shadowOffsetX, context.shadowOffsetY, context.shadowBlur];
              context.shadowOffsetX = 0; context.shadowOffsetY = 0; context.shadowBlur = 0;
            }
            if (!(dash && !nativeDash)) context.stroke();

            if (hidestrokeshadow) {
              context.shadowOffsetX = ss[0]; context.shadowOffsetY = ss[1]; context.shadowBlur = ss[2];
            }
          }
        } else { // no shadow on the PathFigure
          if (hidestrokeshadow) {
            var ss = [context.shadowOffsetX, context.shadowOffsetY, context.shadowBlur];
            context.shadowOffsetX = 0; context.shadowOffsetY = 0; context.shadowBlur = 0;
          }
          if (fig._isFilled === true && this._fill !== null) context.fill();
          if (this._stroke !== null) {
            if (!(dash && !nativeDash)) context.stroke();
          }

          if (hidestrokeshadow) {
            context.shadowOffsetX = ss[0]; context.shadowOffsetY = ss[1]; context.shadowBlur = ss[2];
          }
        }
      } else {
        if (fig._isFilled === true && this._fill !== null) context.fill();
        if (this._stroke !== null) {
          if (!(dash && !nativeDash)) context.stroke();
        }
      }
    } // end path figures
    if (dash && !nativeDash)
      this.strokeNonNativeDashPath(context, g, strokeDashArray, hidestrokeshadow, isShadowed);
  } // end geometry type switch

  // Set dash back when done
  if (dash) {
    if (context['setLineDash'] !== undefined) {
      context['setLineDash'](Util.EmptyArray);
      context['lineDashOffset'] = 0;
    } else if (context['webkitLineDash'] !== undefined) {
      context['webkitLineDash'] = Util.EmptyArray;
      context['webkitLineDashOffset'] = 0;
    } else if (context['mozDash'] !== undefined) {
      context['mozDash'] = null;
      context['mozDashOffset'] = 0;
    } else {
      // no native support!
    }
  }

  if (this.pathObject) this.drawGraphObject(context, diagram);
}; // end draw

/**
* @ignore
* @this {Shape}
* @param {CanvasRenderingContext2D} context
* @param {Geometry} g
* @param {Array.<number>} strokeDashArray
* @param {boolean} hidestrokeshadow
* @param {boolean} isShadowed
*/
Shape.prototype.strokeNonNativeDashPath = function(context, g, strokeDashArray, hidestrokeshadow, isShadowed) {
  var firstFigInSubPath = null;
  var figs = g._figures;
  // for each PathFigure:
  var l = figs.length;
  for (var i = 0; i < l; i++) {
    var fig = figs._arr[i];
    context.beginPath();
    var allpaths = Util.tempArray();
    allpaths.push([fig.startX, fig.startY]);
    // lastPoint only needed for drawing dash approximations
    var lastpointX = fig.startX;
    var lastpointY = fig.startY;
    var lastSubX = lastpointX;
    var lastSubY = lastpointY;

    // for each segment of the PathFigure:
    var segments = fig.segments._arr;
    var sl = segments.length;
    for (var j = 0; j < sl; j++) {
      var seg = segments[j];
      switch (seg._type) {
        case PathSegment.Move:
          this.drawDash2(context, allpaths, strokeDashArray, this._strokeDashOffset);
          allpaths.length = 0;  // restart
          allpaths.push([seg.endX, seg.endY]);

          lastpointX = seg.endX;
          lastpointY = seg.endY;
          lastSubX = lastpointX;
          lastSubY = lastpointY;
          break;
        case PathSegment.Line:
          allpaths.push([seg.endX, seg.endY]);
          lastpointX = seg.endX;
          lastpointY = seg.endY;
          break;
        case PathSegment.Bezier:
          Geo.bezierLines(lastpointX, lastpointY,
                          seg._point1X, seg._point1Y,
                          seg._point2X, seg._point2Y,
                          seg._pointX, seg._pointY,
                          0.5, allpaths);
          lastpointX = seg.endX;
          lastpointY = seg.endY;
          break;
        case PathSegment.QuadraticBezier:
          Geo.quadraticBezierLines(lastpointX, lastpointY,
                                  seg._point1X, seg._point1Y,
                                  seg._pointX, seg._pointY,
                                  0.5, allpaths);
          lastpointX = seg.endX;
          lastpointY = seg.endY;
          break;
        case PathSegment.Arc:
          var curves = seg.buildBeziers(fig);
          var cl = curves.length;
          for (var cli = 0; cli < cl; cli++) {
            var cu = curves[cli];
            Geo.bezierLines(lastpointX, lastpointY,
                            cu.x2, cu.y2,
                            cu.x3, cu.y3,
                            cu.x4, cu.y4,
                            0.5, allpaths);
            lastpointX = cu.x4;
            lastpointY = cu.y4;
          }
          break;
        case PathSegment.SvgArc:
          var curves = seg.buildSVGBeziers(fig, lastpointX, lastpointY);
          var cl = curves.length;
          for (var cli = 0; cli < cl; cli++) {
            var cu = curves[cli];
            Geo.bezierLines(lastpointX, lastpointY,
                            cu.x2, cu.y2,
                            cu.x3, cu.y3,
                            cu.x4, cu.y4,
                            0.5, allpaths);
            lastpointX = cu.x4;
            lastpointY = cu.y4;
          }
          break;
        default:
          Util.throwError('Segment not of valid type');
      }
      if (seg._isClosed) {
        allpaths.push([lastSubX, lastSubY]);
        this.drawDash2(context, allpaths, strokeDashArray, this._strokeDashOffset);
      }
    } // end segment iteration
    this.drawDash2(context, allpaths, strokeDashArray, this._strokeDashOffset);
    Util.freeArray(allpaths);
    if (this._stroke !== null) {
      if (hidestrokeshadow && isShadowed) {
        var ss = [context.shadowOffsetX, context.shadowOffsetY, context.shadowBlur];
        context.shadowOffsetX = 0;
        context.shadowOffsetY = 0;
        context.shadowBlur = 0;
      }
      context.stroke();
      if (hidestrokeshadow && isShadowed) {
        context.shadowOffsetX = ss[0];
        context.shadowOffsetY = ss[1];
        context.shadowBlur = ss[2];
      }
    }
  } // end path figures
};

// This is a special implementation of drawDash used for drawing dashed curves
// It is slower, but it takes an array of points instead of a single point and
// faithfully dashes along the given chain of points,
// carrying over dash remainders properly from one segment to the next.
/**
* @ignore
* @this {Shape}
* @param {CanvasRenderingContext2D} context
* @param {Array} arr an array of x/y arrays [ [x, y],[x, y],[x, y] ].
* @param {Array.<number>} strokeDashArray
* @param {number} offset
*/
Shape.prototype.drawDash2 = function(context, arr, strokeDashArray, offset) {
  var dashLength = 0.001;
  var dashCount = strokeDashArray.length;
  // ??? if dashCount odd, double the array?

  var x, y, x2, y2;
  var len = arr.length;
  if (len < 2) return;
  x = arr[0][0];
  y = arr[0][1];
  if (len === 2) {
    GraphObject.drawDash(context, x, y, arr[1][0], arr[1][1], strokeDashArray, offset);
    return;
  }

  context.moveTo(x, y);

  // if the distance isn't enough, we must take an additional segment
  var segmentsTaken = 1;

  var dx, dy, slope, dist, distRemaining;
  var distRemainingTotal = 0;
  var segData = Util.tempArray(); // an array of every line segment's dx, slope and distance [dx, slope, dist]
  for (var i = 1; i < len; i++) {
    var p = arr[i];
    x2 = p[0];
    y2 = p[1];
    dx = (x2 - x), dy = (y2 - y);
    if (dx === 0) dx = 0.001;
    slope = dy / dx;
    distRemaining = Math.sqrt(dx * dx + dy * dy);
    //distRemaining = Geo.sqrt((dx*dx + dy*dy)*100)/10;
    segData.push([dx, slope, distRemaining]);
    distRemainingTotal += distRemaining;
    // for the next iteration:
    x = x2;
    y = y2;
  }

  // reset x/y to starting point values:
  x = arr[0][0];
  y = arr[0][1];

  var dashIndex = 0;
  var draw = true;
  dashLength = strokeDashArray[dashIndex % dashCount];
  var first = (offset !== 0); // first line is different if there is an offset

  var currSegNum = 0;
  // when currSeg changes the others must change with it to be consistent
  var currSeg = segData[currSegNum];
  dx = currSeg[0];
  slope = currSeg[1];
  dist = currSeg[2]; // Distance in the segment, also used as distance remaining in the segment

  // We dash a single segment for as long as possible until its distance runs out
  // then we create a "remainder" that is added to the start of the next segment before resuming dashing
  var remainder = 0; // amount of dash to add to next segment
  while (distRemainingTotal >= 0.1) {
    // If there's a remainder we don't increment the dash index and make a new dash length
    // the remainder is our last dash length and we must finish drawing that dash first
    if (remainder === 0) {
      dashLength = strokeDashArray[dashIndex % dashCount];
      dashIndex++; // explicitly incremented!
      if (first) {
        offset = offset % dashLength;
        dashLength -= offset;
        first = false;
      }
    }

    // applicible to last dash in entire set:
    if (dashLength > distRemainingTotal) dashLength = distRemainingTotal;
    // applicable to last dash in segment (must save remainder)
    if (dashLength > dist) {
      remainder = dashLength - dist;
      dashLength = dist;
    } else {
      remainder = 0;
    }

    var xStep = Math.sqrt(dashLength * dashLength / (1 + slope * slope));
    //var xStep = Geo.sqrt((dashLength*dashLength / (1 + slope*slope))*100)/10;
    if (dx < 0) xStep = -xStep;
    x += xStep;
    y += slope * xStep;

    if (draw) context.lineTo(x, y);
    else context.moveTo(x, y);

    distRemainingTotal -= dashLength;
    dist -= dashLength;

    if (remainder !== 0) {
      // increment segment if possible
      currSegNum++;
      if (currSegNum === segData.length) { Util.freeArray(segData); return; }
      currSeg = segData[currSegNum];
      dx = currSeg[0];
      slope = currSeg[1];
      dist = currSeg[2]; // Also used as distance remaining
      dashLength = remainder;
    } else {
      draw = !draw; // we only alternate if we were not drawing a remainder
    }
  }
  Util.freeArray(segData);
};


Shape.prototype['getDocumentPoint'] =
/**
* @ignore
* Returns the Point for a given Spot in document coordinates.
* This override takes the {@link #strokeWidth} into account.
* @this {Shape}
* @param {Spot} s a real Spot describing.
* @param {Point=} result an optional Point that is modified and returned.
* @return {Point}
*/
Shape.prototype.getDocumentPoint = function(s, result) {
  if (result === undefined/*notpresent*/) result = new Point();
  if (s.isNoSpot()) Util.throwError('Spot must be real');
  var ns = this.naturalBounds;
  var sw = this.strokeWidth;
  result._set((s.x * (ns.width + sw) - (sw / 2)) + ns.x + s.offsetX,
              (s.y * (ns.height + sw) - (sw / 2)) + ns.y + s.offsetY);
  this.allTransforms.transformPoint(result);
  return result;
};

// For Paths, count intersections on the ray from outside bounding box to p.
// @returns {boolean} true if p is in the geometry.
/**
* @ignore
* @this {Shape}
* @param {Point} p
* @param {boolean=} precise optional argument that forces the strokewidth to stay small.
* @return {boolean}
*/
Shape.prototype.containsPointProtected = function(p, precise) {
  var geom = this.getConstructedGeometry();
  if (geom === null) return false;
  if (this.fill === null && this.stroke === null) return false;
  var bounds = geom.bounds;
  var sw = (this.strokeWidth / 2);

  // If its a line or if there are no filled subpaths by definition
  if (geom.type === Geometry.Line && !precise) { sw += 2; }

  // First make sure the point [p] is even in [bounds + sw]
  var r = Util.tempRect();
  r.assign(bounds);
  r.inflate(sw + 2, sw + 2);
  if (!r.containsPoint(p)) {
    Util.freeRect(r);
    return false;
  }
  var swepsilon = sw + 0.0001;

  // Now decide what to do for each kind of Geometry
  if (geom.type === Geometry.Line) {
    if (this.stroke === null) return false;
    // don't allow extension over endpoints
    var dot1 = (geom.startX - geom.endX) * (p.x - geom.endX) + (geom.startY - geom.endY) * (p.y - geom.endY);
    var dot2 = (geom.endX - geom.startX) * (p.x - geom.startX) + (geom.endY - geom.startY) * (p.y - geom.startY);
    if (dot1 < 0 || dot2 < 0) { return false; }

    return Geo.lineContainsPoint(geom.startX, geom.startY, geom.endX, geom.endY, sw, p.x, p.y);
  } else if (geom.type === Geometry.Rectangle) {
    var x1 = geom.startX;
    var y1 = geom.startY;
    var x2 = geom.endX;
    var y2 = geom.endY;

    var x = Math.min(x1, x2);
    var y = Math.min(y1, y2);
    var w = Math.abs(x2 - x1);
    var h = Math.abs(y2 - y1);

    r.x = x;
    r.y = y;
    r.width = w;
    r.height = h;

    if (this.fill === null) {  // hollow rectangle?
      r.inflate(-swepsilon, -swepsilon);
      // if the point is inside the rectangle, false
      if (r.containsPoint(p)) return false;
      r.inflate(swepsilon, swepsilon);
    }
    if (this.stroke !== null) { // within the outside of the rectangle?
      r.inflate(sw, sw);
    }
    var ret = r.containsPoint(p);
    Util.freeRect(r);
    return ret;
  } else if (geom.type === Geometry.Ellipse) {
    var x1 = geom.startX;
    var y1 = geom.startY;
    var x2 = geom.endX;
    var y2 = geom.endY;

    var x = Math.min(x1, x2);
    var y = Math.min(y1, y2);
    var w = Math.abs(x2 - x1);
    var h = Math.abs(y2 - y1);

    var a = w / 2;
    var b = h / 2;
    var cx = x + a;
    var cy = y + b;
    x = p.x - cx;  // normalize X and Y
    y = p.y - cy;
    if (this.fill === null) {  // hollow ellipse?
      a -= swepsilon;
      b -= swepsilon;
      if (a <= 0 || b <= 0) return false;
      // if the point is inside the ellipse, false
      if ((x * x) / (a * a) + (y * y) / (b * b) <= 1) return false;
      a += swepsilon;
      b += swepsilon;
    }
     if (this.stroke !== null) { // within the outside of the ellipse?
      a += sw;
      b += sw;
    }
    if (a <= 0 || b <= 0) return false;
    return ((x * x) / (a * a) + (y * y) / (b * b) <= 1);
  } else if (geom.type === Geometry.Path) {
    // If there's no fill we can treat the entire geometry as if there are no filled subpaths
    if (this.fill === null) {
      return geom._pathContainsPoint(p.x, p.y, sw);
    }

    return geom.containsPoint(p, sw, this.strokeWidth > 1, precise);
  } else {
    Util.throwError('Unknown Geometry type');
    return false;
  }
};

/**
* @ignore
* @this {Shape}
* @param {number} width
* @param {number} height
* @param {number} minw
* @param {number} minh
*/
Shape.prototype.measureProtected = function(width, height, minw, minh) {
  var des = this.desiredSize;
  var sw = this._strokeWidth;
  width = Math.max(width, 0);
  height = Math.max(height, 0);

  var cb;
  if (this._setGeometry) {
    cb = this._geometry.bounds;
  } else {
    var fig = this.figure;
    var preset = Geo.presetGeometries[fig];
    if (preset === undefined) {
      var func = Geo.generators[fig];
      if (typeof func === 'string') func = Geo.generators[func];
      if (typeof func === 'function') {
        preset = func(null, 100, 100);
        Geo.presetGeometries[fig] = preset;
      } else {
        Util.throwError('Unsupported Figure:' + fig);
      }
    }
    cb = preset.bounds;
  }

  var geoWidth = cb.width;
  var geoHeight = cb.height;
  // These are the expected width and height
  var w = cb.width;
  var h = cb.height;

  // Determine if the shape is stretched and use the input width and height appropriately
  var effectivestretch = this.getEffectiveStretch();
  switch (effectivestretch) {
    case GraphObject.None:
      minw = 0;
      minh = 0;
      break;
    case GraphObject.Fill:
      w = Math.max(width - sw, 0);  // given width and height determine end size (not geometry size) so "- sw"
      h = Math.max(height - sw, 0);
      break;
    case GraphObject.Horizontal:
      w = Math.max(width - sw, 0);
      minh = 0;
      break;
    case GraphObject.Vertical:
      minw = 0;
      h = Math.max(height - sw, 0);
      break;
  } // end stretch switch
  // desired always overrides
  if (isFinite(des.width)) w = des.width;
  if (isFinite(des.height)) h = des.height;
  var max = this.maxSize;
  var min = this.minSize;
  minw = Math.max(minw, min.width) - sw;
  minh = Math.max(minh, min.height) - sw;
  w = Math.min(max.width, w);
  h = Math.min(max.height, h);
  w = isFinite(w) ? Math.max(minw, w) : Math.max(geoWidth, minw);
  h = isFinite(h) ? Math.max(minh, h) : Math.max(geoHeight, minh);

  // w,h cannot get larger or smaller
  // but the geometry can shrink or fill to fit w,h
  // by using geometryStretch
  var stretch = this.getGeometryStretch();
  switch (stretch) {
    case GraphObject.None:
      // Do nothing
      break;
    case GraphObject.Fill:
      geoWidth = w;
      geoHeight = h;
      break;
    case GraphObject.Uniform:
      // Find the smaller side and compute for it
      var ratio = Math.min(w / geoWidth, h / geoHeight);
      if (!isFinite(ratio)) ratio = 1;
      geoWidth = geoWidth * ratio;
      geoHeight = geoHeight * ratio;
      break;
    default:
      Util.throwError(stretch + ' is not a valid geometryStretch.');
  }

  if (this._setGeometry) {
    var geom = this.geometry.computeScaledGeometry(geoWidth, geoHeight);
    this._geometry = geom; // don't override the original geometry
  } else if (this._geometry === null || this._geometry._inputWidth !== width-sw || this._geometry._inputHeight !== height-sw) {
    this._geometry = Geo.makeGeometry(this, geoWidth, geoHeight);
  }

  cb = this._geometry.bounds;
  // variable width or height must measure by their geometry, all others we can use the truly determined width and height
  if (width === Infinity || height === Infinity) {
    this._measureRect(cb.x - (sw / 2), cb.y - (sw / 2), (width === 0 && geoWidth === 0) ? 0 : cb.width + sw, (height === 0 && geoHeight === 0) ? 0 : cb.height + sw);
  } else {
    this._measureRect(-(sw / 2), -(sw / 2), w + sw, h + sw);
  }
};  // end measure

/**
* @ignore
* Create a Shape's measured bounds based on its geometry while making some assumptions:
* - The geometry exists
* - There is no stretch and width/height do not matter
* These conditions should almost never be assumed, except when the shape is a main element of a Link.
* This function replaces both measure and measureProtected,
* which is why it does some things that measureProtected alone does not do.
* @this {Shape}
* @param {number} width
* @param {number} height
*/
Shape.prototype.measureSimple = function(width, height) {
  // don't measure unless invalid
  if (this.getInvalidMeasure() === false) return;

  this._measuredBounds.thaw();
  var logicalSW = this._strokeWidth;
  if (logicalSW === 0) {
    var part = this.part;
    if (part instanceof Adornment && part.type === Panel.Link && part.adornedObject instanceof Shape)
      logicalSW = part.adornedObject.strokeWidth;
  }
  var sw = (logicalSW) * this._scale;
  this._measureRect(-(sw / 2), -(sw / 2), width + sw, height + sw);

  // constraining mb to minSize and maxSize. ???
  var mb = this._measuredBounds;
  var max = this.maxSize;
  var min = this.minSize;
  mb.width = Math.min(max.width, mb.width);
  mb.height = Math.min(max.height, mb.height);
  mb.width = Math.max(min.width, mb.width);
  mb.height = Math.max(min.height, mb.height);

  this._measuredBounds.freeze();
  if (!this._measuredBounds.isReal()) Util.throwError('Non-real measuredBounds has been set');
  this.setInvalidMeasure(false);
};


/**
* @ignore
* @this {Shape}
* @return {EnumValue}
*/
Shape.prototype.getGeometryStretch = function() {
  var stretch = this.geometryStretch;
  if (this._setGeometry) {
    if (stretch === GraphObject.Default) return GraphObject.Fill;
    return stretch;
  } else {
    if (stretch === GraphObject.Default) {
      return Geo.presetGeometries[this.figure]._defaultStretch;
    }
    return stretch;
  }
};

/**
* @ignore
* Arranges the GraphObject onto its panel.
* @this {Shape}
* @param {number} fx
* @param {number} fy
* @param {number} fw
* @param {number} fh
*/
Shape.prototype.arrangeProtected = function(fx, fy, fw, fh) {
  this.commonArrange(fx, fy, fw, fh);
};

// ??? needed for override purposes so long as GraphObject.getNearestIntersectionPoint is public
Shape.prototype['getNearestIntersectionPoint'] =
/**
* @ignore
* @this {Shape}
*/
Shape.prototype.getNearestIntersectionPoint = function(p1, p2, result) {
  return this.getNearestIntersectionPoint2(p1.x, p1.y, p2.x, p2.y, result);
};

// The closest intersection point of a shape with a line is the
// closest such point for each of its segments.
// This currently does not always take into account any pen width.
// out result
/**
* @ignore
* @this {Shape}
* @param {number} p1x
* @param {number} p1y
* @param {number} p2x
* @param {number} p2y
* @param {Point} result
* @return {boolean}
*/
Shape.prototype.getNearestIntersectionPoint2 = function(p1x, p1y, p2x, p2y, result) {
  var tt = this.transform;
  var d = 1 / (tt.m11 * tt.m22 - tt.m12 * tt.m21);
  var m0 = tt.m22 * d;
  var m1 = -tt.m12 * d;
  var m2 = -tt.m21 * d;
  var m3 = tt.m11 * d;
  var m4 = d * (tt.m21 * tt.dy - tt.m22 * tt.dx);
  var m5 = d * (tt.m12 * tt.dx - tt.m11 * tt.dy);

  // Inverted transform point
  var q1x = p1x * m0 + p1y * m2 + m4;
  var q1y = p1x * m1 + p1y * m3 + m5;

  var q2x = p2x * m0 + p2y * m2 + m4;
  var q2y = p2x * m1 + p2y * m3 + m5;

  var sw2 = this.strokeWidth / 2;
  var geom = this._geometry;
  if (geom === null) {
    this.measure(Infinity, Infinity);
    geom = this._geometry;
  }
  var bounds = geom.bounds;
  var ret = false; // the actual value returned
  if (geom.type === Geometry.Line) {
    // shortcut instead of adding startPoint and endPoint to curFigure
    if (this.strokeWidth <= 1.5) {
      ret = Geo.nearestIntersectionOnLine(geom._startX, geom._startY, geom._endX, geom._endY, q1x, q1y, q2x, q2y, result);
    } else {
      var dx, dy;
      if (geom._startX === geom._endX) {
        dx = sw2;
        dy = 0;
      } else {
        var m = (geom._endY - geom._startY) / (geom._endX - geom._startX);
        dy = sw2 / Math.sqrt(1 + m * m);
        dx = dy * m;
      }

      // ??? test dumb objects or arrays [x, y] vs points sometime
      var points = Util.tempArray();
      var p = new Point();
      if (Geo.nearestIntersectionOnLine(geom._startX + dx, geom._startY + dy, geom._endX + dx, geom._endY + dy, q1x, q1y, q2x, q2y, p)) { points.push(p); }
      p = new Point();
      if (Geo.nearestIntersectionOnLine(geom._startX - dx, geom._startY - dy, geom._endX - dx, geom._endY - dy, q1x, q1y, q2x, q2y, p)) { points.push(p); }
      p = new Point();
      if (Geo.nearestIntersectionOnLine(geom._startX + dx, geom._startY + dy, geom._startX - dx, geom._startY - dy, q1x, q1y, q2x, q2y, p)) { points.push(p); }
      p = new Point();
      if (Geo.nearestIntersectionOnLine(geom._endX + dx, geom._endY + dy, geom._endX - dx, geom._endY - dy, q1x, q1y, q2x, q2y, p)) { points.push(p); }
      var l = points.length;
      if (l === 0) { Util.freeArray(points); return false; }
      ret = true;
      var min = Infinity;
      for (var i = 0; i < l; i++) {
        var point = points[i];
        var dist = (point.x - q1x) * (point.x - q1x) + (point.y - q1y) * (point.y - q1y);
        if (dist < min) {
          min = dist;
          result.x = point.x;
          result.y = point.y;
        }
      }
      Util.freeArray(points);
    }

  } else if (geom.type === Geometry.Rectangle) {
    var l = bounds.x - sw2;
    var t = bounds.y - sw2;
    var r = bounds.x + bounds.width + sw2;
    var b = bounds.y + bounds.height + sw2;
    ret = Geo.getNearestIntersectionPoint(l, t, r, b, q1x, q1y, q2x, q2y, result);
  } else if (geom.type === Geometry.Ellipse) {
    ret = this.nearestIntersectionOnEllipse(bounds.copy().inflate(sw2, sw2), q1x, q1y, q2x, q2y, result);
  } else if (geom.type === Geometry.Path) {
    var sx, sy, ex, ey;
    var intp = Util.tempPoint();
    var dx = q2x - q1x;
    var dy = q2y - q1y;
    var min = dx * dx + dy * dy;
    result.x = q2x; result.y = q2y;
    for (var i = 0; i < geom.figures.count; i++) {
      var fig = geom.figures._arr[i];
      var segs = fig.segments;
      sx = fig.startX;
      sy = fig.startY;
      var lmX = sx;
      var lmY = sy;
      var seg, type;
      for (var j = 0; j < segs.count; j++) {
        seg = segs._arr[j];
        type = seg.type;
        ex = seg.endX;
        ey = seg.endY;

        var inter = false;
        switch (type) {
          case PathSegment.Move:
            lmX = ex;
            lmY = ey;
            break;
          case PathSegment.Line:
            inter = this._lineIntersection(sx, sy, ex, ey, q1x, q1y, q2x, q2y, intp);
            break;
          case PathSegment.Bezier:
            var c1x = seg.point1X; var c1y = seg.point1Y;
            var c2x = seg.point2X; var c2y = seg.point2Y;
            inter = Geo.bezierNearestIntersectionOnLine(sx, sy, c1x, c1y, c2x, c2y, ex, ey, q1x, q1y, q2x, q2y, 0.5, intp);
            break;
          case PathSegment.QuadraticBezier:
            var c1x = (sx + 2 * seg.point1X) / 3; // elevate degree
            var c1y = (sy + 2 * seg.point1Y) / 3;
            var c2x = (seg.point1X * 2 + ex) / 3;
            var c2y = (seg.point1X * 2 + ex) / 3;
            inter = Geo.bezierNearestIntersectionOnLine(sx, sy, c1x, c1y, c2x, c2y, ex, ey, q1x, q1y, q2x, q2y, 0.5, intp);
            break;
          case PathSegment.Arc:
          case PathSegment.SvgArc:
            // We don't set inter for Arcs, instead we test the several beziers and single line point inline
            var curves = (seg.type === PathSegment.Arc) ? seg.buildBeziers(fig) : seg.buildSVGBeziers(fig, sx, sy);
            var clen = curves.length;
            for (var k = 0; k < clen; k++) {
              var c = curves[k];
              if (k === 0 && this._lineIntersection(sx, sy, c.x1, c.y1, q1x, q1y, q2x, q2y, intp)) {
                dist = this._testDist(q1x, q1y, intp, min, result);
                if (dist < min) { min = dist; ret = true; }
              }
              if (Geo.bezierNearestIntersectionOnLine(c.x1, c.y1, c.x2, c.y2, c.x3, c.y3, c.x4, c.y4, q1x, q1y, q2x, q2y, 0.5, intp)) {
                dist = this._testDist(q1x, q1y, intp, min, result);
                if (dist < min) { min = dist; ret = true; }
              }
            }
            // manually set this since Arc's endX isn't "normal"
            ex = c.x4;
            ey = c.y4;
            break;
          default:
            Util.throwError('Unknown Segment type: ' + seg.type);
            break;
        }

        sx = ex;
        sy = ey;

        if (inter) {
          dist = this._testDist(q1x, q1y, intp, min, result);
          if (dist < min) { min = dist; ret = true; }
        }

        if (seg.isClosed) {
          // Check one last Line: from this endpoint (ex/ey) to the last move point (lmX/lmY)
          ex = lmX;
          ey = lmY;
          if (this._lineIntersection(sx, sy, ex, ey, q1x, q1y, q2x, q2y, intp)) {
            dist = this._testDist(q1x, q1y, intp, min, result);
            if (dist < min) { min = dist; ret = true; }
          }
        }

      } // end segment for loop
    }

    // offset due to strokewidth
    var lx = p2x - p1x;
    var ly = p2y - p1y;
    var l = Math.sqrt(lx * lx + ly * ly);
    lx /= l; ly /= l;
    result.x -= lx * sw2;
    result.y -= ly * sw2;
    Util.freePoint(intp);
  } else {
    Util.throwError('Invalid Geometry type');
  }
  if (!ret) { return false; }

  this.transform.transformPoint(result);
  return true;
};

/**
* @ignore
* helper for getNearestIntersectionPoint
* @this {Shape}
* @return {number}
*/
Shape.prototype._testDist = function(q1x, q1y, intp, min, result) {
  var dx = intp.x - q1x;
  var dy = intp.y - q1y;
  var dist = dx * dx + dy * dy;
  if (dist < min) {
    result.x = intp.x; result.y = intp.y;
    return dist;
  }
  return min;
};

/**
* @ignore
* helper for getNearestIntersectionPoint
* @this {Shape}
* @return {boolean}
*/
Shape.prototype._lineIntersection = function(sx, sy, ex, ey, q1x, q1y, q2x, q2y, intp) {
  var inter = false;
  var d = (q1x - q2x) * (sy - ey) - (q1y - q2y) * (sx - ex);
  if (d === 0) { return false; }
  intp.x = ((q1x * q2y - q1y * q2x) * (sx - ex) - (q1x - q2x) * (sx * ey - sy * ex)) / d;
  intp.y = ((q1x * q2y - q1y * q2x) * (sy - ey) - (q1y - q2y) * (sx * ey - sy * ex)) / d;
  if ((sx > ex ? sx - ex : ex - sx) < (sy > ey ? sy - ey : ey - sy)) {
    var qmin = sy < ey ? sy : ey;
    var qmax = sy < ey ? ey : sy;
    if ((intp.y > qmin || Geo.isApproxEqual(intp.y, qmin)) && (intp.y < qmax || Geo.isApproxEqual(intp.y, qmax))) { inter = true; }
  } else {
    var qmin = sx < ex ? sx : ex;
    var qmax = sx < ex ? ex : sx;
    if ((intp.x > qmin || Geo.isApproxEqual(intp.x, qmin)) && (intp.x < qmax || Geo.isApproxEqual(intp.x, qmax))) { inter = true; }
  }
  return inter;
};


/**
* @ignore
* @this {GraphObject}
* @param {Rect} r A Rect in container coordinates.
* @param {boolean} partialInclusion True if objects are to be included when they
* intersect.
* @param {Transform} transform
* @return {boolean} Whether or not this object is included.
*/
GraphObject.prototype.findObjectInPath = function(r, partialInclusion, transform) {
  if (this.pickable === false) return false;
  transform.multiply(this.transform);
  if (partialInclusion) {
    return this.intersectsRectPath(r, transform);
  } else {
    return this.containedInRect(r, transform);
  }
};

Shape.prototype['containedInRect'] =
/**
* @ignore
* Determine if a given Rect is large enough to entirely contain this Shape.
* @this {Shape}
* @param {Rect} r A Rect in container coordinates.
* @param {Transform=} transform A transform to use if something other than the Shape's own transform is desired.
* @return {boolean} true if rect r contains the entire object.
*/
Shape.prototype.containedInRect = function(r, transform) {
  // using its own transform means we can just check the actualBounds
  if (transform === undefined/*notpresent*/) {
    return r.containsRect(this.actualBounds);
  }

  // see if all of the four points are inside
  var geom = this._geometry;
  if (geom === null) {
    this.measure(Infinity, Infinity);
    geom = this._geometry;
  }
  var ns = geom.bounds;
  var sw = this.strokeWidth / 2;
  // just add instead of inflating so we don't have to make a new Rect

  var result = false;
  var pnt = Util.tempPoint();
  pnt._set(ns.x - sw, ns.y - sw);
  if (r.containsPoint(transform.transformPoint(pnt))) {
    pnt._set(ns.x - sw, ns.bottom + sw);
    if (r.containsPoint(transform.transformPoint(pnt))) {
      pnt._set(ns.right + sw, ns.bottom + sw);
      if (r.containsPoint(transform.transformPoint(pnt))) {
        pnt._set(ns.right + sw, ns.y - sw);
        if (r.containsPoint(transform.transformPoint(pnt))) {
          result = true;
        }
      }
    }
  }
  Util.freePoint(pnt);
  return result;

  // NYI: Instead of above implementation (taken from GraphObject), use the points specific to the geometry
};

// ?? optimize this sometime
Shape.prototype['intersectsRect'] =
/**
* @ignore
* Determines if a given rectangle intersects the Shape's bounds.
* @this {GraphObject}
* @param {Rect} rect a rectangle in container coordinates.
* @param {Transform=} transform optional transform.
* @return {boolean}
*/
Shape.prototype.intersectsRect = function(rect, transform) {
  // rect completely encompasses the shape
  if (this.containedInRect(rect, transform)) return true;

  if (transform === undefined/*notpresent*/) {
    transform = this.transform;
    if (rect.containsRect(this.actualBounds)) { return true; }
  }

  var tt = Util.tempTransform();
  tt.set(transform);
  tt.invert();

  var l = rect.left, r = rect.right, t = rect.top, b = rect.bottom;
  var pnt = Util.tempPoint();

  pnt._set(l, t); tt.transformPoint(pnt);
  if (this.containsPointProtected(pnt, true)) { Util.freePoint(pnt); return true; }  // LC
  pnt._set(r, t); tt.transformPoint(pnt);
  if (this.containsPointProtected(pnt, true)) { Util.freePoint(pnt); return true; }
  pnt._set(l, b); tt.transformPoint(pnt);
  if (this.containsPointProtected(pnt, true)) { Util.freePoint(pnt); return true; }
  pnt._set(r, b); tt.transformPoint(pnt);
  if (this.containsPointProtected(pnt, true)) { Util.freePoint(pnt); return true; }

  var pnt2 = Util.tempPoint();
  var temp = Util.tempPoint();

  // _intersectsSegment needs container coordinates, not local
  tt.set(transform);
  tt.multiplyInverted(this.transform);
  tt.invert();
  pnt2.x = r; pnt2.y = t; pnt2.transform(tt);
  pnt.x = l; pnt.y = t; pnt.transform(tt);

  var result = false;
  if (this._intersectsSegment(pnt, pnt2, temp)) {    // CC
    result = true;
  } else {
    pnt.x = r; pnt.y = b; pnt.transform(tt);
    if (this._intersectsSegment(pnt, pnt2, temp)) {
      result = true;
    } else {
      pnt2.x = l; pnt2.y = b; pnt2.transform(tt);
      if (this._intersectsSegment(pnt, pnt2, temp)) {
        result = true;
      } else {
        pnt.x = l; pnt.y = t; pnt.transform(tt);
        if (this._intersectsSegment(pnt, pnt2, temp)) {
          result = true;
        }
      }
    }
  }
  Util.freePoint(pnt);
  Util.freeTransform(tt);
  Util.freePoint(pnt2);
  Util.freePoint(temp);
  return result;
};

// container coords.
/**
* @ignore
* @this {GraphObject}
* @param {Point} p1
* @param {Point} p2
* @param {Point} tempp
* @return {boolean}
*/
Shape.prototype._intersectsSegment = function(p1, p2, tempp) {
  if (!this.getNearestIntersectionPoint(p1, p2, tempp)) { return false; }
  var x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y, x = tempp.x, y = tempp.y;
  if (x1 === x2) {
    var min, max;
    if (y1 < y2) { min = y1; max = y2; } else { min = y2; max = y1; }
    return y >= min && y <= max;
  } else {
    var min, max;
    if (x1 < x2) { min = x1; max = x2; } else { min = x2; max = x1; }
    return x >= min && x <= max;
  }
};

/**
* @ignore
* Determines if a given rectangle intersects the Shape's bounds.
* @this {GraphObject}
* @param {Rect} rect a rectangle in container coordinates.
* @param {Transform=} transform optional transform.
* @return {boolean}
*/
Shape.prototype.intersectsRectPath = function(rect, transform) {
  // rect completely encompasses the shape
  if (this.containedInRect(rect, transform)) return true;

  if (transform === undefined/*notpresent*/) {
    transform = this.transform;
    if (rect.containsRect(this.actualBounds)) { return true; }
  }

  var l = rect.left, r = rect.right, t = rect.top, b = rect.bottom;
  var pnt = Util.tempPoint();
  var pnt2 = Util.tempPoint();
  var temp = Util.tempPoint();
  var tt = Util.tempTransform();
  // _intersectsSegment needs container coordinates, not local
  tt.set(transform);
  tt.multiplyInverted(this.transform);
  tt.invert();
  pnt2.x = r; pnt2.y = t; pnt2.transform(tt);
  pnt.x = l; pnt.y = t; pnt.transform(tt);

  var result = false;
  if (this._intersectsSegment(pnt, pnt2, temp)) {    // CC
    result = true;
  } else {
    pnt.x = r; pnt.y = b; pnt.transform(tt);
    if (this._intersectsSegment(pnt, pnt2, temp)) {
      result = true;
    } else {
      pnt2.x = l; pnt2.y = b; pnt2.transform(tt);
      if (this._intersectsSegment(pnt, pnt2, temp)) {
        result = true;
      } else {
        pnt.x = l; pnt.y = t; pnt.transform(tt);
        if (this._intersectsSegment(pnt, pnt2, temp)) {
          result = true;
        }
      }
    }
  }
  Util.freeTransform(tt);
  Util.freePoint(pnt);
  Util.freePoint(pnt2);
  Util.freePoint(temp);
  return result;
};

/**
* @ignore
* @this {Shape}
* @param {Point} p A Point in container coordinates.
* @param {Point} distp A Point representing the distance from the point p.
* @param {boolean} partialInclusion
* @return {boolean}
*/
Shape.prototype.findObjectNear = function(p, distp, partialInclusion) {
  // if it's filled, check to see if it contains the point
  if (partialInclusion && this.fill !== null && this.containsPointProtected(p, true)) {
    return true;
  }

  var dist2 = p.distanceSquaredPoint(distp);
  var dist2orig = dist2;

  if (this.strokeWidth > 1.5) {
    dist2 = this.strokeWidth / 2 + Math.sqrt(dist2);
    dist2 *= dist2;
  }
  var geo = this._geometry;
  if (geo === null) {
    // ??? maybe we should return false here instead
    this.measure(Infinity, Infinity);
    geo = this._geometry;
  }

  // If the circle completely encompasses the bounds of the Shape,
  // regardless of its size, then it is completely contained
  if (!partialInclusion) {
    var bounds = geo.bounds;
    var L = bounds.x;
    var T = bounds.y;
    var R = bounds.x + bounds.width;
    var B = bounds.y + bounds.height;
    if ((Point.distanceSquared(p.x, p.y, L, T) <= dist2) &&
          (Point.distanceSquared(p.x, p.y, R, T) <= dist2) &&
          (Point.distanceSquared(p.x, p.y, L, B) <= dist2) &&
          (Point.distanceSquared(p.x, p.y, R, B) <= dist2)) return true;
  }

  // returns true if a point is OUTSIDE the distance
  // if testCurve is true, we need to return false!
  /** @ignore */
  function testCurve(arr, dist, p) {
    var l = arr.length;
    for (var i = 0; i < l; i++) {
      var arp = arr[i];
      if (p.distanceSquared(arp[0], arp[1]) > dist2) return true;
    }
    return false;
  }

  //_getKeyFigsInPathGeometry
  var x1 = geo._startX;
  var y1 = geo._startY;
  var x2 = geo._endX;
  var y2 = geo._endY;
  if (geo.type === Geometry.Line) {
    var d = Point.distanceLineSegmentSquared(p.x, p.y, x1, y1, x2, y2);
    var dot1 = (x2 - x1) * (p.x - x1) + (y2 - y1) * (p.y - y1); // if either dot product is negative, point is past an endpoin
    var dot2 = (x1 - x2) * (p.x - x2) + (y1 - y2) * (p.y - y2);
    var thresh = (dot1 >= 0 && dot2 >= 0) ? dist2 : dist2orig; // thick stroke doesm't go past endpoints
    if (d <= thresh) { return true; }
    return false;
  }
  else if (geo.type === Geometry.Rectangle) {
    var hit = false;
    if (partialInclusion) hit = Point.distanceLineSegmentSquared(p.x, p.y, x1, y1, x1, y2) <= dist2 ||
        Point.distanceLineSegmentSquared(p.x, p.y, x1, y1, x2, y1) <= dist2 ||
        Point.distanceLineSegmentSquared(p.x, p.y, x2, y1, x2, y2) <= dist2 ||
        Point.distanceLineSegmentSquared(p.x, p.y, x1, y2, x2, y2) <= dist2;
    // !partialInclusion is already taken care of above
    return hit;
  } else if (geo.type === Geometry.Ellipse) {
    // find center
    var cx = (x1 + x2) / 2;
    var cy = (y1 + y2) / 2;

    // make center (0,0)
    var px = p.x - cx;
    var py = p.y - cy;

    var rx = Math.abs(x2 - x1) / 2;
    var ry = Math.abs(y2 - y1) / 2;

    if (rx === 0 || ry === 0) { // ???
      var d = Point.distanceLineSegmentSquared(p.x, p.y, x1, y1, x2, y2);
      if (d <= dist2) { return true; }
      return false;
    }

    if (partialInclusion) {
      var dist = Geo.distancePointEllipse(rx, ry, px, py);
      if (dist * dist <= dist2) { return true; }
      return false;
    } else {
      if (Point.distanceSquared(px, py, -rx, 0) >= dist2) return false;
      if (Point.distanceSquared(px, py, 0, -ry) >= dist2) return false;
      if (Point.distanceSquared(px, py, 0, ry) >= dist2) return false;
      if (Point.distanceSquared(px, py, rx, 0) >= dist2) return false;
      return true;
    }

  } else if (geo.type === Geometry.Path) {
    // check bounds
    var bounds = geo.bounds;
    var L = bounds.x;
    var T = bounds.y;
    var R = bounds.x + bounds.width;
    var B = bounds.y + bounds.height;
    if (p.x > R && p.x < L && p.y > B && p.y < T &&
    Point.distanceLineSegmentSquared(p.x, p.y, L, T, L, B) > dist2 &&
    Point.distanceLineSegmentSquared(p.x, p.y, L, T, R, T) > dist2 &&
    Point.distanceLineSegmentSquared(p.x, p.y, R, B, L, B) > dist2 &&
    Point.distanceLineSegmentSquared(p.x, p.y, R, B, R, T) > dist2
    ) { return false; }

    var tempsw = Math.sqrt(dist2);

    if (partialInclusion) {
      if (this.fill === null ? geo._pathContainsPoint(p.x, p.y, tempsw) : geo.containsPoint(p, tempsw, true))
        { return true; }
    } else {
      // Path must be entirely contained within circle?
      var figs = geo.figures;
      for (var i = 0; i < figs.count; i++) {
        var fig = figs._arr[i];
        var lastX = fig.startX;
        var lastY = fig.startY;
        if (p.distanceSquared(lastX, lastY) > dist2) return false;
        var segments = fig.segments._arr;
        var numsegs = segments.length;
        for (var j = 0; j < numsegs; j++) {
          var seg = segments[j];
          switch (seg.type) {
            case PathSegment.Move:
            case PathSegment.Line:
              lastX = seg.endX;
              lastY = seg.endY;
              if (p.distanceSquared(lastX, lastY) > dist2) return false;
              break;
            case PathSegment.Bezier:
              var res = Util.tempArray();
              Geo.bezierLines(
                lastX, lastY,
                seg.point1X, seg.point1Y,
                seg.point2X, seg.point2Y,
                seg.endX, seg.endY, 0.8, res);
              var tested = testCurve(res, dist2, p);
              Util.freeArray(res);
              if (tested) return false;
              lastX = seg.endX;
              lastY = seg.endY;
              if (p.distanceSquared(lastX, lastY) > dist2) return false;
              break;
            case PathSegment.QuadraticBezier:
              var res = Util.tempArray();
              Geo.quadraticBezierLines(
                lastX, lastY,
                seg.point1X, seg.point1Y,
                seg.endX, seg.endY, 0.8, res);
              var tested = testCurve(res, dist2, p);
              Util.freeArray(res);
              if (tested) return false;
              lastX = seg.endX;
              lastY = seg.endY;
              if (p.distanceSquared(lastX, lastY) > dist2) return false;
              break;
            case PathSegment.Arc:
            case PathSegment.SvgArc:
              var curves = (seg.type === PathSegment.Arc) ? seg.buildBeziers(fig) : seg.buildSVGBeziers(fig, lastX, lastY);
              var clen = curves.length;
              var c = null;
              var res = Util.tempArray();
              for (var i = 0; i < clen; i++) {
                c = curves[i];
                res.length = 0;
                Geo.bezierLines(c.x1, c.y1, c.x2, c.y2, c.x3, c.y3, c.x4, c.y4, 0.8, res);
                if (testCurve(res, dist2, p)) { Util.freeArray(res); return false; }
              }
              Util.freeArray(res);
              if (c !== null) {
                lastX = c.x4;
                lastY = c.y4;
              }
              break;
            default:
              Util.throwError('Unknown Segment type: ' + seg.type);
          } // end switch

        } // end segs
      }
      return true;
    }

  }

  return false;
};

// Find the intersection point of the elliptical path defined by rectangle
// rect and an infinite line p1-p2 that is closest to point p1.
/**
* @ignore
* @this {Shape}
*/
Shape.prototype.nearestIntersectionOnEllipse = function(rect, p1x, p1y, p2x, p2y, result) {
  if (rect.width === 0) {
    return Geo.nearestIntersectionOnLine(rect.x, rect.y,
      rect.x, rect.y + rect.height, p1x, p1y, p2x, p2y, result);
  } else if (rect.height === 0) {
    return Geo.nearestIntersectionOnLine(rect.x, rect.y,
      rect.x + rect.width, rect.y, p1x, p1y, p2x, p2y, result);
  } else {

    var Rx = rect.width / 2;
    var Ry = rect.height / 2;

    var Cx = rect.x + Rx;
    var Cy = rect.y + Ry;

    // see if the slope of P1-P2 is vertical or close to it (1 : 10000)
    var m = 9999;

    if (p1x !== p2x) {
      m = (p1y - p2y) / (p1x - p2x);
    }

    if (Math.abs(m) < 9999) {
      var b = (p1y - Cy) - m * (p1x - Cx);

      if ((Rx * Rx) * (m * m) + (Ry * Ry) - (b * b) < 0) {
        // ??? should this return the closest point,
        // even if there's no intersection
        result.x = NaN; result.y = NaN;
        return false;
      }

      var sqrt = Math.sqrt((Rx * Rx) * (m * m) + (Ry * Ry) - (b * b));

      var xplus = ((-((Rx * Rx) * m * b) + (Rx * Ry * sqrt)) /
        ((Ry * Ry) + ((Rx * Rx) * (m * m)))) + Cx;
      var xminus = ((-((Rx * Rx) * m * b) - (Rx * Ry * sqrt)) /
        ((Ry * Ry) + ((Rx * Rx) * (m * m)))) + Cx;

      var yplus = m * (xplus - Cx) + b + Cy;
      var yminus = m * (xminus - Cx) + b + Cy;

      var distplus = Math.abs((p1x - xplus) * (p1x - xplus)) +
        Math.abs((p1y - yplus) * (p1y - yplus));
      var distminus = Math.abs((p1x - xminus) * (p1x - xminus)) +
        Math.abs((p1y - yminus) * (p1y - yminus));

      if (distplus < distminus) {
        result.x = xplus;
        result.y = yplus;
      } else {
        result.x = xminus;
        result.y = yminus;
      }
    } else {
      var Ry2 = Ry * Ry;
      var Rx2 = Rx * Rx;
      var diff = p1x - Cx;
      var sqr = Ry2 - (Ry2 / Rx2) * (diff * diff);
      if (sqr < 0) {
        result.x = NaN; result.y = NaN;
        return false;
      }

      var sqrt = Math.sqrt(sqr);

      var yplus = Cy + sqrt;
      var yminus = Cy - sqrt;

      var distplus = Math.abs(yplus - p1y);
      var distminus = Math.abs(yminus - p1y);

      if (distplus < distminus) {
        result.x = p1x;
        result.y = yplus;
      } else {
        result.x = p1x;
        result.y = yminus;
      }
    }
    return true;
  }
};

/**
 * @ignore
 * Returns miter length. May be used for drawing/drawnSize measurements.
 * @return {number}
 */
Shape.prototype.getMiterLength = function() {
  if (!this._setGeometry) {
    // its a preset figure, optimize some common ones
    switch (this._figure) {
      case 'None':
      case 'Square':
      case 'Ellipse':
      case 'Circle':
      case 'LineH':
      case 'LineV':
      case 'FramedRectangle':
      case 'RoundedRectangle':
      case 'Line1':
      case 'Line2':
      case 'Border':
      case 'Cube1':
      case 'Cube2':
      case 'Junction':
      case 'Cylinder1':
      case 'Cylinder2':
      case 'Cylinder3':
      case 'Cylinder4':
      case 'PlusLine':
      case 'XLine':
      case 'ThinCross':
      case 'ThickCross':
        return 0;
    }
  }

  return ((this._strokeWidth / 2) * this._strokeMiterLimit) * this.getDocumentScale();
};

/**
 * @ignore
 * Returns the geometry that is sometimes dynamically constructed
 * @return {Geometry}
 */
Shape.prototype.getConstructedGeometry = function() {
  return this._geometry;
};

/**
* Gets or sets the Shape's {@link Geometry} that defines the Shape's figure.
* Setting a geometry is not necessary if a {@link #figure} is specified,
* as that will construct a geometry instead. Setting a geometry always overrides any set figure.
* @name Shape#geometry
* @function.
* @return {Geometry}
*/
/** @type {Geometry} */
Shape.prototype.geometry;
Util.exportProperty(Shape, 'geometry', Shape.prototype.geometry);
Util.defineProperty(Shape, { geometry: 'geometry' },
  /** @this {Shape} */
  function() {
    // do not create if it doesn't yet exist
    if (this._constructedGeometry) return this._constructedGeometry;
    return this._geometry;
  },
  /** @this {Shape} */
  function(val) {
    var old = this._geometry;
    if (old !== val) {
      if (val !== null) {
        if (Debug) Util.checkClass(val, Geometry, Shape, 'geometry');
        this._geometry = val.freeze();  // "in-use": don't allow modifications
        this._constructedGeometry = this._geometry;
      } else {
        this._geometry = null;
        this._constructedGeometry = null;
      }
      var p = this.part;
      if (p) p.resetMaxMiter();
      this._setGeometry = true;
      this.invalidateMeasure();
      this.raiseChanged('geometry', old, val);
    }
  }
);

/**
* When set, creates a {@link Geometry} and normalizes it from a given path string,
* then sets the Geometry on this Shape and offsets the {@link GraphObject#position} by an appropriate amount.
* The getter simply returns the toString value of the {@link Shape#geometry}.
* @name Shape#geometryString
* @function.
* @return {string}
* @since 1.1
*/
/** @type {string} */
Shape.prototype.geometryString;
Util.exportProperty(Shape, 'geometryString', Shape.prototype.geometryString);
Util.defineProperty(Shape, { geometryString: 'geometryString' },
  /** @this {Shape} */
  function() {
    return this.geometry.toString();
  },
  /** @this {Shape} */
  function(val) {
    var geo = Geometry.parse(val);
    var pos = geo.normalize();
    this.geometry = geo;
    var temp = Util.tempPoint();
    var p = this.position;
    if (p.isReal()) {
      temp._set(p.x - pos.x, p.y - pos.y);
    } else {
      temp._set(-pos.x, -pos.y);
    }
    this.position = temp;
    Util.freePoint(temp);
  }
);

/**
* Gets or sets the whether the {@link #position} denotes
* the panel coordinates of the geometry or of the stroked area. Default is false.
* @name Shape#isGeometryPositioned
* @function.
* @return {boolean}
* @since 1.1
*/
/** @type {boolean} */
Shape.prototype.isGeometryPositioned;
Util.defineProperty(Shape, { isGeometryPositioned: 'isGeometryPositioned' },
  /** @this {Shape} */
  function() { return this._isGeometryPositioned; },
  /** @this {Shape} */
  function(val) {
    if (Debug) Util.checkPrimitive(val, 'boolean', Shape, 'isGeometryPositioned');
    var old = this._isGeometryPositioned;
    if (old !== val) {
      this._isGeometryPositioned = val;
      this.invalidateMeasure();
      this.raiseChanged('isGeometryPositioned', old, val);
    }
  }
);

/**
* @ignore
* @this {Shape}
*/
Shape.prototype.invalidateGeometry = function() {
  if (!this._setGeometry)
    this._geometry = null;
  else
    this._constructedGeometry = null;
  // ??? we might be able to skip invalidateMeasure if a desired size is set
  this.invalidateMeasure();
};

/**
* Gets or sets the {@link Brush} or string that describes the fill of the Shape.
* <p>
* The default value is "black".
* Any valid CSS string can specify a solid color, and the {@link Brush}
* class can be used to specify a gradient or pattern.
* A null fill will mean no fill is drawn and the filled portion
* of the Shape will not be selectable.
* A transparent fill is useful when wanting to allow a shape to be pickable
* without obscuring any other objects behind it.
* More information about the syntax of CSS color strings is available at:
* <a href="http://developer.mozilla.org/en-US/docs/Web/CSS/color">CSS colors</a>.
* @name Shape#fill
* @function.
* @return {string|Brush}
*/
/** @type {string|Brush} */
Shape.prototype.fill;
Util.exportProperty(Shape, 'fill', Shape.prototype.fill);
Util.defineProperty(Shape, { fill: 'fill' },
  /** @this {Shape} */
  function() { return this._fill; },
  /** @this {Shape} */
  function(val) {
    var old = this._fill;
    if (old !== val) {
      if (val === null || typeof val === 'string' || val instanceof Brush) {
        if (val instanceof Brush) val.freeze();
        this._fill = val;
        this.invalidateDraw();
        this.raiseChanged('fill', old, val);
      }
    }
  }
);

/**
* Gets or sets the {@link Brush} or string that describes the stroke of the Shape.
* <p>
* The default value is "black".
* Any valid CSS string can specify a solid color, and the {@link Brush}
* class can be used to specify a gradient or pattern.
* A null stroke will mean no stroke is drawn.
* A transparent stroke is useful when wanting to allow a shape to be pickable
* without obscuring any other objects behind it.
* More information about the syntax of CSS color strings is available at:
* <a href="http://developer.mozilla.org/en-US/docs/Web/CSS/color">CSS colors</a>.
* @name Shape#stroke
* @function.
* @return {string|Brush}
*/
/** @type {string|Brush} */
Shape.prototype.stroke;
Util.exportProperty(Shape, 'stroke', Shape.prototype.stroke);
Util.defineProperty(Shape, { stroke: 'stroke' },
  /** @this {Shape} */
  function() { return this._stroke; },
  /** @this {Shape} */
  function(val) {
    var old = this._stroke;
    if (old !== val) {
      if (val === null || typeof val === 'string' || val instanceof Brush) {
        if (val instanceof Brush) val.freeze();
        this._stroke = val;
        this.invalidateDraw();
        this.raiseChanged('stroke', old, val);
      }
    }
  }
);

/**
* Gets or sets a stroke's width.
* Default is 1.0.
* @name Shape#strokeWidth
* @function.
* @return {number}
*/
/** @type {number} */
Shape.prototype.strokeWidth;
Util.exportProperty(Shape, 'strokeWidth', Shape.prototype.strokeWidth);
Util.defineProperty(Shape, { strokeWidth: 'strokeWidth' },
  /** @this {Shape} */
  function() { return this._strokeWidth; },
  /** @this {Shape} */
  function(val) {
    var old = this._strokeWidth;
    if (old !== val) {
      if (Debug) Util.checkRealNumber(val, Shape, 'strokeWidth');
      // On setting, negative, infinite, and NaN values must be ignored
      if (val >= 0) {
        this._strokeWidth = val;
        this.invalidateMeasure();
        var p = this.part;
        if (p) p.resetMaxMiter();
        this.raiseChanged('strokeWidth', old, val);
      }
    }
  }
);

/**
* Gets or sets the style for the stroke's line cap.
* Can be "butt", "round", or "square". Default is "butt".
* @name Shape#strokeCap
* @function.
* @return {string}
*/
/** @type {string} */
Shape.prototype.strokeCap;
Util.exportProperty(Shape, 'strokeCap', Shape.prototype.strokeCap);
Util.defineProperty(Shape, { strokeCap: 'strokeCap' },
  /** @this {Shape} */
  function() { return this._strokeCap; },
  /** @this {Shape} */
  function(val) {
    var old = this._strokeCap;
    if (old !== val) {
      if (typeof val === 'string' &&
          (val === 'butt' || val === 'round' || val === 'square')) {
        this._strokeCap = val;
        this.invalidateDraw();
        this.raiseChanged('strokeCap', old, val);
      } else {
        Util.throwRangeError(val, '"butt", "round", or "square"', Shape, 'strokeCap');
      }
    }
  }
);

/**
* Gets or sets the type of corner that will be drawn when two lines meet.
* Can be "miter", "bevel", or "round". Default is "miter".
* @name Shape#strokeJoin
* @function.
* @return {string}
*/
/** @type {string} */
Shape.prototype.strokeJoin;
Util.exportProperty(Shape, 'strokeJoin', Shape.prototype.strokeJoin);
Util.defineProperty(Shape, { strokeJoin: 'strokeJoin' },
  /** @this {Shape} */
  function() { return this._strokeJoin; },
  /** @this {Shape} */
  function(val) {
    var old = this._strokeJoin;
    if (old !== val) {
      if (typeof val === 'string' &&
          (val === 'miter' || val === 'bevel' || val === 'round')) {
        this._strokeJoin = val;
        this.invalidateDraw();
        this.raiseChanged('strokeJoin', old, val);
      } else {
        Util.throwRangeError(val, '"miter", "bevel", or "round"', Shape, 'strokeJoin');
      }
    }
  }
);

/**
* Gets or sets the style for the stroke's mitre limit ratio.
* Default is 10.
* @name Shape#strokeMiterLimit
* @function.
* @return {number}
*/
/** @type {number} */
Shape.prototype.strokeMiterLimit;
Util.exportProperty(Shape, 'strokeMiterLimit', Shape.prototype.strokeMiterLimit);
Util.defineProperty(Shape, { strokeMiterLimit: 'strokeMiterLimit' },
  /** @this {Shape} */
  function() { return this._strokeMiterLimit; },
  /** @this {Shape} */
  function(val) {
    var old = this._strokeMiterLimit;
    if (old !== val) {
      if (Debug) Util.checkRealNumber(val, Shape, 'strokeMiterLimit');
      // On setting, zero, negative, infinite, and NaN values must be ignored
      if (val > 0) {
        this._strokeMiterLimit = val;
        this.invalidateDraw();
        var p = this.part;
        if (p) p.resetMaxMiter();
        this.raiseChanged('strokeMiterLimit', old, val);
      }
    }
  }
);

/**
* Gets or sets the dash array for creating dashed lines.
* An array of [5, 10] would create dashes of 5 pixels and spaces of 10 pixels.
* Default is null.
* @name Shape#strokeDashArray
* @function.
* @return {Array.<number>}
* @since 1.1
*/
/** @type {Array.<number>} */
Shape.prototype.strokeDashArray;
Util.exportProperty(Shape, 'strokeDashArray', Shape.prototype.strokeDashArray);
Util.defineProperty(Shape, { strokeDashArray: 'strokeDashArray' },
  /** @this {Shape} */
  function() { return this._strokeDashArray; },
  /** @this {Shape} */
  function(val) {
    var old = this._strokeDashArray;
    if (old !== val) {
      // make sure its an array of numbers?
      if (!(val instanceof Array)) Util.throwTypeError(val, 'Array', Shape, 'strokeDashArray:val');
      var l = val.length;
      for (var i = 0; i < l; i++) {
        if (typeof val[i] !== 'number' || val[i] <= 0)
          Util.throwError('strokeDashArray:val ' + val[i] + ' is a negative number or not a number.');
      }
      this._strokeDashArray = val;
      this.invalidateDraw();
      this.raiseChanged('strokeDashArray', old, val);
    }
  }
);

/**
* Gets or sets the offset for dashed lines, used in the phase pattern.
* Default is 0.
* @name Shape#strokeDashOffset
* @function.
* @return {number}
* @since 1.1
*/
/** @type {number} */
Shape.prototype.strokeDashOffset;
Util.exportProperty(Shape, 'strokeDashOffset', Shape.prototype.strokeDashOffset);
Util.defineProperty(Shape, { strokeDashOffset: 'strokeDashOffset' },
  /** @this {Shape} */
  function() { return this._strokeDashOffset; },
  /** @this {Shape} */
  function(val) {
    var old = this._strokeDashOffset;
    if (old !== val) {
      if (Debug) Util.checkRealNumber(val, Shape, 'strokeDashOffset');
      // On setting, zero, negative, infinite, and NaN values must be ignored
      if (val > 0) {
        this._strokeDashOffset = val;
        this.invalidateDraw();
        this.raiseChanged('strokeDashOffset', old, val);
      }
    }
  }
);

/**
* Gets or sets the figure name, used to construct a {@link Geometry}.
* The value must be a string. Default is "None".
* <p/>
* The name can be any case but will always be canonicalized when set. For instance,
* setting "roundedrectangle" will set the value of figure to "RoundedRectangle".
* @name Shape#figure
* @function.
* @return {string}
*/
/** @type {string} */
Shape.prototype.figure;
Util.exportProperty(Shape, 'figure', Shape.prototype.figure);
Util.defineProperty(Shape, { figure: 'figure' },
  /** @this {Shape} */
  function() { return this._figure; },
  /** @this {Shape} */
  function(val) {
    var old = this._figure;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'string', Shape, 'figure');
      var cval = Geo.generators[val];
      if (typeof cval === 'function') {
        cval = val;  // VAL is already in canonical form
      } else {
        cval = Geo.generators[val.toLowerCase()]; // Canonicalize it
        if (!cval) Util.throwError('Unknown Shape.figure: ' + val);
      }
      if (old !== cval) {
        var p = this.part;
        if (p) p.resetMaxMiter();
        this._figure = cval;
        this._setGeometry = false;
        this.invalidateGeometry();
        this.raiseChanged('figure', old, cval);
      }
    }
  }
);

/**
* Gets or sets the name of the kind of arrowhead that this shape should take
* when this shape is an element of a {@link Link}.
* Value must be a string.
* Default is "None".
* <p/>
* The name can be any case but will always be canonicalized when set. For instance,
* setting "opentriangle" will set the value of the arrowhead to "OpenTriangle".
* <p/>
* Setting this property may also set the {@link GraphObject#segmentIndex},
* {@link GraphObject#segmentOrientation}, and {@link GraphObject#alignmentFocus} properties.
* This shape should be an element of a {@link Link}.
* @name Shape#toArrow
* @function.
* @return {string}
*/
/** @type {string} */
Shape.prototype.toArrow;
Util.exportProperty(Shape, 'toArrow', Shape.prototype.toArrow);
Util.defineProperty(Shape, { toArrow: 'toArrow' },
  /** @this {Shape} */
  function() { return this._toArrow; },
  /** @this {Shape} */
  function(val) {
    var old = this._toArrow;
    if (val === true) val = 'Standard';
    else if (val === false) val = 'None';
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'string', Shape, 'toArrow');
      var cval = Geo.findArrowheadGeometry(val);
      if (cval instanceof Geometry) {
        cval = val;  // VAL is already in canonical form
      } else {
        cval = Geo.findArrowheadGeometry(val.toLowerCase()); // Canonicalize it
        if (!cval) Util.throwError('Unknown Shape.toArrow: ' + val);
      }
      if (old !== cval) {
        this._toArrow = cval;
        this._setGeometry = false;
        this.invalidateGeometry();
        this._setArrowheadPath(cval);
        this.raiseChanged('toArrow', old, cval);
      }
    }
  }
);

/**
* Gets or sets the name of the kind of arrowhead that this shape should take
* when this shape is an element of a {@link Link}.
* Value must be a string.
* Default is "None".
* <p/>
* The name can be any case but will always be canonicalized when set. For instance,
* setting "opentriangle" will set the value of the arrowhead to "OpenTriangle".
* <p/>
* Setting this property may also set the {@link GraphObject#segmentIndex},
* {@link GraphObject#segmentOrientation}, and {@link GraphObject#alignmentFocus} properties.
* This shape should be an element of a {@link Link}.
* @name Shape#fromArrow
* @function.
* @return {string}
*/
/** @type {string} */
Shape.prototype.fromArrow;
Util.exportProperty(Shape, 'fromArrow', Shape.prototype.fromArrow);
Util.defineProperty(Shape, { fromArrow: 'fromArrow' },
  /** @this {Shape} */
  function() { return this._fromArrow; },
  /** @this {Shape} */
  function(val) {
    var old = this._fromArrow;
    if (val === true) val = 'Standard';
    else if (val === false) val = 'None';
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'string', Shape, 'fromArrow');
      var cval = Geo.findArrowheadGeometry(val);
      if (cval instanceof Geometry) {
        cval = val;  // VAL is already in canonical form
      } else {
        cval = Geo.findArrowheadGeometry(val.toLowerCase()); // Canonicalize it
        if (!cval) Util.throwError('Unknown Shape.fromArrow: ' + val);
      }
      if (old !== cval) {
        this._fromArrow = cval;
        this._setGeometry = false;
        this.invalidateGeometry();
        this._setArrowheadPath(cval);
        this.raiseChanged('fromArrow', old, cval);
      }
    }
  }
);

/**
* @ignore
* Some shared code. More could go here later but its not urgent.
*/
Shape.prototype._setArrowheadPath = function(val) {
  var diagram = this.diagram;
  if (diagram !== null && diagram.undoManager.isUndoingRedoing) return;
  this.segmentOrientation = Link.OrientAlong;
  var alignmentSpot = Spot.MiddleRight;
  switch (val) {
    case 'halfarrowtop': alignmentSpot = Spot.BottomRight; break;
    case 'halftriangletop': alignmentSpot = Spot.BottomRight; break;
    case 'openrighttriangletop': alignmentSpot = Spot.BottomRight; break;
    case 'opentriangletop': alignmentSpot = Spot.BottomRight; break;
  }
  if (this._toArrow !== 'None') {
    this.segmentIndex = -1;
    this.alignmentFocus = alignmentSpot;
  } else if (this._fromArrow !== 'None') {
    this.segmentIndex = 0;
    this.alignmentFocus = new Spot(1 - alignmentSpot.x, alignmentSpot.y);  //Opposite horizontal alignment in Spot
  }
};

/**
* Gets or sets the top-left Spot used by some {@link Panel}s for determining where in the shape other objects may be placed.
* The value is normally {@link Spot#Default}, but you may want to set it to override the value that many {@link #figure}s use.
* @name Shape#spot1
* @function.
* @return {Spot}
*/
/** @type {Spot} */
Shape.prototype.spot1;
Util.defineProperty(Shape, { spot1: 'spot1' },
  /** @this {Shape} */
  function() { return this._spot1; },
  /** @this {Shape} */
  function(val) {
    Util.checkClass(val, Spot, Shape, 'spot1');
    var old = this._spot1;
    if (!old.equals(val)) {
      val = val.copyFrozen();
      this._spot1 = val;
      this.invalidateMeasure();
      this.raiseChanged('spot1', old, val);
    }
  }
);

/**
* Gets or sets the bottom-right Spot used by some {@link Panel}s for determining where in the shape other objects may be placed.
* The value is normally {@link Spot#Default}, but you may want to set it to override the value that many {@link #figure}s use.
* @name Shape#spot2
* @function.
* @return {Spot}
*/
/** @type {Spot} */
Shape.prototype.spot2;
Util.defineProperty(Shape, { spot2: 'spot2' },
  /** @this {Shape} */
  function() { return this._spot2; },
  /** @this {Shape} */
  function(val) {
    Util.checkClass(val, Spot, Shape, 'spot2');
    var old = this._spot2;
    if (!old.equals(val)) {
      val = val.copyFrozen();
      this._spot2 = val;
      this.invalidateMeasure();
      this.raiseChanged('spot2', old, val);
    }
  }
);

/**
* Gets or sets a property for parameterizing the construction of a {@link Geometry} from a figure.
* The meaning of this property depends on the particular figure.
* @name Shape#parameter1
* @function.
* @return {number}
*/
/** @type {number} */
Shape.prototype.parameter1;
Util.defineProperty(Shape, { parameter1: 'parameter1' },
  /** @this {Shape} */
  function() { return this._parameter1; },
  /** @this {Shape} */
  function(val) {
    var old = this._parameter1;
    if (old !== val) {
      this._parameter1 = val;
      this.invalidateMeasure();
      this.raiseChanged('parameter1', old, val);
    }
  }
);

/**
* Gets or sets a property for parameterizing the construction of a {@link Geometry} from a figure.
* The meaning of this property depends on the particular figure.
* @name Shape#parameter2
* @function.
* @return {number}
*/
/** @type {number} */
Shape.prototype.parameter2;
Util.defineProperty(Shape, { parameter2: 'parameter2' },
  /** @this {Shape} */
  function() { return this._parameter2; },
  /** @this {Shape} */
  function(val) {
    var old = this._parameter2;
    if (old !== val) {
      this._parameter2 = val;
      this.invalidateMeasure();
      this.raiseChanged('parameter2', old, val);
    }
  }
);

/**
* Gets the natural bounds of this Shape as determined by its {@link #geometry}'s bounds.
* The bounds will always include the (0,0) point.
* @name Shape#naturalBounds
* @function.
* @return {Rect}
*/
/** @type {Rect} */
Shape.prototype.naturalBounds;
Util.defineReadOnlyProperty(Shape, { naturalBounds: 'naturalBounds' },
  /** @this {Shape} */
  function() {
    if (this._geometry !== null) {
      var r = this._geometry.bounds;
      this._naturalBounds.assign(r);
      return this._naturalBounds;
    }
    var des = this.desiredSize;
    return new Rect(0, 0, des.width, des.height);
  }
);

/**
* @ignore
* Gets or sets whether the Shape is measured as a rectangle or measured more
* accurately by all of the points in its geometry. The discrepancy between these
* two can be large if there is an angle.
* @name Shape#isRectangular
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Shape.prototype.isRectangular;
Util.exportProperty(Shape, 'isRectangular', Shape.prototype.isRectangular);
Util.defineProperty(Shape, { isRectangular: 'isRectangular' },
  /** @this {Shape} */
  function() { return this._isRectangular; },
  /** @this {Shape} */
  function(val) {
    var old = this._isRectangular;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', Shape, 'isRectangular');
      this._isRectangular = val;
      this.invalidateMeasure();
      this.raiseChanged('isRectangular', old, val);
    }
  }
);

/**
* @ignore
* Gets or sets the {@link GraphObject}
* @name Shape#pathObject
* @function.
* @return {GraphObject}
*/
/** @type {GraphObject} */
Shape.prototype.pathObject;
Util.exportProperty(Shape, 'pathObject', Shape.prototype.pathObject);
Util.defineProperty(Shape, { pathObject: 'pathObject' },
  /** @this {Shape} */
  function() { return this._pathObject; },
  /** @this {Shape} */
  function(val) {
    var old = this._pathObject;
    if (old !== val) {
      if (Debug) Util.checkClass(val, GraphObject, Shape, 'pathObject');
      this._pathObject = val;
      this.invalidateDraw();
      this.raiseChanged('pathObject', old, val);
    }
  }
);

// Later we could allow this to stretch Horizontally or Vertically ??
/**
 * Gets or sets how the shape's geometry is proportionally created given its computed size.
 * Possible values are {@link GraphObject#None}, {@link GraphObject#Fill}, {@link GraphObject#Uniform}, and {@link GraphObject#Default}.
 * The default is {@link GraphObject#Default}, which resolves to {@link GraphObject#Fill} for most figures, though
 * some regular figures such as "Circle" and "Square" default to {@link GraphObject#Uniform}.
 * @name Shape#geometryStretch
 * @function.
 * @return {EnumValue}
 */
/** @type {EnumValue} */
Shape.prototype.geometryStretch;
Util.exportProperty(Shape, 'geometryStretch', Shape.prototype.geometryStretch);
Util.defineProperty(Shape, { geometryStretch: 'geometryStretch' },
  /** @this {Shape} */
  function() { return this._geometryStretch; },
  /** @this {Shape} */
  function(val) {
    var old = this._geometryStretch;
    if (old !== val) {
      Util.checkEnumValue(val, GraphObject, Shape, 'geometryStretch');
      this._geometryStretch = val;
      this.raiseChanged('geometryStretch', old, val);
    }
  }
);

/**
* Gets or sets how frequently this shape should be drawn within a Grid {@link Panel},
* in multiples of the {@link Panel#gridCellSize}.
* Default is 1.  Any new value must be a positive integer.
* @name Shape#interval
* @function.
* @return {number}
*/
/** @type {number} */
Shape.prototype.interval;
Util.exportProperty(Shape, 'interval', Shape.prototype.interval);
Util.defineProperty(Shape, { interval: 'interval' },
  /** @this {Shape} */
  function() { return this._interval; },
  /** @this {Shape} */
  function(val) {
    var old = this._interval;
    if (Debug) Util.checkRealNumber(val, Shape, 'interval');
    val = Math.floor(val);
    if (old !== val) {
      // On setting, negative, infinite, and NaN values must be ignored
      if (val >= 0) {
        this._interval = val;
        this.invalidateMeasure();
        this.raiseChanged('interval', old, val);
      }
    }
  }
);

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/**
 * A newly constructed {@link TextBlock} has no string to show; if it did,
 * it would draw the text, wrapping if needed, in the default font using a black stroke.
 * @constructor
 * @extends GraphObject
 * @class
 * A TextBlock is a {@link GraphObject} that displays a {@link #text} string in a given {@link #font}.
 * <p>
 * The size and appearance of the text is specified by {@link #font},
 * which takes a well-formed CSS string as its value.
 * The order of the CSS properties given is important for cross-browser compatibility,
 * and should be given in this order:
 * <p>
 * <em>"font-style font-variant font-weight font-size font-family"</em>
 * <p>
 * For example, "Italic small-caps bold 32px Georgia, Serif" is a valid font string
 * using every CSS font property.
 * <p>
 * Text is drawn using the {@link #stroke} brush, which may be any CSS color string or a {@link Brush}.
 * <p>
 * TextBlocks typically receive a natural size based on their text and font strings,
 * but often a width is given in order to cause the text to wrap at a certain place.
 * In order for wrapping to occur, the {@link #wrap} property must not be {@link TextBlock#None}.
 * <p>
 * TextBlocks can be edited by users using the {@link TextEditingTool}.
 * The HTMLElement that a given TextBlock uses as its text editor can be customized
 * by setting the {@link #textEditor} property. For an example of custom text editing tool use,
 * see the <a href="../../samples/customTextEditingTool.html">Custom TextEditingTool Sample</a>.
 * <p class="box">
 * For examples of TextBlock possibilities and functionality,
 * see the <a href="../../intro/textBlocks.html">Introduction page on TextBlocks</a>.
 */
function TextBlock() {
  GraphObject.call(this);
  /** @type {string} */
  this._text = '';
  /** @type {string|Brush} */
  this._stroke = 'black';

  /** @type {string} */
  this._font = '13px sans-serif';
  /** @type {string} */
  this._textAlign = 'start';
  /** @type {boolean} */
  this._isMultiline = true;
  /** @type {boolean} */
  this._isUnderline = false;
  /** @type {boolean} */
  this._isStrikethrough = false;

  // italics and bold are up to the user and we have no way of controlling them
  // (short of parsing the 'text' property)
  /** @type {EnumValue} */
  this._wrap = TextBlock.WrapDesiredSize;

  /** @type {number} */
  this._lineCount = 0;
  // this is the absolute line position of the measured text
  // it is used to determine if we need to crop text
  /** @type {number} */
  this._maxPosition = 0;

  // Invalidated along with measure, cached from measure
  // ?? they may not be necessary
  /** @type {?number} */
  this._measuredWidth = null;
  /** @type {?number} */
  this._measuredHeight = null;
  /** @type {?number} */
  this._fontHeight = null;

  // Created in measure and used in drawing
  /** @type {Object} */
  this._lines = {};  //??? anonymous class

  /** @type {boolean} */
  this._editable = false;
  /** @type {HTMLElement} */
  this._textEditor = null;
  /** @type {function(TextBlock, string, string):boolean | null} */
  this._textValidation = null;
  //??? this._textAspectRatio = 1.5;

  /** @type {function(TextEditingTool, string, string) | null} */
  this._errorFunction = null;
}

Util.publish('TextBlock', TextBlock);

Util.inherit(TextBlock, GraphObject);

/**
* @ignore
* Copies properties to a cloned TextBlock.
* @this {TextBlock}
* @param {GraphObject} copy
*/
TextBlock.prototype.cloneProtected = function(copy) {
  GraphObject.prototype.cloneProtected.call(this, copy);
  copy._text = this._text;
  copy._stroke = this._stroke;

  copy._font = this._font;
  copy._textAlign = this._textAlign;
  copy._isMultiline = this._isMultiline;
  copy._isUnderline = this._isUnderline;
  copy._isStrikethrough = this._isStrikethrough;

  copy._wrap = this._wrap;

  copy._lineCount = this._lineCount;
  copy._maxPosition = this._maxPosition;

  copy._measuredWidth = this._measuredWidth;
  copy._measuredHeight = this._measuredHeight;
  copy._fontHeight = this._fontHeight;

  // _lines was recomputed, but now that leaf objects do not invalidate on copy it is kept
  copy._lines = this._lines;


  copy._editable = this._editable;
  copy._textEditor = this._textEditor;
  copy._textValidation = this._textValidation;

  copy._errorFunction = this._errorFunction;
};

/**
* @ignore
* @this {TextBlock}
* @return {string}
*/
TextBlock.prototype.toString = function() {
  if (this._text.length > 22)
    return 'TextBlock("' + this._text.substring(0, 20) + '"...)';
  else
    return 'TextBlock("' + this._text + '")';
};


/**
* The TextBlock will not wrap its text.
* @name TextBlock#None
* @constant
* @static
* @return {EnumValue}
*/
TextBlock['None'] = TextBlock.None = Util.defineEnumValue(TextBlock, 'None', 0);

/**
* The TextBlock will wrap text, making the width of the TextBlock equal to the width of the longest line.
* @name TextBlock#WrapFit
* @constant
* @static
* @return {EnumValue}
*/
TextBlock['WrapFit'] = TextBlock.WrapFit = Util.defineEnumValue(TextBlock, 'WrapFit', 1);

/**
* The TextBlock will wrap text and the width of the TextBlock will be the desiredSize's width, if any.
* @name TextBlock#WrapDesiredSize
* @constant
* @static
* @return {EnumValue}
*/
TextBlock['WrapDesiredSize'] = TextBlock.WrapDesiredSize = Util.defineEnumValue(TextBlock, 'WrapDesiredSize', 2);


/**
* @ignore
* Call GraphObject's invalidateMeasure and invalidate private cached data
* @this {TextBlock}
*/
TextBlock.prototype.invalidateMeasure = function() {
  GraphObject.prototype.invalidateMeasure.call(this);
  this._measuredWidth = null;
  this._measuredHeight = null;
};

/**
 * Gets or sets the current font settings.
 * The font property must be a valid CSS string describing a font.
 * The font string can accept several CSS properties but they must be
 * in a specific order in order to render correctly across all browsers:
 * <p>
 * <em>"font-style font-variant font-weight font-size font-family"</em>
 * <p>
 * For example, "Italic small-caps bold 32px Georgia, Serif" is a valid font string
 * using every CSS font property.
 * For more information about CSS font syntax, see <a href="http://developer.mozilla.org/en-US/docs/Web/CSS/font">CSS fonts</a>.
 * <p>
 * The default is "10px sans-serif".
 * @name TextBlock#font
 * @function.
 * @return {string}
 */
/** @type {string} */
TextBlock.prototype.font;
Util.exportProperty(TextBlock, 'font', TextBlock.prototype.font);
Util.defineProperty(TextBlock, {font: 'font'},
  /** @this {TextBlock} */
  function() { return this._font; },
  /** @this {TextBlock} */
  function(val) {
    var old = this._font;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'string', TextBlock, 'font');
      this._font = val;
      this._fontHeight = null;
      this.invalidateMeasure();
      this.raiseChanged('font', old, val);
    }
  }
);

/**
 * Gets or sets the current text string. The default is an empty string.
 * The text of a TextBlock, along with the values of {@link #font}, {@link #wrap},
 * {@link #isMultiline} and sizing restrictions are what naturally determine
 * the size of the TextBlock.
 * @name TextBlock#text
 * @function.
 * @return {string}
 */
/** @type {string} */
TextBlock.prototype.text;
Util.exportProperty(TextBlock, 'text', TextBlock.prototype.text);
Util.defineProperty(TextBlock, { text: 'text' },
  /** @this {TextBlock} */
  function() { return this._text; },
  /** @this {TextBlock} */
  function(val) {
    var old = this._text;
    // convert the new value to be a string, if necessary
    if (val !== null && val !== undefined) {
      val = val.toString();
    } else {
      val = '';
    }
    if (old !== val) {
      this._text = val;
      this.invalidateMeasure();
      this.raiseChanged('text', old, val);
    }
  }
);

/**
 * Gets or sets the current text alignment property.
 * The possible values are "start", "end", "left", "right", and "center".
 * Any other value is invalid.
 * The default is "start".
 * @name TextBlock#textAlign
 * @function.
 * @return {string}
 */
/** @type {string} */
TextBlock.prototype.textAlign;
Util.exportProperty(TextBlock, 'textAlign', TextBlock.prototype.textAlign);
Util.defineProperty(TextBlock, {textAlign: 'textAlign'},
  /** @this {TextBlock} */
  function() { return this._textAlign; },
  /** @this {TextBlock} */
  function(val) {
    var old = this._textAlign;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'string', TextBlock, 'textAlign');
      if (val === 'start' || val === 'end' || val === 'left' ||
          val === 'right' || val === 'center') {
        this._textAlign = val;
        this.invalidateDraw();
        this.raiseChanged('textAlign', old, val);
      } else {
        Util.throwRangeError(val, '"start", "end", "left", "right", or "center"', TextBlock, 'textAlign');
      }
    }
  }
);

/**
 * Gets the natural bounds of this TextBlock in local coordinates,
 * as determined by its {@link #font} and {@link #text} string.
 * @name TextBlock#naturalBounds
 * @function.
 * @return {Rect}
 */
/** @type {Rect} */
TextBlock.prototype.naturalBounds;
Util.defineReadOnlyProperty(TextBlock, {naturalBounds: 'naturalBounds'},
  /** @this {TextBlock} */
  function() {
    if (!this._naturalBounds.isReal()) {
      // Usually happens in measureProtected
      var sz = this.measureString(this._text, {}, 999999);
      var w = sz.width;
      var h = this.computeHeight(w, {});
      var ds = this.desiredSize;
      if (!isNaN(ds.width)) w = ds.width;
      if (!isNaN(ds.height)) h = ds.height;
      var nb = this._naturalBounds;
      nb.setWidthHeight(w, h);
    }
    return this._naturalBounds;
  }
);

/**
 * Gets or sets whether or not the text allows or displays multiple lines or embedded newlines.
 * If this is false, all characters after the first newline will be omitted. Default is true.
 * @name TextBlock#isMultiline
 * @function.
 * @return {boolean}
 */
/** @type {boolean} */
TextBlock.prototype.isMultiline;
Util.exportProperty(TextBlock, 'isMultiline', TextBlock.prototype.isMultiline);
Util.defineProperty(TextBlock, {isMultiline: 'isMultiline'},
  /** @this {TextBlock} */
  function() { return this._isMultiline; },
  /** @this {TextBlock} */
  function(val) {
    var old = this._isMultiline;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', TextBlock, 'isMultiline');
      this._isMultiline = val;
      this.invalidateMeasure();
      this.raiseChanged('isMultiline', old, val);
    }
  }
);

/**
 * Gets or sets whether or not the text is underlined. Default false.
 * @name TextBlock#isUnderline
 * @function.
 * @return {boolean}
 * @since 1.2
 */
/** @type {boolean} */
TextBlock.prototype.isUnderline;
Util.exportProperty(TextBlock, 'isUnderline', TextBlock.prototype.isUnderline);
Util.defineProperty(TextBlock, {isUnderline: 'isUnderline'},
  /** @this {TextBlock} */
  function() { return this._isUnderline; },
  /** @this {TextBlock} */
  function(val) {
    var old = this._isUnderline;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', TextBlock, 'isUnderline');
      this._isUnderline = val;
      this.invalidateDraw();
      this.raiseChanged('isUnderline', old, val);
    }
  }
);

/**
 * Gets or sets whether or not the text has a strikethrough line (line-through). Default false.
 * @name TextBlock#isStrikethrough
 * @function.
 * @return {boolean}
 * @since 1.2
 */
/** @type {boolean} */
TextBlock.prototype.isStrikethrough;
Util.exportProperty(TextBlock, 'isStrikethrough', TextBlock.prototype.isStrikethrough);
Util.defineProperty(TextBlock, {isStrikethrough: 'isStrikethrough'},
  /** @this {TextBlock} */
  function() { return this._isStrikethrough; },
  /** @this {TextBlock} */
  function(val) {
    var old = this._isStrikethrough;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', TextBlock, 'isStrikethrough');
      this._isStrikethrough = val;
      this.invalidateDraw();
      this.raiseChanged('isStrikethrough', old, val);
    }
  }
);

/**
 * Gets or sets whether the text should be wrapped if it is too long to fit on one line.
 * @name TextBlock#wrap
 * @function.
 * @return {EnumValue}
 */
/** @type {EnumValue} */
TextBlock.prototype.wrap;
Util.exportProperty(TextBlock, 'wrap', TextBlock.prototype.wrap);
Util.defineProperty(TextBlock, {wrap: 'wrap'},
  /** @this {TextBlock} */
  function() { return this._wrap; },
  /** @this {TextBlock} */
  function(val) {
    var old = this._wrap;
    if (old !== val) {
      if (Debug) Util.checkEnumValue(val, TextBlock, TextBlock, 'wrap');
      this._wrap = val;
      this.invalidateMeasure();
      this.raiseChanged('wrap', old, val);
    }
  }
);

/**
 * Gets or sets the {@link Brush} or string that describes the stroke (color) of the {@link #font}.
 * <p>
 * The default value is "black".
 * Any valid CSS string can specify a solid color, and the {@link Brush}
 * class can be used to specify a gradient or pattern.
 * More information about the syntax of CSS color strings is available at:
 * <a href="http://developer.mozilla.org/en-US/docs/Web/CSS/color">CSS colors</a>.
 * @name TextBlock#stroke
 * @function.
 * @return {string|Brush}
 */
/** @type {string|Brush} */
TextBlock.prototype.stroke;
Util.exportProperty(TextBlock, 'stroke', TextBlock.prototype.stroke);
Util.defineProperty(TextBlock, {stroke: 'stroke'},
  /** @this {TextBlock} */
  function() { return this._stroke; },
  /** @this {TextBlock} */
  function(val) {
    var old = this._stroke;
    if (old !== val) {
      if (val === null || typeof val === 'string' || val instanceof Brush) {
        if (val instanceof Brush) val.freeze();
        this._stroke = val;
        this.invalidateDraw();
        this.raiseChanged('stroke', old, val);
      }
    }
  }
);

/**
* Gets the total number of lines in this TextBlock, including lines created from returns and wrapping.
* This value may be meaningless before the TextBlock is measured.
* @name TextBlock#lineCount
* @function.
* @return {number}
*/
/** @type {number} */
TextBlock.prototype.lineCount;
Util.defineReadOnlyProperty(TextBlock, {lineCount: 'lineCount'},
  /** @this {TextBlock} */
  function() { return this._lineCount; }
);

/**
 * Gets or sets whether or not this TextBlock allows in-place editing of the {@link #text}
 * string by the user with the help of the {@link TextEditingTool}.
 * The default is false.
 * @name TextBlock#editable
 * @function.
 * @return {boolean}
 */
/** @type {boolean} */
TextBlock.prototype.editable;
Util.exportProperty(TextBlock, 'editable', TextBlock.prototype.editable);
Util.defineProperty(TextBlock, {editable: 'editable'},
  /** @this {TextBlock} */
  function() { return this._editable; },
  /** @this {TextBlock} */
  function(val) {
    var old = this._editable;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', TextBlock, 'editable');
      this._editable = val;
      this.raiseChanged('editable', old, val);
    }
  }
);

/**
 * Gets or sets the HTMLElement that this TextBlock uses as its text editor in the TextEditingTool.
 * If null, the TextBlock will use the default text editor of the {@link TextEditingTool}. The default is null.
 * @name TextBlock#textEditor
 * @function.
 * @return {HTMLElement}
 */
/** @type {HTMLElement} */
TextBlock.prototype.textEditor;
Util.exportProperty(TextBlock, 'textEditor', TextBlock.prototype.textEditor);
Util.defineProperty(TextBlock, {textEditor: 'textEditor'},
  /** @this {TextBlock} */
  function() { return this._textEditor; },
  /** @this {TextBlock} */
  function(val) {
    var old = this._textEditor;
    if (old !== val) {
      if (!(val instanceof HTMLElement)) Util.throwError('textEditor must be an HTMLElement');
      this._textEditor = val;
      this.raiseChanged('textEditor', old, val);
    }
  }
);

/**
 * Gets or sets the function to call if a text edit made with the {@link TextEditingTool} is invalid.
 * The default is null.
 * @name TextBlock#errorFunction
 * @function.
 * @return {function(TextEditingTool, string, string) | null}
 */
/** @type {function(TextEditingTool, string, string) | null} */
TextBlock.prototype.errorFunction;
Util.exportProperty(TextBlock, 'errorFunction', TextBlock.prototype.errorFunction);
Util.defineProperty(TextBlock, { errorFunction: 'errorFunction' },
  /** @this {TextBlock} */
  function() { return this._errorFunction; },
  /** @this {TextBlock} */
  function(val) {
    var old = this._errorFunction;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', TextBlock, 'errorFunction');
      this._errorFunction = val;
      this.raiseChanged('errorFunction', old, val);
    }
  }
);

/**
 * @ignore
 * Draw the TextBlock to a specified context.
 * @this {TextBlock}
 * @param {CanvasRenderingContext2D} context A Canvas 2D Context for drawing.
 * @param {Diagram} diagram
 */
TextBlock.prototype.drawProtected = function(context, diagram) {
  if (this._stroke === null) return;
  if (this._text.length === 0) return;
  var font = this._font;
  if (font === null) return;
  var maxw = this.naturalBounds.width;
  var fheight = this.getStringHeight();

  if (context.__cachedFont !== font) {
    context.font = font;
    context.__cachedFont = font;
  }
  context.textAlign = this._textAlign;
  //context.textBaseline = 'alphabetic'; // 'top' would make this cleaner but is not consistent across all browsers

  this.setBrush(context, this._stroke, true);
  if (this._isUnderline || this._isStrikethrough) {
    this.setBrush(context, this._stroke, false);
  }

  // lines is saved from measure and used only for drawing. It contains information about line size and text
  var lines = this._lines;

  var x = 0;
  var y = 0;
  var width = maxw;
  var height = fheight;

  var simple = false;
  var a = Util.tempPointAt(0, 0);
  this.allTransforms.transformPoint(a);
  var b = Util.tempPointAt(0, fheight);
  this.allTransforms.transformPoint(b);
  var distsq = a.distanceSquaredPoint(b);
  Util.freePoint(a);
  Util.freePoint(b);
  var sc = diagram.scale;
  distsq = distsq * sc * sc;
  if (distsq < 8) simple = true;

  // We have arrSize and arrText
  var l = lines.arrSize.length;
  for (var i = 0; i < l; i++) {
    var sw = lines.arrSize[i];
    var text = lines.arrText[i];

    if (sw > width) sw = width;
    this.drawPart(text, context, x, y, width, height, sw, simple);
    y += fheight;
  }
};

/**
* @ignore
* Draw one line of a string to a context
* @param {string} line
* @param {CanvasRenderingContext2D} context
* @param {number} rx
* @param {number} ry
* @param {number} rw
* @param {number} rh
* @param {number} stringwidth
* @param {boolean} simple whether or not to draw a line (greeking) instead of text at small sizes.
*/
TextBlock.prototype.drawPart = function(line, context, rx, ry, rw, rh, stringwidth, simple) {
  var offset = 0;

  if (simple) {
    // offsetting a line is different than offsetting text!
    if (this._textAlign === 'start' || this._textAlign === 'left') {
      offset = 0;
    } else if (this._textAlign === 'end' || this._textAlign === 'right') {
      offset = rw - stringwidth;
    } else if (this._textAlign === 'center') {
      offset = (rw - stringwidth) / 2;
    } else {
      Util.throwError('textAlign must be start, end, left, right, or center');
    }

    // Greeking: just draw a line (rects are faster than paths so use a rect)
    context.fillRect(rx + offset, ry + (rh * .25), stringwidth, 1);
    return;
  }

  // if the textBaseline was 'top' the y coordinate of fillText would have to be something like:
  // ry - (rh * .15));
  if (this._textAlign === 'start' || this._textAlign === 'left') {
    offset = 0;
  } else if (this._textAlign === 'end' || this._textAlign === 'right') {
    offset = rw;
  } else if (this._textAlign === 'center') {
    offset = rw / 2;
  } else {
    Util.throwError('textAlign must be start, end, left, right, or center');
  }

  context.fillText(line, rx + offset, ry + rh - (rh * .25));

  var lh = ((rh / 20) | 0);
  if (this._isUnderline) {
    if (this._textAlign === 'end' || this._textAlign === 'right') {
      offset -= stringwidth;
    } else if (this._textAlign === 'center') {
      offset -= (stringwidth / 2);
    }
    context.beginPath();
    context.lineWidth = lh;
    context.moveTo(rx + offset, ry + rh - (rh * .20));
    context.lineTo(rx + offset + stringwidth, ry + rh - (rh * .20));
    context.stroke();
  }
  if (this._isStrikethrough) {
    context.beginPath();
    context.lineWidth = lh;
    var y = (ry + rh - (rh / 2.2)) | 0;
    if (lh % 2 !== 0) y += 0.5; // If the line height is odd, draw on halfpixel
    context.moveTo(rx, y);
    context.lineTo(rx + stringwidth, y);
    context.stroke();
  }
};

/**
 * @ignore
 * @this {TextBlock}
 * @param {number} width
 * @param {number} height
 * @param {number} minw
 * @param {number} minh
 */
TextBlock.prototype.measureProtected = function(width, height, minw, minh) {
  var lines = {}; // needed to keep track of longest line
  var w = 0;
  var h = 0;
  if (!isNaN(this.desiredSize.width)) {
    w = this.desiredSize.width;
  } else {
    w = this.computeWidth();
    // comparing local width to panel width so divide panel width by scale
    w = Math.min(w, width / this.scale);
    w = Math.max(8, w);
  }
  // measuring text needs to know this sooner rather than later
  // since the width affects the height
  if (this.panel) {
    w = Math.min(w, this.panel.maxSize.width);
    w = Math.max(w, this.panel.minSize.width);
  }
  // This computes lines, an object that holds information about wrapping
  h = this.computeHeight(w, lines);
  if (!isNaN(this.desiredSize.height)) {
    h = this.desiredSize.height;
  } else {
    // comparing local width to panel height so divide panel height by scale
    h = Math.min(h, height / this.scale);
  }

  if (this.wrap === TextBlock.WrapFit || isNaN(this.desiredSize.width)) {
    w = lines.maxLineWidth;
    if (isNaN(this.desiredSize.width)) w = Math.max(8, w);
  }

  w = Math.max(minw, w);
  // Arbitrary minimum width:

  h = Math.max(minh, h);


  var nb = this._naturalBounds;
  nb.setWidthHeight(w, h);
  this._measureRect(0, 0, w, h);

  // used in drawing:
  this._lines = lines;
}; // end measure

/**
 * @ignore
 * Arranges the TextBlock onto its panel.
 * @this {TextBlock}
 * @param {number} fx
 * @param {number} fy
 * @param {number} fw
 * @param {number} fh
 */
TextBlock.prototype.arrangeProtected = function(fx, fy, fw, fh) {
  this.commonArrange(fx, fy, fw, fh);
};

// STR has no embedded newlines
// lines is an out var
/**
 * @ignore
 * @this {TextBlock}
 * @param {string} str
 * @param {Object} lines
 * @param {number} maxw
 */
TextBlock.prototype.measureString = function(str, lines, maxw) {
  //if (this.getInvalidMeasure() === false) return this.naturalBounds; // ???? should work but untested
  str = str.replace(/^\s+|\s+$/g, '');
  if (lines.maxLineWidth === undefined) lines.maxLineWidth = 0;
  if (lines.arrSize === undefined) lines.arrSize = [];
  if (lines.arrText === undefined) lines.arrText = [];
  var maxLineWidth = 0;
  var tempWidth;
  var lineWidth;
  var font = this._font;

  if (this._wrap === TextBlock.None) {
    lines.val = 1;
    lines.maxLineWidth = this.getStringWidth(str, font);
    lines.arrSize.push(lines.maxLineWidth);
    lines.arrText.push(str);
    return new Size(lines.maxLineWidth, this.getStringHeight());
  } else {
    // wrapping width is maximum allowed width
    var ww = maxw;

    var fheight = this.getStringHeight();

    var line = str;
    var numlines = 0;
    if (line.length === 0) {
      numlines = 1;
      lines.arrSize.push(0);
      lines.arrText.push(line);
    }
    while (line.length > 0) { // num of characters in line
      var part = this.getFirstWord(line);
      line = line.substr(part.length);
      // if first part doesn't fit, just display as much as we can
      while (this.getStringWidth(part, font) > ww) {
        var l = 1;
        // get the biggest prefix of the part that will fit

        tempWidth = this.getStringWidth(part.substr(0, l), font);
        lineWidth = 0;
        while (tempWidth <= ww) {
          l++;
          lineWidth = tempWidth;
          tempWidth = this.getStringWidth(part.substr(0, l), font);
        }
        // push the valid line width determined by when the while loop ends
        if (l === 1) {
          lines.arrSize[numlines] = tempWidth;
          maxLineWidth = Math.max(maxLineWidth, tempWidth);
        } else {
          lines.arrSize[numlines] = lineWidth;
          maxLineWidth = Math.max(maxLineWidth, lineWidth);
        }

        l--;  // remember the number of characters that fit
        if (l < 1) l = 1;  // always take at least one character
        var prefix = part.substr(0, l);
        // prefix is now the part of this long word that fits
        lines.arrText[numlines] = prefix;
        numlines++;
        // now continue with the rest of this very long word
        part = part.substr(l);
      }
      // now PART fits in the WW width, see if we can add any more words that fit

      var nextword = this.getFirstWord(line);

      tempWidth = this.getStringWidth(part + nextword, font);
      lineWidth = 0;

      while (nextword.length > 0 && tempWidth <= ww) {
        part += nextword;
        line = line.substr(nextword.length);
        nextword = this.getFirstWord(line);
        lineWidth = tempWidth;
        tempWidth = this.getStringWidth((part + nextword).replace(/^\s+|\s+$/g, ''), font);
      }

      // Trim the spaces before and after part. lineWidth is already correct.
      part = part.replace(/^\s+|\s+$/g, '');
      if (part === '') continue;

      // push the valid line width determined by when the while loop ends
      if (nextword.length === 0) {
        lines.arrSize.push(tempWidth);
        maxLineWidth = Math.max(maxLineWidth, tempWidth);
      } else {
        lineWidth = this.getStringWidth(part, font);
        lines.arrSize.push(lineWidth);
        maxLineWidth = Math.max(maxLineWidth, lineWidth);
      }
      lines.arrText.push(part);
      numlines++;
    }
    lines.val = numlines;
    lines.maxLineWidth = Math.max(lines.maxLineWidth, maxLineWidth);
    return new Size(lines.maxLineWidth, fheight * lines.val);
  }
};

// for manual wrapping
/**
 * @ignore
 * @this {TextBlock}
 * @param {string} str
 */
TextBlock.prototype.getFirstWord = function(str) {
  var len = str.length;
  var i = 0;
  // scan characters until we get to whitespace again
  while (i < len && str.charAt(i) !== ' ') i++;
  // include trailing whitespace
  while (i < len && str.charAt(i) === ' ') i++;
  if (i >= len)
    return str;
  else
    return str.substr(0, i);
};

//mostly pass in this._font ?
/**
 * @ignore
 * @this {TextBlock}
 * @param {string} str
 * @param {string} font
 */
TextBlock.prototype.getStringWidth = function(str, font) {
    if (Util.sharedTempFont !== font) {
      Util.sharedTempCtx.font = font;
      Util.sharedTempFont = font;
    }
    var metrics = Util.sharedTempCtx.measureText(str);
    return metrics.width;
};

/**
 * @ignore
 * @this {TextBlock}
 */
TextBlock.prototype.getStringHeight = function() {
    if (this._fontHeight !== null) return this._fontHeight; // ?? is this a worthwhile optimization?
    var font = this._font;

    if (Util.sharedTempFont !== font) {
      Util.sharedTempCtx.font = font;
      Util.sharedTempFont = font;
    }
    var m = 0;
    if (Util.fontHeightMap[font] !== undefined && Util.fontHeightMapCount < 5000) {
      m = Util.fontHeightMap[font];
    } else {
      var metrics = Util.sharedTempCtx.measureText('M');
      m = metrics.width * 1.3; //30% more to get the titles of i and j
      Util.fontHeightMap[font] = m;
      Util.fontHeightMapCount++;
    }
    this._fontHeight = m;
    return m;
};

/**
* @ignore
* @this {TextBlock}
* @param {string} str
* @param {number} start
* @param {Object} nextline a reference object. Not always used, so sometimes passed as anonymous object.
*/
TextBlock.prototype.findFirstLineBreak = function(str, start, nextline) {
  if (nextline.val === undefined) nextline.val = 0;
  var found = str.indexOf('\r', start);
  if (found === -1) { found = str.indexOf('\n', start); }

  if (found >= 0) {
    if (str[found] === '\r' && found + 1 < str.length && str[found + 1] === '\n') {
      nextline.val = found + 2;
    } else {
      nextline.val = found + 1;
    }
  }
  return found;
};

/**
* @ignore
* @this {TextBlock}
* @param {number} maxw
* @param {Object} lines an object reference that must be newly created.
*/
TextBlock.prototype.computeHeight = function(maxw, lines) {
  var str = this._text;
  var font = this._font;
  var fheight = this.getStringHeight();

  if (str.length === 0) {
    lines.maxLineWidth = 0;
    this._lineCount = 1;
    return fheight;
  }

  if (!this.isMultiline) {
    var newline = this.findFirstLineBreak(str, 0, {});
    if (newline >= 0)
      str = str.substr(0, newline);
  }

  var linePos = 0;
  var lineCount = 0;
  var startingIndex = 0;
  var endingIndex = -1;
  var nextline = {};
  nextline.val = 0;
  var done = false;
  while (!done) {
    endingIndex = this.findFirstLineBreak(str, startingIndex, nextline);

    // if there is no newline, then we use the rest of the string
    if (endingIndex === -1) {
      endingIndex = str.length;
      done = true;
    }

    if (startingIndex <= endingIndex) {  // we have a logical line
      var line = str.substr(startingIndex, endingIndex - startingIndex);
      if (this._wrap !== TextBlock.None) {
        lines.val = 0;
        var s = this.measureString(line, lines, maxw);
        linePos += s.height;
        lineCount += lines.val;
      } else {
        // measureString must still be called to compute 'lines'
        this.measureString(line, lines, Infinity);
        linePos += fheight;
        lineCount++;
      }
    }
    startingIndex = nextline.val; // move to the next line
  }
  this._lineCount = lineCount;
  this._maxPosition = linePos;
  return linePos;
};

/**
* @ignore
* @this {TextBlock}
*/
TextBlock.prototype.computeWidth = function() {
  var str = this._text;
  if (str.length === 0) {
    return 0;
  }

  if (this.isMultiline) {
    var maxWidth = 0;
    var startingIndex = 0;
    var done = false;

    var nextline = {};
    nextline.val = 0;
    while (!done) {
      var endingIndex = this.findFirstLineBreak(str, startingIndex, nextline);

      // if there is no newline, then we use the rest of the string
      if (endingIndex === -1) {
        endingIndex = str.length;
        done = true;
      }

      var line = str.substr(startingIndex, endingIndex - startingIndex);
      var width = this.getStringWidth(line.replace(/^\s+|\s+$/g, ''), this._font);
      if (width > maxWidth) { maxWidth = width; }

      // move to the next line
      startingIndex = nextline.val;
    }
    return maxWidth;
  } else {
    var newline = this.findFirstLineBreak(str, 0, {});
    if (newline >= 0)
      str = str.substr(0, newline);
    var width = this.getStringWidth(str, this._font);
    return width;
  }
};

/**
* @ignore
* Gets the row with the largest number of columns for sizing a textArea
* @this {TextBlock}
*/
TextBlock.prototype.getMaxCols = function() {
  var lines = this._lines;
  if (lines === null) return 20; // default?
  var max = 1;
  var text = lines.arrText;
  if (text === undefined) return 1;
  var l = text.length;
  for (var i = 0; i < l; i++) {
    max = Math.max(text[i].length, max);
  }
  return max;
};


/**
 * Gets or sets the predicate that determines whether or not a string of text is valid.
 * The default predicate is null, which is equivalent to simply returning true.
 * <p>
 * The function, if supplied, must not have any side-effects.
 * @name TextBlock#textValidation
 * @function.
 * @return {function(TextBlock, string, string):boolean | null}
 */
/** @type {function(TextBlock, string, string):boolean | null} */
TextBlock.prototype.textValidation;
Util.exportProperty(TextBlock, 'textValidation', TextBlock.prototype.textValidation);
Util.defineProperty(TextBlock, {textValidation: 'textValidation'},
  /** @this {TextBlock} */
  function() { return this._textValidation; },
  /** @this {TextBlock} */
  function(val) {
    var old = this._textValidation;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', TextBlock, 'textValidation');
      this._textValidation = val;
      this.raiseChanged('textValidation', old, val);
    }
  }
);

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/**
* The constructor creates a picture that shows nothing until the
* {@link #source} or {@link #element} is specified. It is also common to specify the
* {@link GraphObject#desiredSize} to make sure that the picture's size is known
* before the image is loaded asynchronously, so that layouts do not need to be recomputed.
* @constructor
* @extends GraphObject
* @class
* A Picture is a {@link GraphObject} that shows an image, video-frame, or Canvas element.
* <p>
* You can specify what to show by either setting the {@link #source} URL property
* to a URL string or the {@link #element} property to an HTMLImageElement,
* HTMLCanvasElement, or HTMLVideoElement.
* <p>
* If a {@link #source} URL is set, the Picture will automatically create a corresponding
* HTMLImageElement and retain a reference to it in memory. If multiple Pictures specify
* the same {@link #source} URL then they will all refer to the same HTMLImageElement.
* <p>
* If an element is not completely loaded during Diagram initialization, a redraw may occur,
* and if an image's size is not known before loading, the containing Part of this Picture
* may be resized, causing side effects such as layouts.
* <p>
* With some images (notably sprite sheets) only a portion of the image is expected to be drawn.
* The {@link #sourceRect} property allows the programmer to specify a rectangular area of
* the source image that the Picture should display.
* <p>
* The {@link #imageStretch} property allows an image to be resized inside of its bounding box.
* This property does not change the size of the Picture element, it only resizes or re-scales
* the image to fit (or not) in its bounds.
* <p class="box">
* For examples of sizing and {@link #imageStretch}, see the <a href="../../intro/pictures.html">Introduction page on Pictures</a>.
* <p>
* The {@link #errorFunction} property allows one to set a function to call when a source fails to load.
* This is useful in instances where images cannot be guaranteed to work, such as with
* user specified input. The error function can set the {@link #source} to a known good value,
* but care should be taken to avoid error infinite loops when doing so.
*/
function Picture() {
  GraphObject.call(this);
  /** @type {HTMLImageElement | HTMLVideoElement | HTMLCanvasElement} */
  this._element = null;
  /** @type {string} */
  this._source = '';
  /** @type {Rect} */
  this._sourceRect = new Rect(NaN, NaN, NaN, NaN).freeze();
  /** @type {EnumValue} */
  this._imageStretch = GraphObject.Fill;
  /** @type {function(Picture, Event) | null} */
  this._errorFunction = null;

  /** @type {?boolean} */
  this._tainted = null;
  /** @type {boolean} */
  this._loaded = false;
  /** @type {boolean} */
  this._isCanvas = false;
}

Util.publish('Picture', Picture);

Util.inherit(Picture, GraphObject);

/**
* @ignore
* Copies properties to a cloned Picture.
* @this {Picture}
* @param {GraphObject} copy
*/
Picture.prototype.cloneProtected = function(copy) {
  GraphObject.prototype.cloneProtected.call(this, copy);
  copy.element = this._element;  // shared
  copy._source = this._source;
  copy._sourceRect.assign(this._sourceRect);
  copy._imageStretch = this._imageStretch;
  copy._errorFunction = this._errorFunction;

  // _tainted and _loaded and _isCanvas are transient
};

/**
* @ignore
* @this {Picture}
* @return {string}
*/
Picture.prototype.toString = function() {
  return 'Picture(' + this.source + ')#' + Util.hashId(this);
};

/**
 * Gets or sets the Picture's HTML element. This can be a HTMLImageElement, HTMLVideoElement, or HTMLCanvasElement.
 * If an image, this element must have its source (src) attribute defined.
 * Setting this does not set the {@link Picture#source} attribute and that attribute may be unknowable.
 * @name Picture#element
 * @function.
 * @return {HTMLImageElement | HTMLVideoElement | HTMLCanvasElement}
 */
/** @type {HTMLImageElement | HTMLVideoElement | HTMLCanvasElement} */
Picture.prototype.element;
Util.exportProperty(Picture, 'element', Picture.prototype.element);
Util.defineProperty(Picture, { element: 'element' },
  /** @this {Picture} */
  function() { return this._element; },
  /** @this {Picture} */
  function(val) {
    var old = this._element;
    if (old !== val) {
      if (!(val instanceof HTMLImageElement || val instanceof HTMLVideoElement || val instanceof HTMLCanvasElement)) {
        Util.throwError('Picture.element must be an instance of Image, Canvas, or Video.');
      }

      var pic = this;
      if (val instanceof HTMLCanvasElement) {
        this._isCanvas = true;
      } else {
        this._isCanvas = false;
        /** @ignore */
        val.onerror = function(e) {
          if (pic._errorFunction !== null) pic._errorFunction(pic, e);
        };
      }

      this._element = val;
      if (val.complete === true || val.complete === undefined) {
        this._loaded = true;
        if (!this.desiredSize.isReal()) {
          this.setInvalidMeasure(false);
          this.invalidateMeasure();
        }
      } else {
        Util.unloadedImages.push(this);
        if (Util.pictureInterval === null) {
          Util.pictureInterval = setInterval(function() {
            var leftToLoad = [];
            var imgs = Util.unloadedImages;
            var l = imgs.length;
            for (var i = 0; i < l; i++) {
              var pic = imgs[i];
              if (!pic.tryLoading()) leftToLoad.push(pic);
            }
            if (leftToLoad.length === 0) {
              clearInterval(Util.pictureInterval);
              Util.pictureInterval = null;
            }
            Util.unloadedImages = leftToLoad;
        }, 200);
        }
      }
      this.raiseChanged('element', old, val);
      this.invalidateDraw();
    }
  }
);

/**
* @ignore
* @this {Picture}
*/
Picture.prototype.tryLoading = function() {
  var elem = this._element;
  if (!elem) return true;
  if (!elem.complete) return false;
  this._loaded = true;
  if (!this.desiredSize.isReal()) {
    this.setInvalidMeasure(false);
    this.invalidateMeasure();
  }
  if (this.diagram) {
    // Calling invalidateMeasure here causes links to get re-rerouted.
    // But it is necessary because the loaded image contains new sizing information
    if (!this.desiredSize.isReal()) {
      this.diagram.invalidateDocumentBounds();
    }
    this.diagram.invalidateDraw();
  } else {
    // Call invalidateDraw on every found diagram
    // If no diagrams found, traverse the DOM looking for them
    var diags = Util.diagramsTraversed;
    var l = diags.length;
    if (l === 0) {
      // traverse and make list
      var cans = document.getElementsByTagName('canvas');
      var ll = cans.length;
      for (var i = 0; i < ll; i++) {
        var can = cans[i];
        // this would be one step fewer if we had a reference to the diagram on the canvas
        if (can.parentElement && can.parentElement._diagram) diags.push(can.parentElement._diagram);
      }
    }
    l = diags.length;
    for (var i = 0; i < l; i++) {
      diags[i].invalidateDraw();
    }
  }
  return true;
};

/**
* @ignore
* @this {Picture}
*/
Picture.prototype._testCors = function() {
  if (this._element === null) {
    this._tainted = false;
    return;
  }
  var canvas = document.createElement('canvas');
  var ctx = canvas.getContext('2d');
  ctx.drawImage(this._element, 0, 0);
  try {
    var test = ctx.getImageData(0, 0, 1, 1).data[3] > 1;
    this._tainted = false;
  } catch (e) {
    this._tainted = true;
  }
};

/**
 * Gets or sets the Picture's source URL, which can be any valid image (png, jpg, gif, etc) URL.
 * Setting this attribute creates an HTMLImageElement and sets the {@link Picture#element} attribute to that element.
 * Setting the source of multiple Pictures to the same URL will cause only one HTMLImageElement to be created and shared.
 * @name Picture#source
 * @function.
 * @return {string}
 */
/** @type {string} */
Picture.prototype.source;
Util.exportProperty(Picture, 'source', Picture.prototype.source);
Util.defineProperty(Picture, { source: 'source' },
  /** @this {Picture} */
  function() { return this._source; },
  /** @this {Picture} */
  function(val) {
    var old = this._source;
    if (old !== val) {
      Util.checkPrimitive(val, 'string', Picture, 'source');
      this._source = val;
      var map = Util.imageSourceMap;
      if (map[val] !== undefined) {
        this.element = map[val];
      } else {
        // doesn't exist!
        //??? no-op if isUndoingRedoing
        var img = document.createElement('img');
        img.src = val;
        map[val] = img;
        if (img instanceof HTMLImageElement) this.element = img;
      }
      this.invalidateDraw();
      this.raiseChanged('source', old, val);
    }
  }
);

/**
 * Gets or sets the rectangular area of the source image that this picture should display.
 * The value must be of type {@link Rect}.
 * The default value is Rect(NaN, NaN, NaN, NaN), which means the whole source image should be used.
 * This is only common with sprite maps and image tables.
 * @name Picture#sourceRect
 * @function.
 * @return {Rect}
 */
/** @type {Rect} */
Picture.prototype.sourceRect;
Util.exportProperty(Picture, 'sourceRect', Picture.prototype.sourceRect);
Util.defineProperty(Picture, {sourceRect: 'sourceRect'},
  /** @this {Picture} */
  function() { return this._sourceRect; },
  /** @this {Picture} */
  function(val) {
    var old = this._sourceRect;
    if (!old.equals(val)) {
      Util.checkClass(val, Rect, Picture, 'sourceRect');
      val = val.copyFrozen();
      this._sourceRect = val;
      this.invalidateDraw();
      this.raiseChanged('sourceRect', old, val);
    }
  }
);

/**
* Gets or sets how the Picture's image is stretched within its bounding box.
* Some images will be a different aspect ratio than their given size or {@link #desiredSize}.
* This property will never change the size of the Picture itself,
* only the size of the image that is drawn in the Picture's {@link #actualBounds}.
* <br/>
* Possible values are {@link GraphObject#None}, {@link GraphObject#Uniform}, and
* {@link GraphObject#UniformToFill}.
* The default is {@link GraphObject#None}.
* @name Picture#imageStretch
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
Picture.prototype.imageStretch;
Util.exportProperty(Picture, 'imageStretch', Picture.prototype.imageStretch);
Util.defineProperty(Picture, { imageStretch: 'imageStretch' },
  /** @this {Picture} */
  function() { return this._imageStretch; },
  /** @this {Picture} */
  function(val) {
    var old = this._imageStretch;
    if (old !== val) {
      Util.checkEnumValue(val, GraphObject, Picture, 'imageStretch');
      this._imageStretch = val;
      this.invalidateDraw();
      this.raiseChanged('imageStretch', old, val);
    }
  }
);

/**
 * Gets or sets the function to call if an image fails to load.
 * The arguments to this function are the Picture and HTMLImageElement's "error" (onerror) Event.
 * @name Picture#errorFunction
 * @function.
 * @return {function(Picture, Event) | null}
 */
/** @type {function(Picture, Event) | null} */
Picture.prototype.errorFunction;
Util.exportProperty(Picture, 'errorFunction', Picture.prototype.errorFunction);
Util.defineProperty(Picture, { errorFunction: 'errorFunction' },
  /** @this {Picture} */
  function() { return this._errorFunction; },
  /** @this {Picture} */
  function(val) {
    var old = this._errorFunction;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', Picture, 'errorFunction');
      this._errorFunction = val;
      if (this._element) {
        var pic = this;
        /** @ignore */
        this._element.onerror = function(e) {
          if (pic._errorFunction !== null) pic._errorFunction(pic, e);
        };
      }
      this.raiseChanged('errorFunction', old, val);
    }
  }
);

/**
 * @ignore
 * Draw the Picture to a specified context.
 * @this {Picture}
 * @param {CanvasRenderingContext2D} context A Canvas 2D Context for drawing.
 * @param {Diagram} diagram
 */
Picture.prototype.drawProtected = function(context, diagram) {
  if (!diagram._drawTainted) {
    if (this._tainted === null) this._testCors();
    if (this._tainted) return;
  }
  var elem = this._element;
  if (elem !== null) {
    var src = elem.src;
    if (src === null || src === '') {
      Util.throwError('Element has no source attribute: ' + elem);
    }

    var siz = this.naturalBounds;
    // the source image size:
    var sx = 0, sy = 0;
    var iscan = this._isCanvas;
    var sw = iscan ? +elem.width : elem.naturalWidth;
    var sh = iscan ? +elem.height : elem.naturalHeight;
    if (sw === 0 || sh === 0) return; // Image failed to load or is nonexistant
    if (sw === undefined && elem.videoWidth) sw = elem.videoWidth || siz.width;
    if (sh === undefined && elem.videoHeight) sh = elem.videoHeight || siz.height;

    if (this.sourceRect.isReal()) {
      sx = this._sourceRect.x;
      sy = this._sourceRect.y;
      sw = this._sourceRect.width;
      sh = this._sourceRect.height;
    }

    // these become the destination size:
    var nw = sw;
    var nh = sh;

    var stretch = this._imageStretch;
    switch (stretch) {
      case GraphObject.None: // Draw it as the natural size
        // we only want a slice of the source rect
        // that is as large as the natural bounds of the object
        if (this.sourceRect.isReal()) break;
        sx += Math.max(((nw - siz.width) / 2), 0);
        sy += Math.max(((nh - siz.height) / 2), 0);
        sw = Math.min(siz.width, nw);
        sh = Math.min(siz.height, nh);
        break;
      case GraphObject.Fill:
        // we want the entire object as the source rect:
        nw = siz.width;
        nh = siz.height;
        break;
      case GraphObject.Uniform:
      case GraphObject.UniformToFill:
        // we want the entire object as the source rect:
        var ratio;
        if (stretch === GraphObject.Uniform) {// if its Uniform we want the larger side to fit
          ratio = Math.min(siz.height / nh, siz.width / nw);
          nw *= ratio;
          nh *= ratio;
        } else if (stretch === GraphObject.UniformToFill) {// if its UniformToFill we want the smaller side to fit
          ratio = Math.max(siz.height / nh, siz.width / nw);
          // uniform to fill is more complex because we are also cropping the image to avoid any need for clipping
          nw *= ratio;
          nh *= ratio;
          // we want the source element to be "cropped" here
          sx += (nw - siz.width) / 2;
          sy += (nh - siz.height) / 2;
          sw *= 1 / ((nw) / siz.width);
          sh *= 1 / ((nh) / siz.height);
          // we want the resulting image to be exactly the width and height of the picture
          nw = siz.width;
          nh = siz.height;
        }
        break;
    }

    // it is possible to draw pictures without the need for clip:
    context.drawImage(
      elem,
      sx, sy, sw, sh,
      // dx, dy, dw, dh
      Math.max((siz.width - nw) / 2, 0), //destination x, typically zero unless the image is smaller than size
      Math.max((siz.height - nh) / 2, 0), //destination y, (same)
      Math.min(siz.width, nw), Math.min(siz.height, nh));

  }
}; // end draw

/**
* Gets the natural size of this picture as determined by its source's width and height.
* The value is initially NaN x NaN until the picture has been measured.
* It will use the {@link #element}'s <c>naturalWidth</c> and <c>naturalHeight</c> if available.
* @name Picture#naturalBounds
* @function.
* @return {Rect}
*/
/** @type {Rect} */
Picture.prototype.naturalBounds;
Util.defineReadOnlyProperty(Picture, { naturalBounds: 'naturalBounds' },
/** @this {Picture} */
  function() { return this._naturalBounds; }
);

/**
* @ignore
* @this {Picture}
* @param {number} width
* @param {number} height
* @param {number=} minw
* @param {number=} minh
*/
Picture.prototype.measureProtected = function(width, height, minw, minh) {
  var des = this.desiredSize;
  var stretch = this.getEffectiveStretch();
  var elem = this._element;
  var iscan = this._isCanvas;
  if (iscan || (!this._loaded && elem && elem.complete)) this._loaded = true;
  if (elem === null) {
    width = 0;
    height = 0;
  }


  if (stretch !== GraphObject.Fill && stretch !== GraphObject.Horizontal) {
    if (isFinite(des.width)) {
      width = des.width;
    } else {
      if (elem !== null && this._loaded !== false) {
        if (this.sourceRect.isReal()) {
          width = this.sourceRect.width;
        } else {
          width = iscan ? +elem.width : elem.naturalWidth;
        }
      }
    }
  } else {
    if (!isFinite(width)) {
      if (this.sourceRect.isReal()) {
        width = this.sourceRect.width;
      } else {
        width = iscan ? +elem.width : elem.naturalWidth;
      }
    }
    minw = 0;
  }

  if (stretch !== GraphObject.Fill && stretch !== GraphObject.Vertical) {
    if (isFinite(des.height)) {
      height = des.height;
    } else {
      if (elem !== null && this._loaded !== false) {
        if (this.sourceRect.isReal()) {
          height = this.sourceRect.height;
        } else {
          height = iscan ? +elem.height : elem.naturalHeight;
        }
      }
    }
  } else {
    if (!isFinite(height)) {
      if (this.sourceRect.isReal()) {
        height = this.sourceRect.height;
      } else {
        height = iscan ? +elem.height : elem.naturalHeight;
      }
    }
    minh = 0;
  }
  var max = this.maxSize;
  var min = this.minSize;
  minw = Math.max(minw, min.width);
  minh = Math.max(minh, min.height);
  width = Math.min(max.width, width);
  height = Math.min(max.height, height);
  width = Math.max(minw, width);
  height = Math.max(minh, height);


  if (elem !== null && !elem.complete) {
    if (!isFinite(width)) width = 0;
    if (!isFinite(height)) height = 0;
  }

  var nb = this._naturalBounds;
  nb.setWidthHeight(width, height);

  this._measureRect(0, 0, width, height);
}; // end measure

/**
 * @ignore
 * @this {Picture}
 * @param {number} fx
 * @param {number} fy
 * @param {number} fw
 * @param {number} fh
 */
Picture.prototype.arrangeProtected = function(fx, fy, fw, fh) {
  this.commonArrange(fx, fy, fw, fh);
};

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

// internal definitions of standard shapes

/**
 * @ignore
 * Used in Geo.makeGeometry, for source compatibility with GoXam and GoDiagram
 * @constructor
 */
function StreamGeometryContext() {
  /** @ignore @type {Geometry} */
  this.geo = new Geometry();
  /** @type {PathFigure} */
  this._fig = null;
}

/** @ignore */
StreamGeometryContext.prototype.reset = function() {
  this.geo = new Geometry();
  this._fig = null;
};

/**
* @ignore
* @this {StreamGeometryContext}
* @param {number} sx
* @param {number} sy
* @param {boolean} isFilled
* @param {boolean=} isSubPath
* @param {boolean=} isShadowed true if shadowed, false if not shadowed. Figures are shadowed by default.
*/
StreamGeometryContext.prototype.beginFigure = function(sx, sy, isFilled, isSubPath, isShadowed) {
  if (this.geo === null) Util.throwError('StreamGeometryContext has been closed');
  if (isSubPath !== undefined && isSubPath === true) {
    if (this._fig === null) Util.throwError('Need to call beginFigure first');
    var seg = new PathSegment(PathSegment.Move);
    seg.endX = sx;
    seg.endY = sy;
    this._fig.segments.add(seg);
  } else {
    this._fig = new PathFigure();
    this._fig.startX = sx;
    this._fig.startY = sy;
    this._fig.isFilled = isFilled;
    this.geo.figures.add(this._fig);
  }
  if (isShadowed !== undefined) this._fig._isShadowed = isShadowed;
};

/**
* @ignore
* @this {StreamGeometryContext}
*/
StreamGeometryContext.prototype.closeLast = function() {
  if (this.geo === null) Util.throwError('StreamGeometryContext has been closed');
  if (this._fig === null) Util.throwError('Need to call beginFigure first');
  var len = this._fig.segments.length;
  if (len > 0)
  this._fig.segments._arr[len - 1].close();
};

/**
* @ignore
* @this {StreamGeometryContext}
*/
StreamGeometryContext.prototype.fillLast = function() {
  if (this.geo === null) Util.throwError('StreamGeometryContext has been closed');
  if (this._fig === null) Util.throwError('Need to call beginFigure first');
  var len = this._fig.segments.length;
  if (len > 0)
  this._fig.isFilled = true;
};


/**
* @ignore
* @param {boolean} shadow whether or not the figure should be shadowed.
* @this {StreamGeometryContext}
*/
StreamGeometryContext.prototype.setShadow = function(shadow) {
  if (this.geo === null) Util.throwError('StreamGeometryContext has been closed');
  if (this._fig === null) Util.throwError('Need to call beginFigure first');
  this._fig.isShadowed = shadow;
};

/**
* @ignore
* @this {StreamGeometryContext}
* @param {number} px
* @param {number} py
* @param {boolean=} close
*/
StreamGeometryContext.prototype.moveTo = function(px, py, close) {
  if (this.geo === null) Util.throwError('StreamGeometryContext has been closed');
  if (this._fig === null) Util.throwError('Need to call beginFigure first');
  var seg = new PathSegment(PathSegment.Move);
  seg.endX = px;
  seg.endY = py;
  if (close) seg.close();
  this._fig.segments.add(seg);
};

/**
* @ignore
* @this {StreamGeometryContext}
* @param {number} px
* @param {number} py
* @param {boolean=} close
*/
StreamGeometryContext.prototype.lineTo = function(px, py, close) {
  if (this.geo === null) Util.throwError('StreamGeometryContext has been closed');
  if (this._fig === null) Util.throwError('Need to call beginFigure first');
  var seg = new PathSegment(PathSegment.Line);
  seg.endX = px;
  seg.endY = py;
  if (close) seg.close();
  this._fig.segments.add(seg);
};

/**
* @ignore
* @this {StreamGeometryContext}
* @param {number} p1x
* @param {number} p1y
* @param {number} p2x
* @param {number} p2y
* @param {number} ex
* @param {number} ey
* @param {boolean=} close
*/
StreamGeometryContext.prototype.bezierTo = function(p1x, p1y, p2x, p2y, ex, ey, close) {
  if (this.geo === null) Util.throwError('StreamGeometryContext has been closed');
  if (this._fig === null) Util.throwError('Need to call beginFigure first');
  var seg = new PathSegment(PathSegment.Bezier);
  seg.point1X = p1x;
  seg.point1Y = p1y;
  seg.point2X = p2x;
  seg.point2Y = p2y;
  seg.endX = ex;
  seg.endY = ey;
  if (close) seg.close();
  this._fig.segments.add(seg);
};

/**
* @ignore
* @this {StreamGeometryContext}
* @param {number} px
* @param {number} py
* @param {number} ex
* @param {number} ey
* @param {boolean=} close
*/
StreamGeometryContext.prototype.quadraticBezierTo = function(px, py, ex, ey, close) {
  if (this.geo === null) Util.throwError('StreamGeometryContext has been closed');
  if (this._fig === null) Util.throwError('Need to call beginFigure first');
  var seg = new PathSegment(PathSegment.QuadraticBezier);
  seg.point1X = px;
  seg.point1Y = py;
  seg.endX = ex;
  seg.endY = ey;
  if (close) seg.close();
  this._fig.segments.add(seg);
};

/**
* @ignore
* @this {StreamGeometryContext}
* @param {number} startAngle
* @param {number} sweepAngle
* @param {number} centerX
* @param {number} centerY
* @param {number} radiusX
* @param {number=} radiusY
* @param {boolean=} close
*/
StreamGeometryContext.prototype.arcTo = function(startAngle, sweepAngle, centerX, centerY, radiusX, radiusY, close) {
  if (this.geo === null) Util.throwError('StreamGeometryContext has been closed');
  if (this._fig === null) Util.throwError('Need to call beginFigure first');
  var seg = new PathSegment(PathSegment.Arc);
  seg.startAngle = startAngle;
  seg.sweepAngle = sweepAngle;
  seg.centerX = centerX;
  seg.centerY = centerY;
  seg.radiusX = radiusX;
  if (radiusY) seg.radiusY = radiusY;
  else seg.radiusY = radiusX;
  if (close) seg.close();
  this._fig.segments.add(seg);
};

/**
* @ignore
* @this {StreamGeometryContext}
* @param {number=} rx
* @param {number=} ry
* @param {number=} xAxisRotation
* @param {boolean=} largeArcFlag
* @param {boolean=} sweepFlag
* @param {number=} cpx
* @param {number=} cpy
* @param {boolean=} close
*/
StreamGeometryContext.prototype.svgArcTo = function(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, cpx, cpy, close) {
  if (this.geo === null) Util.throwError('StreamGeometryContext has been closed');
  if (this._fig === null) Util.throwError('Need to call beginFigure first');
  var seg = new PathSegment(PathSegment.SvgArc, cpx, cpy, rx, ry, xAxisRotation, largeArcFlag, sweepFlag);
  if (close) seg.close();
  this._fig.segments.add(seg);
};

// givenSize is used to override desired size, such as in the case of an arrange
/**
* @ignore
* @param {Shape} shape
* @param {number=} gw The given/arranged width.
* @param {number=} gh The given/arranged height.
*/
Geo.makeGeometry = function(shape, gw, gh) {
  var size = shape.desiredSize;
  var w = size.width;
  var h = size.height;

  // if a given size, ovveride
  // ??? maybe any max/min should be in the caller to this method instead
  // Math.min(givensize, size) or something, also checking for NaN
  if (gw !== undefined/*notpresent*/ && !isNaN(gw) && isFinite(gw)) w = gw;
  if (gh !== undefined/*notpresent*/ && !isNaN(gh) && isFinite(gh)) h = gh;

  if (!isFinite(w)) w = 100;
  if (!isFinite(h)) h = 100;

  /** @ignore @type {Geometry} */
  var geo = undefined;
  // See if the shape has a toArrow, fromArrow, or Figure, in that order.
  if (shape.toArrow !== 'None') {
    geo = Geo.findArrowheadGeometry(shape.toArrow);
  } else if (shape.fromArrow !== 'None') {
    geo = Geo.findArrowheadGeometry(shape.fromArrow);
  } else { // normal figure
    // look up the geometry generator by name
    var func = Geo.generators[shape.figure];
    // maybe it found a name instead of a function -- look again
    if (typeof func === 'string') func = Geo.generators[func];
    if (func === undefined/*notpresent*/) Util.throwError('Unknown Shape.figure: ' + shape.figure);
    geo = func(shape, w, h);
    geo._minSize = new Size(w, h);
  }
  if (geo === undefined) {
    var func = Geo.generators['Rectangle'];
    if (func) geo = func(shape, w, h);
  }

  geo._inputWidth = gw;
  geo._inputHeight = gh;
  return geo;
};

// out Point curve1cp1, out Point curve1cp2,
// out Point midpoint, out Point curve2cp1, out Point curve2cp2
/** @ignore */
Geo.breakUpBezier = function(startx, starty, c1x, c1y, c2x, c2y, endx, endy, fraction,
    curve1cp1, curve1cp2, midpoint, curve2cp1, curve2cp2) {
    var fo = 1 - fraction;
    var so = fraction;
    var m1x = (startx * fo + c1x * so);
    var m1y = (starty * fo + c1y * so);
    var m2x = (c1x * fo + c2x * so);
    var m2y = (c1y * fo + c2y * so);
    var m3x = (c2x * fo + endx * so);
    var m3y = (c2y * fo + endy * so);
    var m12x = (m1x * fo + m2x * so);
    var m12y = (m1y * fo + m2y * so);
    var m23x = (m2x * fo + m3x * so);
    var m23y = (m2y * fo + m3y * so);
    var m123x = (m12x * fo + m23x * so);
    var m123y = (m12y * fo + m23y * so);

    curve1cp1.x = m1x;
    curve1cp1.y = m1y;

    curve1cp2.x = m12x;
    curve1cp2.y = m12y;

    midpoint.x = m123x;
    midpoint.y = m123y;

    curve2cp1.x = m23x;
    curve2cp1.y = m23y;

    curve2cp2.x = m3x;
    curve2cp2.y = m3y;
  };

/**
* @ignore
* This allocates a temporary Array that should be Util.freeArray()'ed by the caller.
* @param {number} points
* @return {Array}
*/
Geo.createBurst = function(points) {
  var star = Geo.createStar(points);
  var pts = Util.tempArray(); //new Point[points * 3 + 1];

  pts[0] = star[0];
  for (var i = 1, count = 1; i < star.length; i += 2, count += 3) {
    pts[count] = star[i];
    pts[count + 1] = star[i];
    pts[count + 2] = star[i + 1];
  }

  Util.freeArray(star);
  return pts;
};

/**
* @ignore
* This allocates a temporary Array that should be Util.freeArray()'ed by the caller.
* @param {number} points
* @return {Array}
*/
Geo.createStar = function(points) {
  // First, create a regular polygon
  var polygon = Geo.createPolygon(points);
  // Calculate the points inbetween
  var pts = Util.tempArray(); //new Point[points * 2 + 1];

  var half = Math.floor(polygon.length / 2);
  var count = polygon.length - 1;
  var offset = (points % 2 === 0) ? 2 : 1;

  for (var i = 0; i < count; i++) {
    // Get the intersection of two lines
    var p0 = polygon[i];
    var p1 = polygon[i + 1];
    var q21 = polygon[(half + i - 1) % count];
    var q2off = polygon[(half + i + offset) % count];
    pts[i * 2] = p0;
    pts[i * 2 + 1] = Geo.getIntersection(p0.x, p0.y,
      q21.x, q21.y,
      p1.x, p1.y,
      q2off.x, q2off.y, new Point());  //?? not currently managed
  }

  pts[pts.length] = pts[0];

  Util.freeArray(polygon);
  return pts;
};

/**
* @ignore
* @param {number} p1x
* @param {number} p1y
* @param {number} p2x
* @param {number} p2y
* @param {number} q1x
* @param {number} q1y
* @param {number} q2x
* @param {number} q2y
* @param {Point} result
* @return {Point}
*/
Geo.getIntersection = function(p1x, p1y, p2x, p2y, q1x, q1y, q2x, q2y, result) {
  var dx1 = p1x - p2x;
  var dx2 = q1x - q2x;
  var x;
  var y;

  if (dx1 === 0 || dx2 === 0) {
    if (dx1 === 0) {
      var m2 = (q1y - q2y) / dx2;
      var b2 = q1y - m2 * q1x;
      x = p1x;
      y = m2 * x + b2;
    }
    else {
      var m1 = (p1y - p2y) / dx1;
      var b1 = p1y - m1 * p1x;
      x = q1x;
      y = m1 * x + b1;
    }
  }
  else {
    var m1 = (p1y - p2y) / dx1;
    var m2 = (q1y - q2y) / dx2;
    var b1 = p1y - m1 * p1x;
    var b2 = q1y - m2 * q1x;

    x = (b2 - b1) / (m1 - m2);
    y = m1 * x + b1;
  }

  result._set(x, y);
  return result;
};

/**
* @ignore
* This allocates a temporary Array that should be Util.freeArray()'ed by the caller.
* @param {number} sides
* @return {Array}
*/
Geo.createPolygon = function(sides) {
  //Point[] points = new Point[sides + 1];
  var points = Util.tempArray();
  var radius = .5;
  var center = .5;
  var offsetAngle = Math.PI * 1.5;
  var angle = 0;

  // Loop through each side of the polygon
  for (var i = 0; i < sides; i++) {
    angle = 2 * Math.PI / sides * i + offsetAngle;
    points[i] = new Point((center + radius * Math.cos(angle)), (center + radius * Math.sin(angle)));
  }

  // Add the last line
  //points[points.length - 1] = points[0];
  points.push(points[0]);
  return points;
};

/** @ignore */
Geo.GeneratorEllipseSpot1 = new Spot(0.156, 0.156).constant();
/** @ignore */
Geo.GeneratorEllipseSpot2 = new Spot(0.844, 0.844).constant();

/** @ignore */
Geo.generators = {
      'None': 'Rectangle',  // none is a rect too, make sure not to return null
      'Rectangle':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var geo = new Geometry();
      geo.type = Geometry.Rectangle;
      geo.startX = 0;
      geo.startY = 0;
      geo.endX = w;
      geo.endY = h;
      return geo;
  },

      'Square':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
    var geo = new Geometry();
    geo._defaultStretch = GraphObject.Uniform;
    geo.type = Geometry.Rectangle;
    geo.startX = 0;
    geo.startY = 0;
    geo.endX = w;
    geo.endY = h;
    return geo;
  },

      'Ellipse':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var geo = new Geometry();
      geo.type = Geometry.Ellipse;
      geo.startX = 0;
      geo.startY = 0;
      geo.endX = w;
      geo.endY = h;
      geo.spot1 = Geo.GeneratorEllipseSpot1;
      geo.spot2 = Geo.GeneratorEllipseSpot2;
      return geo;
  },

      'Circle':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
    var geo = new Geometry();
    geo._defaultStretch = GraphObject.Uniform;
    geo.type = Geometry.Ellipse;
    geo.startX = 0;
    geo.startY = 0;
    geo.endX = w;
    geo.endY = h;
    geo.spot1 = Geo.GeneratorEllipseSpot1;
    geo.spot2 = Geo.GeneratorEllipseSpot2;
    return geo;
  },

      'Connector': 'Ellipse',

      'TriangleRight':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var geo = new Geometry();
      var tempfig = new PathFigure();
      //default startpoint of 0,0
      var ls1 = new PathSegment();
      ls1.endX = w;
      ls1.endY = 0.5 * h;
      tempfig.segments.add(ls1);
      var ls2 = new PathSegment();
      ls2.endX = 0;
      ls2.endY = h;
      tempfig.segments.add(ls2.close());
      geo.figures.add(tempfig);
      geo.spot1 = new Spot(0, .25);
      geo.spot2 = new Spot(.5, .75);
      return geo;
  },

      'TriangleDown':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var geo = new Geometry();
      var tempfig = new PathFigure();
      //default startpoint of 0,0
      var ls1 = new PathSegment();
      ls1.endX = w;
      ls1.endY = 0;
      tempfig.segments.add(ls1);
      var ls2 = new PathSegment();
      ls2.endX = 0.5 * w;
      ls2.endY = h;
      tempfig.segments.add(ls2.close());
      geo.figures.add(tempfig);
      geo.spot1 = new Spot(.25, 0);
      geo.spot2 = new Spot(.75, .5);
      return geo;
  },

      'TriangleLeft':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var geo = new Geometry();
      var tempfig = new PathFigure();
      //default startpoint of 0,0
      tempfig.startX = w;
      tempfig.startY = h;
      var ls1 = new PathSegment();
      ls1.endX = 0;
      ls1.endY = 0.5 * h;
      tempfig.segments.add(ls1);
      var ls2 = new PathSegment();
      ls2.endX = w;
      ls2.endY = 0;
      tempfig.segments.add(ls2.close());
      geo.figures.add(tempfig);
      geo.spot1 = new Spot(.5, .25);
      geo.spot2 = new Spot(1, .75);
      return geo;
  },

      'TriangleUp':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var geo = new Geometry();
      var tempfig = new PathFigure();
      tempfig.startX = w;
      tempfig.startY = h;
      var ls1 = new PathSegment();
      ls1.endX = 0;
      ls1.endY = h;
      tempfig.segments.add(ls1);
      var ls2 = new PathSegment();
      ls2.endX = 0.5 * w;
      ls2.endY = 0;
      tempfig.segments.add(ls2.close());
      geo.figures.add(tempfig);
      geo.spot1 = new Spot(.25, .50);
      geo.spot2 = new Spot(.75, 1);
      return geo;
  },

      // Lines
      'Line1':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var geo = new Geometry();
      geo.type = Geometry.Line;
      geo.startX = 0;
      geo.startY = 0;
      geo.endX = w;
      geo.endY = h;
      return geo;
  },

      'Line2':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var geo = new Geometry();
      geo.type = Geometry.Line;
      geo.startX = w;
      geo.startY = 0;
      geo.endX = 0;
      geo.endY = h;
      return geo;
  },

      'MinusLine': 'LineH',
      'LineH':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var geo = new Geometry();
      geo.type = Geometry.Line;
      geo.startX = 0;
      geo.startY = h / 2;
      geo.endX = w;
      geo.endY = h / 2;
      return geo;
  },

      'LineV':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var geo = new Geometry();
      geo.type = Geometry.Line;
      geo.startX = w / 2;
      geo.startY = 0;
      geo.endX = w / 2;
      geo.endY = h;
      return geo;
  },

      // Curves
      'Curve1':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var factor = Geo.KAPPA;
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, 0, false);
      context.bezierTo(factor * w, 0, 1 * w, (1 - factor) * h, w, h);
      var geo = context.geo;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Curve2':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var factor = Geo.KAPPA;
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, 0, false);
      context.bezierTo(0, factor * h, (1 - factor) * w, h, w, h);
      var geo = context.geo;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Curve3':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var factor = Geo.KAPPA;
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(1 * w, 0, false);
      context.bezierTo(1 * w, factor * h, factor * w, 1 * h, 0, 1 * h);
      var geo = context.geo;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Curve4':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var factor = Geo.KAPPA;
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(1 * w, 0, false);
      context.bezierTo((1 - factor) * w, 0, 0, (1 - factor) * h, 0, 1 * h);
      var geo = context.geo;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      // Polygons
      'Alternative': 'Triangle',
      'Merge': 'Triangle',
      'Triangle':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(.5 * w, 0 * h, true);
      context.lineTo(0 * w, 1 * h);
      context.lineTo(1 * w, 1 * h, true);
      var geo = context.geo;
      geo.spot1 = new Spot(.25, .5);
      geo.spot2 = new Spot(.75, 1);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Decision': 'Diamond',
      'Diamond':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(.5 * w, 0, true);
      context.lineTo(0, .5 * h);
      context.lineTo(.5 * w, 1 * h);
      context.lineTo(1 * w, .5 * h, true);
      var geo = context.geo;
      geo.spot1 = new Spot(.25, .25);
      geo.spot2 = new Spot(.75, .75);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Pentagon':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var points = Geo.createPolygon(5);
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(points[0].x * w, points[0].y * h, true);
      for (var i = 1; i < 5; i++) {
          context.lineTo(points[i].x * w, points[i].y * h);
      }
      Util.freeArray(points);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(.2, .22);
      geo.spot2 = new Spot(.8, .9);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'DataTransmission': 'Hexagon',
      'Hexagon':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var points = Geo.createPolygon(6);
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(points[0].x * w, points[0].y * h, true);
      for (var i = 1; i < 6; i++) {
          context.lineTo(points[i].x * w, points[i].y * h);
      }
      Util.freeArray(points);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(.07, .25);
      geo.spot2 = new Spot(.93, .75);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Heptagon':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var points = Geo.createPolygon(7);
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(points[0].x * w, points[0].y * h, true);
      for (var i = 1; i < 7; i++) {
          context.lineTo(points[i].x * w, points[i].y * h);
      }
      Util.freeArray(points);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(.2, .15);
      geo.spot2 = new Spot(.8, .85);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Octagon':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var points = Geo.createPolygon(8);
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(points[0].x * w, points[0].y * h, true);
      for (var i = 1; i < 8; i++) {
          context.lineTo(points[i].x * w, points[i].y * h);
      }
      Util.freeArray(points);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(.15, .15);
      geo.spot2 = new Spot(.85, .85);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Nonagon':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var points = Geo.createPolygon(9);
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(points[0].x * w, points[0].y * h, true);
      for (var i = 1; i < 9; i++) {
          context.lineTo(points[i].x * w, points[i].y * h);
      }
      Util.freeArray(points);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(.17, .13);
      geo.spot2 = new Spot(.82, .82);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Decagon':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var points = Geo.createPolygon(10);
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(points[0].x * w, points[0].y * h, true);
      for (var i = 1; i < 10; i++) {
          context.lineTo(points[i].x * w, points[i].y * h);
      }
      Util.freeArray(points);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(.16, .16);
      geo.spot2 = new Spot(.84, .84);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Dodecagon':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var points = Geo.createPolygon(12);
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(points[0].x * w, points[0].y * h, true);
      for (var i = 1; i < 12; i++) {
          context.lineTo(points[i].x * w, points[i].y * h);
      }
      Util.freeArray(points);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(.16, .16);
      geo.spot2 = new Spot(.84, .84);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      // Stars
      'FivePointedStar':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var starPoints = Geo.createStar(5);
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(starPoints[0].x * w, starPoints[0].y * h, true);
      for (var i = 1; i < 10; i++) {
          context.lineTo(starPoints[i].x * w, starPoints[i].y * h);
      }
      Util.freeArray(starPoints);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(.312, .383);
      geo.spot2 = new Spot(.693, .765);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'SixPointedStar':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var starPoints = Geo.createStar(6);
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(starPoints[0].x * w, starPoints[0].y * h, true);
      for (var i = 1; i < 12; i++) {
          context.lineTo(starPoints[i].x * w, starPoints[i].y * h);
      }
      Util.freeArray(starPoints);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(.170, .251);
      geo.spot2 = new Spot(.833, .755);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'SevenPointedStar':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var starPoints = Geo.createStar(7);
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(starPoints[0].x * w, starPoints[0].y * h, true);
      for (var i = 1; i < 14; i++) {
          context.lineTo(starPoints[i].x * w, starPoints[i].y * h);
      }
      Util.freeArray(starPoints);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(.363, .361);
      geo.spot2 = new Spot(.641, .709);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'EightPointedStar':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var starPoints = Geo.createStar(8);
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(starPoints[0].x * w, starPoints[0].y * h, true);
      for (var i = 1; i < 16; i++) {
          context.lineTo(starPoints[i].x * w, starPoints[i].y * h);
      }
      Util.freeArray(starPoints);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(.252, .255);
      geo.spot2 = new Spot(.75, .75);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'NinePointedStar':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var starPoints = Geo.createStar(9);
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(starPoints[0].x * w, starPoints[0].y * h, true);
      for (var i = 1; i < 18; i++) {
          context.lineTo(starPoints[i].x * w, starPoints[i].y * h);
      }
      Util.freeArray(starPoints);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(.355, .361);
      geo.spot2 = new Spot(.645, .651);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'TenPointedStar':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var starPoints = Geo.createStar(10);
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(starPoints[0].x * w, starPoints[0].y * h, true);
      for (var i = 1; i < 20; i++) {
          context.lineTo(starPoints[i].x * w, starPoints[i].y * h);
      }
      Util.freeArray(starPoints);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(.281, .261);
      geo.spot2 = new Spot(.723, .748);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      // Bursts
      'FivePointedBurst':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var burstPoints = Geo.createBurst(5);
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(burstPoints[0].x * w, burstPoints[0].y * h, true);
      for (var i = 1; i < burstPoints.length; i += 3) {
          context.bezierTo(burstPoints[i].x * w,
            burstPoints[i].y * h, burstPoints[i + 1].x * w,
            burstPoints[i + 1].y * h, burstPoints[i + 2].x * w,
            burstPoints[i + 2].y * h);
      }
      Util.freeArray(burstPoints);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(.312, .383);
      geo.spot2 = new Spot(.693, .765);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'SixPointedBurst':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var burstPoints = Geo.createBurst(6);
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(burstPoints[0].x * w, burstPoints[0].y * h, true);
      for (var i = 1; i < burstPoints.length; i += 3) {
          context.bezierTo(burstPoints[i].x * w,
            burstPoints[i].y * h, burstPoints[i + 1].x * w,
            burstPoints[i + 1].y * h, burstPoints[i + 2].x * w,
            burstPoints[i + 2].y * h);
      }
      Util.freeArray(burstPoints);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(.170, .251);
      geo.spot2 = new Spot(.833, .755);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'SevenPointedBurst':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var burstPoints = Geo.createBurst(7);
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(burstPoints[0].x * w, burstPoints[0].y * h, true);
      for (var i = 1; i < burstPoints.length; i += 3) {
          context.bezierTo(burstPoints[i].x * w,
            burstPoints[i].y * h, burstPoints[i + 1].x * w,
            burstPoints[i + 1].y * h, burstPoints[i + 2].x * w,
            burstPoints[i + 2].y * h);
      }
      Util.freeArray(burstPoints);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(.363, .361);
      geo.spot2 = new Spot(.641, .709);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'EightPointedBurst':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var burstPoints = Geo.createBurst(8);
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(burstPoints[0].x * w, burstPoints[0].y * h, true);
      for (var i = 1; i < burstPoints.length; i += 3) {
          context.bezierTo(burstPoints[i].x * w,
            burstPoints[i].y * h, burstPoints[i + 1].x * w,
            burstPoints[i + 1].y * h, burstPoints[i + 2].x * w,
            burstPoints[i + 2].y * h);
      }
      Util.freeArray(burstPoints);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(.252, .255);
      geo.spot2 = new Spot(.75, .75);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'NinePointedBurst':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var burstPoints = Geo.createBurst(9);
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(burstPoints[0].x * w, burstPoints[0].y * h, true);
      for (var i = 1; i < burstPoints.length; i += 3) {
          context.bezierTo(burstPoints[i].x * w,
            burstPoints[i].y * h, burstPoints[i + 1].x * w,
            burstPoints[i + 1].y * h, burstPoints[i + 2].x * w,
            burstPoints[i + 2].y * h);
      }
      Util.freeArray(burstPoints);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(.355, .361);
      geo.spot2 = new Spot(.645, .651);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'TenPointedBurst':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var burstPoints = Geo.createBurst(10);
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(burstPoints[0].x * w, burstPoints[0].y * h, true);
      for (var i = 1; i < burstPoints.length; i += 3) {
          context.bezierTo(burstPoints[i].x * w,
            burstPoints[i].y * h, burstPoints[i + 1].x * w,
            burstPoints[i + 1].y * h, burstPoints[i + 2].x * w,
            burstPoints[i + 2].y * h);
      }
      Util.freeArray(burstPoints);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(.281, .261);
      geo.spot2 = new Spot(.723, .748);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      // Basic Shapes
      'Cloud':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(.08034461 * w, .1944299 * h, true);
      //contain boolean values associated to .BezierTo() calls.
      context.bezierTo(-.09239631 * w, .07836421 * h,
        .1406031 * w, -.0542823 * h,
        .2008615 * w, .05349299 * h);
      context.bezierTo(.2450511 * w, -.00697547 * h,
        .3776197 * w, -.01112067 * h,
        .4338609 * w, .074219 * h);
      context.bezierTo(.4539471 * w, 0,
        .6066018 * w, -.02526587 * h,
        .6558228 * w, .07004196 * h);
      context.bezierTo(.6914277 * w, -.01904177 * h,
        .8921095 * w, -.01220843 * h,
        .8921095 * w, .08370865 * h);
      context.bezierTo(1.036446 * w, .04105738 * h,
        1.020377 * w, .3022052 * h,
        .9147671 * w, .3194596 * h);
      context.bezierTo(1.04448 * w, .360238 * h,
        .992256 * w, .5219009 * h,
        .9082935 * w, .562044 * h);
      context.bezierTo(1.032337 * w, .5771781 * h,
        1.018411 * w, .8120651 * h,
        .9212406 * w, .8217117 * h);
      context.bezierTo(1.028411 * w, .9571472 * h,
        .8556702 * w, 1.052487 * h,
        .7592566 * w, .9156953 * h);
      context.bezierTo(.7431877 * w, 1.009325 * h,
        .5624123 * w, 1.021761 * h,
        .5101666 * w, .9310455 * h);
      context.bezierTo(.4820677 * w, 1.031761 * h,
        .3030112 * w, 1.002796 * h,
        .2609328 * w, .9344623 * h);
      context.bezierTo(.2329994 * w, 1.01518 * h,
        .03213784 * w, 1.01518 * h,
        .08034461 * w, .870098 * h);
      context.bezierTo(-.02812061 * w, .9032597 * h,
        -.01205169 * w, .6835638 * h,
        .06829292 * w, .6545475 * h);
      context.bezierTo(-.01812061 * w, .6089503 * h,
        -.00606892 * w, .4555777 * h,
        .06427569 * w, .4265613 * h);
      context.bezierTo(-.01606892 * w, .3892545 * h,
        -.01205169 * w, .1944299 * h,
        .08034461 * w, .1944299 * h);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(.1, .1);
      geo.spot2 = new Spot(.9, .9);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Gate': 'Crescent',
      'Crescent':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {              // Flowchart
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, 0, true);
      context.bezierTo(1 * w, 0, 1 * w, 1 * h, 0, 1 * h);
      context.bezierTo(.5 * w, .75 * h, .5 * w, .25 * h, 0, 0);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(.511, .19);
      geo.spot2 = new Spot(.776, .76);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'FramedRectangle':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      var param1 = shape ? shape.parameter1 : 0;
      var param2 = shape ? shape.parameter2 : 0;
      // Set defaults for parameters if they aren't set already
      if (param1 === 0) param1 = .1; // Distance between left and inner rect
      if (param2 === 0) param2 = .1; // Distance between top and inner rect

      // Outside rectangle
      context.beginFigure(0, 0, true);
      context.lineTo(1 * w, 0);
      context.lineTo(1 * w, 1 * h);
      context.lineTo(0, 1 * h, true);

      // Inside Rectangle
      context.beginFigure(param1 * w, param2 * h, false, true);  // subpath
      context.lineTo(param1 * w, (1 - param2) * h);
      context.lineTo((1 - param1) * w, (1 - param2) * h);
      context.lineTo((1 - param1) * w, param2 * h, true);

      var geo = context.geo;
      geo.spot1 = new Spot(param1, param2);
      geo.spot2 = new Spot(1 - param1, 1 - param2);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Delay': 'HalfEllipse',
      'HalfEllipse':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var factor = Geo.KAPPA;
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, 0, true);
      context.bezierTo(factor * w, 0,
            1 * w, (.5 - factor / 2) * h,
            1 * w, .5 * h);
      context.bezierTo(1 * w, (.5 + factor / 2) * h,
            factor * w, 1 * h, 0, 1 * h);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(0, .20);
      geo.spot2 = new Spot(.75, .80);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Heart':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      // Set default params
      var param1 = shape ? shape.parameter1 : 0;
      if (param1 === 0) param1 = .25; // y value of the middle

      var context = Util.tempStreamGeometryContext();
      context.beginFigure(.5 * w, 1 * h, true);
      context.bezierTo(.1 * w, .8 * h, 0, .5 * h,
          0 * w, .3 * h);
      context.bezierTo(0 * w, 0, .45 * w, 0,
          .5 * w, .3 * h);
      context.bezierTo(.55 * w, 0, 1 * w, 0,
          1 * w, .3 * h);
      context.bezierTo(w, .5 * h, .9 * w, .8 * h,
          .5 * w, 1 * h);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(.15, .29);
      geo.spot2 = new Spot(.86, .68);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Spade':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      // Set default params
      var param1 = shape ? shape.parameter1 : 0;
      if (param1 === 0) param1 = .7; // y value of the center

      var context = Util.tempStreamGeometryContext();
      // Begin at the top middle
      context.beginFigure(.5 * w, 0, true);
      context.lineTo(.51 * w, .01 * h);
      context.bezierTo(.6 * w, .2 * h, w, .25 * h,
          w, .5 * h);
      context.bezierTo(w, .8 * h, .6 * w, .8 * h,
          .55 * w, .7 * h);

      // start the base
      context.bezierTo(.5 * w, .75 * h, .55 * w, .95 * h,
          .75 * w, h);
      context.lineTo(.25 * w, h);
      context.bezierTo(.45 * w, .95 * h, .5 * w, .75 * h,
          .45 * w, .7 * h);

      // Finish the other side of the top
      context.bezierTo(.4 * w, .8 * h, 0, .8 * h,
          0, .5 * h);
      context.bezierTo(0, .25 * h, .4 * w, .2 * h,
          .49 * w, .01 * h);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(.19, .26);
      geo.spot2 = new Spot(.80, .68);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Club':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      // start the base
      context.beginFigure(.4 * w, .6 * h, true);
      context.bezierTo(.5 * w, .75 * h,
        .45 * w, .95 * h, .15 * w, 1 * h);
      context.lineTo(.85 * w, h);
      context.bezierTo(.55 * w, .95 * h,
        .5 * w, .75 * h, .6 * w, .6 * h);
      // First circle': function(shape, w, h)
      var r = .2; // radius
      var cx = .3; // offset from Center x
      var cy = 0; // offset from Center y
      var d = r * (4 * (Math.SQRT2 - 1) / 3);
      context.bezierTo((.5 - r + cx) * w, (.5 + d + cy) * h,
        (.5 - d + cx) * w, (.5 + r + cy) * h,
        (.5 + cx) * w, (.5 + r + cy) * h);
      context.bezierTo((.5 + d + cx) * w, (.5 + r + cy) * h,
        (.5 + r + cx) * w, (.5 + d + cy) * h,
        (1 - .5 + r + cx) * w, (.5 + cy) * h);
      context.bezierTo((1 - .5 + r + cx) * w, (.5 - d + cy) * h,
        (.5 + d + cx) * w, (.5 - r + cy) * h,
        (.5 + cx) * w, (.5 - r + cy) * h);
      context.bezierTo((.5 - d + cx) * w, (.5 - r + cy) * h,
        (.5 - r + cx + .05) * w, (.5 - d + cy - .02) * h,
        (.65) * w, (0.36771243) * h);
      r = .2; // radius
      cx = 0; // offset from Center x
      cy = -.3; // offset from Center y
      d = r * (4 * (Math.SQRT2 - 1) / 3);
      context.bezierTo((.5 + d + cx) * w, (.5 + r + cy) * h,
        (.5 + r + cx) * w, (.5 + d + cy) * h,
        (1 - .5 + r + cx) * w, (.5 + cy) * h);
      context.bezierTo((1 - .5 + r + cx) * w, (.5 - d + cy) * h,
        (.5 + d + cx) * w, (.5 - r + cy) * h,
        (.5 + cx) * w, (.5 - r + cy) * h);
      context.bezierTo((.5 - d + cx) * w, (.5 - r + cy) * h,
        (.5 - r + cx) * w, (.5 - d + cy) * h,
        (.5 - r + cx) * w, (.5 + cy) * h);
      context.bezierTo((.5 - r + cx) * w, (.5 + d + cy) * h,
        (.5 - d + cx) * w, (.5 + r + cy) * h,
        (.35) * w, (0.36771243) * h);
      r = .2; // radius
      cx = -.3; // offset from Center x
      cy = 0; // offset from Center y
      d = r * (4 * (Math.SQRT2 - 1) / 3);
      context.bezierTo((1 - .5 + r + cx - .05) * w, (.5 - d + cy - .02) * h,
        (.5 + d + cx) * w, (.5 - r + cy) * h,
        (.5 + cx) * w, (.5 - r + cy) * h);
      context.bezierTo((.5 - d + cx) * w, (.5 - r + cy) * h,
        (.5 - r + cx) * w, (.5 - d + cy) * h,
        (.5 - r + cx) * w, (.5 + cy) * h);
      context.bezierTo((.5 - r + cx) * w, (.5 + d + cy) * h,
        (.5 - d + cx) * w, (.5 + r + cy) * h,
        (.5 + cx) * w, (.5 + r + cy) * h);
      context.bezierTo((.5 + d + cx) * w, (.5 + r + cy) * h,
        (.5 + r + cx) * w, (.5 + d + cy) * h,
        .4 * w, .6 * h);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(.06, .39);
      geo.spot2 = new Spot(.93, .58);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'YinYang':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var factor = Geo.KAPPA;
      var cpOffset = factor * .5;
      var radius = .5;
      var context = Util.tempStreamGeometryContext();


      cpOffset = factor * .5;
      radius = .5;
      context.beginFigure(w * 0.5, 0, true);
      context.arcTo(270, 180, w * 0.5, w * 0.5, w * 0.5); // Right semi-circle
      // Middle curves
      //context.bezierTo(1 * w, (radius + cpOffset) * h, (radius + cpOffset) * w, 1 * h, radius * w, 1 * h);
      context.bezierTo(1 * w, radius * h, 0, radius * h, radius * w, 0, true);

      radius = .1;
      var centerx = .5;
      var centery = .25;

      //top small circle, goes counter-clockwise
      context.beginFigure((centerx + radius) * w, (centery) * h, true, true);  // subpath
      context.arcTo(0, -360, w * centerx, h * centery, radius * w); // Right semi-circle
      context.closeLast();

      // Left semi-circle
      context.beginFigure(w * 0.5, 0, false);
      context.arcTo(270, -180, w * 0.5, w * 0.5, w * 0.5);
      context.setShadow(false);

      centery = .75;
      //bottom small circle
      context.beginFigure((centerx + radius) * w, (centery) * h, true);  // not a subpath
      context.arcTo(0, 360, w * centerx, h * centery, radius * w); // Right semi-circle
      context.closeLast();

      var geo = context.geo;
      geo._defaultStretch = GraphObject.Uniform;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Peace':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      var d1 = .5 * (4 * (Math.SQRT2 - 1) / 3);
      // First circle': function(shape, w, h)
      context.beginFigure(w, .5 * h, true);
      context.bezierTo(w, (.5 - d1) * h,
        (.5 + d1) * w, 0, .5 * w, 0);
      context.bezierTo((.5 - d1) * w, 0,
        0, (.5 - d1) * h, 0, .5 * h);
      context.bezierTo(0, (.5 + d1) * h,
        (.5 - d1) * w, h, .5 * w, h);
      context.bezierTo((.5 + d1) * w, h,
        w, (.5 + d1) * h, w, .5 * h);

      // Second Circle
      var d2 = .4 * (4 * (Math.SQRT2 - 1) / 3);
      context.beginFigure(.5 * w, .1 * h, true, true);  // subpath
      //start at mid-right
      //TR
      context.bezierTo((.5 + d2) * w, .1 * h,
        .9 * w, (.5 - d2) * h, .9 * w, .5 * h); // right

      //BR
      context.bezierTo(.9 * w, (.5 + d2) * h,
        (.5 + d2) * w, .9 * h, .5 * w, .9 * h); // bot

      // BL
      context.bezierTo((.5 - d2) * w, .9 * h,
        .1 * w, (.5 + d2) * h, .1 * w, .5 * h); // left

      // TL
      context.bezierTo(.1 * w, (.5 - d2) * h,
        (.5 - d2) * w, .1 * h, .5 * w, .1 * h); // top

      //?? unnecessary start of figure?
      //context.BeginFigure(w, .5 * h, true);


      // Inner Circles

      // #1
      var r = .07; // radius
      var cx = 0; // offset from Center x
      var cy = -.707 * .11; // offset from Center y
      var d = r * (4 * (Math.SQRT2 - 1) / 3);
      context.beginFigure((1 - .5 + r + cx) * w, (.5 + cy) * h, true);
      context.bezierTo((1 - .5 + r + cx) * w, (.5 - d + cy) * h,
        (.5 + d + cx) * w, (.5 - r + cy) * h,
        (.5 + cx) * w, (.5 - r + cy) * h);
      context.bezierTo((.5 - d + cx) * w, (.5 - r + cy) * h,
        (.5 - r + cx) * w, (.5 - d + cy) * h,
        (.5 - r + cx) * w, (.5 + cy) * h);
      context.bezierTo((.5 - r + cx) * w, (.5 + d + cy) * h,
        (.5 - d + cx) * w, (.5 + r + cy) * h,
        (.5 + cx) * w, (.5 + r + cy) * h);
      context.bezierTo((.5 + d + cx) * w, (.5 + r + cy) * h,
        (.5 + r + cx) * w, (.5 + d + cy) * h,
        (1 - .5 + r + cx) * w, (.5 + cy) * h);
      // #2
      r = .07; // radius
      cx = -0.707 * .11; // offset from Center x
      cy = 0.707 * .11; // offset from Center y
      d = r * (4 * (Math.SQRT2 - 1) / 3);
      context.beginFigure((1 - .5 + r + cx) * w, (.5 + cy) * h, true);
      context.bezierTo((1 - .5 + r + cx) * w, (.5 - d + cy) * h,
        (.5 + d + cx) * w, (.5 - r + cy) * h,
        (.5 + cx) * w, (.5 - r + cy) * h);
      context.bezierTo((.5 - d + cx) * w, (.5 - r + cy) * h,
        (.5 - r + cx) * w, (.5 - d + cy) * h,
        (.5 - r + cx) * w, (.5 + cy) * h);
      context.bezierTo((.5 - r + cx) * w, (.5 + d + cy) * h,
        (.5 - d + cx) * w, (.5 + r + cy) * h,
        (.5 + cx) * w, (.5 + r + cy) * h);
      context.bezierTo((.5 + d + cx) * w, (.5 + r + cy) * h,
        (.5 + r + cx) * w, (.5 + d + cy) * h,
        (1 - .5 + r + cx) * w, (.5 + cy) * h);

      // #3
      r = .07; // radius
      cx = 0.707 * .11; // offset from Center x
      cy = 0.707 * .11; // offset from Center y
      d = r * (4 * (Math.SQRT2 - 1) / 3);
      context.beginFigure((1 - .5 + r + cx) * w, (.5 + cy) * h, true);
      context.bezierTo((1 - .5 + r + cx) * w, (.5 - d + cy) * h,
        (.5 + d + cx) * w, (.5 - r + cy) * h,
        (.5 + cx) * w, (.5 - r + cy) * h);
      context.bezierTo((.5 - d + cx) * w, (.5 - r + cy) * h,
        (.5 - r + cx) * w, (.5 - d + cy) * h,
        (.5 - r + cx) * w, (.5 + cy) * h);
      context.bezierTo((.5 - r + cx) * w, (.5 + d + cy) * h,
        (.5 - d + cx) * w, (.5 + r + cy) * h,
        (.5 + cx) * w, (.5 + r + cy) * h);
      context.bezierTo((.5 + d + cx) * w, (.5 + r + cy) * h,
        (.5 + r + cx) * w, (.5 + d + cy) * h,
        (1 - .5 + r + cx) * w, (.5 + cy) * h);

      var geo = context.geo;
      geo.spot1 = new Spot(.146, .146);
      geo.spot2 = new Spot(.853, .853);
      geo._defaultStretch = GraphObject.Uniform;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'NotAllowed':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var factor = Geo.KAPPA;
      var cpOffset = factor * .5;
      var radius = .5;
      var centerx = .5;
      var centery = .5;
      var s = Util.tempStreamGeometryContext();
      // Outer circle
      s.beginFigure(centerx * w, (centery - radius) * h, true);
      //UL TL
      s.bezierTo((centerx - cpOffset) * w, (centery - radius) * h,
          (centerx - radius) * w, (centery - cpOffset) * h,
          (centerx - radius) * w, centery * h);
      //BL TB
      s.bezierTo((centerx - radius) * w, (centery + cpOffset) * h,
          (centerx - cpOffset) * w, (centery + radius) * h,
          centerx * w, (centery + radius) * h);
      //BR TR
      s.bezierTo((centerx + cpOffset) * w, (centery + radius) * h,
          (centerx + radius) * w, (centery + cpOffset) * h,
          (centerx + radius) * w, centery * h);
      //UR TT
      s.bezierTo((centerx + radius) * w, (centery - cpOffset) * h,
          (centerx + cpOffset) * w, (centery - radius) * h,
          centerx * w, (centery - radius) * h);

      // Inner circle, composed of two parts, separated by
      // a beam across going from top-right to bottom-left.
      radius = .40;
      cpOffset = factor * .40;
      // First we cut up the top right 90 degree curve into two smaller
      // curves.
      // Since its clockwise, StartOfArrow is the first of the two points
      // on the circle. EndOfArrow is the other one.
      var startOfArrowc1 = Util.tempPoint();
      var startOfArrowc2 = Util.tempPoint();
      var startOfArrow = Util.tempPoint();
      var unused = Util.tempPoint();
      Geo.breakUpBezier(centerx, centery - radius,
          centerx + cpOffset, centery - radius,
          centerx + radius, centery - cpOffset,
          centerx + radius, centery, .42, startOfArrowc1,
          startOfArrowc2, startOfArrow, unused, unused);

      var endOfArrowc1 = Util.tempPoint();
      var endOfArrowc2 = Util.tempPoint();
      var endOfArrow = Util.tempPoint();
      Geo.breakUpBezier(centerx, centery - radius,
          centerx + cpOffset, centery - radius,
          centerx + radius, centery - cpOffset,
          centerx + radius, centery, .58, unused,
          unused, endOfArrow, endOfArrowc1, endOfArrowc2);

      // Cut up the bottom left 90 degree curve into two smaller curves.
      var startOfArrow2c1 = Util.tempPoint();
      var startOfArrow2c2 = Util.tempPoint();
      var startOfArrow2 = Util.tempPoint();
      Geo.breakUpBezier(centerx, centery + radius,
          centerx - cpOffset, centery + radius,
          centerx - radius, centery + cpOffset,
          centerx - radius, centery, .42, startOfArrow2c1,
          startOfArrow2c2, startOfArrow2, unused, unused);
      var endOfArrow2c1 = Util.tempPoint();
      var endOfArrow2c2 = Util.tempPoint();
      var endOfArrow2 = Util.tempPoint();
      Geo.breakUpBezier(centerx, centery + radius,
          centerx - cpOffset, centery + radius,
          centerx - radius, centery + cpOffset,
          centerx - radius, centery, .58, unused,
          unused, endOfArrow2, endOfArrow2c1, endOfArrow2c2);

      // Take all the parts made and
      // make the two separate inner circle parts.
      s.beginFigure(endOfArrow2.x * w, endOfArrow2.y * h, true, true);  // subpath
      s.bezierTo(endOfArrow2c1.x * w, endOfArrow2c1.y * h,
          endOfArrow2c2.x * w, endOfArrow2c2.y * h,
          (centerx - radius) * w, centery * h);
      s.bezierTo((centerx - radius) * w, (centery - cpOffset) * h,
          (centerx - cpOffset) * w, (centery - radius) * h,
          centerx * w, (centery - radius) * h);
      s.bezierTo(startOfArrowc1.x * w, startOfArrowc1.y * h,
          startOfArrowc2.x * w, startOfArrowc2.y * h,
          startOfArrow.x * w, startOfArrow.y * h);
      s.lineTo(endOfArrow2.x * w, endOfArrow2.y * h);
      s.closeLast();

      s.beginFigure(startOfArrow2.x * w, startOfArrow2.y * h, true, true);  // subpath
      s.lineTo(endOfArrow.x * w, endOfArrow.y * h);
      s.bezierTo(endOfArrowc1.x * w, endOfArrowc1.y * h,
          endOfArrowc2.x * w, endOfArrowc2.y * h,
          (centerx + radius) * w, centery * h);
      s.bezierTo((centerx + radius) * w, (centery + cpOffset) * h,
          (centerx + cpOffset) * w, (centery + radius) * h,
          centerx * w, (centery + radius) * h);
      s.bezierTo(startOfArrow2c1.x * w, startOfArrow2c1.y * h,
          startOfArrow2c2.x * w, startOfArrow2c2.y * h,
          startOfArrow2.x * w, startOfArrow2.y * h);
      s.closeLast();

      Util.freePoint(startOfArrowc1);
      Util.freePoint(startOfArrowc2);
      Util.freePoint(startOfArrow);
      Util.freePoint(unused);
      Util.freePoint(endOfArrowc1);
      Util.freePoint(endOfArrowc2);
      Util.freePoint(endOfArrow);
      Util.freePoint(startOfArrow2c1);
      Util.freePoint(startOfArrow2c2);
      Util.freePoint(startOfArrow2);
      Util.freePoint(endOfArrow2c1);
      Util.freePoint(endOfArrow2c2);
      Util.freePoint(endOfArrow2);

      var geo = s.geo;
      Util.freeStreamGeometryContext(s);
      geo._defaultStretch = GraphObject.Uniform;
      return geo;
  },

      'Fragile':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      //Top and crack
      context.beginFigure(0, 0, true);
      context.lineTo(.25 * w, 0);
      context.lineTo(.2 * w, .15 * h);
      context.lineTo(.3 * w, .25 * h);
      context.lineTo(.29 * w, .33 * h);
      context.lineTo(.35 * w, .25 * h);
      context.lineTo(.3 * w, .15 * h);
      context.lineTo(.4 * w, 0);
      context.lineTo(1 * w, 0);

      // Left side
      context.bezierTo(1 * w, .25 * h,
        .75 * w, .5 * h, .55 * w, .5 * h);
      context.lineTo(.55 * w, .9 * h);

      // The base
      context.lineTo(.7 * w, .9 * h);
      context.lineTo(.7 * w, 1 * h);
      context.lineTo(.3 * w, 1 * h);
      context.lineTo(.3 * w, .9 * h);

      // Right side
      context.lineTo(.45 * w, .9 * h);
      context.lineTo(.45 * w, .5 * h);
      context.bezierTo(.25 * w, .5 * h,
        0, .25 * h, 0, 0);
      context.closeLast();

      var geo = context.geo;
      geo.spot1 = new Spot(.25, 0);
      geo.spot2 = new Spot(.75, .4);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'HourGlass':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(.65 * w, .5 * h, true);
      context.lineTo(1 * w, 1 * h);
      context.lineTo(0, 1 * h);
      context.lineTo(.35 * w, .5 * h);
      context.lineTo(0, 0);
      context.lineTo(1 * w, 0);
      context.closeLast();
      var geo = context.geo;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Lightning':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0 * w, .55 * h, true);
      context.lineTo(.75 * w, 0);
      context.lineTo(.25 * w, .45 * h);
      context.lineTo(.9 * w, .48 * h);
      context.lineTo(.4 * w, 1 * h);
      context.lineTo(.65 * w, .55 * h);
      context.closeLast();
      var geo = context.geo;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Parallelogram1':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var param1 = shape ? shape.parameter1 : 0;
      // Topleft corner's x distance from leftmost point
      if (param1 === 0) param1 = .1;

      var context = Util.tempStreamGeometryContext();
      context.beginFigure(param1 * w, 0, true);
      context.lineTo(1 * w, 0);
      context.lineTo((1 - param1) * w, 1 * h);
      context.lineTo(0, 1 * h);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(param1, 0);
      geo.spot2 = new Spot(1 - param1, 1);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Input': 'Output',             // Flowchart
      'Output':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, 1 * h, true);
      context.lineTo(.1 * w, 0);
      context.lineTo(1 * w, 0);
      context.lineTo(.9 * w, 1 * h);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(.1, 0);
      geo.spot2 = new Spot(.9, 1);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Parallelogram2':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var param1 = shape ? shape.parameter1 : 0;
      // Topleft corner's x distance from leftmost point
      if (param1 === 0) param1 = .25;

      var context = Util.tempStreamGeometryContext();
      context.beginFigure(param1 * w, 0, true);
      context.lineTo(1 * w, 0);
      context.lineTo((1 - param1) * w, 1 * h);
      context.lineTo(0, 1 * h);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(param1, 0);
      geo.spot2 = new Spot(1 - param1, 1);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'ThickCross':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var param1 = shape ? shape.parameter1 : 0;
      if (param1 === 0) param1 = .25; // Margin of the cross

      var context = Util.tempStreamGeometryContext();
      context.beginFigure((.5 - param1 / 2) * w, 0, true);
      context.lineTo((.5 + param1 / 2) * w, 0);
      context.lineTo((.5 + param1 / 2) * w, (.5 - param1 / 2) * h);

      context.lineTo(1 * w, (.5 - param1 / 2) * h);
      context.lineTo(1 * w, (.5 + param1 / 2) * h);
      context.lineTo((.5 + param1 / 2) * w, (.5 + param1 / 2) * h);

      context.lineTo((.5 + param1 / 2) * w, 1 * h);
      context.lineTo((.5 - param1 / 2) * w, 1 * h);
      context.lineTo((.5 - param1 / 2) * w, (.5 + param1 / 2) * h);

      context.lineTo(0, (.5 + param1 / 2) * h);
      context.lineTo(0, (.5 - param1 / 2) * h);
      context.lineTo((.5 - param1 / 2) * w, (.5 - param1 / 2) * h);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(.5 - param1 / 2, .5 - param1 / 2);
      geo.spot2 = new Spot(.5 + param1 / 2, .5 + param1 / 2);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'ThickX':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var place = .25 / Math.SQRT2;

      var context = Util.tempStreamGeometryContext();
      context.beginFigure(.3 * w, 0, true);
      context.lineTo(.5 * w, .2 * h);
      context.lineTo(.7 * w, 0);
      context.lineTo(1 * w, .3 * h);
      context.lineTo(.8 * w, .5 * h);
      context.lineTo(1 * w, .7 * h);
      context.lineTo(.7 * w, 1 * h);
      context.lineTo(.5 * w, .8 * h);
      context.lineTo(.3 * w, 1 * h);
      context.lineTo(0, .7 * h);
      context.lineTo(.2 * w, .5 * h);
      context.lineTo(0, .3 * h);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(.5 - place, .5 - place);
      geo.spot2 = new Spot(.5 + place, .5 + place);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'ThinCross':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var param1 = shape ? shape.parameter1 : 0;
      if (param1 === 0) param1 = .1; // Margin of the cross

      var context = Util.tempStreamGeometryContext();
      context.beginFigure((.5 - param1 / 2) * w, 0, true);
      context.lineTo((.5 + param1 / 2) * w, 0);
      context.lineTo(
      (.5 + param1 / 2) * w, (.5 - param1 / 2) * h);
      context.lineTo(1 * w, (.5 - param1 / 2) * h);
      context.lineTo(1 * w, (.5 + param1 / 2) * h);
      context.lineTo(
      (.5 + param1 / 2) * w, (.5 + param1 / 2) * h);
      context.lineTo((.5 + param1 / 2) * w, 1 * h);
      context.lineTo((.5 - param1 / 2) * w, 1 * h);
      context.lineTo(
      (.5 - param1 / 2) * w, (.5 + param1 / 2) * h);
      context.lineTo(0, (.5 + param1 / 2) * h);
      context.lineTo(0, (.5 - param1 / 2) * h);
      context.lineTo(
      (.5 - param1 / 2) * w, (.5 - param1 / 2) * h);
      context.closeLast();
      var geo = context.geo;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'ThinX':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      s.beginFigure(.1 * w, 0, true);
      s.lineTo(.5 * w, .4 * h);
      s.lineTo(.9 * w, 0);
      s.lineTo(1 * w, .1 * h);
      s.lineTo(.6 * w, .5 * h);
      s.lineTo(1 * w, .9 * h);
      s.lineTo(.9 * w, 1 * h);
      s.lineTo(.5 * w, .6 * h);
      s.lineTo(.1 * w, 1 * h);
      s.lineTo(0, .9 * h);
      s.lineTo(.4 * w, .5 * h);
      s.lineTo(0, .1 * h);
      s.closeLast();
      var geo = s.geo;
      return geo;
  },

      'RightTriangle':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, 0, true);
      context.lineTo(1 * w, 1 * h);
      context.lineTo(0, 1 * h);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(0, .5);
      geo.spot2 = new Spot(.5, 1);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'RoundedIBeam':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, 0, true);
      context.lineTo(1 * w, 0);
      context.bezierTo(.5 * w, .25 * h,
      .5 * w, .75 * h, 1 * w, 1 * h);
      context.lineTo(0, 1 * h);
      context.bezierTo(.5 * w, .75 * h,
      .5 * w, .25 * h, 0, 0);
      context.closeLast();
      var geo = context.geo;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'RoundedRectangle':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var param1 = shape ? shape.parameter1 : 0;
      if (param1 <= 0) param1 = 5;  // default corner
      param1 = Math.min(param1, w / 3);
      param1 = Math.min(param1, h / 3);

      var cpOffset = param1 * Geo.KAPPA;

      var context = Util.tempStreamGeometryContext();
      context.beginFigure(param1, 0, true);
      context.lineTo(w - param1, 0);
      context.bezierTo(w - cpOffset, 0,
                      w, cpOffset,
                      w, param1);
      context.lineTo(w, h - param1);
      context.bezierTo(w, h - cpOffset,
                      w - cpOffset, h,
                      w - param1, h);
      context.lineTo(param1, h);
      context.bezierTo(cpOffset, h,
                      0, h - cpOffset,
                      0, h - param1);
      context.lineTo(0, param1);
      context.bezierTo(0, cpOffset,
                      cpOffset, 0,
                      param1, 0);
      context.closeLast();
      var geo = context.geo;
      if (cpOffset > 1) {
          geo.spot1 = new Spot(0, 0, cpOffset, cpOffset);
          geo.spot2 = new Spot(1, 1, -cpOffset, -cpOffset);
      } else {
          geo.spot1 = Spot.TopLeft;
          geo.spot2 = Spot.BottomRight;
      }
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Border':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var param1 = shape ? shape.parameter1 : 0;
      if (param1 <= 0) param1 = 5;  // default corner
      param1 = Math.min(param1, w / 3);
      param1 = Math.min(param1, h / 3);

      var cpOffset = 0;

      var context = Util.tempStreamGeometryContext();
      context.beginFigure(param1, 0, true);
      context.lineTo(w - param1, 0);
      context.bezierTo(w - cpOffset, 0,
                      w, cpOffset,
                      w, param1);
      context.lineTo(w, h - param1);
      context.bezierTo(w, h - cpOffset,
                      w - cpOffset, h,
                      w - param1, h);
      context.lineTo(param1, h);
      context.bezierTo(cpOffset, h,
                      0, h - cpOffset,
                      0, h - param1);
      context.lineTo(0, param1);
      context.bezierTo(0, cpOffset,
                      cpOffset, 0,
                      param1, 0);
      context.closeLast();
      var geo = context.geo;
      if (cpOffset > 1) {
          geo.spot1 = new Spot(0, 0, cpOffset, cpOffset);
          geo.spot2 = new Spot(1, 1, -cpOffset, -cpOffset);
      } else {
          geo.spot1 = Spot.TopLeft;
          geo.spot2 = Spot.BottomRight;
      }
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'SquareIBeam':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var param1 = shape ? shape.parameter1 : 0;
      // Width of the ibeam in % of the total width
      if (param1 === 0) param1 = .2;

      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, 0, true);
      context.lineTo(1 * w, 0);
      context.lineTo(1 * w, param1 * h);
      context.lineTo((.5 + param1 / 2) * w, param1 * h);
      context.lineTo((.5 + param1 / 2) * w, (1 - param1) * h);
      context.lineTo(1 * w, (1 - param1) * h);
      context.lineTo(1 * w, 1 * h);
      context.lineTo(0, 1 * h);
      context.lineTo(0, (1 - param1) * h);
      context.lineTo((.5 - param1 / 2) * w, (1 - param1) * h);
      context.lineTo((.5 - param1 / 2) * w, param1 * h);
      context.lineTo(0, param1 * h);
      context.closeLast();
      var geo = context.geo;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Trapezoid':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var param1 = shape ? shape.parameter1 : 0;
      // Distance from topleft of bounding rectangle,
      // in % of the total width, of the topleft corner
      if (param1 === 0) param1 = .2;

      var context = Util.tempStreamGeometryContext();
      context.beginFigure(param1 * w, 0, true);
      context.lineTo((1 - param1) * w, 0);
      context.lineTo(1 * w, 1 * h);
      context.lineTo(0, 1 * h);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(param1, 0);
      geo.spot2 = new Spot(1 - param1, 1);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'ManualLoop': 'ManualOperation',
      'ManualOperation':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var param1 = shape ? shape.parameter1 : 0;

      var context = Util.tempStreamGeometryContext();
      context.beginFigure(param1, 0, true);
      context.lineTo(0, 0);
      context.lineTo(1 * w, 0);
      context.lineTo(.9 * w, 1 * h);
      context.lineTo(.1 * w, 1 * h);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(.1, 0);
      geo.spot2 = new Spot(.9, 1);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'GenderMale':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      var factor = Geo.KAPPA;
      var cpOffset = factor * .4;
      var radius = .4;
      var centerx = .5;
      var centery = .5;
      var unused = Util.tempPoint();
      var mid = Util.tempPoint();
      var c1 = Util.tempPoint();
      var c2 = Util.tempPoint();
      // Outer circle
      s.beginFigure((centerx - radius) * w, centery * h, true);
      s.bezierTo((centerx - radius) * w, (centery - cpOffset) * h,
        (centerx - cpOffset) * w, (centery - radius) * h,
        centerx * w, (centery - radius) * h);
      Geo.breakUpBezier(centerx, centery - radius,
           centerx + cpOffset, centery - radius,
           centerx + radius, centery - cpOffset,
           centerx + radius, centery, .44, c1,
           c2, mid, unused, unused);
      s.bezierTo(c1.x * w, c1.y * h, c2.x * w, c2.y * h,
        mid.x * w, mid.y * h);
      var startOfArrow = Util.tempPointAt(mid.x, mid.y);
      Geo.breakUpBezier(centerx, centery - radius,
          centerx + cpOffset, centery - radius,
          centerx + radius, centery - cpOffset,
          centerx + radius, centery, .56, unused,
          unused, mid, c1, c2);
      var endOfArrow = Util.tempPointAt(mid.x, mid.y);

      s.lineTo((startOfArrow.x * .1 + .95 * .9) * w,
        (startOfArrow.y * .1) * h);
      s.lineTo(.85 * w, (startOfArrow.y * .1) * h);
      s.lineTo(.85 * w, 0);
      s.lineTo(1 * w, 0);
      s.lineTo(1 * w, .15 * h);
      s.lineTo((endOfArrow.x * .1 + .9) * w, .15 * h);
      s.lineTo((endOfArrow.x * .1 + .9) * w,
        (endOfArrow.y * .1 + .05 * .9) * h);
      s.lineTo(endOfArrow.x * w, endOfArrow.y * h);

      s.bezierTo(c1.x * w, c1.y * h, c2.x * w, c2.y * h,
        (centerx + radius) * w, centery * h);
      s.bezierTo((centerx + radius) * w, (centery + cpOffset) * h,
        (centerx + cpOffset) * w, (centery + radius) * h,
        centerx * w, (centery + radius) * h);
      s.bezierTo((centerx - cpOffset) * w, (centery + radius) * h,
        (centerx - radius) * w, (centery + cpOffset) * h,
        (centerx - radius) * w, centery * h);

      // Inner circle
      radius = .35;
      cpOffset = factor * .35;
      s.beginFigure(centerx * w, (centery - radius) * h, true, true);  // subpath
      //UL TL
      s.bezierTo((centerx - cpOffset) * w, (centery - radius) * h,
        (centerx - radius) * w, (centery - cpOffset) * h,
        (centerx - radius) * w, centery * h);
      //BL TB
      s.bezierTo((centerx - radius) * w, (centery + cpOffset) * h,
        (centerx - cpOffset) * w, (centery + radius) * h,
        centerx * w, (centery + radius) * h);
      //BR TR
      s.bezierTo((centerx + cpOffset) * w, (centery + radius) * h,
        (centerx + radius) * w, (centery + cpOffset) * h,
        (centerx + radius) * w, centery * h);

      // TR
      s.bezierTo((centerx + radius) * w, (centery - cpOffset) * h,
        (centerx + cpOffset) * w, (centery - radius) * h,
        centerx * w, (centery - radius) * h);

      //fixes hit testing
      s.beginFigure((centerx - radius) * w, centery * h, true);

      Util.freePoint(unused);
      Util.freePoint(mid);
      Util.freePoint(c1);
      Util.freePoint(c2);
      Util.freePoint(startOfArrow);
      Util.freePoint(endOfArrow);

      var geo = s.geo;
      geo.spot1 = new Spot(.202, .257);
      geo.spot2 = new Spot(.692, .839);
      geo._defaultStretch = GraphObject.Uniform;
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'GenderFemale':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      // First, the circle': function(shape, w, h)
      var context = Util.tempStreamGeometryContext();
      // Head': function(shape, w, h)
      // Outer Circle
      var r = .375; // radius
      var cx = 0; // offset from Center x
      var cy = -.125; // offset from Center y
      var d = r * (4 * (Math.SQRT2 - 1) / 3);
      context.beginFigure((.525 + cx) * w, (.5 + r + cy) * h, true);
      context.bezierTo((.5 + d + cx) * w, (.5 + r + cy) * h,
        (.5 + r + cx) * w, (.5 + d + cy) * h,
        (1 - .5 + r + cx) * w, (.5 + cy) * h);
      context.bezierTo((1 - .5 + r + cx) * w, (.5 - d + cy) * h,
        (.5 + d + cx) * w, (.5 - r + cy) * h,
        (.5 + cx) * w, (.5 - r + cy) * h);
      context.bezierTo((.5 - d + cx) * w, (.5 - r + cy) * h,
        (.5 - r + cx) * w, (.5 - d + cy) * h,
        (.5 - r + cx) * w, (.5 + cy) * h);
      context.bezierTo((.5 - r + cx) * w, (.5 + d + cy) * h,
        (.5 - d + cx) * w, (.5 + r + cy) * h,
        (.475 + cx) * w, (.5 + r + cy) * h);
      // Legs
      context.lineTo(.475 * w, .85 * h);
      context.lineTo(.425 * w, .85 * h);
      context.lineTo(.425 * w, .9 * h);
      context.lineTo(.475 * w, .9 * h);
      context.lineTo(.475 * w, 1 * h);
      context.lineTo(.525 * w, 1 * h);
      context.lineTo(.525 * w, .9 * h);
      context.lineTo(.575 * w, .9 * h);
      context.lineTo(.575 * w, .85 * h);
      context.lineTo(.525 * w, .85 * h);
      context.closeLast();

      // Inner circle
      r = .325; // radius
      cx = 0; // offset from Center x
      cy = -.125; // offset from Center y
      d = r * (4 * (Math.SQRT2 - 1) / 3);

      context.beginFigure((1 - .5 + r + cx) * w, (.5 + cy) * h, true, true);  // subpath

      context.bezierTo((.5 + r + cx) * w, (.5 + d + cy) * h,
        (.5 + d + cx) * w, (.5 + r + cy) * h,
        (.5 + cx) * w, (.5 + r + cy) * h);
      context.bezierTo((.5 - d + cx) * w, (.5 + r + cy) * h,
        (.5 - r + cx) * w, (.5 + d + cy) * h,
        (.5 - r + cx) * w, (.5 + cy) * h);
      context.bezierTo((.5 - r + cx) * w, (.5 - d + cy) * h,
        (.5 - d + cx) * w, (.5 - r + cy) * h,
        (.5 + cx) * w, (.5 - r + cy) * h);
      context.bezierTo((.5 + d + cx) * w, (.5 - r + cy) * h,
        (1 - .5 + r + cx) * w, (.5 - d + cy) * h,
        (1 - .5 + r + cx) * w, (.5 + cy) * h);

      // fixes hit detection
      context.beginFigure((.525 + cx) * w, (.5 + r + cy) * h, true);
      var geo = context.geo;
      geo.spot1 = new Spot(.232, .136);
      geo.spot2 = new Spot(.782, .611);
      geo._defaultStretch = GraphObject.Uniform;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'PlusLine':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, .5 * h, false);
      context.lineTo(1 * w, .5 * h);
      context.moveTo(.5 * w, 0);
      context.lineTo(.5 * w, 1 * h);
      var geo = context.geo;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'XLine':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, 1 * h, false);
      context.lineTo(1 * w, 0);
      context.moveTo(0, 0);
      context.lineTo(1 * w, 1 * h);
      var geo = context.geo;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'AsteriskLine':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      var offset = .2 / Math.SQRT2;
      context.beginFigure(offset * w, (1 - offset) * h, false);
      context.lineTo((1 - offset) * w, offset * h);
      context.moveTo(offset * w, offset * h);
      context.lineTo((1 - offset) * w, (1 - offset) * h);
      context.moveTo(0 * w, .5 * h);
      context.lineTo(1 * w, .5 * h);
      context.moveTo(.5 * w, 0 * h);
      context.lineTo(.5 * w, 1 * h);
      var geo = context.geo;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'CircleLine':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var factor = Geo.KAPPA;
      var cpOffset = factor * .5;
      var radius = .5;

      var context = Util.tempStreamGeometryContext();
      context.beginFigure(1 * w, radius * h, false);
      context.bezierTo(1 * w, (radius + cpOffset) * h,
          (radius + cpOffset) * w, 1 * h,
          radius * w, 1 * h);
      context.bezierTo((radius - cpOffset) * w, 1 * h,
          0, (radius + cpOffset) * h,
          0, radius * h);
      context.bezierTo(0, (radius - cpOffset) * h,
          (radius - cpOffset) * w, 0,
          radius * w, 0);
      context.bezierTo((radius + cpOffset) * w, 0,
          1 * w, (radius - cpOffset) * h,
          1 * w, radius * h);
      var geo = context.geo;
      geo.spot1 = new Spot(.146, .146);
      geo.spot2 = new Spot(.853, .853);
      geo._defaultStretch = GraphObject.Uniform;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Pie':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      var r = .5;
      var cx = 0; // offset from Center x
      var cy = 0; // offset from Center y
      var d = r * (4 * (Math.SQRT2 - 1) / 3);

      var x1 = (.5 * Math.SQRT2 / 2 + .5);
      var y1 = (.5 - .5 * Math.SQRT2 / 2);
      var x4 = .5;
      var y4 = 0;
      var x2 = .7;
      var y2 = 0;
      var x3 = .5;
      var y3 = 0;

      context.beginFigure(x1 * w, (y1) * h, true);
      context.bezierTo(x2 * w, y2 * h,
        x3 * w, y3 * h, x4 * w, y4 * h);
      context.bezierTo((.5 - d + cx) * w, (.5 - r + cy) * h,
        (.5 - r + cx) * w, (.5 - d + cy) * h,
        (.5 - r + cx) * w, (.5 + cy) * h);
      context.bezierTo((.5 - r + cx) * w, (.5 + d + cy) * h,
        (.5 - d + cx) * w, (.5 + r + cy) * h,
        (.5 + cx) * w, (.5 + r + cy) * h);
      context.bezierTo((.5 + d + cx) * w, (.5 + r + cy) * h,
        (.5 + r + cx) * w, (.5 + d + cy) * h,
        (1 - .5 + r + cx) * w, (.5 + cy) * h);
      context.lineTo(.5 * w, .5 * h);
      context.closeLast();
      var geo = context.geo;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'PiePiece':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var factor = Geo.KAPPA / Math.SQRT2 * .5;
      var x1 = Math.SQRT2 / 2;
      var y1 = 1 - Math.SQRT2 / 2;
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(w, h, true);
      context.bezierTo(w, (1 - factor) * h, (x1 + factor) * w, (y1 + factor) * h, x1 * w, y1 * h);
      context.lineTo(0, h);
      context.closeLast();
      var geo = context.geo;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'StopSign':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var part = 1 / (Math.SQRT2 + 2);
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(part * w, 0, true);
      context.lineTo((1 - part) * w, 0);
      context.lineTo(1 * w, part * h);
      context.lineTo(1 * w, (1 - part) * h);
      context.lineTo((1 - part) * w, 1 * h);
      context.lineTo(part * w, 1 * h);
      context.lineTo(0, (1 - part) * h);
      context.lineTo(0, part * h);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(part / 2, part / 2);
      geo.spot2 = new Spot(1 - part / 2, 1 - part / 2);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'LogicImplies':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var param1 = shape ? shape.parameter1 : 0;
      // Distance the arrow folds from the right
      if (param1 === 0) param1 = .2;

      var context = Util.tempStreamGeometryContext();
      context.beginFigure((1 - param1) * w, 0 * h, false);
      context.lineTo(1 * w, .5 * h);
      context.lineTo((1 - param1) * w, h);
      context.moveTo(0, .5 * h);
      context.lineTo(w, .5 * h);
      var geo = context.geo;
      geo.spot1 = Spot.TopLeft;
      geo.spot2 = new Spot(.8, .5);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'LogicIff':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var param1 = shape ? shape.parameter1 : 0;
      if (param1 === 0) param1 = .2; // Distance the arrow folds from the right

      var context = Util.tempStreamGeometryContext();
      context.beginFigure((1 - param1) * w, 0 * h, false);
      context.lineTo(1 * w, .5 * h);
      context.lineTo((1 - param1) * w, h);

      context.moveTo(0, .5 * h);
      context.lineTo(w, .5 * h);

      context.moveTo(param1 * w, 0);
      context.lineTo(0, .5 * h);
      context.lineTo(param1 * w, h);
      var geo = context.geo;
      geo.spot1 = new Spot(.2, 0);
      geo.spot2 = new Spot(.8, .5);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'LogicNot':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, 0, false);
      context.lineTo(1 * w, 0);
      context.lineTo(1 * w, 1 * h);
      var geo = context.geo;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'LogicAnd':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, 1 * h, false);
      context.lineTo(.5 * w, 0);
      context.lineTo(1 * w, 1 * h);
      var geo = context.geo;
      geo.spot1 = new Spot(.25, .5);
      geo.spot2 = new Spot(.75, 1);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'LogicOr':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, 0, false);
      context.lineTo(.5 * w, 1 * h);
      context.lineTo(1 * w, 0);
      var geo = context.geo;
      geo.spot1 = new Spot(.219, 0);
      geo.spot2 = new Spot(.78, .409);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'LogicXor':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(.5 * w, 0, false);
      context.lineTo(.5 * w, 1 * h);
      context.moveTo(0, .5 * h);
      context.lineTo(1 * w, .5 * h);

      var factor = Geo.KAPPA;
      var cpOffset = factor * .5;
      var radius = .5;
      context.bezierTo(1 * w, (radius + cpOffset) * h,
        (radius + cpOffset) * w, 1 * h,
        radius * w, 1 * h);
      context.bezierTo((radius - cpOffset) * w, 1 * h,
        0, (radius + cpOffset) * h,
        0, radius * h);
      context.bezierTo(0, (radius - cpOffset) * h,
        (radius - cpOffset) * w, 0,
        radius * w, 0);
      context.bezierTo((radius + cpOffset) * w, 0,
        1 * w, (radius - cpOffset) * h,
        1 * w, radius * h);
      var geo = context.geo;
      geo._defaultStretch = GraphObject.Uniform;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'LogicTruth':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, 0, false);
      context.lineTo(1 * w, 0);
      context.moveTo(.5 * w, 0);
      context.lineTo(.5 * w, 1 * h);
      var geo = context.geo;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'LogicFalsity':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, 1 * h, false);
      context.lineTo(1 * w, 1 * h);
      context.moveTo(.5 * w, 1 * h);
      context.lineTo(.5 * w, 0);
      var geo = context.geo;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'LogicThereExists':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, 0, false);
      context.lineTo(1 * w, 0);
      context.lineTo(1 * w, .5 * h);
      context.lineTo(0, .5 * h);
      context.moveTo(1 * w, .5 * h);
      context.lineTo(1 * w, 1 * h);
      context.lineTo(0, 1 * h);
      var geo = context.geo;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'LogicForAll':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, 0, false);
      context.lineTo(.5 * w, 1 * h);
      context.lineTo(1 * w, 0);
      context.moveTo(.25 * w, .5 * h);
      context.lineTo(.75 * w, .5 * h);
      var geo = context.geo;
      geo.spot1 = new Spot(.25, 0);
      geo.spot2 = new Spot(.75, .5);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'LogicIsDefinedAs':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, 0, false);
      context.lineTo(w, 0);

      context.moveTo(0, .5 * h);
      context.lineTo(w, .5 * h);

      context.moveTo(0, h);
      context.lineTo(w, h);
      var geo = context.geo;
      geo.spot1 = new Spot(.01, .01);
      geo.spot2 = new Spot(.99, .49);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'LogicIntersect':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      // upside down U
      var factor = Geo.KAPPA;
      var cpOffset = factor * .5;
      var radius = .5;

      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, 1 * h, false);
      context.lineTo(0, radius * h);
      context.bezierTo(0, (radius - cpOffset) * h,
        (radius - cpOffset) * w, 0,
        radius * w, 0);
      context.bezierTo((radius + cpOffset) * w, 0,
        1 * w, (radius - cpOffset) * h,
        1 * w, radius * h);
      context.lineTo(1 * w, 1 * h);
      var geo = context.geo;
      geo.spot1 = new Spot(0, .5);
      geo.spot2 = Spot.BottomRight;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'LogicUnion':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      // upside right U
      var factor = Geo.KAPPA;
      var cpOffset = factor * .5;
      var radius = .5;

      var context = Util.tempStreamGeometryContext();
      context.beginFigure(1 * w, 0, false);
      context.lineTo(1 * w, radius * h);
      context.bezierTo(1 * w, (radius + cpOffset) * h,
        (radius + cpOffset) * w, 1 * h,
        radius * w, 1 * h);
      context.bezierTo((radius - cpOffset) * w, 1 * h,
        0, (radius + cpOffset) * h,
        0, radius * h);
      context.lineTo(0, 0);
      var geo = context.geo;
      geo.spot1 = Spot.TopLeft;
      geo.spot2 = new Spot(1, .5);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Arrow':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var param1 = shape ? shape.parameter1 : 0;
      var param2 = shape ? shape.parameter2 : 0;
      // % from the edge the ends of the arrow are
      if (param1 === 0) param1 = .3;
      // Arrow width
      if (param2 === 0) param2 = .3;

      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, (.5 - param2 / 2) * h, true);
      context.lineTo((1 - param1) * w, (.5 - param2 / 2) * h);

      context.lineTo((1 - param1) * w, 0);
      context.lineTo(1 * w, .5 * h);
      context.lineTo((1 - param1) * w, 1 * h);
      context.lineTo((1 - param1) * w, (.5 + param2 / 2) * h);

      context.lineTo(0, (.5 + param2 / 2) * h);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(0, .5 - param2 / 2);
      var temp = Geo.getIntersection(0, .5 + param2 / 2,
          1, .5 + param2 / 2,
          1 - param1, 1,
          1, .5,
          Util.tempPoint());
      geo.spot2 = new Spot(temp.x, temp.y);
      Util.freePoint(temp);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'ISOProcess': 'Chevron',
      'Chevron':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, 0, true);
      context.lineTo(.5 * w, 0);
      context.lineTo(1 * w, .5 * h);
      context.lineTo(.5 * w, 1 * h);
      context.lineTo(0, 1 * h);
      context.lineTo(.5 * w, .5 * h); // true, false)
      context.closeLast();
      var geo = context.geo;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'DoubleArrow':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, 0, true);
      context.lineTo(.3 * w, 0.214 * h);
      context.lineTo(.3 * w, 0);
      context.lineTo(1.0 * w, .5 * h);
      context.lineTo(.3 * w, 1.0 * h);
      context.lineTo(.3 * w, 0.786 * h);
      context.lineTo(0, 1.0 * h);
      context.closeLast();

      context.beginFigure(.3 * w, .214 * h, false);
      context.lineTo(.3 * w, .786 * h);
      context.setShadow(false);
      var geo = context.geo;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'DoubleEndArrow':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(1 * w, .5 * h, true);
      context.lineTo(.7 * w, 1 * h);
      context.lineTo(.7 * w, .7 * h);
      context.lineTo(.3 * w, .7 * h);
      context.lineTo(.3 * w, 1 * h);
      context.lineTo(0, .5 * h);
      context.lineTo(.3 * w, 0);
      context.lineTo(.3 * w, .3 * h);
      context.lineTo(.7 * w, .3 * h);
      context.lineTo(.7 * w, 0);
      context.closeLast();
      var geo = context.geo;
      var temp = Geo.getIntersection(0, .5, .3, 0, 0, .3, .3, .3, Util.tempPoint());  //?? constant
      geo.spot1 = new Spot(temp.x, temp.y);
      temp = Geo.getIntersection(.7, 1, 1, .5, .7, .7, 1, .7, temp);  //?? constant
      geo.spot2 = new Spot(temp.x, temp.y);
      Util.freePoint(temp);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'IBeamArrow':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(1 * w, .5 * h, true);
      context.lineTo(.7 * w, 1 * h);
      context.lineTo(.7 * w, .7 * h);
      context.lineTo(.2 * w, .7 * h);
      context.lineTo(.2 * w, 1 * h);
      context.lineTo(0, 1 * h);
      context.lineTo(0, 0);
      context.lineTo(.2 * w, 0);
      context.lineTo(.2 * w, .3 * h);
      context.lineTo(.7 * w, .3 * h);
      context.lineTo(.7 * w, 0);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(0, .3);
      var temp = Geo.getIntersection(.7, 1, 1, .5, .7, .7, 1, .7, Util.tempPoint());  //?? constant
      geo.spot2 = new Spot(temp.x, temp.y);
      Util.freePoint(temp);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Pointer':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(1 * w, .5 * h, true);
      context.lineTo(0, 1 * h);
      context.lineTo(.2 * w, .5 * h);
      context.lineTo(0, 0);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(.2, .35);
      var temp = Geo.getIntersection(.2, .65, 1, .65, 0, 1, 1, .5, Util.tempPoint());  //?? constant
      geo.spot2 = new Spot(temp.x, temp.y);
      Util.freePoint(temp);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'RoundedPointer':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(1 * w, .5 * h, true);
      context.lineTo(0, 1 * h);
      context.bezierTo(.5 * w, .75 * h,
          .5 * w, .25 * h,
          0, 0);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(.4, .35);
      var temp = Geo.getIntersection(.2, .65, 1, .65, 0, 1, 1, .5, Util.tempPoint());  //?? constant
      geo.spot2 = new Spot(temp.x, temp.y);
      Util.freePoint(temp);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'SplitEndArrow':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(1 * w, .5 * h, true);
      context.lineTo(.7 * w, 1 * h);
      context.lineTo(.7 * w, .7 * h);
      context.lineTo(0, .7 * h);
      context.lineTo(.2 * w, .5 * h);
      context.lineTo(0, .3 * h);
      context.lineTo(.7 * w, .3 * h);
      context.lineTo(.7 * w, 0);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(.2, .3);
      var temp = Geo.getIntersection(.7, 1, 1, .5, .7, .7, 1, .7, Util.tempPoint());  //?? constant
      geo.spot2 = new Spot(temp.x, temp.y);
      Util.freePoint(temp);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'MessageToUser': 'SquareArrow',
      'SquareArrow':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(1 * w, .5 * h, true);
      context.lineTo(.7 * w, 1 * h);
      context.lineTo(0, 1 * h);
      context.lineTo(0, 0);
      context.lineTo(.7 * w, 0);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = Spot.TopLeft;
      geo.spot2 = new Spot(.7, 1);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Cone1':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var factor = Geo.KAPPA;
      var cpxOffset = factor * .5;
      var cpyOffset = factor * .1;

      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, .9 * h, true);
      context.lineTo(.5 * w, 0);
      context.lineTo(1 * w, .9 * h);
      context.bezierTo(1 * w, (.9 + cpyOffset) * h,
        (.5 + cpxOffset) * w, 1 * h,
        .5 * w, 1 * h);
      context.bezierTo((.5 - cpxOffset) * w, 1 * h,
        0, (.9 + cpyOffset) * h,
        0, .9 * h);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(.25, .5);
      geo.spot2 = new Spot(.75, .97);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Cone2':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, .9 * h, true);
      context.bezierTo((1 - .85 / .9) * w, 1 * h,
        (.85 / .9) * w, 1 * h,
        1 * w, .9 * h);

      context.lineTo(.5 * w, 0);
      context.lineTo(0, .9 * h);
      context.closeLast();

      context.beginFigure(0, .9 * h, false);
      context.bezierTo((1 - .85 / .9) * w, .8 * h,
        (.85 / .9) * w, .8 * h,
        1 * w, .9 * h);
      context.setShadow(false);
      var geo = context.geo;
      geo.spot1 = new Spot(.25, .5);
      geo.spot2 = new Spot(.75, .82);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Cube1':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(.5 * w, 1 * h, true);
      context.lineTo(1 * w, .85 * h);
      context.lineTo(1 * w, .15 * h);
      context.lineTo(.5 * w, 0 * h);
      context.lineTo(0 * w, .15 * h);
      context.lineTo(0 * w, .85 * h);
      context.closeLast();

      context.beginFigure(.5 * w, 1 * h, false);
      context.lineTo(.5 * w, .3 * h);
      context.lineTo(0, .15 * h);
      context.moveTo(.5 * w, .3 * h);
      context.lineTo(1 * w, .15 * h);
      context.setShadow(false);

      var geo = context.geo;
      geo.spot1 = new Spot(0, .3);
      geo.spot2 = new Spot(.5, .85);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Cube2':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, .3 * h, true);
      context.lineTo(0 * w, 1 * h);
      context.lineTo(.7 * w, h);
      context.lineTo(1 * w, .7 * h);
      context.lineTo(1 * w, 0 * h);
      context.lineTo(.3 * w, 0 * h);
      context.closeLast();

      context.beginFigure(0, .3 * h, false);
      context.lineTo(.7 * w, .3 * h);
      context.lineTo(1 * w, 0 * h);
      context.moveTo(.7 * w, .3 * h);
      context.lineTo(.7 * w, 1 * h);
      context.setShadow(false);
      var geo = context.geo;
      geo.spot1 = new Spot(0, .3);
      geo.spot2 = new Spot(.7, 1);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'MagneticData': 'Cylinder1',
      'Cylinder1':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var factor = Geo.KAPPA;
      var cpxOffset = factor * .5;
      var cpyOffset = factor * .1;

      var context = Util.tempStreamGeometryContext();
      // The base (top)
      context.beginFigure(0, .1 * h, true);
      context.bezierTo(0, (.1 - cpyOffset) * h,
        (.5 - cpxOffset) * w, 0, .5 * w, 0);
      context.bezierTo((.5 + cpxOffset) * w, 0,
        1.0 * w, (.1 - cpyOffset) * h,
        1.0 * w, .1 * h);
      context.lineTo(w, .9 * h);

      //// Bottom curve
      context.bezierTo(1.0 * w, (.9 + cpyOffset) * h,
        (.5 + cpxOffset) * w, 1.0 * h,
        .5 * w, 1.0 * h);
      context.bezierTo((.5 - cpxOffset) * w, 1.0 * h,
        0, (.9 + cpyOffset) * h,
        0, .9 * h);
      context.lineTo(0, .1 * h);

      context.beginFigure(0, .1 * h, false);
      context.bezierTo(0, (.1 + cpyOffset) * h,
        (.5 - cpxOffset) * w, .2 * h,
        .5 * w, .2 * h);
      context.bezierTo((.5 + cpxOffset) * w, .2 * h,
        1.0 * w, (.1 + cpyOffset) * h,
        1.0 * w, .1 * h);
      context.setShadow(false);
      var geo = context.geo;
      geo.spot1 = new Spot(0, .2);
      geo.spot2 = new Spot(1, .9);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Cylinder2':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var factor = Geo.KAPPA;
      var cpxOffset = factor * .5;
      var cpyOffset = factor * .1;

      var s = Util.tempStreamGeometryContext();
      // The body, starting and ending bottom left
      s.beginFigure(0, .9 * h, true);
      s.lineTo(0, .1 * h);
      s.bezierTo(0, (.1 - cpyOffset) * h,
        (.5 - cpxOffset) * w, 0,
        .5 * w, 0);
      s.bezierTo((.5 + cpxOffset) * w, 0,
        1 * w, (.1 - cpyOffset) * h,
        1 * w, .1 * h);
      s.lineTo(1 * w, .9 * h);
      s.bezierTo(1 * w, (.9 + cpyOffset) * h,
        (.5 + cpxOffset) * w, 1 * h,
        .5 * w, 1 * h);
      s.bezierTo((.5 - cpxOffset) * w, 1 * h,
        0, (.9 + cpyOffset) * h,
        0, .9 * h);

      // The base (bottom)
      s.beginFigure(0, .9 * h, false);
      s.bezierTo(0, (.9 - cpyOffset) * h,
        (.5 - cpxOffset) * w, .8 * h,
        .5 * w, .8 * h);
      s.bezierTo((.5 + cpxOffset) * w, .8 * h,
        1 * w, (.9 - cpyOffset) * h,
        1 * w, .9 * h);
      s.setShadow(false);
      var geo = s.geo;
      geo.spot1 = new Spot(0, .1);
      geo.spot2 = new Spot(1, .8);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'Cylinder3':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var factor = Geo.KAPPA;
      var cpxOffset = factor * .1;
      var cpyOffset = factor * .5;

      var s = Util.tempStreamGeometryContext();
      // The body, starting and ending top left
      s.beginFigure(.1 * w, 0, true);
      s.lineTo(.9 * w, 0);
      s.bezierTo((.9 + cpxOffset) * w, 0,
        1 * w, (.5 - cpyOffset) * h,
        1 * w, .5 * h);
      s.bezierTo(1 * w, (.5 + cpyOffset) * h,
        (.9 + cpxOffset) * w, 1 * h,
        .9 * w, 1 * h);  //other side down
      s.lineTo(.1 * w, 1 * h);
      s.bezierTo((.1 - cpxOffset) * w, 1 * h,
        0, (.5 + cpyOffset) * h,
        0, .5 * h);
      s.bezierTo(0, (.5 - cpyOffset) * h,
        (.1 - cpxOffset) * w, 0,
        .1 * w, 0);

      //cylinder line (left)
      s.beginFigure(.1 * w, 0, false);
      s.bezierTo((.1 + cpxOffset) * w, 0,
        .2 * w, (.5 - cpyOffset) * h,
        .2 * w, .5 * h);
      s.bezierTo(.2 * w, (.5 + cpyOffset) * h,
        (.1 + cpxOffset) * w, 1 * h,
        .1 * w, 1 * h);
      s.setShadow(false);
      var geo = s.geo;
      geo.spot1 = new Spot(.2, 0);
      geo.spot2 = new Spot(.9, 1);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'DirectData': 'Cylinder4',
      'Cylinder4':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var factor = Geo.KAPPA;
      var cpxOffset = factor * .1;
      var cpyOffset = factor * .5;

      var s = Util.tempStreamGeometryContext();
      // The body, starting and ending top right
      s.beginFigure(.9 * w, 0, true);
      s.bezierTo((.9 + cpxOffset) * w, 0,
        1 * w, (.5 - cpyOffset) * h,
        1 * w, .5 * h);
      s.bezierTo(1 * w, (.5 + cpyOffset) * h,
        (.9 + cpxOffset) * w, 1 * h,
        .9 * w, 1 * h);
      s.lineTo(.1 * w, 1 * h);
      s.bezierTo((.1 - cpxOffset) * w, 1 * h,
        0, (.5 + cpyOffset) * h,
        0, .5 * h);
      s.bezierTo(0, (.5 - cpyOffset) * h,
        (.1 - cpxOffset) * w, 0,
        .1 * w, 0);
      s.lineTo(.9 * w, 0);

      // Cylinder line (right)
      s.beginFigure(.9 * w, 0, false);
      s.bezierTo((.9 - cpxOffset) * w, 0,
        .8 * w, (.5 - cpyOffset) * h,
        .8 * w, .5 * h);
      s.bezierTo(.8 * w, (.5 + cpyOffset) * h,
        (.9 - cpxOffset) * w, 1 * h,
        .9 * w, 1 * h);
      s.setShadow(false);
      var geo = s.geo;
      geo.spot1 = new Spot(.1, 0);
      geo.spot2 = new Spot(.8, 1);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'Prism1':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(.25 * w, .25 * h, true);
      context.lineTo(.75 * w, 0);
      context.lineTo(w, .5 * h);
      context.lineTo(.5 * w, h);
      context.lineTo(0, h);
      context.closeLast();

      //inner prism line
      context.beginFigure(.25 * w, .25 * h, false);
      context.lineTo(.5 * w, h);
      context.setShadow(false);
      var geo = context.geo;
      geo.spot1 = new Spot(.408, .172);
      geo.spot2 = new Spot(.833, .662);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Prism2':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, .25 * h, true);
      context.lineTo(.75 * w, 0);
      context.lineTo(1 * w, .25 * h);
      context.lineTo(.75 * w, .75 * h);
      context.lineTo(0, 1 * h);
      context.closeLast();

      //inner prism lines
      context.beginFigure(0, h, false);
      context.lineTo(.25 * w, .5 * h);
      context.lineTo(w, .25 * h);

      context.moveTo(0, .25 * h);
      context.lineTo(.25 * w, .5 * h);
      context.setShadow(false);
      var geo = context.geo;
      geo.spot1 = new Spot(.25, .5);
      geo.spot2 = new Spot(.75, .75);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Pyramid1':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(.5 * w, 0, true);
      context.lineTo(w, .75 * h);
      context.lineTo(.5 * w, 1 * h);
      context.lineTo(0, .75 * h);
      context.closeLast();

      //inner pyramid line
      context.beginFigure(.5 * w, 0, false);
      context.lineTo(.5 * w, 1 * h);
      context.setShadow(false);
      var geo = context.geo;
      geo.spot1 = new Spot(.25, .367);
      geo.spot2 = new Spot(.75, .875);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Pyramid2':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(.5 * w, 0, true);
      context.lineTo(w, .85 * h);
      context.lineTo(.5 * w, 1 * h);
      context.lineTo(0, .85 * h);
      context.closeLast();

      //inner pyramid lines
      context.beginFigure(.5 * w, 0, false);
      context.lineTo(.5 * w, .7 * h);
      context.lineTo(0, .85 * h);

      context.moveTo(.5 * w, .7 * h);
      context.lineTo(1 * w, .85 * h);
      context.setShadow(false);
      var geo = context.geo;
      geo.spot1 = new Spot(.25, .367);
      geo.spot2 = new Spot(.75, .875);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Actor':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var factor = Geo.KAPPA;
      var radiusw = .2;
      var radiush = .1;
      var offsetw = factor * radiusw;
      var offseth = factor * radiush;
      var centerx = .5;
      var centery = .1;

      var s = Util.tempStreamGeometryContext();
      // Head
      s.beginFigure(centerx * w, (centery + radiush) * h, true);
      s.bezierTo((centerx - offsetw) * w, (centery + radiush) * h,
      (centerx - radiusw) * w, (centery + offseth) * h,
      (centerx - radiusw) * w, centery * h);
      s.bezierTo((centerx - radiusw) * w, (centery - offseth) * h,
      (centerx - offsetw) * w, (centery - radiush) * h,
      centerx * w, (centery - radiush) * h);
      s.bezierTo((centerx + offsetw) * w, (centery - radiush) * h,
      (centerx + radiusw) * w, (centery - offseth) * h,
      (centerx + radiusw) * w, centery * h);
      s.bezierTo((centerx + radiusw) * w, (centery + offseth) * h,
      (centerx + offsetw) * w, (centery + radiush) * h,
      centerx * w, (centery + radiush) * h);

      // Body
      var r = .05;
      var cpOffset = factor * r;
      centerx = .05;
      centery = .25;

      s.beginFigure(.5 * w, .2 * h, true);
      s.lineTo(.95 * w, .2 * h);
      centerx = .95;
      centery = .25;
      // Right shoulder
      s.bezierTo((centerx + cpOffset) * w, (centery - r) * h,
      (centerx + r) * w, (centery - cpOffset) * h,
      (centerx + r) * w, centery * h);
      // Right arm
      s.lineTo(1 * w, .6 * h);
      s.lineTo(.85 * w, .6 * h);
      s.lineTo(.85 * w, .35 * h);

      // Under right arm
      r = .025;
      cpOffset = factor * r;
      centerx = .825;
      centery = .35;
      s.bezierTo((centerx + r) * w, (centery - cpOffset) * h,
      (centerx + cpOffset) * w, (centery - r) * h,
      centerx * w, (centery - r) * h);
      s.bezierTo((centerx - cpOffset) * w, (centery - r) * h,
      (centerx - r) * w, (centery - cpOffset) * h,
      (centerx - r) * w, centery * h);

      // Right side/leg
      s.lineTo(.8 * w, 1 * h);
      s.lineTo(.55 * w, 1 * h);
      s.lineTo(.55 * w, .7 * h);

      // Right in between
      r = .05;
      cpOffset = factor * r;
      centerx = .5;
      centery = .7;
      s.bezierTo((centerx + r) * w, (centery - cpOffset) * h,
      (centerx + cpOffset) * w, (centery - r) * h,
      centerx * w, (centery - r) * h);
      s.bezierTo((centerx - cpOffset) * w, (centery - r) * h,
      (centerx - r) * w, (centery - cpOffset) * h,
      (centerx - r) * w, centery * h);

      // Left side/leg
      s.lineTo(.45 * w, 1 * h);
      s.lineTo(.2 * w, 1 * h);
      s.lineTo(.2 * w, .35 * h);

      // Left under arm
      r = .025;
      cpOffset = factor * r;
      centerx = .175;
      centery = .35;
      s.bezierTo((centerx + r) * w, (centery - cpOffset) * h,
      (centerx + cpOffset) * w, (centery - r) * h,
      centerx * w, (centery - r) * h);
      s.bezierTo((centerx - cpOffset) * w, (centery - r) * h,
      (centerx - r) * w, (centery - cpOffset) * h,
      (centerx - r) * w, centery * h);

      // Left arm
      s.lineTo(.15 * w, .6 * h);
      s.lineTo(0 * w, .6 * h);
      s.lineTo(0 * w, .25 * h);

      r = .05;
      cpOffset = factor * r;
      centerx = .05;
      centery = .25;
      // Left shoulder
      s.bezierTo((centerx - r) * w, (centery - cpOffset) * h,
      (centerx - cpOffset) * w, (centery - r) * h,
      centerx * w, (centery - r) * h);
      s.lineTo(.5 * w, .2 * h);
      var geo = s.geo;
      geo.spot1 = new Spot(.2, .2);
      geo.spot2 = new Spot(.8, .65);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'Card':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(1 * w, 0 * h, true);
      context.lineTo(1 * w, 1 * h);
      context.lineTo(0 * w, 1 * h);
      context.lineTo(0 * w, .2 * h);
      context.lineTo(.2 * w, 0 * h);
      context.closeLast();
      var geo = context.geo;
      geo.spot1 = new Spot(0, .2);
      geo.spot2 = Spot.BottomRight;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Collate':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(.5 * w, .5 * h, true);
      context.lineTo(0, 0);
      context.lineTo(1 * w, 0);
      context.lineTo(.5 * w, .5 * h);

      context.beginFigure(.5 * w, .5 * h, true);
      context.lineTo(1 * w, 1 * h);
      context.lineTo(0, 1 * h);
      context.lineTo(.5 * w, .5 * h);
      var geo = context.geo;
      geo.spot1 = new Spot(.25, 0);
      geo.spot2 = new Spot(.75, .25);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'CreateRequest':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var param1 = shape ? shape.parameter1 : 0;
      if (param1 === 0) param1 = .1;

      var context = Util.tempStreamGeometryContext();
      // Body
      context.beginFigure(0, 0, true);
      context.lineTo(1 * w, 0);
      context.lineTo(1 * w, 1 * h);
      context.lineTo(0, 1 * h);
      context.closeLast();
      // Inside lines
      context.beginFigure(0, param1 * h, false);
      context.lineTo(1 * w, param1 * h);
      context.moveTo(0, (1 - param1) * h);
      context.lineTo(1 * w, (1 - param1) * h);
      context.setShadow(false);
      var geo = context.geo;
      geo.spot1 = new Spot(0, param1);
      geo.spot2 = new Spot(1, 1 - param1);
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'Database':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      var factor = Geo.KAPPA;
      var cpxOffset = factor * .5;
      var cpyOffset = factor * .1;
      // Body
      s.beginFigure(1 * w, .1 * h, true);
      s.lineTo(1 * w, .9 * h);
      s.bezierTo(1 * w, (.9 + cpyOffset) * h,
        (.5 + cpxOffset) * w, 1 * h,
        .5 * w, 1 * h);
      s.bezierTo((.5 - cpxOffset) * w, 1 * h,
        0, (.9 + cpyOffset) * h,
        0, .9 * h);
      s.lineTo(0, .1 * h);
      s.bezierTo(0, (.1 - cpyOffset) * h,
        (.5 - cpxOffset) * w, 0,
        .5 * w, 0);
      s.bezierTo((.5 + cpxOffset) * w, 0,
        1 * w, (.1 - cpyOffset) * h,
        1 * w, .1 * h);

      // Rings
      s.beginFigure(1 * w, .1 * h, false);
      s.bezierTo(1 * w, (.1 + cpyOffset) * h,
        (.5 + cpxOffset) * w, .2 * h,
        .5 * w, .2 * h);
      s.bezierTo((.5 - cpxOffset) * w, .2 * h,
        0, (.1 + cpyOffset) * h,
        0, .1 * h);
      s.moveTo(1 * w, .2 * h);
      s.bezierTo(1 * w, (.2 + cpyOffset) * h,
        (.5 + cpxOffset) * w, .3 * h,
        .5 * w, .3 * h);
      s.bezierTo((.5 - cpxOffset) * w, .3 * h,
        0, (.2 + cpyOffset) * h,
        0, .2 * h);
      s.moveTo(1 * w, .3 * h);
      s.bezierTo(1 * w, (.3 + cpyOffset) * h,
        (.5 + cpxOffset) * w, .4 * h,
        .5 * w, .4 * h);
      s.bezierTo((.5 - cpxOffset) * w, .4 * h,
        0, (.3 + cpyOffset) * h,
        0, .3 * h);
      s.setShadow(false);
      var geo = s.geo;
      geo.spot1 = new Spot(0, .4);
      geo.spot2 = new Spot(1, .9);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'StoredData': 'DataStorage',
      'DataStorage':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      s.beginFigure(0, 0, true);
      s.lineTo(.75 * w, 0);
      s.bezierTo(1 * w, 0, 1 * w, 1 * h,
        .75 * w, 1 * h);
      s.lineTo(0, 1 * h);
      s.bezierTo(.25 * w, .9 * h, .25 * w, .1 * h,
        0, 0);
      s.closeLast();
      var geo = s.geo;
      geo.spot1 = new Spot(.226, 0);
      geo.spot2 = new Spot(.81, 1);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'DiskStorage':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      var factor = Geo.KAPPA;
      var cpxOffset = factor * .5;
      var cpyOffset = factor * .1;
      // Body
      s.beginFigure(1 * w, .1 * h, true);
      s.lineTo(1 * w, .9 * h);
      s.bezierTo(1 * w, (.9 + cpyOffset) * h,
        (.5 + cpxOffset) * w, 1 * h,
        .5 * w, 1 * h);
      s.bezierTo((.5 - cpxOffset) * w, 1 * h,
        0, (.9 + cpyOffset) * h, 0, .9 * h);
      s.lineTo(0, .1 * h);
      s.bezierTo(0, (.1 - cpyOffset) * h,
        (.5 - cpxOffset) * w, 0, .5 * w, 0);
      s.bezierTo((.5 + cpxOffset) * w, 0,
        1 * w, (.1 - cpyOffset) * h, 1 * w, .1 * h);
      // Rings
      s.beginFigure(1 * w, .1 * h, false);
      s.bezierTo(1 * w, (.1 + cpyOffset) * h,
        (.5 + cpxOffset) * w, .2 * h, .5 * w, .2 * h);
      s.bezierTo((.5 - cpxOffset) * w, .2 * h,
        0, (.1 + cpyOffset) * h, 0, .1 * h);
      s.moveTo(1 * w, .2 * h);
      s.bezierTo(1 * w, (.2 + cpyOffset) * h,
        (.5 + cpxOffset) * w, .3 * h, .5 * w, .3 * h);
      s.bezierTo((.5 - cpxOffset) * w, .3 * h,
        0, (.2 + cpyOffset) * h, 0, .2 * h);
      s.setShadow(false);
      var geo = s.geo;
      geo.spot1 = new Spot(0, .3);
      geo.spot2 = new Spot(1, .9);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'Display':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      s.beginFigure(.25 * w, 0, true);
      s.lineTo(.75 * w, 0);
      s.bezierTo(1 * w, 0, 1 * w, 1 * h,
        .75 * w, 1 * h);
      s.lineTo(.25 * w, 1 * h);
      s.lineTo(0, .5 * h);
      s.closeLast();
      var geo = s.geo;
      geo.spot1 = new Spot(.25, 0);
      geo.spot2 = new Spot(.75, 1);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'DividedEvent':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var param1 = shape ? shape.parameter1 : 0;
      if (param1 === 0) param1 = .2;
      else if (param1 < .15) param1 = .15; // Minimum

      var s = Util.tempStreamGeometryContext();
      var factor = Geo.KAPPA;
      var cpOffset = factor * .2;
      s.beginFigure(0, .2 * h, true);
      s.bezierTo(0, (.2 - cpOffset) * h,
        (.2 - cpOffset) * w, 0, .2 * w, 0);
      s.lineTo(.8 * w, 0);
      s.bezierTo((.8 + cpOffset) * w, 0,
        1 * w, (.2 - cpOffset) * h,
        1 * w, .2 * h);
      s.lineTo(1 * w, .8 * h);
      s.bezierTo(1 * w, (.8 + cpOffset) * h,
        (.8 + cpOffset) * w, 1 * h,
        .8 * w, 1 * h);
      s.lineTo(.2 * w, 1 * h);
      s.bezierTo((.2 - cpOffset) * w, 1 * h,
        0, (.8 + cpOffset) * h,
        0, .8 * h);
      s.lineTo(0, .2 * h);

      s.beginFigure(0, param1 * h, false);
      s.lineTo(1 * w, param1 * h);
      s.setShadow(false);
      var geo = s.geo;
      geo.spot1 = new Spot(0, param1);
      geo.spot2 = new Spot(1, 1 - param1);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'DividedProcess':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var param1 = shape ? shape.parameter1 : 0;
      if (param1 < .1) param1 = .1; // Minimum

      var s = Util.tempStreamGeometryContext();
      s.beginFigure(0, 0, true);
      s.lineTo(1 * w, 0);
      s.lineTo(1 * w, 1 * h);
      s.lineTo(0, 1 * h);
      s.closeLast();

      s.beginFigure(0, param1 * h, false);
      s.lineTo(1 * w, param1 * h);
      s.setShadow(false);
      var geo = s.geo;
      geo.spot1 = new Spot(0, param1);
      geo.spot2 = Spot.BottomRight;
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'Document':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      h = h / .8;
      var s = Util.tempStreamGeometryContext();
      s.beginFigure(0, .7 * h, true);
      s.lineTo(0, 0);
      s.lineTo(1 * w, 0);
      s.lineTo(1 * w, .7 * h);
      s.bezierTo(.5 * w, .4 * h, .5 * w, 1 * h,
        0, .7 * h);
      s.closeLast();

      var geo = s.geo;
      geo.spot1 = Spot.TopLeft;
      geo.spot2 = new Spot(1, .6);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'ExternalOrganization':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var param1 = shape ? shape.parameter1 : 0;
      if (param1 < .2) param1 = .2; // Minimum

      var s = Util.tempStreamGeometryContext();
      // Body
      s.beginFigure(0, 0, true);
      s.lineTo(1 * w, 0);
      s.lineTo(1 * w, 1 * h);
      s.lineTo(0, 1 * h);
      s.closeLast();

      // Top left triangle
      s.beginFigure(param1 * w, 0, false);
      s.lineTo(0, param1 * h);
      // Top right triangle
      s.moveTo(1 * w, param1 * h);
      s.lineTo((1 - param1) * w, 0);
      // Bottom left triangle
      s.moveTo(0, (1 - param1) * h);
      s.lineTo(param1 * w, 1 * h);
      // Bottom Right triangle
      s.moveTo((1 - param1) * w, 1 * h);
      s.lineTo(1 * w, (1 - param1) * h);
      s.setShadow(false);
      var geo = s.geo;
      geo.spot1 = new Spot(param1 / 2, param1 / 2);
      geo.spot2 = new Spot(1 - param1 / 2, 1 - param1 / 2);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'ExternalProcess':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      // Body
      s.beginFigure(.5 * w, 0, true);
      s.lineTo(1 * w, .5 * h);
      s.lineTo(.5 * w, 1 * h);
      s.lineTo(0, .5 * h);
      s.closeLast();

      // Top left triangle
      s.beginFigure(.1 * w, .4 * h, false);
      s.lineTo(.1 * w, .6 * h);
      // Top right triangle
      s.moveTo(.9 * w, .6 * h);
      s.lineTo(.9 * w, .4 * h);
      // Bottom left triangle
      s.moveTo(.6 * w, .1 * h);
      s.lineTo(.4 * w, .1 * h);
      // Bottom Right triangle
      s.moveTo(.4 * w, .9 * h);
      s.lineTo(.6 * w, .9 * h);
      s.setShadow(false);
      var geo = s.geo;
      geo.spot1 = new Spot(.25, .25);
      geo.spot2 = new Spot(.75, .75);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'File':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      // Body
      s.beginFigure(0, 0, true);
      s.lineTo(.75 * w, 0);
      s.lineTo(1 * w, .25 * h);
      s.lineTo(1 * w, 1 * h);
      s.lineTo(0, 1 * h);
      s.closeLast();
      // The fold
      s.beginFigure(.75 * w, 0, false);
      s.lineTo(.75 * w, .25 * h);
      s.lineTo(1 * w, .25 * h);
      s.setShadow(false);
      var geo = s.geo;
      geo.spot1 = new Spot(0, .25);
      geo.spot2 = Spot.BottomRight;
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'Interrupt':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      s.beginFigure(1 * w, .5 * h, true);
      s.lineTo(0, 1 * h);
      s.lineTo(0, 0);
      s.lineTo(1 * w, .5 * h);
      s.beginFigure(1 * w, .5 * h, false);
      s.lineTo(1 * w, 1 * h);
      s.beginFigure(1 * w, .5 * h, false);
      s.lineTo(1 * w, 0);
      var geo = s.geo;
      geo.spot1 = new Spot(0, .25);
      geo.spot2 = new Spot(.5, .75);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'InternalStorage':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var param1 = shape ? shape.parameter1 : 0;
      var param2 = shape ? shape.parameter2 : 0;
      if (param1 === 0) param1 = .1; // Distance from left
      if (param2 === 0) param2 = .1; // Distance from top

      var s = Util.tempStreamGeometryContext();
      // The main body
      s.beginFigure(0, 0, true);
      s.lineTo(1 * w, 0);
      s.lineTo(1 * w, 1 * h);
      s.lineTo(0, 1 * h);
      s.closeLast();
      // Two lines
      s.beginFigure(param1 * w, 0, false);
      s.lineTo(param1 * w, 1 * h);
      s.moveTo(0, param2 * h);
      s.lineTo(1 * w, param2 * h);
      s.setShadow(false);
      var geo = s.geo;
      geo.spot1 = new Spot(param1, param2);
      geo.spot2 = Spot.BottomRight;
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'Junction':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      // X in circle
      var factor = Geo.KAPPA;
      var dist = (1 / Math.SQRT2);
      var small = ((1 - 1 / Math.SQRT2) / 2);
      var cpOffset = factor * .5;
      var radius = .5;

      // Circle
      s.beginFigure(1 * w, radius * h, true);
      s.bezierTo(1 * w, (radius + cpOffset) * h,
        (radius + cpOffset) * w, 1 * h,
        radius * w, 1 * h);
      s.bezierTo((radius - cpOffset) * w, 1 * h,
        0, (radius + cpOffset) * h,
        0, radius * h);
      s.bezierTo(0, (radius - cpOffset) * h,
        (radius - cpOffset) * w, 0,
        radius * w, 0);
      s.bezierTo((radius + cpOffset) * w, 0,
        1 * w, (radius - cpOffset) * h,
        1 * w, radius * h);

      // X
      s.beginFigure((small + dist) * w, (small + dist) * h, false);
      s.lineTo(small * w, small * h);
      s.moveTo(small * w, (small + dist) * h);
      s.lineTo((small + dist) * w, small * h);
      s.setShadow(false);
      var geo = s.geo;
      geo._defaultStretch = GraphObject.Uniform;
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'LinedDocument':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      h = h / .8;
      var s = Util.tempStreamGeometryContext();
      s.beginFigure(0, .7 * h, true);
      s.lineTo(0, 0);
      s.lineTo(1 * w, 0);
      s.lineTo(1 * w, .7 * h);
      s.bezierTo(.5 * w, .4 * h, .5 * w, 1 * h,
      0, .7 * h);
      s.closeLast();

      s.beginFigure(.1 * w, 0, false);
      s.lineTo(.1 * w, .75 * h);
      s.setShadow(false);
      var geo = s.geo;
      geo.spot1 = new Spot(.1, 0);
      geo.spot2 = new Spot(1, .6);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'LoopLimit':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      s.beginFigure(0, 1 * h, true);
      s.lineTo(0, .25 * h);
      s.lineTo(.25 * w, 0);
      s.lineTo(.75 * w, 0);
      s.lineTo(1 * w, .25 * h);
      s.lineTo(1 * w, 1 * h);
      s.closeLast();
      var geo = s.geo;
      geo.spot1 = new Spot(0, .25);
      geo.spot2 = Spot.BottomRight;
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'SequentialData': 'MagneticTape',
      'MagneticTape':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      var factor = Geo.KAPPA;
      var cpOffset = factor * .5;
      var radius = .5;

      s.beginFigure(.5 * w, 1 * h, true);
      s.bezierTo((radius - cpOffset) * w, 1 * h,
                   0, (radius + cpOffset) * h,
                   0, radius * h);
      s.bezierTo(0, (radius - cpOffset) * h,
                   (radius - cpOffset) * w, 0,
                   radius * w, 0);
      s.bezierTo((radius + cpOffset) * w, 0,
                   1 * w, (radius - cpOffset) * h,
                   1 * w, radius * h);
      s.bezierTo(1 * w, (radius + cpOffset) * h,
                   (radius + cpOffset) * w, .9 * h,
                   (radius + .1) * w, .9 * h);
      s.lineTo(1 * w, .9 * h);
      s.lineTo(1 * w, 1 * h);
      s.lineTo(.5 * w, 1 * h);
      var geo = s.geo;
      geo.spot1 = new Spot(.15, .15);
      geo.spot2 = new Spot(.85, .8);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'ManualInput':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      s.beginFigure(1 * w, 0, true);
      s.lineTo(1 * w, 1 * h);
      s.lineTo(0, 1 * h);
      s.lineTo(0, .25 * h);
      s.closeLast();
      var geo = s.geo;
      geo.spot1 = new Spot(0, .25);
      geo.spot2 = Spot.BottomRight;
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'MessageFromUser':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var param1 = shape ? shape.parameter1 : 0;
      if (param1 === 0) param1 = .7; // How far from the right the point is

      var s = Util.tempStreamGeometryContext();
      s.beginFigure(0, 0, true);
      s.lineTo(1 * w, 0);
      s.lineTo(param1 * w, .5 * h);
      s.lineTo(1 * w, 1 * h);
      s.lineTo(0, 1 * h);
      s.closeLast();
      var geo = s.geo;
      geo.spot1 = Spot.TopLeft;
      geo.spot2 = new Spot(param1, 1);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'MicroformProcessing':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var param1 = shape ? shape.parameter1 : 0;
      if (param1 === 0) param1 = .25; // How far from the top/bottom the points are

      var s = Util.tempStreamGeometryContext();
      s.beginFigure(0, 0, true);
      s.lineTo(.5 * w, param1 * h);
      s.lineTo(1 * w, 0);
      s.lineTo(1 * w, 1 * h);
      s.lineTo(.5 * w, (1 - param1) * h);
      s.lineTo(0, 1 * h);
      s.closeLast();
      var geo = s.geo;
      geo.spot1 = new Spot(0, param1);
      geo.spot2 = new Spot(1, 1 - param1);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'MicroformRecording':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      s.beginFigure(0, 0, true);
      s.lineTo(.75 * w, .25 * h);
      s.lineTo(1 * w, .15 * h);
      s.lineTo(1 * w, .85 * h);
      s.lineTo(.75 * w, .75 * h);
      s.lineTo(0, 1 * h);
      s.closeLast();
      var geo = s.geo;
      geo.spot1 = new Spot(0, .25);
      geo.spot2 = new Spot(1, .75);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'MultiDocument':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      h = h / .8;
      var s = Util.tempStreamGeometryContext();
      // Outline
      s.beginFigure(w, 0, true);
      s.lineTo(w, .5 * h);
      s.bezierTo(.96 * w, .47 * h, .93 * w, .45 * h,
                   .9 * w, .44 * h);
      s.lineTo(.9 * w, .6 * h);
      s.bezierTo(.86 * w, .57 * h, .83 * w, .55 * h,
                   .8 * w, .54 * h);
      s.lineTo(.8 * w, .7 * h);
      s.bezierTo(.4 * w, .4 * h, .4 * w, 1 * h,
                   0, .7 * h);
      s.lineTo(0, .2 * h);
      s.lineTo(.1 * w, .2 * h);
      s.lineTo(.1 * w, .1 * h);
      s.lineTo(.2 * w, .1 * h);
      s.lineTo(.2 * w, 0);
      s.closeLast();

      // Inside lines
      s.beginFigure(.1 * w, .2 * h, false);
      s.lineTo(.8 * w, .2 * h);
      s.lineTo(.8 * w, .54 * h);

      s.moveTo(.2 * w, .1 * h);
      s.lineTo(.9 * w, .1 * h);
      s.lineTo(.9 * w, .44 * h);
      s.setShadow(false);
      var geo = s.geo;
      geo.spot1 = new Spot(0, .25);
      geo.spot2 = new Spot(.8, .77);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'MultiProcess':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();

      s.beginFigure(.1 * w, .1 * h, true);
      s.lineTo(.2 * w, .1 * h);
      s.lineTo(.2 * w, 0);
      s.lineTo(1 * w, 0);
      s.lineTo(1 * w, .8 * h);
      s.lineTo(.9 * w, .8 * h);
      s.lineTo(.9 * w, .9 * h);
      s.lineTo(.8 * w, .9 * h);
      s.lineTo(.8 * w, 1 * h);
      s.lineTo(0, 1 * h);
      s.lineTo(0, .2 * h);
      s.lineTo(.1 * w, .2 * h);
      s.closeLast();

      s.beginFigure(.2 * w, .1 * h, false);
      s.lineTo(.9 * w, .1 * h);
      s.lineTo(.9 * w, .8 * h);
      s.moveTo(.1 * w, .2 * h);
      s.lineTo(.8 * w, .2 * h);
      s.lineTo(.8 * w, .9 * h);
      s.setShadow(false);
      var geo = s.geo;
      geo.spot1 = new Spot(0, .2);
      geo.spot2 = new Spot(.8, 1);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'OfflineStorage':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var param1 = shape ? shape.parameter1 : 0;
      if (param1 === 0) param1 = .1; // Distance between 2 top lines
      var l = 1 - param1; // Length of the top line

      var s = Util.tempStreamGeometryContext();
      s.beginFigure(0, 0, true);
      s.lineTo(1 * w, 0);
      s.lineTo(.5 * w, 1 * h);
      s.closeLast();

      s.beginFigure(.5 * param1 * w, param1 * h, false);
      s.lineTo((1 - .5 * param1) * w, param1 * h);
      s.setShadow(false);
      var geo = s.geo;
      geo.spot1 = new Spot(l / 4 + .5 * param1, param1);
      geo.spot2 = new Spot(3 * l / 4 + .5 * param1, param1 + .5 * l);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'OffPageConnector':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      s.beginFigure(0, 0, true);
      s.lineTo(.75 * w, 0);
      s.lineTo(1 * w, .5 * h);
      s.lineTo(.75 * w, 1 * h);
      s.lineTo(0, 1 * h);
      s.closeLast();
      var geo = s.geo;
      geo.spot1 = Spot.TopLeft;
      geo.spot2 = new Spot(.75, 1);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'Or':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      // + in circle
      var factor = Geo.KAPPA;
      var cpOffset = factor * .5;
      var radius = .5;

      // Circle
      s.beginFigure(1 * w, radius * h, true);
      s.bezierTo(1 * w, (radius + cpOffset) * h,
        (radius + cpOffset) * w, 1 * h,
        radius * w, 1 * h);
      s.bezierTo((radius - cpOffset) * w, 1 * h,
        0, (radius + cpOffset) * h,
        0, radius * h);
      s.bezierTo(0, (radius - cpOffset) * h,
        (radius - cpOffset) * w, 0,
        radius * w, 0);
      s.bezierTo((radius + cpOffset) * w, 0,
        1 * w, (radius - cpOffset) * h,
        1 * w, radius * h);

      // +
      s.beginFigure(1 * w, .5 * h, false);
      s.lineTo(0, .5 * h);
      s.moveTo(.5 * w, 1 * h);
      s.lineTo(.5 * w, 0);
      s.setShadow(false);
      var geo = s.geo;
      geo._defaultStretch = GraphObject.Uniform;
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'PaperTape':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      h = h / .8;
      var s = Util.tempStreamGeometryContext();
      s.beginFigure(0, .7 * h, true);
      s.lineTo(0, .3 * h);
      s.bezierTo(.5 * w, .6 * h,
        .5 * w, 0,
        1 * w, .3);
      s.lineTo(1 * w, .7 * h);
      s.bezierTo(.5 * w, .4 * h,
        .5 * w, 1 * h,
        0, .7 * h);
      s.closeLast();
      var geo = s.geo;
      geo.spot1 = new Spot(0, .49);
      geo.spot2 = new Spot(1, .75);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'PrimitiveFromCall':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var param1 = shape ? shape.parameter1 : 0;
      var param2 = shape ? shape.parameter2 : 0;
      if (param1 === 0) param1 = .1; // Distance of left line from left
      if (param2 === 0) param2 = .3; // Distance of point from right

      var s = Util.tempStreamGeometryContext();

      // Body
      s.beginFigure(0, 0, true);
      s.lineTo(1 * w, 0);
      s.lineTo((1 - param2) * w, .5 * h);
      s.lineTo(1 * w, 1 * h);
      s.lineTo(0, 1 * h);
      s.closeLast();
      var geo = s.geo;
      geo.spot1 = new Spot(param1, 0);
      geo.spot2 = new Spot(1 - param2, 1);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'PrimitiveToCall':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var param1 = shape ? shape.parameter1 : 0;
      var param2 = shape ? shape.parameter2 : 0;
      if (param1 === 0) param1 = .1; // Distance of left line from left
      if (param2 === 0) param2 = .3; // Distance of top and bottom right corners from right

      var s = Util.tempStreamGeometryContext();

      // Body
      s.beginFigure(0, 0, true);
      s.lineTo((1 - param2) * w, 0);
      s.lineTo(1 * w, .5 * h);
      s.lineTo((1 - param2) * w, 1 * h);
      s.lineTo(0, 1 * h);
      s.closeLast();
      var geo = s.geo;
      geo.spot1 = new Spot(param1, 0);
      geo.spot2 = new Spot(1 - param2, 1);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'Subroutine': 'Procedure',
      'Procedure':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var param1 = shape ? shape.parameter1 : 0;
      // Distance of left  and right lines from edge
      if (param1 === 0) param1 = .1;

      var s = Util.tempStreamGeometryContext();
      s.beginFigure(0, 0, true);
      s.lineTo(1 * w, 0);
      s.lineTo(1 * w, 1 * h);
      s.lineTo(0, 1 * h);
      s.closeLast();

      s.beginFigure((1 - param1) * w, 0, false);
      s.lineTo((1 - param1) * w, 1 * h);
      s.moveTo(param1 * w, 0);
      s.lineTo(param1 * w, 1 * h);
      s.setShadow(false);
      var geo = s.geo;
      geo.spot1 = new Spot(param1, 0);
      geo.spot2 = new Spot(1 - param1, 1);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'Process':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var param1 = shape ? shape.parameter1 : 0;
      if (param1 === 0) param1 = .1; // Distance of left  line from left edge

      var s = Util.tempStreamGeometryContext();
      s.beginFigure(0, 0, true);
      s.lineTo(1 * w, 0);
      s.lineTo(1 * w, 1 * h);
      s.lineTo(0, 1 * h);
      s.closeLast();

      s.beginFigure(param1 * w, 0, false);
      s.lineTo(param1 * w, 1 * h);
      s.setShadow(false);
      var geo = s.geo;
      geo.spot1 = new Spot(param1, 0);
      geo.spot2 = Spot.BottomRight;
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'Sort':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      s.beginFigure(.5 * w, 0, true);
      s.lineTo(1 * w, .5 * h);
      s.lineTo(.5 * w, 1 * h);
      s.lineTo(0, .5 * h);
      s.closeLast();

      s.beginFigure(0, .5 * h, false);
      s.lineTo(1 * w, .5 * h);
      s.setShadow(false);
      var geo = s.geo;
      geo.spot1 = new Spot(.25, .25);
      geo.spot2 = new Spot(.75, .5);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'Start':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      s.beginFigure(.25 * w, 0, true);
      s.lineTo(.75 * w, 0);
      s.bezierTo(1 * w, 0, 1 * w, 1 * h,
        .75 * w, 1 * h);
      s.lineTo(.25 * w, 1 * h);
      s.bezierTo(0, 1 * h, 0, 0,
        .25 * w, 0);

      s.beginFigure(.25 * w, 0, false);
      s.lineTo(.25 * w, 1 * h);
      s.moveTo(.75 * w, 0);
      s.lineTo(.75 * w, 1 * h);
      s.setShadow(false);
      var geo = s.geo;
      geo.spot1 = new Spot(.25, 0);
      geo.spot2 = new Spot(.75, 1);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'Terminator':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      s.beginFigure(.25 * w, 0, true);
      s.lineTo(.75 * w, 0);
      s.bezierTo(1 * w, 0, 1 * w, 1 * h,
      .75 * w, 1 * h);
      s.lineTo(.25 * w, 1 * h);
      s.bezierTo(0, 1 * h, 0, 0,
      .25 * w, 0);
      var geo = s.geo;
      geo.spot1 = new Spot(.23, 0);
      geo.spot2 = new Spot(.77, 1);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'TransmittalTape':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var param1 = shape ? shape.parameter1 : 0;
      if (param1 === 0) param1 = .1; // Bottom line's distance from the point on the triangle

      var s = Util.tempStreamGeometryContext();
      s.beginFigure(0, 0, true);
      s.lineTo(1 * w, 0);
      s.lineTo(1 * w, 1 * h);
      s.lineTo(.75 * w, (1 - param1) * h);
      s.lineTo(0, (1 - param1) * h);
      s.closeLast();
      var geo = s.geo;
      geo.spot1 = Spot.TopLeft;
      geo.spot2 = new Spot(1, 1 - param1);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      // Digital Circuits
      'AndGate':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      var factor = Geo.KAPPA;
      var cpOffset = factor * .5;

      // The gate body
      s.beginFigure(0, 0, true);
      s.lineTo(.5 * w, 0);
      s.bezierTo((.5 + cpOffset) * w, 0,
        1 * w, (.5 - cpOffset) * h, 1 * w, .5 * h);
      s.bezierTo(1 * w, (.5 + cpOffset) * h,
        (.5 + cpOffset) * w, 1 * h, .5 * w, 1 * h);
      s.lineTo(0, 1 * h);
      s.closeLast();
      var geo = s.geo;
      geo.spot1 = Spot.TopLeft;
      geo.spot2 = new Spot(.55, 1);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'Buffer':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      s.beginFigure(0, 0, true);
      s.lineTo(1 * w, .5 * h);
      s.lineTo(0, 1 * h);
      s.closeLast();
      var geo = s.geo;
      geo.spot1 = new Spot(0, .25);
      geo.spot2 = new Spot(.5, .75);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'Clock':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      var factor = Geo.KAPPA;
      var cpOffset = factor * .5;
      var radius = .5;

      // Ellipse
      s.beginFigure(1 * w, radius * h, true);
      s.bezierTo(1 * w, (radius + cpOffset) * h,
        (radius + cpOffset) * w, 1 * h,
        radius * w, 1 * h);
      s.bezierTo((radius - cpOffset) * w, 1 * h,
        0, (radius + cpOffset) * h,
        0, radius * h);
      s.bezierTo(0, (radius - cpOffset) * h,
        (radius - cpOffset) * w, 0,
        radius * w, 0);
      s.bezierTo((radius + cpOffset) * w, 0,
        1 * w, (radius - cpOffset) * h,
        1 * w, radius * h);

      // Inside clock
      // This first line solves a GDI+ graphical error with
      // more complex gradient brushes.
      s.beginFigure(1 * w, radius * h, false);
      s.lineTo(1 * w, radius * h);

      s.beginFigure(.8 * w, .75 * h, false);
      s.lineTo(.8 * w, .25 * h);
      s.lineTo(.6 * w, .25 * h);
      s.lineTo(.6 * w, .75 * h);
      s.lineTo(.4 * w, .75 * h);
      s.lineTo(.4 * w, .25 * h);
      s.lineTo(.2 * w, .25 * h);
      s.lineTo(.2 * w, .75 * h);
      s.setShadow(false);
      var geo = s.geo;
      geo._defaultStretch = GraphObject.Uniform;
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'Ground':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      s.beginFigure(.5 * w, 0, false);
      s.lineTo(.5 * w, .4 * h);
      s.moveTo(.2 * w, .6 * h);
      s.lineTo(.8 * w, .6 * h);
      s.moveTo(.3 * w, .8 * h);
      s.lineTo(.7 * w, .8 * h);
      s.moveTo(.4 * w, 1 * h);
      s.lineTo(.6 * w, 1 * h);
      var geo = s.geo;
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'Inverter':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      var factor = Geo.KAPPA;
      var cpOffset = factor * .1;
      var radius = .1;
      var centerx = .9;
      var centery = .5;

      // Triangle
      s.beginFigure(.8 * w, .5 * h, true);
      s.lineTo(0, 1 * h);
      s.lineTo(0, 0);
      s.lineTo(.8 * w, .5 * h);

      // Inversion
      s.beginFigure((centerx + radius) * w, centery * h, true);
      s.bezierTo((centerx + radius) * w, (centery + cpOffset) * h,
        (centerx + cpOffset) * w, (centery + radius) * h,
        centerx * w, (centery + radius) * h);
      s.bezierTo((centerx - cpOffset) * w, (centery + radius) * h,
        (centerx - radius) * w, (centery + cpOffset) * h,
        (centerx - radius) * w, centery * h);
      s.bezierTo((centerx - radius) * w, (centery - cpOffset) * h,
        (centerx - cpOffset) * w, (centery - radius) * h,
        centerx * w, (centery - radius) * h);
      s.bezierTo((centerx + cpOffset) * w, (centery - radius) * h,
        (centerx + radius) * w, (centery - cpOffset) * h,
        (centerx + radius) * w, centery * h);

      var geo = s.geo;
      geo.spot1 = new Spot(0, .25);
      geo.spot2 = new Spot(.4, .75);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'NandGate':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      var factor = Geo.KAPPA;
      var cpxOffset = factor * .5;
      var cpyOffset = factor * .4;

      var cpOffset = factor * .1;
      var radius = .1;
      var centerx = .9;
      var centery = .5;

      // The gate body
      s.beginFigure(.8 * w, .5 * h, true);
      s.bezierTo(.8 * w, (.5 + cpyOffset) * h,
        (.4 + cpxOffset) * w, 1 * h,
        .4 * w, 1 * h);
      s.lineTo(0, 1 * h);
      s.lineTo(0, 0);
      s.lineTo(.4 * w, 0);
      s.bezierTo((.4 + cpxOffset) * w, 0,
        .8 * w, (.5 - cpyOffset) * h,
        .8 * w, .5 * h);

      // Inversion
      s.beginFigure((centerx + radius) * w, centery * h, true);
      s.bezierTo((centerx + radius) * w, (centery + cpOffset) * h,
        (centerx + cpOffset) * w, (centery + radius) * h,
        centerx * w, (centery + radius) * h);
      s.bezierTo((centerx - cpOffset) * w, (centery + radius) * h,
        (centerx - radius) * w, (centery + cpOffset) * h,
        (centerx - radius) * w, centery * h);
      s.bezierTo((centerx - radius) * w, (centery - cpOffset) * h,
        (centerx - cpOffset) * w, (centery - radius) * h,
        centerx * w, (centery - radius) * h);
      s.bezierTo((centerx + cpOffset) * w, (centery - radius) * h,
        (centerx + radius) * w, (centery - cpOffset) * h,
        (centerx + radius) * w, (centery) * h);

      var geo = s.geo;
      geo.spot1 = new Spot(0, .05);
      geo.spot2 = new Spot(.55, .95);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'NorGate':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      var factor = Geo.KAPPA;

      // Normal
      var radius = .5;
      var cpOffset = factor * radius;
      var centerx = 0;
      var centery = .5;
      s.beginFigure(.8 * w, .5 * h, true);

      s.bezierTo(.7 * w, (centery + cpOffset) * h,
        (centerx + cpOffset) * w, (centery + radius) * h,
        0, 1 * h);
      s.bezierTo(.25 * w, .75 * h,
        .25 * w, .25 * h, 0, 0);
      s.bezierTo((centerx + cpOffset) * w, (centery - radius) * h,
        .7 * w, (centery - cpOffset) * h,
        .8 * w, .5 * h);

      // Inversion
      radius = .1;
      cpOffset = factor * .1;
      centerx = .9;
      centery = .5;

      s.beginFigure((centerx - radius) * w, centery * h, true);
      s.bezierTo((centerx - radius) * w, (centery - cpOffset) * h,
        (centerx - cpOffset) * w, (centery - radius) * h,
        centerx * w, (centery - radius) * h);
      s.bezierTo((centerx + cpOffset) * w, (centery - radius) * h,
        (centerx + radius) * w, (centery - cpOffset) * h,
        (centerx + radius) * w, centery * h);
      s.bezierTo((centerx + radius) * w, (centery + cpOffset) * h,
        (centerx + cpOffset) * w, (centery + radius) * h,
        centerx * w, (centery + radius) * h);
      s.bezierTo((centerx - cpOffset) * w, (centery + radius) * h,
        (centerx - radius) * w, (centery + cpOffset) * h,
        (centerx - radius) * w, centery * h);

      var geo = s.geo;
      geo.spot1 = new Spot(.2, .25);
      geo.spot2 = new Spot(.6, .75);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'OrGate':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      var factor = Geo.KAPPA;
      var radius = .5;
      var cpOffset = factor * radius;
      var centerx = 0;
      var centery = .5;

      s.beginFigure(0, 0, true);
      s.bezierTo((centerx + cpOffset + cpOffset) * w, (centery - radius) * h,
        .8 * w, (centery - cpOffset) * h, 1 * w, .5 * h);
      s.bezierTo(.8 * w, (centery + cpOffset) * h,
        (centerx + cpOffset + cpOffset) * w, (centery + radius) * h,
        0, 1 * h);
      s.bezierTo(.25 * w, .75 * h, .25 * w, .25 * h, 0, 0);
      s.closeLast();
      var geo = s.geo;
      geo.spot1 = new Spot(.2, .25);
      geo.spot2 = new Spot(.75, .75);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'XnorGate':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      var factor = Geo.KAPPA;

      // Normal
      var radius = .5;
      var cpOffset = factor * radius;
      var centerx = .2;
      var centery = .5;
      s.beginFigure(.1 * w, 0, false);
      s.bezierTo(.35 * w, .25 * h, .35 * w, .75 * h,
        .1 * w, 1 * h);

      s.beginFigure(.8 * w, .5 * h, true);
      s.bezierTo(.7 * w, (centery + cpOffset) * h,
        (centerx + cpOffset) * w, (centery + radius) * h,
        .2 * w, 1 * h);
      s.bezierTo(.45 * w, .75 * h, .45 * w, .25 * h,
        .2 * w, 0);
      s.bezierTo((centerx + cpOffset) * w, (centery - radius) * h,
        .7 * w, (centery - cpOffset) * h, .8 * w, .5 * h);

      // Inversion
      radius = .1;
      cpOffset = factor * .1;
      centerx = .9;
      centery = .5;
      s.beginFigure((centerx - radius) * w, centery * h, true);
      s.bezierTo((centerx - radius) * w, (centery - cpOffset) * h,
        (centerx - cpOffset) * w, (centery - radius) * h,
        centerx * w, (centery - radius) * h);
      s.bezierTo((centerx + cpOffset) * w, (centery - radius) * h,
        (centerx + radius) * w, (centery - cpOffset) * h,
        (centerx + radius) * w, centery * h);
      s.bezierTo((centerx + radius) * w, (centery + cpOffset) * h,
        (centerx + cpOffset) * w, (centery + radius) * h,
        centerx * w, (centery + radius) * h);
      s.bezierTo((centerx - cpOffset) * w, (centery + radius) * h,
        (centerx - radius) * w, (centery + cpOffset) * h,
        (centerx - radius) * w, centery * h);

      var geo = s.geo;
      geo.spot1 = new Spot(.4, .25);
      geo.spot2 = new Spot(.65, .75);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'XorGate':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      var factor = Geo.KAPPA;
      var radius = .5;
      var cpOffset = factor * radius;
      var centerx = .2;
      var centery = .5;

      s.beginFigure(.1 * w, 0, false);
      s.bezierTo(.35 * w, .25 * h, .35 * w, .75 * h,
        .1 * w, 1 * h);

      s.beginFigure(.2 * w, 0, true);
      s.bezierTo((centerx + cpOffset) * w, (centery - radius) * h,
        .9 * w, (centery - cpOffset) * h,
        1 * w, .5 * h);
      s.bezierTo(.9 * w, (centery + cpOffset) * h,
        (centerx + cpOffset) * w, (centery + radius) * h,
        .2 * w, 1 * h);
      s.bezierTo(.45 * w, .75 * h, .45 * w, .25 * h,
        .2 * w, 0);
      s.closeLast();
      var geo = s.geo;
      geo.spot1 = new Spot(.4, .25);
      geo.spot2 = new Spot(.8, .75);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'Capacitor':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      // Two vertical Lines
      s.beginFigure(0, 0, false);
      s.lineTo(0, 1 * h);
      s.moveTo(1 * w, 0);
      s.lineTo(1 * w, 1 * h);
      var geo = s.geo;
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'Resistor':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      s.beginFigure(0, .5 * h, false);
      s.lineTo(.1 * w, 0);
      s.lineTo(.2 * w, 1 * h);
      s.lineTo(.3 * w, 0);
      s.lineTo(.4 * w, 1 * h);
      s.lineTo(.5 * w, 0);
      s.lineTo(.6 * w, 1 * h);
      s.lineTo(.7 * w, .5 * h);  // I only go from 0 to .7, letting bounds resize it accordingly
      var geo = s.geo;
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'Inductor':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      // 3 loops and two ends
      var factor = Geo.KAPPA;
      var cpOffset = factor * .1;
      var radius = .1;
      var centerx = .1;
      var centery = .5;
      s.beginFigure((centerx - cpOffset * .5) * w, (centery + radius) * h, false);
      s.bezierTo((centerx - cpOffset) * w, (centery + radius) * h,
        (centerx - radius) * w, (centery + cpOffset) * h,
        (centerx + radius) * w, (centery + cpOffset) * h);

      centerx = .3;
      centery = .5;
      s.bezierTo((centerx + radius) * w, (centery + cpOffset) * h,
        (centerx + cpOffset) * w, (centery + radius) * h,
        centerx * w, (centery + radius) * h);
      s.bezierTo((centerx - cpOffset) * w, (centery + radius) * h,
        (centerx - radius) * w, (centery + cpOffset) * h,
        (centerx + radius) * w, (centery + cpOffset) * h);

      centerx = .5;
      centery = .5;
      s.bezierTo((centerx + radius) * w, (centery + cpOffset) * h,
        (centerx + cpOffset) * w, (centery + radius) * h,
        centerx * w, (centery + radius) * h);
      s.bezierTo((centerx - cpOffset) * w, (centery + radius) * h,
        (centerx - radius) * w, (centery + cpOffset) * h,
        (centerx + radius) * w, (centery + cpOffset) * h);

      centerx = .7;
      centery = .5;
      s.bezierTo((centerx + radius) * w, (centery + cpOffset) * h,
        (centerx + cpOffset) * w, (centery + radius) * h,
        centerx * w, (centery + radius) * h);
      s.bezierTo((centerx - cpOffset) * w, (centery + radius) * h,
        (centerx - radius) * w, (centery + cpOffset) * h,
        (centerx + radius) * w, (centery + cpOffset) * h);

      centerx = .9;
      centery = .5;
      s.bezierTo((centerx + radius) * w, (centery + cpOffset) * h,
        (centerx + cpOffset) * w, (centery + radius) * h,
        (centerx + cpOffset * .5) * w, (centery + radius) * h);
      var geo = s.geo;
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'ACvoltageSource':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      // Circle with curve in middle
      var factor = Geo.KAPPA;
      var cpOffset = factor * .5;
      var radius = .5;
      var centerx = .5;
      var centery = .5;
      s.beginFigure((centerx - radius) * w, centery * h, false);
      s.bezierTo((centerx - radius) * w, (centery - cpOffset) * h,
      (centerx - cpOffset) * w, (centery - radius) * h,
      centerx * w, (centery - radius) * h);
      s.bezierTo((centerx + cpOffset) * w, (centery - radius) * h,
      (centerx + radius) * w, (centery - cpOffset) * h,
      (centerx + radius) * w, centery * h);
      s.bezierTo((centerx + radius) * w, (centery + cpOffset) * h,
      (centerx + cpOffset) * w, (centery + radius) * h,
      centerx * w, (centery + radius) * h);
      s.bezierTo((centerx - cpOffset) * w, (centery + radius) * h,
      (centerx - radius) * w, (centery + cpOffset) * h,
      (centerx - radius) * w, centery * h);

      s.moveTo((centerx - radius + .1) * w, centery * h);
      s.bezierTo(centerx * w, (centery - radius) * h,
      centerx * w, (centery + radius) * h,
      (centerx + radius - .1) * w, centery * h);
      var geo = s.geo;
      geo._defaultStretch = GraphObject.Uniform;
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'DCvoltageSource':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      // Small vertical line and large vertical line
      s.beginFigure(0, .75 * h, false);
      s.lineTo(0, .25 * h);
      s.moveTo(1 * w, 0);
      s.lineTo(1 * w, 1 * h);
      var geo = s.geo;
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'Diode':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      // Small vertical line and large vertical line
      s.beginFigure(1 * w, 0, false);
      s.lineTo(1 * w, .5 * h);
      s.lineTo(0, 1 * h);
      s.lineTo(0, 0);
      s.lineTo(1 * w, .5 * h);
      s.lineTo(1 * w, 1 * h);
      var geo = s.geo;
      geo.spot1 = new Spot(0, .25);
      geo.spot2 = new Spot(.5, .75);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      // Computer Shapes
      'Wifi':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var origw = w;
      var origh = h;
      w = w * .38;
      h = h * .6;

      var s = Util.tempStreamGeometryContext();
      var factor = Geo.KAPPA;
      var cpOffset = factor * .8;
      var radius = .8;
      var centerx = 0;
      var centery = .5;
      var xOffset = (origw - w) / 2;
      var yOffset = (origh - h) / 2;

      //Left curves

      s.beginFigure(centerx * w + xOffset, (centery + radius) * h + yOffset, true);
      s.bezierTo((centerx - cpOffset) * w + xOffset,
      (centery + radius) * h + yOffset,
      (centerx - radius) * w + xOffset,
      (centery + cpOffset) * h + yOffset,
      (centerx - radius) * w + xOffset,
      centery * h + yOffset);
      s.bezierTo((centerx - radius) * w + xOffset,
      (centery - cpOffset) * h + yOffset,
      (centerx - cpOffset) * w + xOffset,
      (centery - radius) * h + yOffset,
      centerx * w + xOffset,
      (centery - radius) * h + yOffset);
      s.bezierTo(centerx * w + xOffset,
      (centery - radius) * h + yOffset,
      (centerx - radius + cpOffset * .5) * w + xOffset,
      (centery - cpOffset) * h + yOffset,
      (centerx - radius + cpOffset * .5) * w + xOffset,
      centery * h + yOffset);
      s.bezierTo((centerx - radius + cpOffset * .5) * w + xOffset,
      (centery + cpOffset) * h + yOffset,
      centerx * w + xOffset,
      (centery + radius) * h + yOffset,
      centerx * w + xOffset,
      (centery + radius) * h + yOffset);
      s.closeLast();

      cpOffset = factor * .4;
      radius = .4;
      centerx = .2;
      centery = .5;
      s.beginFigure(centerx * w + xOffset, (centery + radius) * h + yOffset, true);
      s.bezierTo((centerx - cpOffset) * w + xOffset,
      (centery + radius) * h + yOffset,
      (centerx - radius) * w + xOffset,
      (centery + cpOffset) * h + yOffset,
      (centerx - radius) * w + xOffset,
      centery * h + yOffset);
      s.bezierTo((centerx - radius) * w + xOffset,
      (centery - cpOffset) * h + yOffset,
      (centerx - cpOffset) * w + xOffset,
      (centery - radius) * h + yOffset,
      centerx * w + xOffset,
      (centery - radius) * h + yOffset);
      s.bezierTo(centerx * w + xOffset,
      (centery - radius) * h + yOffset,
      (centerx - radius + cpOffset * .5) * w + xOffset,
      (centery - cpOffset) * h + yOffset,
      (centerx - radius + cpOffset * .5) * w + xOffset,
      centery * h + yOffset);
      s.bezierTo((centerx - radius + cpOffset * .5) * w + xOffset,
      (centery + cpOffset) * h + yOffset,
      centerx * w + xOffset,
      (centery + radius) * h + yOffset,
      centerx * w + xOffset,
      (centery + radius) * h + yOffset);
      s.closeLast();

      //Center circle
      cpOffset = factor * .2;
      radius = .2;
      centerx = .5;
      centery = .5;
      s.beginFigure((centerx - radius) * w + xOffset, centery * h + yOffset, true);
      s.bezierTo((centerx - radius) * w + xOffset,
      (centery - cpOffset) * h + yOffset,
      (centerx - cpOffset) * w + xOffset,
      (centery - radius) * h + yOffset,
      centerx * w + xOffset,
      (centery - radius) * h + yOffset);
      s.bezierTo((centerx + cpOffset) * w + xOffset,
      (centery - radius) * h + yOffset,
      (centerx + radius) * w + xOffset,
      (centery - cpOffset) * h + yOffset,
      (centerx + radius) * w + xOffset,
      centery * h + yOffset);
      s.bezierTo((centerx + radius) * w + xOffset,
      (centery + cpOffset) * h + yOffset,
      (centerx + cpOffset) * w + xOffset,
      (centery + radius) * h + yOffset,
      centerx * w + xOffset,
      (centery + radius) * h + yOffset);
      s.bezierTo((centerx - cpOffset) * w + xOffset,
      (centery + radius) * h + yOffset,
      (centerx - radius) * w + xOffset,
      (centery + cpOffset) * h + yOffset,
      (centerx - radius) * w + xOffset,
      centery * h + yOffset);

      //Right curves
      cpOffset = factor * .4;
      radius = .4;
      centerx = .8;
      centery = .5;
      s.beginFigure(centerx * w + xOffset, (centery - radius) * h + yOffset, true);
      s.bezierTo((centerx + cpOffset) * w + xOffset,
      (centery - radius) * h + yOffset,
      (centerx + radius) * w + xOffset,
      (centery - cpOffset) * h + yOffset,
      (centerx + radius) * w + xOffset,
      centery * h + yOffset);
      s.bezierTo((centerx + radius) * w + xOffset,
      (centery + cpOffset) * h + yOffset,
      (centerx + cpOffset) * w + xOffset,
      (centery + radius) * h + yOffset,
      centerx * w + xOffset,
      (centery + radius) * h + yOffset);
      s.bezierTo(centerx * w + xOffset,
      (centery + radius) * h + yOffset,
      (centerx + radius - cpOffset * .5) * w + xOffset,
      (centery + cpOffset) * h + yOffset,
      (centerx + radius - cpOffset * .5) * w + xOffset,
      centery * h + yOffset);
      s.bezierTo((centerx + radius - cpOffset * .5) * w + xOffset,
      (centery - cpOffset) * h + yOffset,
      centerx * w + xOffset,
      (centery - radius) * h + yOffset,
      centerx * w + xOffset,
      (centery - radius) * h + yOffset);
      s.closeLast();

      cpOffset = factor * .8;
      radius = .8;
      centerx = 1;
      centery = .5;
      s.beginFigure(centerx * w + xOffset, (centery - radius) * h + yOffset, true);
      s.bezierTo((centerx + cpOffset) * w + xOffset,
      (centery - radius) * h + yOffset,
      (centerx + radius) * w + xOffset,
      (centery - cpOffset) * h + yOffset,
      (centerx + radius) * w + xOffset,
      centery * h + yOffset);
      s.bezierTo((centerx + radius) * w + xOffset,
      (centery + cpOffset) * h + yOffset,
      (centerx + cpOffset) * w + xOffset,
      (centery + radius) * h + yOffset,
      centerx * w + xOffset,
      (centery + radius) * h + yOffset);
      s.bezierTo(centerx * w + xOffset,
      (centery + radius) * h + yOffset,
      (centerx + radius - cpOffset * .5) * w + xOffset,
      (centery + cpOffset) * h + yOffset,
      (centerx + radius - cpOffset * .5) * w + xOffset,
      centery * h + yOffset);
      s.bezierTo((centerx + radius - cpOffset * .5) * w + xOffset,
      (centery - cpOffset) * h + yOffset,
      centerx * w + xOffset,
      (centery - radius) * h + yOffset,
      centerx * w + xOffset,
      (centery - radius) * h + yOffset);
      s.closeLast();

      var geo = s.geo;
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'Email':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      s.beginFigure(0, 0, true);
      s.lineTo(1 * w, 0);
      s.lineTo(1 * w, 1 * h);
      s.lineTo(0, 1 * h);
      s.lineTo(0, 0);
      s.closeLast();

      s.beginFigure(0, 0, false);
      s.lineTo(.5 * w, .6 * h);
      s.lineTo(1 * w, 0);
      s.moveTo(0, 1 * h);
      s.lineTo(.45 * w, .54 * h);
      s.moveTo(1 * w, 1 * h);
      s.lineTo(.55 * w, .54 * h);
      s.setShadow(false);
      var geo = s.geo;
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'Ethernet':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      //Boxe above the wire
      s.beginFigure(.35 * w, 0, true);
      s.lineTo(.65 * w, 0);
      s.lineTo(.65 * w, .4 * h);
      s.lineTo(.35 * w, .4 * h);
      s.lineTo(.35 * w, 0);
      s.closeLast();


      // Boxes under the wires
      s.beginFigure(.10 * w, 1 * h, true, true);
      s.lineTo(.40 * w, 1 * h);
      s.lineTo(.40 * w, .6 * h);
      s.lineTo(.10 * w, .6 * h);
      s.lineTo(.10 * w, 1 * h);
      s.closeLast();

      s.beginFigure(.60 * w, 1 * h, true, true);
      s.lineTo(.90 * w, 1 * h);
      s.lineTo(.90 * w, .6 * h);
      s.lineTo(.60 * w, .6 * h);
      s.lineTo(.60 * w, 1 * h);
      s.closeLast();

      //Wires
      s.beginFigure(0, .5 * h, false);
      s.lineTo(1 * w, .5 * h);
      s.moveTo(.5 * w, .5 * h);
      s.lineTo(.5 * w, .4 * h);
      s.moveTo(.75 * w, .5 * h);
      s.lineTo(.75 * w, .6 * h);
      s.moveTo(.25 * w, .5 * h);
      s.lineTo(.25 * w, .6 * h);
      s.setShadow(false);


      var geo = s.geo;
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'Power':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      var factor = Geo.KAPPA;
      var cpOffset = factor * .4;
      var radius = .4;
      var centerx = .5;
      var centery = .5;
      var unused = Util.tempPoint();
      var mid = Util.tempPoint();
      var c1 = Util.tempPoint();
      var c2 = Util.tempPoint();
      // Find the 45 degree midpoint for the first bezier
      Geo.breakUpBezier(centerx, centery - radius,
          centerx + cpOffset, centery - radius,
          centerx + radius, centery - cpOffset,
          centerx + radius, centery, .5, unused,
          unused, mid, c1, c2);
      var start = Util.tempPointAt(mid.x, mid.y);
      s.beginFigure(mid.x * w, mid.y * h, true);
      s.bezierTo(c1.x * w, c1.y * h, c2.x * w, c2.y * h,
        (centerx + radius) * w, centery * h);
      s.bezierTo((centerx + radius) * w, (centery + cpOffset) * h,
        (centerx + cpOffset) * w, (centery + radius) * h,
        centerx * w, (centery + radius) * h);
      s.bezierTo((centerx - cpOffset) * w, (centery + radius) * h,
        (centerx - radius) * w, (centery + cpOffset) * h,
        (centerx - radius) * w, centery * h);

      // Find the 45 degree midpoint of for the fourth bezier
      Geo.breakUpBezier(centerx - radius, centery,
          centerx - radius, centery - cpOffset,
          centerx - cpOffset, centery - radius,
          centerx, centery - radius, .5, c1,
          c2, mid, unused, unused);
      s.bezierTo(c1.x * w, c1.y * h,
        c2.x * w, c2.y * h,
        mid.x * w, mid.y * h);

      //now make a smaller circle
      cpOffset = factor * .3;
      radius = .3;

      // Find the 45 degree midpoint for the first bezier
      Geo.breakUpBezier(centerx - radius, centery,
          centerx - radius, centery - cpOffset,
          centerx - cpOffset, centery - radius,
          centerx, centery - radius, .5, c1,
          c2, mid, unused, unused);
      s.lineTo(mid.x * w, mid.y * h);
      s.bezierTo(c2.x * w, c2.y * h, c1.x * w, c1.y * h,
        (centerx - radius) * w, centery * h);
      s.bezierTo((centerx - radius) * w, (centery + cpOffset) * h,
        (centerx - cpOffset) * w, (centery + radius) * h,
        centerx * w, (centery + radius) * h);
      s.bezierTo((centerx + cpOffset) * w, (centery + radius) * h,
        (centerx + radius) * w, (centery + cpOffset) * h,
        (centerx + radius) * w, centery * h);

      // Find the 45 degree midpoint for the fourth bezier
      Geo.breakUpBezier(centerx, centery - radius,
          centerx + cpOffset, centery - radius,
          centerx + radius, centery - cpOffset,
          centerx + radius, centery, .5, unused,
          unused, mid, c1, c2);
      s.bezierTo(c2.x * w, c2.y * h, c1.x * w, c1.y * h,
        mid.x * w, mid.y * h);
      s.closeLast();

      // The line
      s.beginFigure(.45 * w, 0, true);
      s.lineTo(.45 * w, .5 * h);
      s.lineTo(.55 * w, .5 * h);
      s.lineTo(.55 * w, 0);
      s.closeLast();

      Util.freePoint(unused);
      Util.freePoint(mid);
      Util.freePoint(c1);
      Util.freePoint(c2);
      Util.freePoint(start);

      var geo = s.geo;
      geo.spot1 = new Spot(.25, .55);
      geo.spot2 = new Spot(.75, .8);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'Fallout':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      var factor = Geo.KAPPA;
      var cpOffset = factor * .5;
      var radius = .5;
      var centerx = .5;
      var centery = .5;
      //Containing circle
      s.beginFigure((centerx - radius) * w, centery * h, true);
      s.bezierTo((centerx - radius) * w, (centery - cpOffset) * h,
        (centerx - cpOffset) * w, (centery - radius) * h,
        centerx * w, (centery - radius) * h);
      s.bezierTo((centerx + cpOffset) * w, (centery - radius) * h,
        (centerx + radius) * w, (centery - cpOffset) * h,
        (centerx + radius) * w, centery * h);
      s.bezierTo((centerx + radius) * w, (centery + cpOffset) * h,
        (centerx + cpOffset) * w, (centery + radius) * h,
        centerx * w, (centery + radius) * h);
      s.bezierTo((centerx - cpOffset) * w, (centery + radius) * h,
        (centerx - radius) * w, (centery + cpOffset) * h,
        (centerx - radius) * w, centery * h);

      var offsetx = 0;
      var offsety = 0;
      //Triangles
      s.beginFigure((.3 + offsetx) * w, (.8 + offsety) * h, true, true);  // subpath
      s.lineTo((.5 + offsetx) * w, (.5 + offsety) * h);
      s.lineTo((.1 + offsetx) * w, (.5 + offsety) * h);
      s.lineTo((.3 + offsetx) * w, (.8 + offsety) * h);
      offsetx = .4;
      offsety = 0;
      s.closeLast();
      //Triangles
      s.beginFigure((.3 + offsetx) * w, (.8 + offsety) * h, true, true);  // subpath
      s.lineTo((.5 + offsetx) * w, (.5 + offsety) * h);
      s.lineTo((.1 + offsetx) * w, (.5 + offsety) * h);
      s.lineTo((.3 + offsetx) * w, (.8 + offsety) * h);
      offsetx = .2;
      offsety = -.3;
      s.closeLast();
      //Triangles
      s.beginFigure((.3 + offsetx) * w, (.8 + offsety) * h, true, true);  // subpath
      s.lineTo((.5 + offsetx) * w, (.5 + offsety) * h);
      s.lineTo((.1 + offsetx) * w, (.5 + offsety) * h);
      s.lineTo((.3 + offsetx) * w, (.8 + offsety) * h);
      s.closeLast();
      var geo = s.geo;
      geo._defaultStretch = GraphObject.Uniform;
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'IrritationHazard':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      s.beginFigure(.2 * w, 0 * h, true);
      s.lineTo(.5 * w, .3 * h);
      s.lineTo(.8 * w, 0 * h);
      s.lineTo(1 * w, .2 * h);
      s.lineTo(.7 * w, .5 * h);
      s.lineTo(1 * w, .8 * h);
      s.lineTo(.8 * w, 1 * h);
      s.lineTo(.5 * w, .7 * h);
      s.lineTo(.2 * w, 1 * h);
      s.lineTo(0 * w, .8 * h);
      s.lineTo(.3 * w, .5 * h);
      s.lineTo(0 * w, .2 * h);
      s.closeLast();
      var geo = s.geo;
      geo.spot1 = new Spot(.3, .3);
      geo.spot2 = new Spot(.7, .7);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'ElectricalHazard':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      s.beginFigure(.37, 0 * h, true);
      s.lineTo(.5 * w, .11 * h);
      s.lineTo(.77 * w, .04 * h);
      s.lineTo(.33 * w, .49 * h);
      s.lineTo(1 * w, .37 * h);
      s.lineTo(.63 * w, .86 * h);
      s.lineTo(.77 * w, .91 * h);
      s.lineTo(.34 * w, 1 * h);
      s.lineTo(.34 * w, .78 * h);
      s.lineTo(.44 * w, .8 * h);
      s.lineTo(.65 * w, .56 * h);
      s.lineTo(0 * w, .68 * h);
      s.closeLast();
      var geo = s.geo;
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'FireHazard':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var s = Util.tempStreamGeometryContext();
      s.beginFigure(.1 * w, 1 * h, true);
      s.bezierTo(-.25 * w, .63 * h,
      .45 * w, .44 * h, .29 * w, 0 * h);
      s.bezierTo(.48 * w, .17 * h,
      .54 * w, .35 * h, .51 * w, .42 * h);
      s.bezierTo(.59 * w, .29 * h,
      .58 * w, .28 * h, .59 * w, .18 * h);
      s.bezierTo(.8 * w, .34 * h,
      .88 * w, .43 * h, .75 * w, .6 * h);
      s.bezierTo(.87 * w, .48 * h,
      .88 * w, .43 * h, .88 * w, .31 * h);
      s.bezierTo(1.17 * w, .76 * h,
      .82 * w, .8 * h, .9 * w, 1 * h);
      s.closeLast();
      var geo = s.geo;
      geo.spot1 = new Spot(.05, .645);
      geo.spot2 = new Spot(.884, .908);
      Util.freeStreamGeometryContext(s);
      return geo;
  },

      'BpmnActivityLoop':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      var r = .5;
      var cx = 0; // offset from Center x
      var cy = 0; // offset from Center y
      var d = r * (4 * (Math.SQRT2 - 1) / 3);
      var mx1 = (.5 * Math.SQRT2 / 2 + .5);
      var my1 = (.5 - .5 * Math.SQRT2 / 2);
      var x1 = 1;
      var y1 = .5;
      var x2 = .5;
      var y2 = 0;
      context.beginFigure(mx1 * w, (1 - my1) * h, false);
      context.bezierTo(x1 * w, .7 * h,
      x1 * w, y1 * h, x1 * w, y1 * h);
      context.bezierTo((.5 + r + cx) * w, (.5 - d + cx) * h,
      (.5 + d + cx) * w, (.5 - r + cx) * h,
      (x2 + cx) * w, (y2 + cx) * h);
      context.bezierTo((.5 - d + cx) * w, (.5 - r + cy) * h,
      (.5 - r + cx) * w, (.5 - d + cy) * h,
      (.5 - r + cx) * w, (.5 + cy) * h);  // ccw, topmiddle to middleleft
      context.bezierTo((.5 - r + cx) * w, (.5 + d + cy) * h,
      (.5 - d + cx) * w, (.5 + r + cy) * h,
      (.35 + cx) * w, (.5 + r - .02 + cy) * h);
      // draw arrowhead
      context.moveTo((.35 + cx) * w, (.5 + r - .2 + cy) * h);
      context.lineTo((.35 + cx) * w, (.5 + r + cy) * h);
      context.lineTo((.15 + cx) * w, (.5 + r + cy) * h);
      var geo = context.geo;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'BpmnActivityParallel':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, 0, false);
      context.lineTo(0, 1 * h);
      context.moveTo(.5 * w, 0);
      context.lineTo(.5 * w, 1 * h);
      context.moveTo(1 * w, 0);
      context.lineTo(1 * w, 1 * h);
      var geo = context.geo;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'BpmnActivitySequential':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, 0, false);
      context.lineTo(1 * w, 0);
      context.moveTo(0, .5 * h);
      context.lineTo(1 * w, .5 * h);
      context.moveTo(0, 1 * h);
      context.lineTo(1 * w, 1 * h);
      var geo = context.geo;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'BpmnActivityAdHoc':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, 0, false);
      context.beginFigure(1 * w, 1 * h, false);
      context.beginFigure(0, .5 * h, false);
      context.bezierTo(.2 * w, .35 * h,
        .3 * w, .35 * h, .5 * w, .5 * h);
      context.bezierTo(.7 * w, .65 * h,
        .8 * w, .65 * h, 1 * w, .5 * h);
      var geo = context.geo;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'BpmnActivityCompensation':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, .5 * h, true);
      context.lineTo(.5 * w, 0);
      context.lineTo(.5 * w, .5 * h);
      context.lineTo(1 * w, 1 * h);
      context.lineTo(1 * w, 0);
      context.lineTo(.5 * w, .5 * h);
      context.lineTo(.5 * w, 1 * h);
      context.closeLast();
      var geo = context.geo;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'BpmnTaskMessage':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, .2 * h, true);
      context.lineTo(1 * w, .2 * h);
      context.lineTo(1 * w, .8 * h);
      context.lineTo(0, .8 * h);
      context.lineTo(0, .8 * h);
      context.closeLast();

      context.beginFigure(0, .2 * h, false);
      context.lineTo(.5 * w, .5 * h);
      context.lineTo(1 * w, .2 * h);
      context.setShadow(false);
      var geo = context.geo;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'BpmnTaskScript':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(.7 * w, 1 * h, true);
      context.lineTo(.3 * w, 1 * h);
      context.bezierTo(.6 * w, .5 * h,
      0, .5 * h, 0.3 * w, 0);
      context.lineTo(.7 * w, 0);
      context.bezierTo(.4 * w, .5 * h,
      1 * w, .5 * h, .7 * w, 1 * h);
      context.closeLast();

      //lines on script
      context.beginFigure(.45 * w, .73 * h, false);
      context.lineTo(.7 * w, .73 * h);
      context.moveTo(.38 * w, .5 * h);
      context.lineTo(.63 * w, .5 * h);
      context.moveTo(.31 * w, .27 * h);
      context.lineTo(.56 * w, .27 * h);
      context.setShadow(false);
      var geo = context.geo;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'BpmnTaskUser':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, 0, false);
      //shirt
      context.beginFigure(.335 * w, (1 - .555) * h, true);
      context.lineTo(.335 * w, (1 - .405) * h);
      context.lineTo((1 - .335) * w, (1 - .405) * h);
      context.lineTo((1 - .335) * w, (1 - .555) * h);
      context.bezierTo((1 - .12) * w, .46 * h,
        (1 - .02) * w, .54 * h, 1 * w, .68 * h);
      context.lineTo(1 * w, 1 * h);
      context.lineTo(0, 1 * h);
      context.lineTo(0, .68 * h);
      context.bezierTo(.02 * w, .54 * h,
        .12 * w, .46 * h, .335 * w, (1 - .555) * h);
      //start of neck
      context.lineTo(.365 * w, (1 - .595) * h);
      var radiushead = .5 - .285;
      var centerx = .5;
      var centery = radiushead;
      var alpha2 = Math.PI / 4;
      var factor = ((4 * (1 - Math.cos(alpha2))) / (3 * Math.sin(alpha2)));
      var cpOffset = factor * .5;
      var radiusw = radiushead;
      var radiush = radiushead;
      var offsetw = factor * radiusw;
      var offseth = factor * radiush;
      // Circle (head)
      context.bezierTo((centerx - ((offsetw + radiusw) / 2)) * w, (centery + ((radiush + offseth) / 2)) * h,
        (centerx - radiusw) * w, (centery + offseth) * h,
        (centerx - radiusw) * w, centery * h);
      context.bezierTo((centerx - radiusw) * w, (centery - offseth) * h,
        (centerx - offsetw) * w, (centery - radiush) * h,
        centerx * w, (centery - radiush) * h);
      context.bezierTo((centerx + offsetw) * w, (centery - radiush) * h,
        (centerx + radiusw) * w, (centery - offseth) * h,
        (centerx + radiusw) * w, centery * h);
      context.bezierTo((centerx + radiusw) * w, (centery + offseth) * h,
        (centerx + ((offsetw + radiusw) / 2)) * w, (centery + ((radiush + offseth) / 2)) * h,
        (1 - .365) * w, (1 - .595) * h);
      context.lineTo((1 - .365) * w, (1 - .595) * h);
      //neckline
      context.lineTo((1 - .335) * w, (1 - .555) * h);
      context.lineTo((1 - .335) * w, (1 - .405) * h);
      context.lineTo(.335 * w, (1 - .405) * h);
      //arm lines
      context.beginFigure(.2 * w, 1 * h, false);
      context.lineTo(.2 * w, .8 * h);
      context.beginFigure(.8 * w, 1 * h, false);
      context.lineTo(.8 * w, .8 * h);
      var geo = context.geo;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'BpmnEventConditional':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      // Body
      context.beginFigure(.1 * w, 0, true);
      context.lineTo(.9 * w, 0);
      context.lineTo(.9 * w, 1 * h);
      context.lineTo(.1 * w, 1 * h);
      context.closeLast();
      // Inside lines
      context.beginFigure(.2 * w, .2 * h, false);
      context.lineTo(.8 * w, .2 * h);
      context.moveTo(.2 * w, .4 * h);
      context.lineTo(.8 * w, .4 * h);
      context.moveTo(.2 * w, .6 * h);
      context.lineTo(.8 * w, .6 * h);
      context.moveTo(.2 * w, .8 * h);
      context.lineTo(.8 * w, .8 * h);
      context.setShadow(false);
      var geo = context.geo;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'BpmnEventError':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, 1 * h, true);
      context.lineTo(.33 * w, 0);
      context.lineTo(.66 * w, .50 * h);
      context.lineTo(1 * w, 0);
      context.lineTo(.66 * w, 1 * h);
      context.lineTo(.33 * w, .50 * h);
      context.closeLast();
      var geo = context.geo;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'BpmnEventEscalation':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      context.beginFigure(0, 0, false);
      // set dimensions
      context.beginFigure(1 * w, 1 * h, false);
      context.beginFigure(.1 * w, 1 * h, true);
      context.lineTo(.5 * w, 0);
      context.lineTo(.9 * w, 1 * h);
      context.lineTo(.5 * w, .5 * h);
      context.closeLast();
      var geo = context.geo;
      Util.freeStreamGeometryContext(context);
      return geo;
  },

      'BpmnEventTimer':
      /**
      * @ignore
      * @param {Shape} shape
      * @param {number} w
      * @param {number} h
      * @return {Geometry}
      */
  function(shape, w, h) {
      var context = Util.tempStreamGeometryContext();
      var radius = .5;
      var factor = Geo.KAPPA;
      var cpOffset = factor * .5;
      context.beginFigure(1 * w, radius * h, true);
      context.bezierTo(1 * w, (radius + cpOffset) * h,
        (radius + cpOffset) * w, 1 * h,
        radius * w, 1 * h);
      context.bezierTo((radius - cpOffset) * w, 1 * h,
        0, (radius + cpOffset) * h,
        0, radius * h);
      context.bezierTo(0, (radius - cpOffset) * h,
        (radius - cpOffset) * w, 0,
        radius * w, 0);
      context.bezierTo((radius + cpOffset) * w, 0,
        1 * w, (radius - cpOffset) * h,
        1 * w, radius * h);

      // now, draw the hour lines
      context.beginFigure(radius * w, 0, false);
      context.lineTo(radius * w, .15 * h);
      context.moveTo(radius * w, 1 * h);
      context.lineTo(radius * w, .85 * h);
      context.moveTo(0, radius * h);
      context.lineTo(.15 * w, radius * h);
      context.moveTo(1 * w, radius * h);
      context.lineTo(.85 * w, radius * h);

      // now draw the hands
      context.moveTo(radius * w, radius * h);
      context.lineTo(.58 * w, 0.1 * h);
      context.moveTo(radius * w, radius * h);
      context.lineTo(.78 * w, .54 * h);
      context.setShadow(false);
      var geo = context.geo;
      geo._defaultStretch = GraphObject.Uniform;
      Util.freeStreamGeometryContext(context);
      return geo;
  }

}; // end Geo.generators

(function() {
// Allow lowercase
for (var i in Geo.generators) {
  Geo.generators[i.toLowerCase()] = i;
}
})();


// Arrowheads for links
/** @ignore */
Geo.arrowheadGenerators = {
  'Standard': 'F1 m 0,0 l 8,4 -8,4 2,-4 z',
  'Backward': 'F1 m 8,0 l -2,4 2,4 -8,-4 z',
  'Triangle': 'F1 m 0,0 l 8,4.62 -8,4.62 z',
  'BackwardTriangle': 'F1 m 8,4 l 0,4 -8,-4 8,-4 0,4 z',
  'Boomerang': 'F1 m 0,0 l 8,4 -8,4 4,-4 -4,-4 z',
  'BackwardBoomerang': 'F1 m 8,0 l -8,4 8,4 -4,-4 4,-4 z',
  'SidewaysV': 'm 0,0 l 8,4 -8,4 0,-1 6,-3 -6,-3 0,-1 z',
  'BackwardV': 'm 8,0 l -8,4 8,4 0,-1 -6,-3 6,-3 0,-1 z',

  'OpenTriangle': 'm 0,0 l 8,4 -8,4',
  'BackwardOpenTriangle': 'm 8,0 l -8,4 8,4',
  'OpenTriangleLine': 'm 0,0 l 8,4 -8,4 m 8.5,0 l 0,-8',
  'BackwardOpenTriangleLine': 'm 8,0 l  -8,4 8,4 m -8.5,0 l 0,-8',

  'OpenTriangleTop': 'm 0,0 l 8,4 m 0,4',
  'BackwardOpenTriangleTop': 'm 8,0 l -8,4 m 0,4',
  'OpenTriangleBottom': 'm 0,8 l 8,-4',
  'BackwardOpenTriangleBottom': 'm 0,4 l 8,4',

  'HalfTriangleTop': 'F1 m 0,0 l 0,4 8,0 z m 0,8',
  'BackwardHalfTriangleTop': 'F1 m 8,0 l 0,4 -8,0 z m 0,8',
  'HalfTriangleBottom': 'F1 m 0,4 l 0,4 8,-4 z',
  'BackwardHalfTriangleBottom': 'F1 m 8,4 l 0,4 -8,-4 z',

  'ForwardSemiCircle': 'm 4,0 b 270 180 0 4 4',
  'BackwardSemiCircle': 'm 4,8 b 90 180 0 -4 4',

  'Feather': 'm 0,0 l 3,4 -3,4',
  'BackwardFeather': 'm 3,0 l -3,4 3,4',
  'DoubleFeathers': 'm 0,0 l 3,4 -3,4 m 3,-8 l 3,4 -3,4',
  'BackwardDoubleFeathers': 'm 3,0 l -3,4 3,4 m 3,-8 l -3,4 3,4',
  'TripleFeathers': 'm 0,0 l 3,4 -3,4 m 3,-8 l 3,4 -3,4 m 3,-8 l 3,4 -3,4',
  'BackwardTripleFeathers': 'm 3,0 l -3,4 3,4 m 3,-8 l -3,4 3,4 m 3,-8 l -3,4 3,4',

  'ForwardSlash': 'm 0,8 l 5,-8',
  'BackSlash': 'm 0,0 l 5,8',
  'DoubleForwardSlash': 'm 0,8 l 4,-8 m -2,8 l 4,-8',
  'DoubleBackSlash': 'm 0,0 l 4,8 m -2,-8 l 4,8',
  'TripleForwardSlash': 'm 0,8 l 4,-8 m -2,8 l 4,-8 m -2,8 l 4,-8',
  'TripleBackSlash': 'm 0,0 l 4,8 m -2,-8 l 4,8 m -2,-8 l 4,8',

  'Fork': 'm 0,4 l 8,0 m -8,0 l 8,-4 m -8,4 l 8,4',
  'BackwardFork': 'm 8,4 l -8,0 m 8,0 l -8,-4 m 8,4 l -8,4',
  'LineFork': 'm 0,0 l 0,8 m 0,-4 l 8,0 m -8,0 l 8,-4 m -8,4 l 8,4',
  'BackwardLineFork': 'm 8,4 l -8,0 m 8,0 l -8,-4 m 8,4 l -8,4 m 8,-8 l 0,8',
  'CircleFork': 'F1 m 6,4 b 0 360 -3 0 3 z m 0,0 l 6,0 m -6,0 l 6,-4 m -6,4 l 6,4',
  'BackwardCircleFork': 'F1 m 0,4 l 6,0 m -6,-4 l 6,4 m -6,4 l 6,-4 m 6,0 b 0 360 -3 0 3',
  'CircleLineFork': 'F1 m 6,4 b 0 360 -3 0 3 z m 1,-4 l 0,8 m 0,-4 l 6,0 m -6,0 l 6,-4 m -6,4 l 6,4',
  'BackwardCircleLineFork': 'F1 m 0,4 l 6,0 m -6,-4 l 6,4 m -6,4 l 6,-4 m 0,-4 l 0,8 m 7,-4 b 0 360 -3 0 3',

  'Circle': 'F1 m 8,4 b 0 360 -4 0 4 z',
  'Block': 'F1 m 0,0 l 0,8 8,0 0,-8 z',
  'StretchedDiamond': 'F1 m 0,3 l 5,-3 5,3 -5,3 -5,-3 z',
  'Diamond': 'F1 m 0,4 l 4,-4 4,4 -4,4 -4,-4 z',
  'Chevron': 'F1 m 0,0 l 5,0 3,4 -3,4 -5,0 3,-4 -3,-4 z',
  'StretchedChevron': 'F1 m 0,0 l 8,0 3,4 -3,4 -8,0 3,-4 -3,-4 z',

  'NormalArrow': 'F1 m 0,2 l 4,0 0,-2 4,4 -4,4 0,-2 -4,0 z',
  'X': 'm 0,0 l 8,8 m 0,-8 l -8,8',
  'TailedNormalArrow': 'F1 m 0,0 l 2,0 1,2 3,0 0,-2 2,4 -2,4 0,-2 -3,0 -1,2 -2,0 1,-4 -1,-4 z',
  'DoubleTriangle': 'F1 m 0,0 l 4,4 -4,4 0,-8 z  m 4,0 l 4,4 -4,4 0,-8 z',
  'BigEndArrow' : 'F1 m 0,0 l 5,2 0,-2 3,4 -3,4 0,-2 -5,2 0,-8 z',
  'ConcaveTailArrow': 'F1 m 0,2 h 4 v -2 l 4,4 -4,4 v -2 h -4 l 2,-2 -2,-2 z',
  'RoundedTriangle': 'F1 m 0,1 a 1,1 0 0 1 1,-1 l 7,3 a 0.5,1 0 0 1 0,2 l -7,3 a 1,1 0 0 1 -1,-1 l 0,-6 z',
  'SimpleArrow': 'F1 m 1,2 l -1,-2 2,0 1,2 -1,2 -2,0 1,-2 5,0 0,-2 2,2 -2,2 0,-2 z',
  'AccelerationArrow' : 'F1 m 0,0 l 0,8 0.2,0 0,-8 -0.2,0 z m 2,0 l 0,8 1,0 0,-8 -1,0 z m 3,0 l 2,0 2,4 -2,4 -2,0 0,-8 z',
  'BoxArrow' : 'F1 m 0,0 l 4,0 0,2 2,0 0,-2 2,4 -2,4 0,-2 -2,0 0,2 -4,0 0,-8 z',
  'TriangleLine' : 'F1 m 8,4 l -8,-4 0,8 8,-4 z m 0.5,4 l 0,-8',

  'CircleEndedArrow' : 'F1 m 10,4 l -2,-3 0,2 -2,0 0,2 2,0 0,2 2,-3 z m -4,0 b 0 360 -3 0 3 z',

  'DynamicWidthArrow' : 'F1 m 0,3 l 2,0 2,-1 2,-2 2,4 -2,4 -2,-2 -2,-1 -2,0 0,-2 z',
  'EquilibriumArrow' : 'm 0,3 l 8,0 -3,-3 m 3,5 l -8,0 3,3',
  'FastForward' : 'F1 m 0,0 l 3.5,4 0,-4 3.5,4 0,-4 1,0 0,8 -1,0 0,-4 -3.5,4 0,-4 -3.5,4 0,-8 z',
  'Kite': 'F1 m 0,4 l 2,-4 6,4 -6,4 -2,-4 z',
  'HalfArrowTop': 'F1 m 0,0 l 4,4 4,0 -8,-4 z m 0,8',
  'HalfArrowBottom': 'F1 m 0,8 l 4,-4 4,0 -8,4 z',
  'OpposingDirectionDoubleArrow' : 'F1 m 0,4 l 2,-4 0,2 4,0 0,-2 2,4 -2,4 0,-2 -4,0 0,2 -2,-4 z',
  'PartialDoubleTriangle' : 'F1 m 0,0 4,3 0,-3 4,4 -4,4 0,-3 -4,3 0,-8 z',
  'LineCircle': 'F1 m 0,0 l 0,8 m 7 -4 b 0 360 -3 0 3 z',
  'DoubleLineCircle' : 'F1 m 0,0 l 0,8 m 2,-8 l 0,8 m 7 -4 b 0 360 -3 0 3 z',
  'TripleLineCircle' : 'F1 m 0,0 l 0,8 m 2,-8 l 0,8 m 2,-8 l 0,8 m 7 -4 b 0 360 -3 0 3 z',
  'CircleLine' : 'F1 m 6 4 b 0 360 -3 0 3 z m 1,-4 l 0,8',
  'DiamondCircle': 'F1 m 8,4 l -4,4 -4,-4 4,-4 4,4 m 8,0 b 0 360 -4 0 4 z',
  'PlusCircle' : 'F1 m 8,4 b 0 360 -4 0 4 l -8 0 z m -4 -4 l 0 8',
  'OpenRightTriangleTop': 'm 8,0 l 0,4 -8,0 m 0,4',
  'OpenRightTriangleBottom' : 'm 8,8 l 0,-4 -8,0',
  'Line': 'm 0,0 l 0,8',
  'DoubleLine': 'm 0,0 l 0,8 m 2,0 l 0,-8',
  'TripleLine': 'm 0,0 l 0,8 m 2,0 l 0,-8 m 2,0 l 0,8',
  'PentagonArrow': 'F1 m 8,4 l -4,-4 -4,0 0,8 4,0 4,-4 z',

  'None': ''
}; // end Geo.arrowheadGenerators


// Gets populated with all of the above only on a diagram setup
/** @ignore */
Geo.presetGeometries = {};

// Gets populated with all of the above only on a diagram setup
/** @ignore */
Geo.arrowheadGeometries = {};

/** @ignore */
Geo.findArrowheadGeometry = function(name) {
  // on the first successful diagram setup, construct arrowhead geometries
  if (Geo.arrowheadGenerators) {
    for (var i in Geo.arrowheadGenerators) {
      var geo = Geometry.parse(Geo.arrowheadGenerators[i], false);
      Geo.arrowheadGeometries[i] = geo;
      Geo.arrowheadGeometries[i.toLowerCase()] = i;
    }
    Geo.arrowheadGenerators = undefined;
  }
  return Geo.arrowheadGeometries[name];
};


/**
* @ignore
* @name Shape#FigureGenerators
* @constant
* @static
* @return {Object}
*/
Shape['FigureGenerators'] = Geo.generators;

/**
* @ignore
* @name Shape#ArrowheadGeometries
* @constant
* @static
* @return {Object}
*/
Shape['ArrowheadGeometries'] = Geo.arrowheadGeometries;

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
Part
Adornment
*/

/**
 * The constructor builds an empty Part.
 * @constructor
 * @param {EnumValue=} type if not supplied, the default Panel type is {@link Panel#Position}.
 * @extends Panel
 * @class
 * This is the base class for all user-manipulated top-level objects.
 * Because it inherits from {@link Panel}, it is automatically a visual container
 * of other {@link GraphObject}s.
 * Because it thus also inherits from {@link GraphObject}, it also has properties such as
 * {@link GraphObject#actualBounds}, {@link GraphObject#contextMenu}, and {@link GraphObject#visible}.
 * <p>
 * If you just want an object that users can select and manipulate,
 * you can create an instance of this class.
 * <p>
 * If you want an object that also supports being connected by links to other objects,
 * use the {@link Node} class, which inherits from Part.
 * Create those connections by using instances of the {@link Link} class.
 * <p>
 * If you want a node that logically contains a subgraph of nodes and links,
 * use the {@link Group} class, which inherits from {@link Node}.
 * <p>
 * If you want an object that decorates another Part, without having to modify that Part,
 * use the {@link Adornment} class.
 * Adornments do not support linking or grouping or being selected.
 * <hr/>
 * <p>
 * Parts can be added to a {@link Layer} by calling {@link Diagram#add}.
 * You can specify which layer the part should be in by setting {@link #layerName}.
 * Parts cannot be nested in the visual tree -- you cannot call {@link Panel#add} to add a Part to a {@link Panel}.
 * <p>
 * You can construct a Part, add {@link GraphObject}s to it programmatically, and then add the part to a diagram.
 * However it is commonplace to add data to a model by setting its {@link Model#nodeDataArray} or calling {@link Model#addNodeData},
 * or for {@link Link}s, setting the {@link GraphLinksModel#linkDataArray} or calling {@link GraphLinksModel#addLinkData}.
 * Such actions will cause a diagram that is displaying the model to copy a template,
 * which is a Part that may have data {@link Binding}s, and add the new part to the diagram.
 * The {@link Panel#data} property will refer to that data object in the model.
 * <p class="box">
 * See the <a href="../../intro/usingModels.html">Introduction on using Models</a>
 * for examples and more information.
 * <hr/>
 * <p>
 * The size and position of a part is given by its {@link GraphObject#actualBounds}.
 * The size is determined by the {@link GraphObject}s that are elements inside this part.
 * You can change the position by setting {@link GraphObject#position} or {@link Part#location}.
 * <p>
 * The "location" of a part is normally the same as its "position".
 * The "position" is always the point that is at the top-left corner of the area occupied by the part.
 * But the "location" may be different from the "position" if you want to think of the part as being "at" a different spot in the part.
 * For example, you might want the "location" to be at the center of a {@link Picture} that has a {@link TextBlock} title of arbitrary size.
 * In this case you would set the {@link #locationSpot} to be {@link Spot#Center} and the {@link #locationObjectName}
 * to be the name of the Picture element in your Part.
 * <p>
 * A part may be selected or de-selected by setting its {@link #isSelected} property.
 * This may also happen due to a call to {@link Diagram#select} or other operations that change the selection.
 * The user may change this property in the operation of the {@link ClickSelectingTool},
 * due to the user's mouse click, if the part is {@link #selectable}.
 * <hr/>
 * <p>
 * There are many properties named "...able", that control what operations the user may perform on this part.
 * These properties correspond to the similarly named properties on {@link Diagram} and {@link Layer} that govern the
 * behavior for all parts in all layers or for all parts in the given layer.
 * For example, the {@link Part#copyable} property corresponds to the properties {@link Diagram#allowCopy} and {@link Layer#allowCopy}.
 * <p>
 * For each of these "ability" properties there is a corresponding "can..." predicate.
 * For example, the {@link Part#canCopy} predicate is false if any of the three previously named properties is false.
 * Commands and tools will normally call these predicates rather than just looking at Part properties.
 * <p class="box">
 * For more discussion about permissions, please read: <a href="../../intro/permissions.html">Permissions</a>.
 * <p>
 * As previously mentioned, each {@link Diagram} supports the notion of selected parts.
 * One way of displaying that a part is selected is by modifying the part.
 * You can set the {@link #selectionChanged} property to be a function that is called when the value of {@link #isSelected} has changed;
 * it is passed the Part as the first argument.
 * The function can modify the color of one or more {@link GraphObject}s in the visual tree of that Part.
 * Or perhaps it could toggle the {@link GraphObject#visible} property of an object that is normally hidden when the part is not selected.
 * <p>
 * But the Part class also supports showing separate visual objects for a part when it gets selected.
 * These visuals are typically used to show that the part is selected ("selection handles")
 * or are used to allow the user to manipulate or modify the part with a tool ("tool handles").
 * These handles are instances of {@link Adornment}s.
 * The {@link #updateAdornments} method is responsible for showing or hiding adornments,
 * normally depending on whether the part is selected.
 * <p>
 * When the {@link #selectionAdorned} property is true, a selected part automatically gets an {@link Adornment} created for it.
 * <p>
 * Tool handles are shown for those mode-less mouse-down tools that need it.
 * The process of updating adornments for a part will call {@link Tool#updateAdornments} on each tool in {@link ToolManager#mouseDownTools}.
 * Most tools might not need special tool handles.
 * But, for example, {@link ResizingTool} naturally will want to create an adornment with eight resize handles
 * positioned at the corners and at the middles of the sides of the selected node's visual element,
 * if the node has its {@link #canResize} function returning true.
 * <p>
 * However one does not always want the whole Part to get the selection handle or all tool handles.
 * Sometimes one wants to emphasize selection by highlighting a particular element within the part's visual tree.
 * This can be achieved by setting the {@link #selectionObjectName} property,
 * and making sure the desired element has the same {@link GraphObject#name} property value.
 * <p class="box">
 * For more discussion about selection, see <a href="../../intro/selection.html">Selection</a>.
 * <p>
 * Similarly the {@link #resizeObjectName} and {@link #rotateObjectName} properties direct the
 * corresponding {@link ResizingTool} and {@link RotatingTool} to operate on the particular {@link GraphObject}
 * in the Part's visual tree with the given name.
 * That includes both providing tool handles and actually modifying properties on that object.
 * <p>
 * Parts are not resizable or rotatable by default: you need to set {@link #resizable} and/or {@link #rotatable} to true.
 * <p class="box">
 * For more discussion about tools, see <a href="../../intro/tools.html">Tools</a>.
 * <p>
 * A Part may be positioned (or a {@link Link} may be routed) by a {@link Layout}.
 * This will happen automatically if the layout is the value of {@link Diagram#layout} or {@link Group#layout}.
 * <p>
 * If you set {@link #isLayoutPositioned} to false, this part will not participate in any of the standard layouts,
 * so it will not be moved by a layout or affect other parts in a layout.
 * In order for the part to get a {@link #location} or position you will need to supply it explicitly.
 * <p>
 * As parts are added to or removed from a diagram, the {@link Layout} responsible for positioning the part is invalidated.
 * This will cause the layout to be performed again in the near future, at the end of the transaction.
 * This automatic layout invalidation also occurs as parts change their visibility ({@link GraphObject#visible})
 * or their size ({@link GraphObject#actualBounds}).
 * If you do want there to be a {@link Diagram#layout} but you do not want an automatic layout to happen
 * after removing parts (for example), you can set {@link #layoutConditions} not to include the {@link Part#LayoutRemoved} flag.
 * In this particular case, you could set {@link #layoutConditions} to:
 * <code>go.Part.LayoutStandard & ~go.Part.LayoutRemoved</code>.
 * It may also reasonable for your application to set it to {@link Part#LayoutNone}.
 * Do not forget to consider applying the same conditions to links as well as to nodes and groups.
 * <p>
 * If you want to save the locations/positions of the parts in a diagram, it is commonplace to
 * data bind the {@link #location} to a property on your node data with a TwoWay {@link Binding}
 * (call {@link Binding#makeTwoWay}).
 * Then as the nodes are moved, whether manually by the user or automatically by a {@link Layout},
 * the model data is automatically updated with the location.
 * <p class="box">
 * For more discussion about related topics, see <a href="../../intro/selection.html">Selection</a>,
 * <a href="../../intro/tools.html">Tools</a>, and
 * <a href="../../intro/permissions.html">Permissions</a>.
 * <p>
 * Parts that are templates should have no relationships with other Parts.
 * Only real Parts that are in a Diagram can belong to Groups or have any Adornments.
 * Only real Nodes in a Diagram can be connected with Links.
 */
function Part(type) {
  if (arguments.length === 0) {
    Panel.call(this);
  } else {
    Panel.call(this, type);
  }

  // BIT FLAGS:

  // Part:
  // 0x00000001 this._copyable = true;
  // 0x00000002 this._deletable = true;
  // 0x00000004 this._textEditable = true;
  // 0x00000008 this._groupable = true;
  // 0x00000010 this._movable = true;
  // 0x00000020 this._selectionAdorned = true;
  // 0x00000040 this._isInDocumentBounds = true;
  // 0x00000080 this._isLayoutPositioned = true;
  // 0x00000100 this._selectable = true;
  // 0x00000200 this._reshapable = false;
  // 0x00000400 this._resizable = false;
  // 0x00000800 this._rotatable = false;
  // 0x00001000 this._isSelected = false;
  // 0x00002000 this._isShadowed = false;
  // 0x00004000 this._invalidAdornments = true;
  // 0x00008000 this._invalidPosition = true;
  // 0x00010000 this._notifyLater = false;
  // 0x00020000 this._inView = false;

  // 0x00000001|0x00000002|0x00000004|0x00000008|0x00000010|0x00000020|
  // 0x00000040|0x00000080|0x00000100|0x00004000|0x00008000
  this._partFlags = 49663;

  /** @type {string} */
  this._category = '';
  /** @type {string} */
  this._layerName = '';
  /** @type {function(Part, Layer, Layer) | null} */
  this._layerChanged = null;

  /** @type {Adornment} */
  this._selectionAdornmentTemplate = null;
  /** @type {Adornment} */
  this._resizeAdornmentTemplate = null;
  /** @type {Adornment} */
  this._rotateAdornmentTemplate = null;

  /** @type {string} */
  this._selectionObjectName = '';
  /** @type {GraphObject} */
  this._selectionObject = null;  // must be in visual tree
  /** @type {function(Part) | null} */
  this._selectionChanged = null;

  /** @type {Map} */
  this._adornments = null;  // owned Adornments
  /** @type {string} */
  this._resizeObjectName = '';
  /** @type {GraphObject} */
  this._resizeObject = null;  // must be in visual tree
  /** @type {Size} */
  this._resizeCellSize = new Size(NaN, NaN).freeze();
  /** @type {string} */
  this._rotateObjectName = '';
  /** @type {GraphObject} */
  this._rotateObject = null;  // must be in visual tree
  /** @type {string} */
  this._text = '';

  /** @type {Group} */
  this._containingGroup = null;  // owning Group
  /** @type {function(Part, Group, Group) | null} */
  this._containingGroupChanged = null;
  /** @type {Layer} */
  this._layer = null;

  /** @type {Point} */
  this._location = new Point(NaN, NaN).freeze();
  /** @type {string} */
  this._locationObjectName = '';
  /** @type {GraphObject} */
  this._locationObject = null;  // must be in visual tree
  /** @type {Spot} */
  this._locationSpot = Spot.TopLeft;
  /** @type {Point} */
  this._minLocation = Geo.InfiniteTopLeft;
  /** @type {Point} */
  this._maxLocation = Geo.InfiniteBottomRight;
  /** @type {function(Part, Point, Point) | null} */
  this._dragComputation = null;

  /** @type {number} */
  this._layoutConditions = Part.LayoutStandard;

  /** @type {Point} */
  this._shadowOffset = new Point(6, 6).freeze();
  /** @type {?string} */
  this._shadowColor = 'gray';
  /** @type {number} */
  this._shadowBlur = 4;

  // set only when drawn in the layer
  /** @type {number} */
  this._layerIndex = -1;

  // used in getDrawnSize
  /** @type {Rect} */
  this._drawnRect = new Rect();

  /** @type {Object} */
  this._nameMap = null;

  /** @type {number} */
  this._maxMiter = NaN;
}

Util.publish('Part', Part);

Util.inherit(Part, Panel);

/**
* @ignore
* Copies properties to a cloned Part.
* @this {Part}
* @param {GraphObject} copy
*/
Part.prototype.cloneProtected = function(copy) {
  Panel.prototype.cloneProtected.call(this, copy);

  // BIT FLAGS:
  //    0x00000001 copy._copyable = this._copyable;
  //    0x00000002 copy._deletable = this._deletable;
  //    0x00000004 copy._textEditable = this._textEditable;
  //    0x00000008 copy._groupable = this._groupable;
  //    0x00000010 copy._movable = this._movable;
  //    0x00000020 copy._selectionAdorned = this._selectionAdorned;
  //    0x00000040 copy._isInDocumentBounds = this._isInDocumentBounds;
  //    0x00000080 copy._isLayoutPositioned = this._isLayoutPositioned;
  //    0x00000100 copy._selectable = this._selectable;
  //    0x00000200 copy._reshapable = this._reshapable;
  //    0x00000400 copy._resizable = this._resizable;
  //    0x00000800 copy._rotatable = this._rotatable;

  //  DONT COPY - Default false:
  //    0x00001000 copy._isSelected = false;

  //    0x00002000 copy._isShadowed = this._isShadowed;

  //  DONT COPY any of these, use defaults:
  //    0x00004000 copy._invalidAdornments = true;
  //    0x00008000 copy._invalidPosition = true;
  //    0x00010000 copy._notifyLater = false;
  //    0x00020000 copy._inView = false;

  copy._partFlags = this._partFlags & (~0x00001000) | 0x00004000 | 0x00008000 & (~0x00010000) & (~0x00020000);

  copy._category = this._category;
  copy._layerName = this._layerName;
  copy._layerChanged = this._layerChanged;

  copy._selectionAdornmentTemplate = this._selectionAdornmentTemplate;  // share templates
  copy._resizeAdornmentTemplate = this._resizeAdornmentTemplate;
  copy._rotateAdornmentTemplate = this._rotateAdornmentTemplate;

  copy._selectionObjectName = this._selectionObjectName;
  //  copy._selectionObject = null;  // cached
  copy._selectionChanged = this._selectionChanged;

  copy._adornments = null;  // Parts need their own Adornments
  copy._resizeObjectName = this._resizeObjectName;
  //  copy._resizeObject = null;  // cached
  copy._resizeCellSize.assign(this._resizeCellSize);
  copy._rotateObjectName = this._rotateObjectName;
  //  copy._rotateObject = null;  // cached
  copy._text = this._text;

  //copy._containingGroup updated by copier
  copy._containingGroupChanged = this._containingGroupChanged;
  //copy._layer updated by copier

  copy._location.assign(this._location);
  copy._locationObjectName = this._locationObjectName;
  //  copy._locationObject = null;  // cached
  copy._locationSpot = this._locationSpot.copyFrozen();
  copy._minLocation = this._minLocation.copyFrozen();
  copy._maxLocation = this._maxLocation.copyFrozen();
  copy._dragComputation = this._dragComputation;

  copy._layoutConditions = this._layoutConditions;

  copy._shadowOffset.assign(this._shadowOffset);
  copy._shadowColor = this._shadowColor;
  copy._shadowBlur = this._shadowBlur;

  // don't copy temporary properties
  // this._layerIndex
  // this._drawnRect
  // this._nameMap
  // this._maxMiter
};

/**
* @ignore
* Fix up references in the argument object so that the argument object can get a new visual tree
* @this {Part}
* @param {GraphObject} copy  The original Part whose category is being changed by displacing its visual tree with this Part's visual tree.
*/
Part.prototype.displaceProtected = function(copy) {
  Panel.prototype.displaceProtected.call(this, copy);
  // force these cached references to be recalculated
  copy.invalidateContainingGroup();
  copy._selectionObject = null;
  copy._resizeObject = null;
  copy._rotateObject = null;
  copy._locationObject = null;
  copy._nameMap = null;
};

/**
* @ignore
* @this {Part}
* @return {string}
*/
Part.prototype.toString = function() {
  var s = Util.getClassName(Object.getPrototypeOf(this)) + '#' + Util.hashId(this);
  if (this.data) s += '(' + Binding.toString(this.data) + ')';
  return s;
};

/**
* This value may be used as the value of the {@link Part#layoutConditions} property to indicate that
* no operation on this Part causes invalidation of the {@link Layout} responsible for this Part.
* @name Part#LayoutNone
* @constant
* @static
* @return {number}
*/
Part['LayoutNone'] = Part.LayoutNone = 0;

/**
* This flag may be combined with other "Layout" flags as the value of the {@link Part#layoutConditions} property to indicate that
* when a Part is added to a Diagram or Group, it invalidates the {@link Layout} responsible for the Part.
* @name Part#LayoutAdded
* @constant
* @static
* @return {number}
*/
Part['LayoutAdded'] = Part.LayoutAdded = 1;

/**
* This flag may be combined with other "Layout" flags as the value of the {@link Part#layoutConditions} property to indicate that
* when a Part is removed from a Diagram or Group, it invalidates the {@link Layout} responsible for the Part.
* @name Part#LayoutRemoved
* @constant
* @static
* @return {number}
*/
Part['LayoutRemoved'] = Part.LayoutRemoved = 2;

/**
* This flag may be combined with other "Layout" flags as the value of the {@link Part#layoutConditions} property to indicate that
* when a Part's {@link GraphObject#visible} becomes true, it invalidates the {@link Layout} responsible for the Part.
* @name Part#LayoutShown
* @constant
* @static
* @return {number}
*/
Part['LayoutShown'] = Part.LayoutShown = 4;

/**
* This flag may be combined with other "Layout" flags as the value of the {@link Part#layoutConditions} property to indicate that
* when a Part's {@link GraphObject#visible} becomes false, it invalidates the {@link Layout} responsible for the Part.
* @name Part#LayoutHidden
* @constant
* @static
* @return {number}
*/
Part['LayoutHidden'] = Part.LayoutHidden = 8;

/**
* This flag may be combined with other "Layout" flags as the value of the {@link Part#layoutConditions} property to indicate that
* when a Part's {@link GraphObject#actualBounds} changes size, it invalidates the {@link Layout} responsible for the Part;
* this flag is ignored for Parts that are Links.
* @name Part#LayoutNodeSized
* @constant
* @static
* @return {number}
*/
Part['LayoutNodeSized'] = Part.LayoutNodeSized = 16;

/**
* This flag may be combined with other "Layout" flags as the value of the {@link Part#layoutConditions} property to indicate that
* when a {@link Group} has been laid out, it invalidates the {@link Layout} responsible for that Group;
* this flag is ignored for Parts that are not Groups.
* @name Part#LayoutGroupLayout
* @constant
* @static
* @return {number}
*/
Part['LayoutGroupLayout'] = Part.LayoutGroupLayout = 32;

/**
* This is the default value for the {@link Part#layoutConditions} property:
* the {@link Layout} responsible for the Part is invalidated when the Part is added or removed
* from the Diagram or Group or when it changes visibility or size or when a Group's layout has been performed.
* @name Part#LayoutStandard
* @constant
* @static
* @return {number}
*/
Part['LayoutStandard'] = Part.LayoutStandard = Part.LayoutAdded | Part.LayoutRemoved | Part.LayoutShown | Part.LayoutHidden | Part.LayoutNodeSized | Part.LayoutGroupLayout;

/**
* @ignore
* This value may be used as the value of {@link Part#layoutConditions} property to indicate that
* the {@link Layout} responsible for the Part is invalidated when the Part is added or removed
* from the Diagram or Group or when it changes visibility or size.
* @name Part#LayoutAll
* @constant
* @static
* @return {number}
*/
/* Part['LayoutAll'] = */Part.LayoutAll = 0xFFFFFF;



/**
* @ignore
* Call this method to notify that the some state has changed.
* This just calls the {@link #diagram}'s {@link Diagram#raiseChangedEvent} method.
* @this {Part}
* @param {EnumValue} change specifies the general nature of the change;
* permissible values include {@link ChangedEvent#Property}, {@link ChangedEvent#Insert},
* {@link ChangedEvent#Remove}, and {@link ChangedEvent#Transaction}.
* @param {string} propertyname names the property that was modified.
* @param {Object} obj the object that was modified, typically a {@link GraphObject}.
* @param {*} oldval the previous or older value.
* @param {*} newval the next or newer value.
* @param {*=} oldparam an optional value that helps describe the older value.
* @param {*=} newparam an optional value that helps describe the newer value.
*/
Part.prototype.raisePartChangedEvent = function(change, propertyname, obj, oldval, newval, oldparam, newparam) {
  var diagram = this.diagram;
  if (diagram !== null) {
    if (change === ChangedEvent.Insert && propertyname === 'elements') {
      if (newval instanceof Panel) {
        newval.walkPanels(function(p) { diagram.rememberItemArrayPanel(p); });
      }
    } else if (change === ChangedEvent.Remove && propertyname === 'elements') {
      if (newval instanceof Panel) {
        newval.walkPanels(function(p) { diagram.forgetItemArrayPanel(p); });
      }
    }

    diagram.raiseChangedEvent(change, propertyname, obj, oldval, newval, oldparam, newparam);
  }
};

Part.prototype['updateTargetBindings'] =
/**
* Re-evaluate all data bindings on this Part,
* in order to assign new property values to the {@link GraphObject}s in this visual tree
* based on this this object's {@link #data} property values.
* This method does nothing if {@link #data} is null.
* @this {Part}
* @param {string=} srcprop An optional source data property name:
*   when provided, only evaluates those {@link Binding}s that use that particular property;
*   when not provided or when it is the empty string, all bindings are evaluated.
*/
Part.prototype.updateTargetBindings = function(srcprop) {
  Panel.prototype.updateTargetBindings.call(this, srcprop);
  if (this.data !== null) {
    var elts = this.elements;
    while (elts.next()) {
      var pan = elts.value;
      if (pan instanceof Panel) {
        pan.walkPanels(function(p) { if (p.data !== null) p.updateTargetBindings(); });  // don't limit to SRCPROP
      }
    }
  }
};

// Adornments

/**
* Gets an iterator over all of the {@link Adornment}s associated with this part.
* After each call to the iterator's next() method that returns true,
* the iterator's key will be the category and the iterator's value will
* be an {@link Adornment}.
* <p>
* Templates should not have any adornments.
* @name Part#adornments
* @function.
* @return {Iterator}
*/
/** @type {Iterator} */
Part.prototype.adornments;
Util.defineReadOnlyProperty(Part, { adornments: 'adornments' },
  /** @this {Part} */
  function() {
    if (this._adornments === null) return Util.EmptyIterator;
    return this._adornments.iterator;
  }
);

Part.prototype['findAdornment'] =
/**
* Find an {@link Adornment} of a given category associated with this Part.
* <p>
* Templates should not have any adornments.
* @this {Part}
* @param {string} category
* @return {Adornment} Returns null if no such Adornment was found.
*/
Part.prototype.findAdornment = function(category) {
  if (Debug) Util.checkPrimitive(category, 'string', Part, 'findAdornment:category');
  var ads = this._adornments;
  if (ads === null) return null;
  return ads.getValue(category);
};

Part.prototype['addAdornment'] =
/**
* Associate an {@link Adornment} with this Part, perhaps replacing any existing adornment.
* This adds the Adornment to the {@link Layer} named "Adornment".
* If the Adornment was already associated with a Part, it is unassociated with that old Part.
* <p>
* Adornments are also data bound to the same data that this Part has, if any.
* <p>
* This method should not be called on templates.
* @this {Part}
* @param {string} category a string identifying the kind or role of the given adornment for this Part.
* @param {Adornment} ad
*/
Part.prototype.addAdornment = function(category, ad) {
  if (ad === null) return;  // not adding or replacing anything
  if (Debug) {
    Util.checkPrimitive(category, 'string', Part, 'addAdornment:category');
    Util.checkClass(ad, Adornment, Part, 'addAdornment:ad');
  }
  var oldad = null;
  var ads = this._adornments;
  if (ads !== null) oldad = ads.getValue(category);
  if (oldad !== ad) {
    if (oldad !== null) {
      var od = oldad.diagram;
      if (od !== null) od.remove(oldad);
    }
    if (ads === null) {
      ads = new Map('string', Adornment);
      this._adornments = ads;
    }
    if (ad._category !== category) ad.category = category;
    ads.add(category, ad);
    var diagram = this.diagram;
    if (diagram !== null) {
      diagram.add(ad);
      // Adornments are data bound too, so that they can customized by the data
      ad.data = this.data;
    }
  }
};

Part.prototype['removeAdornment'] =
/**
* Remove any {@link Adornment} of the given category that may be associated with this Part.
* @this {Part}
* @param {string} category a string identifying the kind or role of the given adornment for this Part.
*/
Part.prototype.removeAdornment = function(category) {
  if (Debug) Util.checkPrimitive(category, 'string', Part, 'removeAdornment:category');
  var ads = this._adornments;
  if (ads === null) return;
  var oldad = ads.getValue(category);
  if (oldad !== null) {
    var od = oldad.diagram;
    if (od !== null) od.remove(oldad);
  }
  ads.remove(category);
  if (ads.count === 0) this._adornments = null;
};

Part.prototype['clearAdornments'] =
/**
* Remove all adornments associated with this part.
* @this {Part}
*/
Part.prototype.clearAdornments = function() {
  var ads = this._adornments;
  if (ads !== null) {
    var list = Util.tempArray();
    var it = ads.iterator;
    while (it.next()) {
      list.push(it.key);
    }
    var l = list.length;
    for (var i = 0; i < l; i++) {
      this.removeAdornment(list[i]);  // remove Adornment from Layer and remove dictionary entry
    }
    Util.freeArray(list);
  }
};

/**
* This is responsible for creating any selection {@link Adornment} (if this Part {@link #isSelected}) and
* any tool adornments for this part.
* @expose
* @this {Part}
*/
Part.prototype.updateAdornments = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  this.updateSelectionAdornment(diagram);
  this.updateToolAdornments(diagram);
  // update any other adornments that have a placeholder
  var itr = this.adornments;
  while (itr.next()) {
    var adorn = itr.value;
    if (adorn.isStandard) continue;
    if (adorn._placeholder !== null) adorn.invalidateMeasure();
  }
};

/**
* @ignore
* This is responsible for creating or removing any selection {@link Adornment},
* depending on whether {@link #isSelected}.
* By default the adornment is a {@link Shape} that surrounds this part,
* or that follows the {@link Link}'s route if this is a Link.
* @this {Part}
*/
Part.prototype.updateSelectionAdornment = function(diagram) {
  var adornment = null;
  var category = 'Selection';
  if (this.isSelected && this.selectionAdorned) {
    var selelt = this.selectionObject;
    if (selelt === null || !this.actualBounds.isReal() || !this.isVisible() ||
        !selelt.isVisibleObject() || !selelt.actualBounds.isReal()) return;
    adornment = this.findAdornment(category);
    if (adornment === null) {
      var template = this.selectionAdornmentTemplate;
      if (template === null) {
        if (this instanceof Link) {
          template = diagram.linkSelectionAdornmentTemplate;
        } else if (this instanceof Part) {
          if (this instanceof Group) {
            template = diagram.groupSelectionAdornmentTemplate;
          } else {
            template = diagram.nodeSelectionAdornmentTemplate;
          }
        }
      }
      if (!(template instanceof Adornment)) return;
      template.freezeBindings();
      adornment = template.copy();
      if (!(adornment instanceof Adornment)) return;
      adornment.category = category;
      adornment.isStandard = true;
      adornment.adornedObject = selelt;
    }
    if (adornment !== null) {
      var place = adornment.placeholder;
      if (place !== null) {
        var ns = selelt.naturalBounds;
        var sc = selelt.getDocumentScale();
        var sw = 0;
        if (selelt instanceof Shape) sw = selelt.strokeWidth;
        var dessz = Util.tempSize();
        dessz._set((selelt.naturalBounds.width + sw) * sc, (selelt.naturalBounds.height + sw) * sc);
        place.desiredSize = dessz;
        Util.freeSize(dessz);
      }
      adornment.angle = selelt.getDocumentAngle();
      // Links, including adornment links, set their location in their measure phase
      if (!(adornment.type === Panel.Link)) {
        var temploc = Util.tempPoint();
        adornment.location = selelt.getDocumentPoint(Spot.TopLeft, temploc);
        Util.freePoint(temploc);
      } else {
        // don't set the location, measureLink does that
        adornment.invalidateMeasure();
      }
    }
    this.addAdornment(category, adornment);
  } else {
    this.removeAdornment(category);
  }
};

/**
* @ignore
* This is responsible for creating any tool {@link Adornment}s for this part.
* This iterates over the mouse-down tools,
* calling {@link Tool#updateAdornments} on each one.
* @this {Part}
*/
Part.prototype.updateToolAdornments = function(diagram) {
  var tools = diagram.toolManager.mouseDownTools._arr;
  var l = tools.length;
  for (var i = 0; i < l; i++) {
    var t = tools[i];
    if (t.isEnabled) t.updateAdornments(this);
  }
};


/**
* @ignore
* @this {Part}
* @param {Layer} val
*/
Part.prototype.setLayer = function(val) {
  this._layer = val;
};

/**
 * Gets the {@link Layer} that this Part is in.
 * The value is the Layer that is named with the value of {@link #layerName}.
 * <p>
 * This will be null if it has not yet been added to a {@link Diagram},
 * or if it has already been removed from a Diagram.
 * @name Part#layer
 * @function.
 * @return {Layer}
 */
/** @type {Layer} */
Part.prototype.layer;
Util.defineReadOnlyProperty(Part, { layer: 'layer'},
  /** @this {Part} */
  function() { return this._layer; }
);

/**
 * Gets the {@link Diagram} that this Part is in.
 * <p>
 * This will be null if it is not in a {@link Layer}.
 * @name Part#diagram
 * @function.
 * @return {Diagram}
 */
/** @type {Diagram} */
Part.prototype.diagram;
Util.defineReadOnlyProperty(Part, { diagram: 'diagram'},
  /** @this {Part} */
  function() {
    var layer = this._layer;
    if (layer !== null) return layer.diagram;
    return null;
  }
);

/**
* Gets or sets the layer name for this part.
* The initial value is an empty string, which is the name of the default layer.
* The value of this property determines the value of {@link #layer}.
* <p>
* If this part is not yet in a {@link Diagram},
* this value is used by {@link Diagram#add}
* to determine which {@link Layer} this part should go in.
* If no layer can be found with this name, it uses the default layer.
* <p>
* Changing the value of this property while it is already in a layer
* causes it to change layers if needed.
* @name Part#layerName
* @function.
* @return {string}
* @see Part#layerChanged
*/
/** @type {string} */
Part.prototype.layerName;
Util.exportProperty(Part, 'layerName', Part.prototype.layerName);
Util.defineProperty(Part, { layerName: 'layerName' },
  /** @this {Part} */
  function() { return this._layerName; },
  /** @this {Part} */
  function(val) {
    var old = this._layerName;
    if (old !== val) {
      Util.checkPrimitive(val, 'string', Part, 'layerName');
      var diagram = this.diagram;
      // no-op if in Diagram and named layer does not exist
      if (diagram !== null && diagram.findLayer(val) === null) return;
      this._layerName = val;

      this.raiseChanged('layerName', old, val);

      // if already in a differently named layer, remove it,
      // find the right new layer, and add it
      //??? no-op if isUndoingRedoing
      var oldlayer = this.layer;
      if (oldlayer !== null && oldlayer.name !== val) {
        diagram = oldlayer.diagram;
        if (diagram !== null) {
          var newlayer = diagram.findLayer(val);
          if (newlayer !== null && newlayer !== oldlayer) {
            var index = oldlayer.internalRemove(-1, this, true);
            // use newParam === true to indicate that it is changing layers, not being removed from the diagram
            if (index >= 0) diagram.raiseChangedEvent(ChangedEvent.Remove, 'parts', oldlayer, this, null, index, true);
            index = newlayer.internalAdd(99999999, this, true);
            // use oldParam === true to indicate that it is changing layers, not being added to the diagram
            if (index >= 0) diagram.raiseChangedEvent(ChangedEvent.Insert, 'parts', newlayer, null, this, true, index);
            var func = this.layerChanged;
            if (func !== null) {
              var oldUpdatingModel = diagram.isUpdatingModel;
              diagram.isUpdatingModel = true;
              func(this, oldlayer, newlayer);
              diagram.isUpdatingModel = oldUpdatingModel;
            }
          }
        }
      }
    }
  }
);

/**
* Gets or sets the function to execute when this part changes layers.
* It is typically used to modify the appearance of the part.
* This function must not change the layer of this part by setting {@link #layerName}.
* <p>
* If this property value is a function, it is called with three arguments,
* this {@link Part}, the old {@link Layer} (may be null), and the new {@link Layer} (may be null).
* By default this property is null -- no function is called.
* @name Part#layerChanged
* @function.
* @return {function(Part, Layer, Layer) | null}
* @see Part#layerChanged
*/
/** @type {function(Part, Layer, Layer) | null} */
Part.prototype.layerChanged;
Util.exportProperty(Part, 'layerChanged', Part.prototype.layerChanged);
Util.defineProperty(Part, { layerChanged: 'layerChanged' },
  /** @this {Part} */
  function() { return this._layerChanged; },
  /** @this {Part} */
  function(val) {
    var old = this._layerChanged;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', Part, 'layerChanged');
      this._layerChanged = val;
      this.raiseChanged('layerChanged', old, val);
    }
  }
);

/**
* @ignore
* This read-only property is true when this Part is in a {@link Layer} that is temporary ({@link Layer#isTemporary}).
* Temporary layers include the predefined layers named "Tool" and "Adornment" and "Grid".
* @name Part#isTemporary
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Part.prototype.isTemporary;
Util.defineReadOnlyProperty(Part, { isTemporary: 'isTemporary' },
  /** @this {Part} */
  function() {
    if (this._layer !== null) return this._layer.isTemporary;
    return false;
  }
);


/**
* @ignore
* @this {Part}
*/
Part.prototype.invalidateAdornments = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  diagram.invalidateViewportObjects();
   if (this.getInvalidAdornments() === true) return;

  this.setInvalidAdornments(true);
  this.invalidateDraw(); // ??? needed?
  diagram._invalidObjects.add(this);
  diagram.requestUpdate();
};

/**
* @ignore
* @this {Part}
*/
Part.prototype.validateAdornments = function() {
  if (this.getInvalidAdornments() === false) return;
  this.updateAdornments();
  this.setInvalidAdornments(false);

  var diagram = this.diagram;
  if (diagram === null) return;
  diagram._invalidDraw = true;
};

/**
* Gets or sets the position of this part in document coordinates,
* based on the {@link #locationSpot} in this part's {@link #locationObject}.
* <p>
* Value must be of type {@link Point}.
* The initial value is Point(NaN, NaN).
* It is commonplace to data bind this property to some property on your model node data.
* <p>
* The value is related to the {@link GraphObject#position}.
* For Parts, both are in document coordinates; setting one property will set the other property.
* By default both will have the same value.
* However, by setting either or both of {@link #locationSpot} and {@link #locationObjectName},
* the location will be determined by a spot in the {@link #locationObject},
* a {@link GraphObject} that is in the visual tree of this Part.
* The {@link GraphObject#position} will always refer to the point at the top-left corner of the whole part.
* <p>
* The {@link #minLocation} and {@link #maxLocation} limit the location of a part, not its position.
* Grid snapping will normally locate the location to be on grid points.
* @name Part#location
* @function.
* @return {Point}
* @see Part#locationObjectName
* @see Part#locationSpot
*/
/** @type {Point} */
Part.prototype.location;
Util.exportProperty(Part, 'location', Part.prototype.location);
Util.defineProperty(Part, { location: 'location'},
  /** @this {Part} */
  function() { return this._location; },
  /** @this {Part} */
  function(val) {
    var old = this._location;
    if (!old.equals(val)) {
      if (this instanceof Link) return;
      if (Debug) Util.checkClass(val, Point, Part, 'location');
      val = val.copyFrozen();
      var diagram = this.diagram;

      this._location = val;

      if (this.getInvalidArrange() === false) {
        var pos = this._position;

        var offx = val.x - old.x;
        var offy = val.y - old.y;
        var oldpos = pos.copy();
        pos._set(oldpos.x + offx, oldpos.y + offy);
        // Instead of invalidating the arrange
        this._invalidatePosition();

        if (!pos.equals(oldpos) && diagram) {
          //var skips = diagram.skipsUndoManager;
          //diagram.skipsUndoManager = true;
          this.raiseChanged('position', oldpos, pos);
          //diagram.skipsUndoManager = skips;
        }
      }
      this.raiseChanged('location', old, val);
    }
  }
);

/**
* @ignore
* @this {Part}
*/
Part.prototype._invalidatePosition = function() {
  if (this.getInvalidPosition() !== false) return;
  var diagram = this.diagram;
  if (diagram !== null) {
    diagram._invalidObjects.add(this);
    if (this instanceof Node && !diagram.undoManager.isUndoingRedoing) this.invalidateConnectedLinks();
    diagram.requestUpdate();
  }
  this.setInvalidPosition(true);
};

/**
* @ignore
* @this {Part}
*/
Part.prototype.validatePosition = function() {
  if (this.getInvalidPosition() === false) return;

  var pos = this.position;
  var loc = this.location;
  if (!loc.isReal() || !pos.isReal()) {
    this.determinePosLoc(pos, loc);
    this._invalidateTransform();
  }

  var p = this._position;
  var ab = this._actualBounds;
  var old = ab.copy();
  ab.thaw();
  ab.x = p.x;
  ab.y = p.y;
  ab.freeze();

  this.onBoundsChanged(old, ab);
  this.setInvalidPosition(false);
};

/**
* Gets the {@link GraphObject} that determines the location of this Part.
* The value will be in the visual tree of this Part and is usually named with
* the value of {@link #locationObjectName}.
* @name Part#locationObject
* @function.
* @return {GraphObject}
*/
/** @type {GraphObject} */
Part.prototype.locationObject;
Util.defineReadOnlyProperty(Part, { locationObject: 'locationObject'},
  /** @this {Part} */
  function() {
    if (this._locationObject === null) {
      var ename = this.locationObjectName;
      if (ename !== undefined && ename !== null && ename !== '') {
        var elt = this.findObject(ename);
        if (elt !== null) {  // found it: cache it
          this._locationObject = elt;
        } else {  // not yet found
          this._locationObject = this;
        }
      } else if (this instanceof Adornment && this._type !== Panel.Link && this._placeholder !== null) {
        this._locationObject = this._placeholder;
      } else {  // always use main visual child
        this._locationObject = this;
      }
    }
    return this._locationObject.visible ? this._locationObject : this;
  }
);

/**
* Gets or sets the minimum location of this Part to which the user may drag using the {@link DraggingTool}.
* <p>
* Value must be of type {@link Point}.
* The initial value is (-Infinity, -Infinity), which imposes no position constraint.
* A X value of NaN causes {@link DraggingTool#computeMove} to use the part's current location's X value as the minimum,
* and similarly for NaN as the Y value.
* @name Part#minLocation
* @function.
* @return {Point}
*/
/** @type {Point} */
Part.prototype.minLocation;
Util.exportProperty(Part, 'minLocation', Part.prototype.minLocation);
Util.defineProperty(Part, { minLocation: 'minLocation'},
  /** @this {Part} */
  function() { return this._minLocation; },
  /** @this {Part} */
  function(val) {
    var old = this._minLocation;
    if (!old.equals(val)) {
      if (Debug) Util.checkClass(val, Point, Part, 'minLocation');
      val = val.copyFrozen();
      this._minLocation = val;
      this.raiseChanged('minLocation', old, val);
    }
  }
);

/**
* Gets or sets the maximum location of this Part to which the user may drag using the {@link DraggingTool}.
* <p>
* Value must be of type {@link Point}.
* The initial value is (Infinity, Infinity), which imposes no position constraint.
* A X value of NaN causes {@link DraggingTool#computeMove} to use the part's current location's X value as the maximum,
* and similarly for NaN as the Y value.
* @name Part#maxLocation
* @function.
* @return {Point}
*/
/** @type {Point} */
Part.prototype.maxLocation;
Util.exportProperty(Part, 'maxLocation', Part.prototype.maxLocation);
Util.defineProperty(Part, { maxLocation: 'maxLocation'},
  /** @this {Part} */
  function() { return this._maxLocation; },
  /** @this {Part} */
  function(val) {
    var old = this._maxLocation;
    if (!old.equals(val)) {
      if (Debug) Util.checkClass(val, Point, Part, 'maxLocation');
      val = val.copyFrozen();
      this._maxLocation = val;
      this.raiseChanged('maxLocation', old, val);
    }
  }
);


/**
* Gets or sets the name of the {@link GraphObject} that provides the location of this Part.
* This name determines the value of {@link #locationObject}.
* The actual {@link #location} also depends on the {@link #locationSpot}.
* <p>
* The initial value is an empty string, meaning the whole Part itself determines the location.
* If you want to use a particular GraphObject in the visual tree of this Part,
* set this property to be the {@link GraphObject#name} of the element that you want to be the {@link #locationObject}.
* @name Part#locationObjectName
* @function.
* @return {string}
* @see Part#location
* @see Part#locationSpot
*/
/** @type {string} */
Part.prototype.locationObjectName;
Util.exportProperty(Part, 'locationObjectName', Part.prototype.locationObjectName);
Util.defineProperty(Part, { locationObjectName: 'locationObjectName'},
  /** @this {Part} */
  function() { return this._locationObjectName; },
  /** @this {Part} */
  function(val) {
    var old = this._locationObjectName;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'string', Part, 'locationObjectName');
      this._locationObjectName = val;
      this._locationObject = null;
      this.invalidateArrange();
      this.raiseChanged('locationObjectName', old, val);
    }
  }
);

/**
* Gets or sets the location Spot of this Node, the spot on the {@link #locationObject}
* that is used in positioning this part in the diagram.
* <p>
* Value must be of the type {@link Spot}.
* The initial value is <code>Spot.TopLeft</code>.
* The value must be a specific spot -- i.e. one for which {@link Spot#isSpot} is true.
* <p>
* It is commonplace to set this property to <code>Spot.Center</code>, so that the {@link #location}
* has a value corresponding to the point at the center of this Part's {@link #locationObject} element.
* But the {@link GraphObject#position} of a Part is always at the top-left corner
* point of the {@link GraphObject#actualBounds}.
* @name Part#locationSpot
* @function.
* @return {Spot}
* @see Part#location
* @see Part#locationObjectName
*/
/** @type {Spot} */
Part.prototype.locationSpot;
Util.exportProperty(Part, 'locationSpot', Part.prototype.locationSpot);
Util.defineProperty(Part, { locationSpot: 'locationSpot'},
  /** @this {Part} */
  function() { return this._locationSpot; },
  /** @this {Part} */
  function(val) {
    var old = this._locationSpot;
    if (!old.equals(val)) {
      if (Debug) {
        Util.checkClass(val, Spot, Part, 'locationSpot');
        if (!val.isSpot()) Util.throwError('Part.locationSpot must be a specific Spot value, not: ' + val);
      }
      val = val.copyFrozen();
      this._locationSpot = val;
      this.invalidateArrange();
      this.raiseChanged('locationSpot', old, val);
    }
  }
);

Part.prototype['move'] =
/**
* Move this part and any parts that are owned by this part to a new position.
* <p>
* If this part is a {@link Group}, it also moves all of its members, recursively.
* If this part is a {@link Link}, it also moves all of its label nodes.
* @this {Part}
* @param {Point} newpos a new {@link Point} in document coordinates.
*/
Part.prototype.move = function(newpos) {
  this.position = newpos;

  /* ??? No longer needed because of validatePosition() call at the end of position setter
  if (this.getInvalidArrange() === false) {
    this.validatePosition();
  }*/
};

Part.prototype['moveTo'] =
/**
* @ignore
* Move this part and any parts that are owned by this part to a new position.
* <p>
* If this part is a {@link Group}, it also moves all of its members, recursively.
* If this part is a {@link Link}, it also moves all of its label nodes.
* @this {Part}
* @param {number} newx a new X value in document coordinates.
* @param {number} newy a new Y value in document coordinates.
*/
Part.prototype.moveTo = function(newx, newy) {
  var p = Util.tempPointAt(newx, newy);
  this.move(p);
  Util.freePoint(p);
};


Part.prototype['isVisible'] =
/**
* This predicate is true if this Part can be seen.
* Parts that can be seen can be manipulated by the user, can take space in the document, or can take part in a layout,
* among many possibilities.
* <p>
* A Part is not seen if it is not {@link GraphObject#visible} or if it is in a {@link Layer} that is not {@link Layer#visible}.
* <p>
* If a Part is a member of a {@link Group} and the Group is not {@link Group#isSubGraphExpanded}, the part is not seen.
* (The containing Group might still be visible.)
* <p>
* If a {@link Node} is a "tree child" of a Node that is not {@link Node#isTreeExpanded}, the node is not seen.
* (The parent Node might still be visible.)
* <p>
* If a {@link Link} is connected to or from a {@link Node} that is not <code>isVisible()</code>
* and is not a member of a {@link Group} that <code>isVisible()</code>, the link is not seen.
* <p>
* If a {@link Node} is a "link label" of a {@link Link} and that Link is not <code>isVisible()</code>, the node is not seen.
* <p>
* This is different from {@link GraphObject#isVisibleObject},
* which ignores whether the {@link Layer} is visible and just checks {@link GraphObject#visible}
* up the chain of containing {@link Panel}s.
* <p>
* If you want to know whether a Part is in the Diagram's viewport, try:
* <code><br/>
*   diagram.viewportBounds.containsRect(part.actualBounds)<br/>
* </code>
* or:
* <code><br/>
*   diagram.viewportBounds.intersectsRect(part.actualBounds)<br/>
* </code>
* @this {Part}
* @return {boolean} true if {@link GraphObject#visible} is true and if {@link Layer#visible} is true.
*/
Part.prototype.isVisible = function() {
  // GraphObject.visible must be true
  if (!this.visible) return false;
  // if there's a Layer, the layer had better be visible
  var layer = this.layer;
  if (layer !== null && !layer.visible) return false;
  // if this is inside a Group, it should not be seen if the group is collapsed or if the group is not seen
  var container = this.containingGroup;
  if (container !== null && (!container.isSubGraphExpanded || !container.isVisible())) return false;
  if (this instanceof Node) {
    // check if this Node should be unseen because its tree parent is collapsed
    var parent = this.findTreeParentNode();
    if (parent !== null && !parent.isTreeExpanded) return false;
    // if it's a label node, we need to track down whether the labeled link is visible...
    var ll = this.labeledLink;
    if (ll !== null) {
      var nodesvis = {};
      nodesvis[Util.hashId(this)] = true;
      return ll.searchThroughLinkVis(nodesvis);
    }
  } else if (this instanceof Link) {
    var tochildren = true;
    var diagram = this.diagram;
    if (diagram !== null) tochildren = diagram.isTreePathToChildren;
    // this allows for partly or completely disconnected Links that are visible:
    var from = this.fromNode;
    if (from !== null) {
      if (this.isTreeLink && tochildren && !from.isTreeExpanded) return false;
      var visfrom = from.findVisibleNode();
      if (visfrom === null) return false;
      // links inside groups should not connect with their parent group
      if (visfrom === container) return false;
    }
    var to = this.toNode;
    if (to !== null) {
      if (this.isTreeLink && !tochildren && !to.isTreeExpanded) return false;
      var visto = to.findVisibleNode();
      if (visto === null) return false;
      // links inside groups should not connect with their parent group
      if (visto === container) return false;
    }
  }
  return true;
};

/**
* @ignore
* @this {Part}
* @param {Object} nodesvis
* @return {boolean}
*/
Part.prototype.searchThroughLinkVis = function(nodesvis) {
  // search both sides of the link
  var node = this.fromNode;
  if (node !== null) {
    var ll = node.labeledLink;
    if (ll !== null) {
      if (!nodesvis[Util.hashId(node)]) {
        nodesvis[Util.hashId(node)] = true;
        ll.searchThroughLinkVis(nodesvis);
      }
    } else {
      // else it's a terminal node
      if (node.findVisibleNode() === null) return false;
    }
  }
  node = this.toNode;
  if (node !== null) {
    var ll = node.labeledLink;
    if (ll !== null) {
      if (!nodesvis[Util.hashId(node)]) {
        nodesvis[Util.hashId(node)] = true;
        ll.searchThroughLinkVis(nodesvis);
      }
    } else {
      // else it's a terminal node
      if (node.findVisibleNode() === null) return false;
    }
  }
  return true;
};

Part.prototype['findObject'] =
/**
* @ignore
* @this {Part}
* @param {string} name The name to search for, using a case-sensitive string comparison.
* @return {GraphObject} If no such named object can be found, this returns null.
*/
Part.prototype.findObject = function(name) {
  if (this.name === name) return this;

  if (this._nameMap === null) this._nameMap = {};
  var map = this._nameMap;
  if (map[name] !== undefined) return map[name];

  var elements = this._elements._arr;
  var l = elements.length;
  for (var i = 0; i < l; i++) {
    var elt = elements[i];
    if (elt.name === name) { map[name] = elt; return elt; }
    if (elt instanceof Panel && !elt.isItemPanel()) {
      var found = elt.findObject(name);
      if (found !== null) { map[name] = found; return found; }
    }
  }
  map[name] = null; return null;
};

/**
* @ignore
* @this {Part}
*/
Part.prototype.clearNameMap = function() {
  this._nameMap = null;
};

/**
* @ignore
* Gets a point on a GraphObject relative to this Part
* @this {Part}
* @param {GraphObject} elt
* @param {Spot} spot
* @param {Point=} result an optional Point that is modified and returned
* @return {Point}
*/
Part.prototype.getRelativePoint = function(elt, spot, result) {
  if (result === undefined/*notpresent*/) result = new Point();
  var s = spot;
  if (s.isNoSpot()) s = Spot.Center;
  var sz = elt.naturalBounds;
  result._set(sz.width * s.x + s.offsetX, sz.height * s.y + s.offsetY);
  if (elt === null || elt === this) return result;

  var pt = result;
  elt.transform.transformPoint(pt);
  var parent = elt.panel;
  while (parent !== null && parent !== this) {
    parent.transform.transformPoint(pt);
    parent = parent.panel;
  }
  // definitely needed to get the correct offset, at
  this._localTransform.transformPoint(pt);
  // local transform means we need this extra bit typically included in the normal transform
  pt.offset(-this._measuredBounds.x, -this._measuredBounds.y);
  return pt;
};

Part.prototype['ensureBounds'] =
/**
* @ignore
* Measures if needed to make sure the GraphObject#measuredBounds,
* GraphObject#actualBounds, and GraphObject#naturalBounds are all real numbers,
* primarily to get the actual Width and Height.
* @this {Part}
*/
Part.prototype.ensureBounds = function() {
  this.measure(Infinity, Infinity);
  this.arrange();
};

/**
* @ignore
* Arrange a GraphObject onto its diagram.
* @param {Point} result a Point that is modified and returned
* @this {Part}
*/
Part.prototype.determineOffset = function(result) {
  var s = this.locationSpot;
  var obj = this.locationObject;

  if (s.isNoSpot()) Util.throwError('Spot must be real: ' + s.toString());

  // if the object is a GraphObject and has a location object other than itself
  // then we need to find the appropriate spot location by transforming backwards to this part
  var ns = obj.naturalBounds;
  result.setSpot(0, 0, ns.width, ns.height, s); // scale is taken care of by localTransform below

  if (obj !== this) {
    obj.transform.transformPoint(result);

    if (obj.strokeWidth) {
      var sw2 = obj._strokeWidth / 2;
      result.offset(-sw2, -sw2);
    }

    var parent = obj.panel;
    while (parent !== null && parent !== this) {
      parent.transform.transformPoint(result);
      parent = parent.panel;
    }
  }
  // definitely needed to get the correct offset, at
  this._localTransform.transformPoint(result);
  // local transform means we need this extra bit typically included in the normal transform
  result.offset(-this._measuredBounds.x, -this._measuredBounds.y);
  return result;
};

/**
* @ignore
* Takes a rect (usually a part's actualBounds) and expands it according to the shadow size
* @this {Part}
* @param {Rect} rect the actual bounds of an object.
* @param {Rect=} result optionally, modify this Rect and return it
* @return {Rect} a rectangle in document coordinates.
*/
Part.prototype.getDrawnSize = function(rect, result) {
  var r;
  if (result === undefined/*notpresent*/) {
    r = this._drawnRect;
  } else {
    r = result;
  }

  // miter amounts
  var m = this.getMaxMiter();
  var m2 = m * 2;

  if (!this.isShadowed) {
    r._set(rect.x - 1 - m, rect.y - 1 - m, rect.width + 2 + m2, rect.height + 2 + m2);
    return r;
  }

  var x = rect.x;
  var y = rect.y;
  var w = rect.width;
  var h = rect.height;
  var blur = this.shadowBlur;
  var off = this.shadowOffset;
  w += blur;
  h += blur;
  x -= blur / 2;
  y -= blur / 2;
  if (off.x > 0) {
    w += off.x;
  } else {
    x += off.x;
    w -= off.x;
  }
  if (off.y > 0) {
    h += off.y;
  } else {
    y += off.y;
    h -= off.y;
  }
  r._set(x - 1, y - 1, w + 2, h + 2);
  return r;
};

/**
* @ignore
* The maxMiter is the maximum possible miter value of all Shapes in a panel
* @this {Part}
* @return {number}
*/
Part.prototype.getMaxMiter = function() {
  if (isNaN(this._maxMiter)) {
    this._maxMiter = this.findMiter();
  }
  return this._maxMiter;
};

/**
* @ignore
* Called when a shape changes within a panel (added, removed, strokeWidth, strokeMiterLimit changed)
* @this {Part}
*/
Part.prototype.resetMaxMiter = function() {
  this._maxMiter = NaN;
};

/**
* @ignore
* Arrange a graphObject onto its diagram.
* @this {Part}
*/
Part.prototype.arrange = function() {
  this._invalidateTransform();

  if (this.getInvalidArrange() === false) {
    // This is uncommon but needed because cloned objects
    // can start with invalidArrange = false
    // Which means that location will not be set normally
    // (during an invalid arrage) and must be set here
    this.validatePosition();
    return;
  }

  var oldActual = Util.tempRect();
  oldActual.assign(this._actualBounds);

  this._validateTransforms();

  // Part 1: Determine bounds

  this._actualBounds.thaw();
  var oldInView = this.getInView();
  // This might falsely reset inView, and if the old and new actual bounds
  // are the same we have a problem, so save the old inView
  this.arrangeProtected(
    0,
    0,
    this._measuredBounds.width,
    this._measuredBounds.height);

  // Part 2: Determine position/location
  var pos = this.position;
  var loc = this.location;
  this.determinePosLoc(pos, loc);

  // Part 3: set actualBounds x/y
  // This is not done sooner because the arrange step may set location/position
  // (As it does in the case of Link)
  // And because the locationObject must be arranged
  var act = this._actualBounds;
  act.x = pos.x;
  act.y = pos.y;
  act.freeze();

  this._invalidateTransform();
  this.onBoundsChanged(oldActual, act);
  if (oldActual.equals(act)) {
    this.setInView(oldInView);
  } else {
    // maybe invalidate Layout if Node or Part (but not Link or Adornment) changed size
    if (this.isNodeLike() &&
        (!Geo.isApprox(oldActual.width, act.width) || !Geo.isApprox(oldActual.height, act.height))) {
      this.invalidateLayout(Part.LayoutNodeSized);  // no-op if isUndoingRedoing
    }
  }
  Util.freeRect(oldActual);
  this.setInvalidPosition(false);
};

/**
* @ignore
* @this {Part}
*/
Part.prototype.determinePosLoc = function(pos, loc) {
  // if no position/location exist we can default to NaN
  var x = NaN;
  var y = NaN;
  var off = this.determineOffset(Util.tempPoint());
  if (loc.isReal()) {
    // We have the offset, fix position
    x = loc.x - off.x;
    y = loc.y - off.y;
    //var oldpos = pos.copy();
    pos._set(x, y);
    // ??? This position change is not recorded in the undo manager because we do not want
    //     the position setter (during undo) to also (incorrectly) set the location.
    //     However we may need to record this in the future if the undo manager is to never need
    //     validation after undoing.
    // if (!pos.equals(oldpos)) this.raiseChanged('position', oldpos, pos);
  } else if (pos.isReal()) {
    x = pos.x;
    y = pos.y;
    //var oldloc = loc.copy();
    loc._set(x + off.x, y + off.y);
    // ??? see comment on this.raiseChanged('position'... above
    // if (!loc.equals(oldloc)) this.raiseChanged('location', oldloc, loc);
  }
  Util.freePoint(off);
};

/**
* @ignore
* After this is called you must invalidate the draw
* @this {Part}
* @param {boolean} inside whether or not the part is inside of the document bounds.
* @param {Diagram} diagram
*/
Part.prototype.notifyDiagram = function(inside, diagram) {
  this.setNotifyLater(false);

  var node = this; // for closure compiler
  if (node instanceof Node) {
    diagram.invalidatePositionArray(node);
  }

  if (!this.layer.isTemporary && !inside) diagram.invalidateDocumentBounds();

  var ab = this._actualBounds;
  var vpb = diagram.viewportBounds;
  if (vpb.isReal()) {
    if (this.getInView()) { // was it in before?
      // ??? 10 is an arbitrary amount to cover all adornments (used in layer too)
      if (!ab.intersectsRectPlus(vpb, 10)) { // no longer in the viewport
        this.setInView(false);
        this.invalidateAdornments();
      }
    } else { // see if the object is in viewport now
      if (ab.intersectsRect(vpb)) {
        this.setInView(true);
      }
    }
    this.updateAdornments();
  } else {
    diagram._invalidViewportObjects = true; // make sure that this is invalid
  }
};

/**
* @ignore
* @this {Part}
* @return {boolean}
*/
Part.prototype.isReadyToMeasureArrange = function() {
  return true;
};

/**
* @ignore
* @this {Part}
*/
Part.prototype.drawSimple = function(context, diagram) {
  if (!this.visible) return;
  var ab = this._actualBounds;
  if (ab.width === 0 || ab.height === 0 || isNaN(ab.x) || isNaN(ab.y)) return;
  // Make sure it exists
  var tt = this.transform;
  var myPanel = this.panel;
  // ??? might not be a good place to do this, but it is a place where all the info is known
  // construct the allTransforms for this object
  var t2 = this._allTransforms;
  t2.reset();
  if (myPanel !== null) {
    if (myPanel.trueTransform()) {
      t2.multiply(myPanel.allTransforms);
    } else if (myPanel.panel !== null) {
      t2.multiply(myPanel.panel.allTransforms);
    }
  }
  t2.multiply(this._transform);

  // areaBackground is in the parent's transform space
  if (this._areaBackground !== null) {
    this.setBrush(context, this._areaBackground, true, true);
    context.fillRect(ab.x, ab.y, ab.width, ab.height);
  }


  if (this._areaBackground === null && this._background === null) {
    context.fillStyle = 'rgba(0,0,0,0.4)';
    context.fillRect(ab.x, ab.y, ab.width, ab.height);
  }

  // background is in local space
  if (this._background !== null) {
    if (!tt.isIdentity()) {
      context.transform(tt.m11, tt.m12, tt.m21, tt.m22, tt.dx, tt.dy);
    }
    var ns = this.naturalBounds;
    var nx = 0;
    var ny = 0;
    var nw = ns.width;
    var nh = ns.height;
    var sw = 0;
    this.setBrush(context, this._background, true);
    context.fillRect(
      nx - (sw / 2),
      ny - (sw / 2),
      nw + sw, nh + sw);
    //for when not saving+clipping+restoring
    if (!tt.isIdentity()) {
      var d = 1 / (tt.m11 * tt.m22 - tt.m12 * tt.m21);
      var m0 = tt.m22 * d;
      var m1 = -tt.m12 * d;
      var m2 = -tt.m21 * d;
      var m3 = tt.m11 * d;
      var m4 = d * (tt.m21 * tt.dy - tt.m22 * tt.dx);
      var m5 = d * (tt.m12 * tt.dx - tt.m11 * tt.dy);
      context.transform(m0, m1, m2, m3, m4, m5);
    }
  }
};

/**
* @ignore
* @this {Part}
* @return {boolean}
*/
Part.prototype.isNodeLike = function() {
  return true;
};

/**
* Gets or sets the category of this part,
* typically used to distinguish different kinds of nodes or links.
* <p>
* The initial value is an empty string, which is the default category.
* Any new value must be a string.
* This should not be set in templates.
* <p>
* When building Parts for node data or link data in a model,
* the {@link Diagram} will call {@link Model#getCategoryForNodeData} or
* {@link GraphLinksModel#getCategoryForLinkData} to get the category string for the data object.
* The diagram uses this value to look up a template in {@link Diagram#nodeTemplateMap},
* {@link Diagram#linkTemplateMap} or {@link Diagram#groupTemplateMap}.
* That template is copied to create the actual Part that is added to the diagram.
* The diagram will set this property to remember the category it used.
* <p>
* To change the category for a Part created for model data, call {@link Model#setCategoryForNodeData} or
* {@link GraphLinksModel#setCategoryForLinkData}.
* <p>
* This property is also used to distinguish {@link Adornment}s on a Part.
* In this scenario you create the Adornment, often indirectly by specifying a template,
* and set this property explicitly.
* For example, {@link ResizingTool#updateAdornments} creates a resizing Adornment from the
* {@link Part#resizeAdornmentTemplate} and sets its category to be "Resizing".
* Changing the category of an existing Adornment will update any adorned part's association.
* @name Part#category
* @function.
* @return {string}
*/
/** @type {string} */
Part.prototype.category;
Util.exportProperty(Part, 'category', Part.prototype.category);
Util.defineProperty(Part, { category: 'category'},
  /** @this {Part} */
  function() { return this._category; },
  /** @this {Part} */
  function(val) {
    var old = this._category;
    if (old === val) return;
    Util.checkPrimitive(val, 'string', Part, 'category');
    this._category = val;
    this.raiseChanged('category', old, val);
    var diagram = this.diagram;
    var data = this.data;
    if (diagram !== null && data !== null) {
      var model = diagram.model;
      //??? if (diagram.undoManager.isUndoingRedoing) return;
      if (this instanceof Link) {
        // update model
        if (model instanceof GraphLinksModel) {
          model.setCategoryForLinkData(data, val);
        } else if (model instanceof TreeModel) {
          model.setParentLinkCategoryForNodeData(data, val);
        }
        // replace visual tree of Link
        var template = diagram.findTemplateForLinkData(data, val);
        if (template instanceof Link) {
          template.freezeBindings();
          var link = template.copy();
          if (link instanceof Link) {
            this._displaceWith(link, old, val);
          }
        }
      } else if (!(this instanceof Adornment)) {  // Node or simple Part
        // update model
        if (model !== null) {
          model.setCategoryForNodeData(data, val);
        }
        // replace visual tree of Node or Part
        var template = diagram.findTemplateForNodeData(data, val);
        if (template instanceof Part) {
          template.freezeBindings();
          var part = template.copy();
          if (part instanceof Part && !(part instanceof Link)) {
            this._displaceWith(part, old, val);
          }
        }
      }
    }
    if (this instanceof Adornment) {
      var p = this.adornedPart;
      if (p !== null) {
        var ads = p._adornments;
        // don't bother calling removeAdornment,
        // since we don't want it to be removed from the layer unnecessarily
        if (ads !== null) ads.remove(old);
        p.addAdornment(this._category, this);
      }
    }
  }
);

/**
* @ignore
* @this {Part} the Part whose category is changing
* @param {Part} part a Part copy of the new template specified by the new category.
* @param {string} oldcat the old category.
* @param {string} newcat the new category.
*/
Part.prototype._displaceWith = function(part, oldcat, newcat) {
  if (part.constructor !== this.constructor) {
    if (!Util.warnedAboutDisplacingDifferentClass) {
      Util.warnedAboutDisplacingDifferentClass = true;
      Util.trace('Should not change the class of the Part when changing category from "' + oldcat + '" to "' + newcat + '"');
      Util.trace('  Old class: ' + Util.getClassName(this) + ', new class: ' + Util.getClassName(part) + ', part: ' + this.toString());
    }
  }

  this.clearAdornments();
  var olddata = this.data;
  var oldlayername = this.layerName;
  var oldisselected = this.isSelected;
  var oldistreeleaf = true;
  var oldistreeexpanded = true;
  var oldwastreeexpanded = false;
  if (this instanceof Node) {
    oldistreeleaf = this.isTreeLeaf;
    oldistreeexpanded = this.isTreeExpanded;
    oldwastreeexpanded = this.wasTreeExpanded;
  }

  // Fix up references from the (old) Part to any of its visual elements.
  // Note that this process does not recurse through the visual tree -- it's only a top-level displacement.
  part.displaceProtected(this);
  // Panel._elements list is copied before cloneProtected so that Group._placeholder can be initialized

  // this keeps valid all references to this Part that are in the Diagram/Layer or in other Parts
  part.cloneProtected(this);
  this._category = newcat;
  this.invalidateMeasure();
  this.invalidateDraw();

  var diagram = this.diagram;
  var oldskip = true;
  if (diagram !== null) {
    oldskip = diagram.skipsUndoManager;
    diagram.skipsUndoManager = true;
  }

  this._data = olddata;  // use same data
  if (olddata !== null) this.updateTargetBindings();

  if (diagram !== null) {
    diagram.skipsUndoManager = oldskip;
  }

  // change layers, if needed
  var newlayername = this.layerName;
  if (newlayername !== oldlayername) {
    this._layerName = oldlayername;
    this.layerName = newlayername;
  }
  // keep some "transient" properties, don't copy them from the new template:
  if (this instanceof Node) {
    this.isTreeLeaf = oldistreeleaf;
    this.isTreeExpanded = oldistreeexpanded;
    this.wasTreeExpanded = oldwastreeexpanded;
  }
  this.isSelected = oldisselected;
};


// User permissions

/**
* This predicate returns true if {@link #copyable} is true,
* if the layer's {@link Layer#allowCopy} is true, and
* if the diagram's {@link Diagram#allowCopy} is true.
* @expose
* @this {Part}
* @return {boolean} true if the user may copy this part.
*/
Part.prototype.canCopy = function() {
  if (!this.copyable) return false;
  var layer = this.layer;
  if (layer === null) return true;
  if (!layer.allowCopy) return false;
  var diagram = layer.diagram;
  if (diagram === null) return true;
  if (!diagram.allowCopy) return false;
  return true;
};

/**
* This predicate returns true if {@link #deletable} is true,
* if the layer's {@link Layer#allowDelete} is true, and
* if the diagram's {@link Diagram#allowDelete} is true.
* @expose
* @this {Part}
* @return {boolean} true if the user may delete this part.
*/
Part.prototype.canDelete = function() {
  if (!this.deletable) return false;
  var layer = this.layer;
  if (layer === null) return true;
  if (!layer.allowDelete) return false;
  var diagram = layer.diagram;
  if (diagram === null) return true;
  if (!diagram.allowDelete) return false;
  return true;
};

/**
* This predicate returns true if {@link #textEditable} is true,
* if the layer's {@link Layer#allowTextEdit} is true, and
* if the diagram's {@link Diagram#allowTextEdit} is true.
* @expose
* @this {Part}
* @return {boolean} true if the user may edit this part.
*/
Part.prototype.canEdit = function() {
  if (!this.textEditable) return false;
  var layer = this.layer;
  if (layer === null) return true;
  if (!layer.allowTextEdit) return false;
  var diagram = layer.diagram;
  if (diagram === null) return true;
  if (!diagram.allowTextEdit) return false;
  return true;
};

/**
* This predicate returns true if {@link #groupable} is true,
* if the layer's {@link Layer#allowGroup} is true, and
* if the diagram's {@link Diagram#allowGroup} is true.
* @expose
* @this {Part}
* @return {boolean} true if the user may group this part.
*/
Part.prototype.canGroup = function() {
  if (!this.groupable) return false;
  var layer = this.layer;
  if (layer === null) return true;
  if (!layer.allowGroup) return false;
  var diagram = layer.diagram;
  if (diagram === null) return true;
  if (!diagram.allowGroup) return false;
  return true;
};

/**
* This predicate returns true if {@link #movable} is true,
* if the layer's {@link Layer#allowMove} is true, and
* if the diagram's {@link Diagram#allowMove} is true.
* @expose
* @this {Part}
* @return {boolean} true if the user may move this part.
*/
Part.prototype.canMove = function() {
  if (!this.movable) return false;
  var layer = this.layer;
  if (layer === null) return true;
  if (!layer.allowMove) return false;
  var diagram = layer.diagram;
  if (diagram === null) return true;
  if (!diagram.allowMove) return false;
  return true;
};

/**
* This predicate returns true if {@link #reshapable} is true,
* if the layer's {@link Layer#allowReshape} is true, and
* if the diagram's {@link Diagram#allowReshape} is true.
* @expose
* @this {Part}
* @return {boolean} true if the user may reshape this part.
*/
Part.prototype.canReshape = function() {
  if (!this.reshapable) return false;
  var layer = this.layer;
  if (layer === null) return true;
  if (!layer.allowReshape) return false;
  var diagram = layer.diagram;
  if (diagram === null) return true;
  if (!diagram.allowReshape) return false;
  return true;
};

/**
* This predicate returns true if {@link #resizable} is true,
* if the layer's {@link Layer#allowResize} is true, and
* if the diagram's {@link Diagram#allowResize} is true.
* @expose
* @this {Part}
* @return {boolean} true if the user may resize this part.
*/
Part.prototype.canResize = function() {
  if (!this.resizable) return false;
  var layer = this.layer;
  if (layer === null) return true;
  if (!layer.allowResize) return false;
  var diagram = layer.diagram;
  if (diagram === null) return true;
  if (!diagram.allowResize) return false;
  return true;
};

/**
* This predicate returns true if {@link #rotatable} is true,
* if the layer's {@link Layer#allowRotate} is true, and
* if the diagram's {@link Diagram#allowRotate} is true.
* @expose
* @this {Part}
* @return {boolean} true if the user may rotate this part.
*/
Part.prototype.canRotate = function() {
  if (!this.rotatable) return false;
  var layer = this.layer;
  if (layer === null) return true;
  if (!layer.allowRotate) return false;
  var diagram = layer.diagram;
  if (diagram === null) return true;
  if (!diagram.allowRotate) return false;
  return true;
};

/**
* This predicate returns true if {@link #selectable} is true,
* if the layer's {@link Layer#allowSelect} is true, and
* if the diagram's {@link Diagram#allowSelect} is true.
* @expose
* @this {Part}
* @return {boolean} true if the user may select this part.
*/
Part.prototype.canSelect = function() {
  if (!this.selectable) return false;
  var layer = this.layer;
  if (layer === null) return true;
  if (!layer.allowSelect) return false;
  var diagram = layer.diagram;
  if (diagram === null) return true;
  if (!diagram.allowSelect) return false;
  return true;
};


// Permission properties

/**
* Gets or sets whether the user may copy this part.
* The initial value is true.
* @name Part#copyable
* @function.
* @return {boolean}
* @see Part#canCopy
*/
/** @type {boolean} */
Part.prototype.copyable;
Util.exportProperty(Part, 'copyable', Part.prototype.copyable);
Util.defineProperty(Part, { copyable: 'copyable'},
  /** @this {Part} */
  function() { return (this._partFlags & 0x00000001) !== 0; },
  /** @this {Part} */
  function(val) {
    var old = (this._partFlags & 0x00000001) !== 0;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', Part, 'copyable');
      this._partFlags = this._partFlags ^ 0x00000001;
      this.raiseChanged('copyable', old, val);
    }
  }
);

/**
* Gets or sets whether the user may delete this part.
* The initial value is true.
* @name Part#deletable
* @function.
* @return {boolean}
* @see Part#canDelete
*/
/** @type {boolean} */
Part.prototype.deletable;
Util.exportProperty(Part, 'deletable', Part.prototype.deletable);
Util.defineProperty(Part, { deletable: 'deletable'},
  /** @this {Part} */
  function() { return (this._partFlags & 0x00000002) !== 0; },
  /** @this {Part} */
  function(val) {
    var old = (this._partFlags & 0x00000002) !== 0;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', Part, 'deletable');
      this._partFlags = this._partFlags ^ 0x00000002;
      this.raiseChanged('deletable', old, val);
    }
  }
);

/**
* Gets or sets whether the user may do in-place text editing on {@link TextBlock}s in this part
* that have {@link TextBlock#editable} set to true.
* The initial value is true.
* @name Part#textEditable
* @function.
* @return {boolean}
* @see Part#canEdit
* @see TextBlock#textEditable
*/
/** @type {boolean} */
Part.prototype.textEditable;
Util.exportProperty(Part, 'textEditable', Part.prototype.textEditable);
Util.defineProperty(Part, { textEditable: 'textEditable'},
  /** @this {Part} */
  function() { return (this._partFlags & 0x00000004) !== 0; },
  /** @this {Part} */
  function(val) {
    var old = (this._partFlags & 0x00000004) !== 0;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', Part, 'textEditable');
      this._partFlags = this._partFlags ^ 0x00000004;
      this.raiseChanged('textEditable', old, val);
      this.updateAdornments();
    }
  }
);

/**
* Gets or sets whether the user may group this part to be a member of a new {@link Group}.
* The initial value is true.
* @name Part#groupable
* @function.
* @return {boolean}
* @see Part#canGroup
*/
/** @type {boolean} */
Part.prototype.groupable;
Util.exportProperty(Part, 'groupable', Part.prototype.groupable);
Util.defineProperty(Part, { groupable: 'groupable'},
  /** @this {Part} */
  function() { return (this._partFlags & 0x00000008) !== 0; },
  /** @this {Part} */
  function(val) {
    var old = (this._partFlags & 0x00000008) !== 0;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', Part, 'groupable');
      this._partFlags = this._partFlags ^ 0x00000008;
      this.raiseChanged('groupable', old, val);
    }
  }
);

/**
* Gets or sets whether the user may move this part.
* The initial value is true.
* @name Part#movable
* @function.
* @return {boolean}
* @see Part#canMove
*/
/** @type {boolean} */
Part.prototype.movable;
Util.exportProperty(Part, 'movable', Part.prototype.movable);
Util.defineProperty(Part, { movable: 'movable'},
  /** @this {Part} */
  function() { return (this._partFlags & 0x00000010) !== 0; },
  /** @this {Part} */
  function(val) {
    var old = (this._partFlags & 0x00000010) !== 0;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', Part, 'movable');
      this._partFlags = this._partFlags ^ 0x00000010;
      this.raiseChanged('movable', old, val);
    }
  }
);

/**
* Gets or sets whether a selection adornment is shown for this part when it is selected.
* The initial value is true.
* @name Part#selectionAdorned
* @function.
* @return {boolean}
* @see Part#selectionChanged
* @see Part#selectionAdornmentTemplate
*/
/** @type {boolean} */
Part.prototype.selectionAdorned;
Util.exportProperty(Part, 'selectionAdorned', Part.prototype.selectionAdorned);
Util.defineProperty(Part, { selectionAdorned: 'selectionAdorned'},
  /** @this {Part} */
  function() { return (this._partFlags & 0x00000020) !== 0; },
  /** @this {Part} */
  function(val) {
    var old = (this._partFlags & 0x00000020) !== 0;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', Part, 'selectionAdorned');
      this._partFlags = this._partFlags ^ 0x00000020;
      this.raiseChanged('selectionAdorned', old, val);
      this.updateAdornments();
    }
  }
);

/**
* Gets or sets whether this Part is part of the document bounds.
* <p>
* The initial value is true.
* A value of false causes {@link Diagram#computeBounds} to ignore this part.
* If the value is false, it is possible that user will not be able to scroll far enough to see this part,
* if the part's {@link GraphObject#actualBounds} are outside of the {@link Diagram#documentBounds}.
* @name Part#isInDocumentBounds
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Part.prototype.isInDocumentBounds;
Util.exportProperty(Part, 'isInDocumentBounds', Part.prototype.isInDocumentBounds);
Util.defineProperty(Part, { isInDocumentBounds: 'isInDocumentBounds' },
  /** @this {Part} */
  function() { return (this._partFlags & 0x00000040) !== 0; },
  /** @this {Part} */
  function(val) {
    var old = (this._partFlags & 0x00000040) !== 0;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', Part, 'isInDocumentBounds');
      this._partFlags = this._partFlags ^ 0x00000040;
      //??? invalidate Diagram's document bounds
      this.raiseChanged('isInDocumentBounds', old, val);
    }
  }
);

/**
* Gets or sets whether a {@link Layout} positions this Node or routes this Link.
* This property affects the value of {@link #canLayout}.
* <p>
* The initial value is true, meaning that this part is laid out by the layout responsible for this Part.
* If this part is a member of a {@link Group}, it is the {@link Group#layout},
* otherwise it is the {@link Diagram#layout}.
* <p>
* A value of false means that this part is not affected by and does not affect any automatic layout.
* You will need to make sure that it has a real {@link #location} or {@link GraphObject#position} value.
* @name Part#isLayoutPositioned
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Part.prototype.isLayoutPositioned;
Util.exportProperty(Part, 'isLayoutPositioned', Part.prototype.isLayoutPositioned);
Util.defineProperty(Part, { isLayoutPositioned: 'isLayoutPositioned' },
  /** @this {Part} */
  function() { return (this._partFlags & 0x00000080) !== 0; },
  /** @this {Part} */
  function(val) {
    var old = (this._partFlags & 0x00000080) !== 0;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', Part, 'isLayoutPositioned');
      this._partFlags = this._partFlags ^ 0x00000080;
      this.raiseChanged('isLayoutPositioned', old, val);
      this.invalidateLayout(val ? Part.LayoutShown : Part.LayoutHidden);  // no-op if isUndoingRedoing
    }
  }
);

/**
* Gets or sets whether the user may select this part.
* The initial value is true.
* @name Part#selectable
* @function.
* @return {boolean}
* @see Part#canSelect
* @see Part#isSelected
* @see Part#selectionChanged
* @see Part#selectionObjectName
* @see Part#selectionAdornmentTemplate
*/
/** @type {boolean} */
Part.prototype.selectable;
Util.exportProperty(Part, 'selectable', Part.prototype.selectable);
Util.defineProperty(Part, { selectable: 'selectable'},
  /** @this {Part} */
  function() { return (this._partFlags & 0x00000100) !== 0; },
  /** @this {Part} */
  function(val) {
    var old = (this._partFlags & 0x00000100) !== 0;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', Part, 'selectable');
      this._partFlags = this._partFlags ^ 0x00000100;
      this.raiseChanged('selectable', old, val);
      this.updateAdornments();
    }
  }
);

/**
* Gets or sets whether the user may reshape this part.
* The initial value is false.
* @name Part#reshapable
* @function.
* @return {boolean}
* @see Part#canReshape
*/
/** @type {boolean} */
Part.prototype.reshapable;
Util.exportProperty(Part, 'reshapable', Part.prototype.reshapable);
Util.defineProperty(Part, { reshapable: 'reshapable'},
  /** @this {Part} */
  function() { return (this._partFlags & 0x00000200) !== 0; },
  /** @this {Part} */
  function(val) {
    var old = (this._partFlags & 0x00000200) !== 0;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', Part, 'selectable');
      this._partFlags = this._partFlags ^ 0x00000200;
      this.raiseChanged('selectable', old, val);
      this.updateAdornments();
    }
  }
);

/**
* Gets or sets whether the user may resize this part.
* The initial value is false.
* @name Part#resizable
* @function.
* @return {boolean}
* @see Part#canResize
*/
/** @type {boolean} */
Part.prototype.resizable;
Util.exportProperty(Part, 'resizable', Part.prototype.resizable);
Util.defineProperty(Part, { resizable: 'resizable'},
  /** @this {Part} */
  function() { return (this._partFlags & 0x00000400) !== 0; },
  /** @this {Part} */
  function(val) {
    var old = (this._partFlags & 0x00000400) !== 0;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', Part, 'selectable');
      this._partFlags = this._partFlags ^ 0x00000400;
      this.raiseChanged('selectable', old, val);
      this.updateAdornments();
    }
  }
);

/**
* Gets or sets whether the user may rotate this part.
* The initial value is false.
* @name Part#rotatable
* @function.
* @return {boolean}
* @see Part#canRotate
*/
/** @type {boolean} */
Part.prototype.rotatable;
Util.exportProperty(Part, 'rotatable', Part.prototype.rotatable);
Util.defineProperty(Part, { rotatable: 'rotatable'},
  /** @this {Part} */
  function() { return (this._partFlags & 0x00000800) !== 0; },
  /** @this {Part} */
  function(val) {
    var old = (this._partFlags & 0x00000800) !== 0;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', Part, 'selectable');
      this._partFlags = this._partFlags ^ 0x00000800;
      this.raiseChanged('selectable', old, val);
      this.updateAdornments();
    }
  }
);

/**
* Gets or sets whether this Part is selected.
* The initial value is false.
* <p>
* Selected parts typically are shown either with an {@link Adornment}
* or with a different appearance by changing the brush or visibility of one or
* more of the {@link GraphObject}s within the part.
* <p>
* Changing this value does not by itself raise any "ChangingSelection" and "ChangedSelection" {@link DiagramEvent}s.
* {@link Tool}s and the {@link CommandHandler} and methods such as {@link Diagram#select} do raise those DiagramEvents
* because they want to surround changes to this property with a single "ChangingSelection" DiagramEvent beforehand and a single "ChangedSelection" afterwards.
* @name Part#isSelected
* @function.
* @return {boolean}
* @see Part#selectable
* @see Part#selectionAdorned
* @see Part#selectionChanged
* @see Part#selectionObjectName
* @see Part#selectionAdornmentTemplate
*/
/** @type {boolean} */
Part.prototype.isSelected;
Util.exportProperty(Part, 'isSelected', Part.prototype.isSelected);
Util.defineProperty(Part, { isSelected: 'isSelected' },
/** @this {Part} */
  function() { return (this._partFlags & 0x00001000) !== 0; },
/** @this {Part} */
  function(val) {
    var old = (this._partFlags & 0x00001000) !== 0;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', Part, 'isSelected');
      var diagram = this.diagram;
      // check to make sure it's OK to select
      if (val) {
        if (!this.canSelect()) return;
        if (diagram !== null) {
          var max = diagram.maxSelectionCount;
          var count = diagram.selection.count;
          if (count >= max) return;
        }
      }
      // OK: select it
      this._partFlags = this._partFlags ^ 0x00001000;
      var oldskip = false;
      if (diagram !== null) {
        oldskip = diagram.skipsUndoManager;
        diagram.skipsUndoManager = true;
        var coll = diagram.selection;
        coll.thaw();
        if (val)
          coll.add(this);
        else
          coll.remove(this);
        coll.freeze();
      }
      this.raiseChanged('isSelected', old, val);
      this.invalidateAdornments(); // was this.updateAdornments();
      var func = this.selectionChanged;
      if (func !== null) {
        func(this);
      }
      if (diagram !== null) {
        diagram.requestUpdate();
        diagram.skipsUndoManager = oldskip;
      }
    }
  }
);

/**
* Gets or sets whether this part will draw shadows.
* The initial value is false.
* @name Part#isShadowed
* @function.
* @return {boolean}
* @see Part#shadowOffset
* @see Part#shadowColor
* @see Part#shadowBlur
*/
/** @type {boolean} */
Part.prototype.isShadowed;
Util.exportProperty(Part, 'isShadowed', Part.prototype.isShadowed);
Util.defineProperty(Part, { isShadowed: 'isShadowed' },
  /** @this {Part} */
  function() { return (this._partFlags & 0x00002000) !== 0; },
  /** @this {Part} */
  function(val) {
    var old = (this._partFlags & 0x00002000) !== 0;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', Part, 'isShadowed');
      this._partFlags = this._partFlags ^ 0x00002000;
      this.raiseChanged('isShadowed', old, val);
      this.invalidateDraw();
    }
  }
);

/** @ignore @this {Part} */
Part.prototype.getInvalidAdornments = function() {
  return (this._partFlags & 0x00004000) !== 0;
};
/** @ignore @this {Part}  @param {boolean} val */
Part.prototype.setInvalidAdornments = function(val) {
  if (val) {
    this._partFlags |= 0x00004000;
  } else {
    this._partFlags &= ~0x00004000;
  }
};

/** @ignore @this {Part} */
Part.prototype.getInvalidPosition = function() {
  return (this._partFlags & 0x00008000) !== 0;
};
/** @ignore @this {Part}  @param {boolean} val */
Part.prototype.setInvalidPosition = function(val) {
  if (val) {
    this._partFlags |= 0x00008000;
  } else {
    this._partFlags &= ~0x00008000;
  }
};

/** @ignore @this {Part} */
Part.prototype.getNotifyLater = function() {
  return (this._partFlags & 0x00010000) !== 0;
};
/** @ignore @this {Part}  @param {boolean} val */
Part.prototype.setNotifyLater = function(val) {
  if (val) {
    this._partFlags |= 0x00010000;
  } else {
    this._partFlags &= ~0x00010000;
  }
};

/** @ignore @this {Part} */
Part.prototype.getInView = function() {
  return (this._partFlags & 0x00020000) !== 0;
};
/** @ignore @this {Part}  @param {boolean} val */
Part.prototype.setInView = function(val) {
  if (val) {
    this._partFlags |= 0x00020000;
  } else {
    this._partFlags &= ~0x00020000;
  }
};


// Selecting

/**
* Gets or sets the name of the {@link GraphObject} that should get a selection handle
* when this part is selected.
* The value of this property affects the value of {@link #selectionObject}.
* The initial value is an empty string, meaning the whole {@link Part} itself gets any selection handle.
* <p>
* If no GraphObject has a {@link GraphObject#name} that is this name, {@link #selectionObject} returns the whole Part.
* @name Part#selectionObjectName
* @function.
* @return {string}
*/
/** @type {string} */
Part.prototype.selectionObjectName;
Util.exportProperty(Part, 'selectionObjectName', Part.prototype.selectionObjectName);
Util.defineProperty(Part, { selectionObjectName: 'selectionObjectName'},
  /** @this {Part} */
  function() { return this._selectionObjectName; },
  /** @this {Part} */
  function(val) {
    var old = this._selectionObjectName;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'string', Part, 'selectionObjectName');
      this._selectionObjectName = val;
      this._selectionObject = null;  // clear any cached value
      this.raiseChanged('selectionObjectName', old, val);
    }
  }
);

/**
* Gets or sets the {@link Adornment} template used to create a selection handle for this Part.
* <p>
* If this is null, depending on the class of this Part, the value of {@link Diagram#nodeSelectionAdornmentTemplate}, {@link Diagram#groupSelectionAdornmentTemplate},
* or {@link Diagram#linkSelectionAdornmentTemplate} is used instead.
* <p>
* It is commonplace to make use of a {@link Placeholder} in an {@link Adornment} for a {@link Node}, {@link Group}, or simple {@link Part}.
* The Placeholder represents the {@link Adornment#adornedObject} of the adorned Part.
* For {@link Link}s, the Adornment is commonly of {@link Panel#type} {@link Panel#Link},
* although you can use other Panel types along with a Placeholder.
* @name Part#selectionAdornmentTemplate
* @function.
* @return {Adornment}
*/
/** @type {Adornment} */
Part.prototype.selectionAdornmentTemplate;
Util.exportProperty(Part, 'selectionAdornmentTemplate', Part.prototype.selectionAdornmentTemplate);
Util.defineProperty(Part, { selectionAdornmentTemplate: 'selectionAdornmentTemplate'},
  /** @this {Part} */
  function() { return this._selectionAdornmentTemplate; },
  /** @this {Part} */
  function(val) {
    var old = this._selectionAdornmentTemplate;
    if (old !== val) {
      if (Debug) Util.checkClass(val, Adornment, Part, 'selectionAdornmentTemplate');
      if (this instanceof Link) val.type = Panel.Link;
      this._selectionAdornmentTemplate = val;
      this.raiseChanged('selectionAdornmentTemplate', old, val);
    }
  }
);

/**
* Gets the {@link GraphObject} that should get a selection handle when this part is selected.
* The value will be in the visual tree of this Part and is usually named with
* the value of {@link #selectionObjectName}.
* When the {@link #selectionObjectName} is unspecified, this whole Part is used as the "selection object".
* @name Part#selectionObject
* @function.
* @return {GraphObject}
*/
/** @type {GraphObject} */
Part.prototype.selectionObject;
Util.defineReadOnlyProperty(Part, { selectionObject: 'selectionObject'},
  /** @this {Part} */
  function() {
    if (this._selectionObject === null) {
      var ename = this.selectionObjectName;
      if (ename !== null && ename !== '') {
        var elt = this.findObject(ename);
        if (elt !== null) {  // found it: cache it
          this._selectionObject = elt;
        } else {  // not yet found
          this._selectionObject = this;
        }
      } else {  // always use main visual child
        if (this instanceof Link) {  // but for Links use the path, if present
          var path = this.path;
          if (path !== null) {
            this._selectionObject = path;
          } else {
            this._selectionObject = this;
          }
        } else {
          this._selectionObject = this;
        }
      }
    }
    return this._selectionObject;
  }
);

/**
* Gets or sets the function to execute when this part is selected or deselected.
* It is typically used to modify the appearance of the part.
* This function must not select or deselect any parts.
* <p>
* If this property value is a function, it is called with one argument,
* this {@link Part} that was selected or that became unselected.
* When it is called, the value of {@link Diagram#skipsUndoManager} is temporarily set to true.
* By default this property is null.
* <p>
* This function is called with {@link Diagram#skipsUndoManager} temporarily set to true,
* so that any changes to {@link GraphObject}s are not recorded in the {@link UndoManager}.
* You do not need to start and commit any transaction in this function.
* @name Part#selectionChanged
* @function.
* @return {function(Part) | null}
* @see Part#isSelected
* @see Part#selectionAdorned
* @see Part#selectionAdornmentTemplate
*/
/** @type {function(Part) | null} */
Part.prototype.selectionChanged;
Util.exportProperty(Part, 'selectionChanged', Part.prototype.selectionChanged);
Util.defineProperty(Part, { selectionChanged: 'selectionChanged'},
  /** @this {Part} */
  function() { return this._selectionChanged; },
  /** @this {Part} */
  function(val) {
    var old = this._selectionChanged;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', Part, 'selectionChanged');
      this._selectionChanged = val;
      this.raiseChanged('selectionChanged', old, val);
    }
  }
);


// Resizing

/**
* Gets or sets the adornment template used to create a resize handle {@link Adornment} for this part.
* This is used by the {@link ResizingTool}, {@link ToolManager#resizingTool}.
* @name Part#resizeAdornmentTemplate
* @function.
* @return {Adornment}
*/
/** @type {Adornment} */
Part.prototype.resizeAdornmentTemplate;
Util.exportProperty(Part, 'resizeAdornmentTemplate', Part.prototype.resizeAdornmentTemplate);
Util.defineProperty(Part, { resizeAdornmentTemplate: 'resizeAdornmentTemplate' },
  /** @this {Part} */
  function() { return this._resizeAdornmentTemplate; },
  /** @this {Part} */
  function(val) {
    var old = this._resizeAdornmentTemplate;
    if (old !== val) {
      if (Debug) Util.checkClass(val, Adornment, Part, 'resizeAdornmentTemplate');
      this._resizeAdornmentTemplate = val;
      this.raiseChanged('resizeAdornmentTemplate', old, val);
    }
  }
);

/**
* Gets or sets the name of the {@link GraphObject} that should get a resize handle
* when this part is selected.
* The value of this property affects the value of {@link #resizeObject}.
* The initial value is an empty string, meaning the whole {@link Part} itself gets any resize handle.
* @name Part#resizeObjectName
* @function.
* @return {string}
*/
/** @type {string} */
Part.prototype.resizeObjectName;
Util.exportProperty(Part, 'resizeObjectName', Part.prototype.resizeObjectName);
Util.defineProperty(Part, { resizeObjectName: 'resizeObjectName'},
  /** @this {Part} */
  function() { return this._resizeObjectName; },
  /** @this {Part} */
  function(val) {
    var old = this._resizeObjectName;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'string', Part, 'resizeObjectName');
      this._resizeObjectName = val;
      this._resizeObject = null;  // clear any cached value
      this.raiseChanged('resizeObjectName', old, val);
    }
  }
);

/**
* Gets the {@link GraphObject} that should get resize handles when this part is selected.
* The value will be in the visual tree of this Part and is usually named with
* the value of {@link #resizeObjectName}.
* @name Part#resizeObject
* @function.
* @return {GraphObject}
*/
/** @type {GraphObject} */
Part.prototype.resizeObject;
Util.defineReadOnlyProperty(Part, { resizeObject: 'resizeObject'},
  /** @this {Part} */
  function() {
    if (this._resizeObject === null) {
      var ename = this.resizeObjectName;
      if (ename !== null && ename !== '') {
        var elt = this.findObject(ename);
        if (elt !== null) {  // found it: cache it
          this._resizeObject = elt;
        } else {  // not yet found
          this._resizeObject = this;
        }
      } else {  // always use main visual child
        this._resizeObject = this;
      }
    }
    return this._resizeObject;
  }
);

/**
* Gets or sets the width and height multiples used when resizing.
* By default this property is the Size(NaN, NaN).
* @name Part#resizeCellSize
* @function.
* @return {Size}
*/
/** @type {Size} */
Part.prototype.resizeCellSize;
Util.exportProperty(Part, 'resizeCellSize', Part.prototype.resizeCellSize);
Util.defineProperty(Part, { resizeCellSize: 'resizeCellSize'},
  /** @this {Part} */
  function() { return this._resizeCellSize; },
  /** @this {Part} */
  function(val) {
    var old = this._resizeCellSize;
    if (!old.equals(val)) {
      if (Debug) Util.checkClass(val, Size, Part, 'resizeCellSize');
      val = val.copyFrozen();
      this._resizeCellSize = val;
      this.raiseChanged('resizeCellSize', old, val);
    }
  }
);


// Rotating

/**
* Gets or sets the adornment template used to create a rotation handle {@link Adornment} for this part.
* This is used by the {@link RotatingTool}, {@link ToolManager#rotatingTool}.
* @name Part#rotateAdornmentTemplate
* @function.
* @return {Adornment}
*/
/** @type {Adornment} */
Part.prototype.rotateAdornmentTemplate;
Util.exportProperty(Part, 'rotateAdornmentTemplate', Part.prototype.rotateAdornmentTemplate);
Util.defineProperty(Part, { rotateAdornmentTemplate: 'rotateAdornmentTemplate' },
  /** @this {Part} */
  function() { return this._rotateAdornmentTemplate; },
  /** @this {Part} */
  function(val) {
    var old = this._rotateAdornmentTemplate;
    if (old !== val) {
      if (Debug) Util.checkClass(val, Adornment, Part, 'rotateAdornmentTemplate');
      this._rotateAdornmentTemplate = val;
      this.raiseChanged('rotateAdornmentTemplate', old, val);
    }
  }
);

/**
* Gets or sets the name of the {@link GraphObject} that should get a rotate handle
* when this part is selected.
* The value of this property affects the value of {@link #rotateObject}.
* The initial value is an empty string, meaning the whole {@link Part} itself gets any rotate handle.
* @name Part#rotateObjectName
* @function.
* @return {string}
*/
/** @type {string} */
Part.prototype.rotateObjectName;
Util.exportProperty(Part, 'rotateObjectName', Part.prototype.rotateObjectName);
Util.defineProperty(Part, { rotateObjectName: 'rotateObjectName'},
  /** @this {Part} */
  function() { return this._rotateObjectName; },
  /** @this {Part} */
  function(val) {
    var old = this._rotateObjectName;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'string', Part, 'rotateObjectName');
      this._rotateObjectName = val;
      this._rotateObject = null;  // clear any cached value
      this.raiseChanged('rotateObjectName', old, val);
    }
  }
);

/**
* Gets the {@link GraphObject} that should get rotate handles when this part is selected.
* The value will be in the visual tree of this Part and is usually named with
* the value of {@link #rotateObjectName}.
* @name Part#rotateObject
* @function.
* @return {GraphObject}
*/
/** @type {GraphObject} */
Part.prototype.rotateObject;
Util.defineReadOnlyProperty(Part, { rotateObject: 'rotateObject'},
  /** @this {Part} */
  function() {
    if (this._rotateObject === null) {
      var ename = this.rotateObjectName;
      if (ename !== null && ename !== '') {
        var elt = this.findObject(ename);
        if (elt !== null) {  // found it: cache it
          this._rotateObject = elt;
        } else {  // not yet found
          this._rotateObject = this;
        }
      } else {  // always use main visual child
        this._rotateObject = this;
      }
    }
    return this._rotateObject;
  }
);


/**
* Gets or sets a text string that is associated with this part.
* <p>
* The initial value is an empty string.
* This value is often used for sorting.
* @name Part#text
* @function.
* @return {string}
*/
/** @type {string} */
Part.prototype.text;
Util.exportProperty(Part, 'text', Part.prototype.text);
Util.defineProperty(Part, { text: 'text'},
  /** @this {Part} */
  function() { return this._text; },
  /** @this {Part} */
  function(val) {
    var old = this._text;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'string', Part, 'text');
      this._text = val;
      this.raiseChanged('text', old, val);
    }
  }
);


// Grouping

/**
* Gets or sets the {@link Group} of which this {@link Part} or {@link Node} is a member.
* This will be null if this is a top-level part.
* <p>
* You cannot set this property on a {@link Link}; it is set for you automatically
* based on the group memberships of the connected nodes.
* You cannot set this property on an {@link Adornment} at all.
* <p>
* A template should not be a member of any group.
* @name Part#containingGroup
* @function.
* @return {Group}
*/
/** @type {Group} */
Part.prototype.containingGroup;
Util.exportProperty(Part, 'containingGroup', Part.prototype.containingGroup);
Util.defineProperty(Part, { containingGroup: 'containingGroup' },
  /** @this {Part} */
  function() { return this._containingGroup; },
  /** @this {Part} */
  function(val) {
    // don't allow this to be set on Links
    // (internally use setContainingGroup for Links, instead)
    if (this.isNodeLike()) {
      var old = this._containingGroup;
      if (old !== val) {
        if (Debug && val !== null) Util.checkClass(val, Group, Part, 'containingGroup');
        if (val !== null && (this === val || val.isMemberOf(this))) {
          if (this === val) Util.throwError('Cannot make a Group a member of itself: ' + this.toString());
          Util.throwError('Cannot make a Group indirectly contain itself: ' + this.toString() + ' already contains ' + val.toString());
        }

        // invalidate layout of old containing group or whole diagram
        this.invalidateLayout(Part.LayoutRemoved);  // no-op if isUndoingRedoing

        var diagram = this.diagram;
        if (old !== null) {
          old.removeMemberInternal(this);
        } else if (this instanceof Group) {
          if (diagram !== null) diagram._topLevelGroups.remove(this);
        }
        this._containingGroup = val;
        if (val !== null) {
          val.addMemberInternal(this);
        } else if (this instanceof Group) {
          if (diagram !== null) diagram._topLevelGroups.add(this);
        }

        // invalidate layout of new containing group or whole diagram
        this.invalidateLayout(Part.LayoutAdded);  // no-op if isUndoingRedoing

        // update model
        //??? no-op if isUndoingRedoing
        if (diagram !== null) {
          var data = this.data;
          var model = diagram.model;
          if (data !== null && model instanceof GraphLinksModel) {
            // if VAL is null or if VAL.data is null, the node data's group key is set to undefined
            var gdata = (val !== null ? val.data : null);
            model.setGroupKeyForNodeData(data, model.getKeyForNodeData(gdata));
          }
        }

        var func = this.containingGroupChanged;
        if (func !== null) {
          var oldUpdatingModel = true;
          if (diagram !== null) {
            oldUpdatingModel = diagram.isUpdatingModel;
            diagram.isUpdatingModel = true;
          }
          func(this, old, val);
          if (diagram !== null) {
            diagram.isUpdatingModel = oldUpdatingModel;
          }
        }

        if (this instanceof Group) {
          // connected links need to have their containingGroup recalculated,
          // including links connected to member nodes and nested groups
          var coll = new Set(Part);
          CommandHandler.gatherCollection(coll, this, true, 0);
          var it = coll.iterator;
          while (it.next()) {
            var p = it.value;
            if (p instanceof Node) {
              var lit = p.linksConnected;
              while (lit.next()) {
                var l = lit.value;
                //?? can this be optimized not to bother with Links that are in COLL
                l.updateContainingGroup();
              }
            }
          }
        }
        if (this instanceof Node) {
          var lit = this.linksConnected;
          while (lit.next()) {
            var l = lit.value;
            l.updateContainingGroup();
          }
        }

        this.raiseChanged('containingGroup', old, val);

        if (val !== null) val.sortZOrder();
      }
    } else {
      Util.throwError('cannot set the Part.containingGroup of a Link or Adornment');
      return;
    }
  }
);

/**
* @ignore
* @this {Part}
*/
Part.prototype.invalidateContainingGroup = function() {
  var group = this.containingGroup;
  if (group !== null) {
    group.invalidateMeasure();
    if (group._placeholder !== null) {
      group._placeholder.invalidateMeasure();
    }
    group.invalidateConnectedLinks();
  }
};

/**
* @ignore
* Called by Layer.internalAdd, overridden on Node and Group and Link.
* @this {Part}
*/
Part.prototype.internalAddProtected = function() {
  var old = this._containingGroup;
  if (old !== null) old.addMemberInternal(this);
};

/**
* @ignore
* Called by Layer.internalRemove, overridden on Node and Group and Link.
* @this {Part}
*/
Part.prototype.internalRemoveProtected = function() {
  // do the following instead of: this.containingGroup = null;
  var old = this._containingGroup;
  if (old !== null) old.removeMemberInternal(this);
};

/**
* @ignore
* Overridden by Node and Group and Link.
* @this {Part}
*/
Part.prototype.deleteCascade = function() {
  // this is not called for Links!
  var data = this.data;
  if (data !== null) {
    var diagram = this.diagram;
    if (diagram !== null) {
      var model = diagram.model;
      if (model !== null) {
        model.removeNodeData(data);
      }
    }
  }
};

/**
* Gets or sets the function that is called after this Part has changed which {@link Group} it belongs to, if any.
* It is typically used to modify the appearance of the part.
* The first argument will be this Part.
* The second argument will be the old Group, or null if it had been a top-level part.
* The third argument will be the new Group, or null if it is now a top-level part.
* <p>
* If the value is a function, that function must not modify the part's containing {@link Group}.
* The containing Group has already been changed -- trying to change it again may produce undefined behavior.
* <p>
* The initial value is null -- no function is called.
* @name Part#containingGroupChanged
* @function.
* @return {function(Part, Group, Group) | null}
*/
/** @type {function(Part, Group, Group) | null} */
Part.prototype.containingGroupChanged;
Util.exportProperty(Part, 'containingGroupChanged', Part.prototype.containingGroupChanged);
Util.defineProperty(Part, { containingGroupChanged: 'containingGroupChanged' },
  /** @this {Part} */
  function() { return this._containingGroupChanged; },
  /** @this {Part} */
  function(val) {
    var old = this._containingGroupChanged;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', Part, 'containingGroupChanged');
      this._containingGroupChanged = val;
      this.raiseChanged('containingGroupChanged', old, val);
    }
  }
);

/** @ignore */
Util.defineReadOnlyProperty(Part, { topLevelPart: 'topLevelPart' },  //??? keep for compatibility
  /** @this {Part} */
  function() { return this._findTopLevelPart(this); }
);

Part.prototype['findTopLevelPart'] =
/**
* Gets the top-level Part for this part, which is itself when {@link #isTopLevel} is true.
* This will not return null.
* @this {Part}
* @return {Part}
* @since 1.1
*/
Part.prototype.findTopLevelPart = function() {
  return this._findTopLevelPart(this);
};

/**
* @ignore
* @this {Part}
* @param {Part} p
* @return {Part}
*/
Part.prototype._findTopLevelPart = function(p) {
  var sg = p.containingGroup;
  if (sg !== null) return this._findTopLevelPart(sg);
  if (p instanceof Node) {
    var n = p;
    var ll = n.labeledLink;
    if (ll !== null) return this._findTopLevelPart(ll);
  }
  return p;
};

/**
* Gets whether this part is not member of any {@link Group} node
* nor is it a label node for a {@link Link}.
* @name Part#isTopLevel
* @function.
* @return {boolean}
* @see Part#containingGroup
* @see Node#labeledLink
*/
/** @type {boolean} */
Part.prototype.isTopLevel;
Util.defineReadOnlyProperty(Part, { isTopLevel: 'isTopLevel'},
  /** @this {Part} */
  function() {
    if (this.containingGroup !== null) return false;
    if (this instanceof Node) {
      var n = this;
      if (n.isLinkLabel) return false;
    }
    return true;
  }
);

Part.prototype['isMemberOf'] =
/**
* This predicate is true if this part is a member of the given {@link Part}, perhaps indirectly.
* <p>
* If the given part is a {@link Group} and this part is a member of the given group, this returns true.
* If this part is a {@link Node} and it is a label node for the given link, this returns true.
* Otherwise this searches recursively any {@link Part#containingGroup} of the given part.
* <p>
* A part cannot be contained by itself.
* A template should not be a member of any group.
* @this {Part}
* @param {Part} part
* @return {boolean}
*/
Part.prototype.isMemberOf = function(part) {
  if (!(part instanceof Group)) return false;
  return this._isMemberOf(this, part);
};

/**
* @ignore
* @this {Part}
* @param {Part} p
* @param {Part} part
* @return {boolean}
*/
Part.prototype._isMemberOf = function(p, part) {
  if (p === part || part === null) return false;
  var g = p.containingGroup;
  if (g !== null && (g === part || this._isMemberOf(g, part))) return true;
  if (p instanceof Node) {
    var n = p;
    var ll = n.labeledLink;
    if (ll !== null) return this._isMemberOf(ll, part);
  }
  return false;
};

Part.prototype['findCommonContainingGroup'] =
/**
* Find the {@link Group} that contains both this part and another one.
* <p>
* This returns null if the two parts are unrelated in the hierarchy of part membership.
* If non-null, the result is a {@link Group}.
* @this {Part}
* @param {Part} other
* @return {Group}
*/
Part.prototype.findCommonContainingGroup = function(other) {
  return this._findCommonContainingGroup(this, other);
};

/**
* @ignore
* @this {Part}
* @param {Part} a
* @param {Part} b
* @return {Group}
*/
Part.prototype._findCommonContainingGroup = function(a, b) {
  if (a === null) return null;
  if (b === null) return null;
  var asg = a.containingGroup;
  if (asg === null) return null;
  if (a === b) return asg;
  var bsg = b.containingGroup;
  if (bsg === null) return null;
  if (asg === bsg) return bsg;
  if (this._isMemberOf(b, asg)) return asg;
  if (this._isMemberOf(a, bsg)) return bsg;
  return this._findCommonContainingGroup(asg, bsg);
};


// Layout

/**
* Gets or sets flags that control when the {@link Layout} that is responsible for this Part is invalidated.
* The initial value is {@link Part#LayoutStandard},
* which causes the layout for this part to be invalidated when the part is added or removed or changes visibility or size.
* <p>
* Individual layout conditions include: {@link Part#LayoutAdded}, {@link Part#LayoutRemoved},
* {@link Part#LayoutShown}, {@link Part#LayoutHidden}, and {@link Part#LayoutNodeSized}.
* <p>
* This property is ignored if {@link #isLayoutPositioned} is false.
* @name Part#layoutConditions
* @function.
* @return {number}
*/
/** @type {number} */
Part.prototype.layoutConditions;
Util.exportProperty(Part, 'layoutConditions', Part.prototype.layoutConditions);
Util.defineProperty(Part, { layoutConditions: 'layoutConditions' },
  /** @this {Part} */
  function() { return this._layoutConditions; },
  /** @this {Part} */
  function(val) {
    var old = this._layoutConditions;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'number', Part, 'layoutConditions');
      this._layoutConditions = val;
      this.raiseChanged('layoutConditions', old, val);
    }
  }
);

/**
* This predicate is called by Layout implementations to decide whether this Part
* should be positioned and might affect the positioning of other Parts.
* <p>
* This is false if {@link #isLayoutPositioned} is false, if {@link #isVisible} returns false,
* or if the part is in a temporary {@link Layer}.
* @expose
* @this {Part}
* @return {boolean}
*/
Part.prototype.canLayout = function() {
  if (!this.isLayoutPositioned) return false;
  if (!this.isVisible()) return false;
  // also consider whether this.layer.isTemporary
  var lay = this.layer;
  if (lay !== null && lay.isTemporary) return false;
  // link labels are always laid out by their Link, not by the Diagram or Group
  if (this instanceof Node) {
    var n = this;
    if (n.isLinkLabel) return false;
  }
  return true;
};

/**
* @ignore
* This predicate is called by {@link #invalidateLayout} with a layout condition in order to decide whether
* to invalidate the Layout responsible for this Part after a change identified by the condition argument.
* <p>
* If the condition argument flag is not set in the value of {@link #layoutConditions}, this returns false.
* In particular, a Part that becomes not visible may still cause a layout invalidation
* if {@link #layoutConditions} includes {@link Part#LayoutHidden}, even though that Part
* will not participate in the layout.
* <p>
* This predicate is also false if {@link #isLayoutPositioned} is false
* or if the part is in a temporary {@link Layer}.
* @this {Part}
* @param {number} condition the reason that the layout should be invalidated,
*   a value such as {@link Part#LayoutAdded} or {@link Part#LayoutShown}.
* @return {boolean}
*/
Part.prototype.canInvalidateLayout = function(condition) {
  if (!this.isLayoutPositioned) return false;
  // when invalidating, consider the layoutConditions
  if ((condition & this.layoutConditions) === 0) return false;
  // also consider whether this.layer.isTemporary
  var lay = this.layer;
  if (lay !== null && lay.isTemporary) return false;
  // link labels are always laid out by their Link, not by the Diagram or Group
  if (this instanceof Node) {
    var n = this;
    if (n.isLinkLabel) return false;
  }
  var diagram = this.diagram;
  if (diagram !== null && diagram.undoManager.isUndoingRedoing) return false;
  return true;
};

Part.prototype['invalidateLayout'] =
/**
* Invalidate the {@link Layout} that is responsible for positioning this Part.
* If this part is in a {@link Group}, invalidate its {@link Group#layout}, if it has one.
* Otherwise invalidate the {@link Diagram#layout}.
* <p>
* But note that if {@link #isLayoutPositioned} is false, or if it is in a temporary {@link Layer},
* or if it is not in a diagram or group, no layout is invalidated.
* @this {Part}
* @param {number=} condition the reason that the layout should be invalidated;
* if this argument is not supplied, any value of {@link #layoutConditions} other than {@link Part#LayoutNone}
* will allow the layout to be invalidated.
*/
Part.prototype.invalidateLayout = function(condition) {
  if (condition === undefined/*notpresent*/) condition = Part.LayoutAll;
  if (!this.canInvalidateLayout(condition)) return;
  var g = this._containingGroup;
  if (g !== null) {
    var lay = g.layout;
    if (lay !== null) {
      lay.invalidateLayout();
    } else {
      g.invalidateLayout(condition);  // go up chain of Groups
    }
  } else {
    var d = this.diagram;
    if (d !== null) {
      var lay = d.layout;
      if (lay !== null) {
        lay.invalidateLayout();
      }
    }
  }
};


/**
* Gets or sets the function used to determine the location that this Part can be dragged to.
* The first argument is a reference to the Part being dragged, the second argument is a Point describing
* the proposed location, and the third argument is a snapped location, if one was determined during dragging.
* It should return a Point that is the proposed new location.
* <p>
* By default this function is null and the {@link DraggingTool} uses the snapped location,
* if one was determined and if {@link DraggingTool#isGridSnapEnabled} is true,
* or the proposed location (the second argument) if not snapping to a grid.
* <p>
* In either case the {@link DraggingTool} will limit the proposed new location by {@link #minLocation} and {@link #maxLocation}.
* <p>
* The function, if supplied, must not have any side-effects.
* @name Part#dragComputation
* @function.
* @return {function(Part, Point, Point):Point | null}
*/
/** @type {function(Part, Point, Point):Point | null} */
Part.prototype.dragComputation;
Util.exportProperty(Part, 'dragComputation', Part.prototype.dragComputation);
Util.defineProperty(Part, { dragComputation: 'dragComputation'},
  /** @this {Part} */
  function() { return this._dragComputation; },
  /** @this {Part} */
  function(val) {
    var old = this._dragComputation;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', Part, 'dragComputation');
      this._dragComputation = val;
      this.raiseChanged('dragComputation', old, val);
    }
  }
);


// Shadows

/**
* Gets or sets the X and Y offset of this part's shadow. This is only relevant if {@link #isShadowed} is true.
* The initial value is (6, 6).
* @name Part#shadowOffset
* @function.
* @return {Point}
* @see Part#isShadowed
* @see Part#shadowColor
* @see Part#shadowBlur
*/
/** @type {Point} */
Part.prototype.shadowOffset;
Util.exportProperty(Part, 'shadowOffset', Part.prototype.shadowOffset);
Util.defineProperty(Part, { shadowOffset: 'shadowOffset' },
  /** @this {Part} */
  function() { return this._shadowOffset; },
  /** @this {Part} */
  function(val) {
    var old = this._shadowOffset;
    if (!old.equals(val)) {
      if (Debug) Util.checkClass(val, Point, Part, 'shadowOffset');
      val = val.copyFrozen();
      this._shadowOffset = val;
      this.invalidateDraw();
      this.raiseChanged('shadowOffset', old, val);
    }
  }
);

/**
* Gets or sets the CSS string that describes a shadow color. Default is 'gray'.
* Brushes cannot be used for this property -- only strings.
* @name Part#shadowColor
* @function.
* @return {string}
* @see Part#isShadowed
* @see Part#shadowOffset
* @see Part#shadowBlur
*/
/** @type {string} */
Part.prototype.shadowColor;
Util.exportProperty(Part, 'shadowColor', Part.prototype.shadowColor);
Util.defineProperty(Part, { shadowColor: 'shadowColor' },
  /** @this {Part} */
  function() { return this._shadowColor; },
  /** @this {Part} */
  function(val) {
    var old = this._shadowColor;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'string', Part, 'shadowColor');
      this._shadowColor = val;
      this.invalidateDraw();
      this.raiseChanged('shadowColor', old, val);
    }
  }
);

/**
* Gets or sets the numerical value that describes the shadow's blur. Default is 4.
* @name Part#shadowBlur
* @function.
* @return {number}
* @see Part#isShadowed
* @see Part#shadowOffset
* @see Part#shadowColor
*/
/** @type {number} */
Part.prototype.shadowBlur;
Util.exportProperty(Part, 'shadowBlur', Part.prototype.shadowBlur);
Util.defineProperty(Part, { shadowBlur: 'shadowBlur' },
  /** @this {Part} */
  function() { return this._shadowBlur; },
  /** @this {Part} */
  function(val) {
    var old = this._shadowBlur;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'number', Part, 'shadowBlur');
      this._shadowBlur = val;
      this.invalidateDraw();
      this.raiseChanged('shadowBlur', old, val);
    }
  }
);



/**
 * @constructor
 * @param {EnumValue=} type if not supplied, the default Panel type is {@link Panel#Position}.
 * @extends Part
 * @class
 * An adornment is a special kind of {@link Part} that is associated with another Part,
 * the {@link Adornment#adornedPart}.
 * <p>
 * Adornments are normally associated with a particular {@link GraphObject} in the adorned part --
 * that is the value of {@link #adornedObject}.
 * However, the {@link #adornedObject} may be null, in which case the {@link #adornedPart} will also be null.
 * <p>
 * The area occupied by the adorned object is represented in the adornment's visual tree by a {@link Placeholder}.
 * The placeholder is always the {@link Part#locationObject},
 * although you may specify any {@link Spot} as the {@link Part#locationSpot}.
 * An adornment need not have a placeholder, but it may have at most one.
 * <p>
 * Adornments can be distinguished by their {@link Part#category}.
 * This property can be an arbitrary string value determined by the code creating the adornment,
 * typically a tool that wants to be able to tell various adornments apart from each other.
 * Use the {@link Part#findAdornment} method to find an adornment for a part of a given category.
 * <p>
 * For example, one of the Adornments created by {@link Part#updateAdornments} when the part
 * {@link Part#isSelected} has the {@link Part#category} of "Selection".
 * Those created by {@link ResizingTool#updateAdornments} have a category of "Resize"
 * and normally contain eight resize handles.
 * <p>
 * Besides the selection adornment and tool adornments, adornments are also used for
 * context menus and tooltips.
 * The {@link #adornedObject} in such cases refers to the {@link GraphObject} to which the
 * the context menu or tooltip applies.
 * <p>
 * There cannot be any links connected to an adornment,
 * nor can an adornment have members or be a member of a group.
 * <p>
 * An adornment cannot have its own adornments.
 * An adornment cannot be selected.
 * <p>
 * Adornments are not positioned by a {@link Layout} because they are normally positioned
 * according to the Part that they adorn.
 * <p/>
 * For more discussion and examples, see <a href="../../intro/selection.html">Selection</a>,
 * <a href="../../intro/toolTips.html">ToolTips</a>,
 * <a href="../../intro/contextMenus.html">Context Menus</a>, and
 * <a href="../../intro/tools.html">Tools</a>.
 */
function Adornment(type) {
  if (arguments.length === 0)
    Part.call(this, Panel.Position);
  else
    Part.call(this, type);

  this.layerName = 'Adornment';
  /** @type {GraphObject} */
  this._adornedObject = null;

  this._partFlags &= ~0x00000100; // not selectable

  this._location = new Point(NaN, NaN);

  // used when adornments are of type Panel.Link
  /** @type {List} */
  this._childrenBounds = new List(Rect);

  /** @type {Placeholder} */
  this._placeholder = null;
  /** @type {boolean} */
  this._isStandard = false;
}

Util.publish('Adornment', Adornment);

Util.inherit(Adornment, Part);

/**
* @ignore
* @this {Adornment}
* @return {string}
*/
Adornment.prototype.toString = function() {
  var apart = this.adornedPart;
  return 'Adornment(' + this.category + ')' + (apart !== null ? apart.toString() : '');
};

/**
* @ignore
* Only for Link Adornments
* @this {Adornment}
*/
Adornment.prototype._getGeometry = function() {
  if (this._adornedObject && this._adornedObject.geometry)
    return this._adornedObject.geometry;
  return null;
};

/**
* @ignore
* Only for Link Adornments
* @this {Adornment}
* @return {Rect}
*/
Adornment.prototype._getRouteBounds = function() {
  if (this._adornedObject && this._adornedObject.part instanceof Link)
    return this._adornedObject.part._getRouteBounds();
  return null;
};

/**
* @ignore
* Only for Link Adornments
* @this {Adornment}
*/
Adornment.prototype._getPath = function() {
  //if (this.adornedObject instanceof Shape) return this.adornedObject;
  return null;
};


/**
* @ignore
* Only for Link Adornments
* @this {Adornment}
*/
Adornment.prototype.makeShapeGeometry = function() {
  var link = this.adornedObject.part;
  var shape = this.adornedObject;
  if (!(link instanceof Link)) return;
  if (!(shape instanceof Shape)) return;

  var path = link.path;
  var geom = path.getConstructedGeometry();
  // If the selection object does not have geometry we will make it now
  link.makeShapeGeometry();
  geom = path.getConstructedGeometry();

  var children = this._elements;
  var l = children.length;
  for (var i = 0; i < l; i++) {
    var e = children._arr[i];
    // Take all shapes that have panelMain = true and give them a specific, shared geometry
    if (e.isPanelMain && e instanceof Shape) {
     e._geometry = geom;  // all must share same Geometry
    }
  }
};


/**
* @ignore
* @this {Adornment}
*/
Adornment.prototype._getPoints = function() {
  var link = this.adornedPart;
  if (link instanceof Link) return link._points;
  return null;
};

/**
* Gets a {@link Placeholder} that this Adornment may contain in its visual tree.
* This may be null if there is no such placeholder object.
* @name Adornment#placeholder
* @function.
* @return {Placeholder}
*/
/** @type {Placeholder} */
Adornment.prototype.placeholder;
Util.defineReadOnlyProperty(Adornment, { placeholder: 'placeholder'},
  /** @this {Adornment} */
  function() { return this._placeholder; }
);

/**
* @ignore
* Set and used by Part.updateAdornments (updateToolAdornments/updateSelectionAdornment)
* @name Adornment#isStandard
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Adornment.prototype.isStandard;
Util.exportProperty(Adornment, 'isStandard', Adornment.prototype.isStandard);
Util.defineProperty(Adornment, { isStandard: 'isStandard' },
  /** @this {Adornment} */
  function() { return this._isStandard; },
  /** @this {Adornment} */
  function(val) {
    var old = this._isStandard;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', Adornment, 'isStandard');
      this._isStandard = val;
      //??? invalidate Diagram's document bounds
      this.raiseChanged('isStandard', old, val);
    }
  }
);

/**
* Gets or sets the {@link GraphObject} that is adorned.
* Setting this property updates the adorned object's Part by calling {@link Part#addAdornment}.
* This may be null if the Adornment does not adorn a particular object.
* @name Adornment#adornedObject
* @function.
* @return {GraphObject}
*/
/** @type {GraphObject} */
Adornment.prototype.adornedObject;
Util.exportProperty(Adornment, 'adornedObject', Adornment.prototype.adornedObject);
Util.defineProperty(Adornment, { adornedObject: 'adornedObject'},
  /** @this {Adornment} */
  function() { return this._adornedObject; },
  /** @this {Adornment} */
  function(val) {
    if (Debug && val !== null) {
      Util.checkClass(val, GraphObject, Part, 'adornedObject:val');
    }
    var op = this.adornedPart;
    var part = null;
    if (val !== null) part = val.part;
    if (op !== null && (val === null || op !== part)) {
      // remove from old map, if it exists
      op.removeAdornment(this.category);
    }
    this._adornedObject = val;
    if (part) part.addAdornment(this.category, this);
  }
);

/**
* Gets the {@link Part} that contains the adorned object.
* This will be null if the {@link #adornedObject} is null.
* @name Adornment#adornedPart
* @function.
* @return {Part}
*/
/** @type {Part} */
Adornment.prototype.adornedPart;
Util.defineReadOnlyProperty(Adornment, { adornedPart: 'adornedPart'},
  /** @this {Adornment} */
  function() {
    var obj = this._adornedObject;
    if (obj !== null) return obj.part;
    return null;
  }
);

/**
 * @ignore
 * @this {Adornment}
 * @return {boolean}
 */
Adornment.prototype.isReadyToMeasureArrange = function() {
  var obj = this._adornedObject;
  if (obj === null) return true;
  var adpart = obj.part;
  return (adpart === null || !adpart.getInvalidArrange());
};

/**
* @ignore
* @this {Part}
* @return {boolean}
*/
Adornment.prototype.isNodeLike = function() {
  return false;
};

/**
* @ignore
* This property always returns null; it cannot be set.
* @name Adornment#containingGroup
* @function.
* @return {Group}
*/
/** @type {Group} */
Adornment.prototype.containingGroup;
Util.defineReadOnlyProperty(Adornment, { containingGroup: 'containingGroup'},
  /** @this {Adornment} */
  function() { return null; }
);

/**
* @ignore
* Call this method to notify that the some state has changed.
* This just calls the {@link #diagram}'s {@link Diagram#raiseChangedEvent} method.
* @this {Adornment}
* @param {EnumValue} change specifies the general nature of the change;
* permissible values include {@link ChangedEvent#Property}, {@link ChangedEvent#Insert},
* {@link ChangedEvent#Remove}, and {@link ChangedEvent#Transaction}.
* @param {string} propertyname names the property that was modified.
* @param {Object} obj the object that was modified, typically a {@link GraphObject}.
* @param {*} oldval the previous or older value.
* @param {*} newval the next or newer value.
* @param {*=} oldparam an optional value that helps describe the older value.
* @param {*=} newparam an optional value that helps describe the newer value.
*/
Adornment.prototype.raisePartChangedEvent = function(change, propertyname, obj, oldval, newval, oldparam, newparam) {
  // maintain Placeholder
  if (change === ChangedEvent.Insert && propertyname === 'elements') {
    if (newval instanceof Placeholder) {
      if (this._placeholder === null) {
        this._placeholder = newval;
      } else if (this._placeholder !== newval) {
        Util.throwError('Cannot insert a second Placeholder into the visual tree of an Adornment.');
      }
    } else if (newval instanceof Panel) {
      var place = newval.searchVisualTree(function(g) { return g instanceof Placeholder; });
      if (place instanceof Placeholder) {
        if (this._placeholder === null) {
          this._placeholder = place;
        } else if (this._placeholder !== place) {
          Util.throwError('Cannot insert a second Placeholder into the visual tree of an Adornment.');
        }
      }
    }
  } else if (change === ChangedEvent.Remove && propertyname === 'elements') {
    if (oldval === this._placeholder) {
      this._placeholder = null;
    } else if (oldval instanceof Panel && this._placeholder.isContainedBy(oldval)) {
      this._placeholder = null;
    }
  }
  Part.prototype.raisePartChangedEvent.call(this, change, propertyname, obj, oldval, newval, oldparam, newparam);
};

/**
* @ignore
* Adornments cannot have any of their own Adornments, so this method is always a no-op.
* @this {Adornment}
*/
Adornment.prototype.updateAdornments = function() {
};

/**
* @ignore
* @this {Adornment}
*/
Adornment.prototype.deleteCascade = function() {
};

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
Node
*/


/**
 * Constructs an empty Node.
 * The panel type must be one of the values permitted by {@link Panel#type}.
 * @constructor
 * @param {EnumValue=} type if not supplied, the default Panel type is {@link Panel#Position}.
 * @extends Part
 * @class
 * A Node is a {@link Part} that may connect to other nodes with {@link Link}s,
 * or that may be a member of a {@link Group}.
 * <p/>
 * {@link Group} inherits from Node,
 * enabling nodes to logically contain other nodes and links.
 * <p class="box">
 * For a more general discussion of how to define nodes, see <a href="../../intro/nodes.html">Introduction to Nodes</a>.
 * <p/>
 * Although you can create a Node and {@link Diagram#add} it to a Diagram, this does not update the Model.
 * It is more common to create a node by adding a node data object to the model
 * by calling {@link Model#addNodeData}. For example:
 * <pre>
 *   myDiagram.startTransaction("make new node");
 *   myDiagram.model.addNodeData({ key: "Omega" });
 *   myDiagram.commitTransaction("make new node");
 * </pre>
 * This will cause a Node or simple {@link Part} to be created (copying the template found in {@link Diagram#nodeTemplateMap}),
 * added to the Diagram in some {@link Layer} (based on {@link Part#layerName}), and bound to the node data
 * (resulting in {@link Panel#data} referring to that node data object).
 * <p/>
 * It is very common to initialize a Diagram by setting {@link Model#nodeDataArray} to a JavaScript Array
 * of JavaScript objects holding the properties that you need in your model.
 * Nearly all of the samples do this kind of initialization.
 * <p/>
 * You can delete a Node by either calling {@link Diagram#remove} or by calling {@link Model#removeNodeData}.
 * The latter obviously will modify the Model; the former does so if the Node was created from model data.
 * Commands such as {@link CommandHandler#deleteSelection} call these methods within a transaction.
 * <p/>
 * You can find all of the {@link Link}s that are connected with a Node by calling {@link #findLinksConnected}.
 * Because links normally have a direction, you can find all of the links that have their {@link Link#toNode}
 * be a given Node by calling {@link #findLinksInto}.
 * Similarly, you can call {@link #findLinksOutOf} to find all of the links coming out from a node;
 * such links have their {@link Link#fromNode} be that node.
 * For tree-structured graphs, use {@link #findTreeChildrenLinks} or {@link #findTreeParentLink}.
 * <p/>
 * If you are not so interested in the links but are interested in the nodes at the other end of the links
 * connecting with a node, there are other methods that you can call.
 * {@link #findNodesConnected} returns all of the nodes that are at the other end of the links that
 * connect with a given node.
 * {@link #findNodesInto} and {@link #findNodesOutOf} return the subsets of those nodes considering
 * only those links that go into or come out of the given node.
 * For tree-structured graphs, use {@link #findTreeChildrenNodes} or {@link #findTreeParentNode}.
 * <p/>
 * For example, to operate on the data of all of the destination nodes:
 * <pre>
 * var it = somenode.findNodesOutOf();
 * while (it.next()) {
 *   var child = it.value;
 *   if (child.data.text.indexOf("special") >= 0) { ... }
 * }
 * </pre>
 * <p/>
 * You can link two nodes by creating a new {@link Link}, setting its {@link Link#toNode} and {@link Link#fromNode}
 * (in either order), and {@link Diagram#add}ing it to the diagram.
 * But it is more common to add a link data object to the {@link Diagram#model} by calling {@link GraphLinksModel#addLinkData}.
 * Just creating and adding a {@link Link} will not update the model.
 * <p/>
 * Thus to add a link when using a {@link GraphLinksModel} you should do something like:
 * <pre>
 *   myDiagram.startTransaction("make new link");
 *   myDiagram.model.addLinkData({ from: "Alpha", to: "Beta" });
 *   myDiagram.commitTransaction("make new link");
 * </pre>
 * where you would substitute the keys of the actual nodes that you want to connect with a link.
 * If you are using a {@link TreeModel}, there are no link data objects, so you just need to call
 * {@link TreeModel#setParentKeyForNodeData} to specify the "parent" node's key for a "child" node data.
 * <p/>
 * To find a {@link Link} given a link data object in the {@link GraphLinksModel},
 * call {@link Diagram#findLinkForData}.  When using a {@link TreeModel}, call either {@link Diagram#findNodeForData}
 * or {@link Diagram#findNodeForKey} to get a Node, and then call {@link #findTreeParentLink} to get the Link, if any exists.
 * <p/>
 * To find a link that connects two nodes, call {@link #findLinksTo} or {@link #findLinksBetween}.
 * With the former method, the direction matters; with the latter method it returns links in either direction.
 * <p/>
 * As links connect with a node or are disconnected, you may want to update the appearance of the node.
 * You can set the {@link #linkConnected} and {@link #linkDisconnected} properties to be functions that are called.
 * These functions must not modify any link relationships -- the properties just exist to update the appearance of the node.
 * A typical usage would be to change the color or figure of a shape.
 * <p/>
 * Nodes also support the ability to provide logical and physical distinctions in the connection points
 * that links use at a node. These connection objects are called "ports".
 * By default that will be the whole {@link Node}.
 * However, you can set the {@link GraphObject#portId} property on any {@link GraphObject} in the visual tree of a node
 * to cause that element to be treated as a "port".
 * The "port id" is just a string that ought to be unique amongst all of the port elements in the node.
 * <p/>
 * In the case of a node only having a single port, you should set the {@link GraphObject#portId} as an empty string.
 * When there is no such element declared as the default port, it uses the whole node.
 * You can use the {@link #port} property to get the only port element.
 * <p/>
 * When a node should have multiple ports,
 * i.e. multiple {@link GraphObject}s acting as separate connection points for links,
 * you should set each port's {@link GraphObject#portId} to a string value that is unique for the node.
 * When there may be multiple ports on a node, you can get a collection of elements representing ports
 * by using the {@link #ports} property.
 * Use the {@link #findPort} method to find a particular port element by name.
 * <p class="box">
 * For a more general discussion of ports, see <a href="../../intro/ports.html">Introduction to Ports</a>.
 * <p/>
 * All of the "findLinks..." and "findNodes..." methods mentioned above take an optional port id argument.
 * When no argument is passed, these methods consider all links connecting with the node.
 * When a port id argument is provided, these methods only consider links that connect with that port
 * in the given node.
 * Thus when navigating through the diagram, you can easily look at all of the nodes that links coming out of
 * a given node go to.  Or you can just look at those nodes at the ends of links coming out of a particular port.
 * <p/>
 * You can also control the default connecting behavior of {@link Link}s at each port.
 * Because a port can be any {@link GraphObject}, they are all properties on GraphObject.
 * The properties are duplicated so that you can guide the "from" ends of links differently from the "to" ends of links.
 * The properties include:
 * <ul>
 *   <li>{@link GraphObject#fromSpot}, {@link GraphObject#toSpot}</li>
 *   <li>{@link GraphObject#fromEndSegmentLength}, {@link GraphObject#toEndSegmentLength}</li>
 *   <li>{@link GraphObject#fromShortLength}, {@link GraphObject#toShortLength}</li>
 *   <li>{@link GraphObject#fromLinkable}, {@link GraphObject#toLinkable}</li>
 *   <li>{@link GraphObject#fromLinkableDuplicates}, {@link GraphObject#toLinkableDuplicates}</li>
 *   <li>{@link GraphObject#fromLinkableSelfNode}, {@link GraphObject#toLinkableSelfNode}</li>
 *   <li>{@link GraphObject#fromMaxLinks}, {@link GraphObject#toMaxLinks}</li>
 * </ul>
 * The "...Spot" and "...Length" properties control the position and routing of links at a port.
 * The "...Linkable..." and "...MaxLinks" properties control whether or not users can draw a new link
 * or reconnect an existing link from or to a port.
 * (The "...Spot" and "...Length" properties also exist on {@link Link}, to override for a particular
 * link the default values that come from a port element.)
 * <p class="box">
 * For a more general discussion of link points, see <a href="../../intro/connectionPoints.html">Introduction to Link Connection Points</a>.
 * <p/>
 * When the graph is tree-structured, you can use several functions for traversing the tree:
 * <ul>
 *   <li>{@link #findTreeParentNode}</li>
 *   <li>{@link #findTreeChildrenNodes}</li>
 *   <li>{@link #findTreeParentLink}</li>
 *   <li>{@link #findTreeChildrenLinks}</li>
 *   <li>{@link #findTreeRoot}</li>
 *   <li>{@link #findTreeParts}</li>
 *   <li>{@link #isInTreeOf}</li>
 * </ul>
 * Determining whether a tree grows from the root via links that go out to the children or vice-versa
 * is controlled for the whole diagram by the {@link Diagram#isTreePathToChildren} property.
 * However an individual link will be ignored by the above functions if {@link Link#isTreeLink} is false.
 * <p/>
 * The Node class also supports the notion of expanding and collapsing a subtree of nodes and links,
 * causing those nodes and links to be shown or hidden.
 * Principally this is a matter of setting {@link Node#isTreeExpanded}.
 * Of course if the diagram's graph is not tree-structured, these concepts and properties might not apply.
 * <p/>
 * If you want to change the appearance of the node you can do so in a function that you assign to
 * the {@link #treeExpandedChanged} property.
 * This function must not modify any link relationships or expand or collapse any subtrees -- the property just exists
 * to update the appearance of the node.
 * <p/>
 * There is an option for link routing to try to avoid crossing over nodes:
 * {@link Link#routing} = {@link Link#AvoidsNodes}.
 * You can control whether such links should avoid or ignore a node by setting {@link #avoidable}.
 * Set {@link #avoidableMargin} to control the area beyond the {@link GraphObject#actualBounds}
 * where AvoidsNodes links should not go.
 * <p class="box">
 * For more discussion and examples, see <a href="../../intro/nodes.html">Nodes</a>,
 * <a href="../../intro/ports.html">Ports</a>, and
 * <a href="../../intro/connectionPoints.html">Link Points</a>.
 * <p class="box">
 * For more about trees, see <a href="../../intro/trees.html">Trees</a>, and
 * <a href="../../intro/subtrees.html">SubTrees</a>.
 * <p/>
 * Only Nodes that are in Diagrams can have connections via Links.
 * Templates should not be connected with Links, be labels of Links, be members of Groups, or have any Adornments.
 */
function Node(type) {
  if (arguments.length === 0)
    Part.call(this, Panel.Position);
  else
    Part.call(this, type);

  /** @type {List} */
  this._linksConnected = new List(Link);  // related Links; must be List for filter support
  /** @type {function(Node, Link, GraphObject) | null} */
  this._linkConnected = null;
  /** @type {function(Node, Link, GraphObject) | null} */
  this._linkDisconnected = null;
  /** @type {Link} */
  this._labeledLink = null;  // owning Link; non-null implies isLinkLabel===true

  /** @type {boolean} */
  this._isTreeExpanded = true;
  /** @type {boolean} */
  this._wasTreeExpanded = false;
  /** @type {function(Node) | null} */
  this._treeExpandedChanged = null;
  /** @type {boolean} */
  this._isTreeLeaf = true;

  /** @type {boolean} */
  this._avoidable = true;
  /** @type {Margin} */
  this._avoidableMargin = Geo.TwoMargin;

  /** @type {Set} */
  this._bundles = null;  // all LinkBundles connected to this node
  /** @type {Map} */
  this._ports = null;  // must be in visual tree

  /** @type {Node|boolean|null} */
  this._treeParentNode = false; // null is a valid value, so default is false
}

Util.publish('Node', Node);

Util.inherit(Node, Part);

/**
* @ignore
* Copies properties to a cloned Node.
* @this {Node}
* @param {GraphObject} copy
*/
Node.prototype.cloneProtected = function(copy) {
  Part.prototype.cloneProtected.call(this, copy);

  // copy._linksConnected references should be handled by copier
  copy._linkConnected = this._linkConnected;
  copy._linkDisconnected = this._linkDisconnected;
  // copy._labeledLink reference should be handled by copier

  copy._isTreeExpanded = this._isTreeExpanded;
  copy._wasTreeExpanded = this._wasTreeExpanded;
  copy._treeExpandedChanged = this._treeExpandedChanged;
  copy._isTreeLeaf = this._isTreeLeaf;

  copy._avoidable = this._avoidable;
  copy._avoidableMargin = this._avoidableMargin.copyFrozen();

  // copy._bundles should be rebuilt
  // copy._ports will be reconstructed upon demand
  // copy._treeParentNode should be rebuilt since it is a reference
};

/**
* @ignore
* Fix up references in the argument object so that the argument object can get a new visual tree
* @this {Node}
* @param {GraphObject} copy  The original Part whose category is being changed by displacing its visual tree with this Part's visual tree.
*/
Node.prototype.displaceProtected = function(copy) {
  Part.prototype.displaceProtected.call(this, copy);
  copy.invalidateConnectedLinks();
  copy._bundles = this._bundles;
  copy._ports = null;  // recalculate any ports for a Node
};


/**
* This value for {@link Link#fromEndSegmentDirection} and
* {@link Link#toEndSegmentDirection} indicates that the
* real value is inherited from the corresponding connected port.
* @name Node#DirectionDefault
* @constant
* @static
* @return {EnumValue}
*/
Node['DirectionDefault'] = Node.DirectionDefault = Util.defineEnumValue(Node, 'DirectionDefault', 0);

/**
* This value for {@link GraphObject#fromEndSegmentDirection} and
* {@link GraphObject#toEndSegmentDirection} indicates that the link's
* end segment angle stays the same even if the node is rotated.
* @name Node#DirectionAbsolute
* @constant
* @static
* @return {EnumValue}
*/
Node['DirectionAbsolute'] = Node.DirectionAbsolute = Util.defineEnumValue(Node, 'DirectionAbsolute', 1);

/**
* This value for {@link GraphObject#fromEndSegmentDirection} and
* {@link GraphObject#toEndSegmentDirection} indicates that the link's
* end segment angle is rotated to match the node's angle.
* @name Node#DirectionRotatedNode
* @constant
* @static
* @return {EnumValue}
*/
Node['DirectionRotatedNode'] = Node.DirectionRotatedNode = Util.defineEnumValue(Node, 'DirectionRotatedNode', 2);

/**
* This value for {@link GraphObject#fromEndSegmentDirection} and
* {@link GraphObject#toEndSegmentDirection} indicates that the link's
* end segment angle is rotated to match the node's angle,
* but only in increments of 90 degrees.
* @name Node#DirectionRotatedNodeOrthogonal
* @constant
* @static
* @return {EnumValue}
*/
Node['DirectionRotatedNodeOrthogonal'] = Node.DirectionRotatedNodeOrthogonal = Util.defineEnumValue(Node, 'DirectionRotatedNodeOrthogonal', 3);


/**
* @ignore
* @this {Node}
* @param {LinkBundle} bundle
*/
Node.prototype.addBundle = function(bundle) {
  if (bundle === null) return;
  if (this._bundles === null) {  // create collection if needed
    this._bundles = new Set(LinkBundle);
  }
  this._bundles.add(bundle);
};

/**
* @ignore
* @this {Node}
* @param {LinkBundle} bundle
*/
Node.prototype.removeBundle = function(bundle) {
  if (bundle === null) return;
  if (this._bundles !== null) {
    this._bundles.remove(bundle);
  }
};

/**
* @ignore
* @this {Node}
* @param {Node} other
* @param {?string} thisparam
* @param {?string} otherparam
* @return {LinkBundle}
*/
Node.prototype.findBundle = function(other, thisparam, otherparam) {
  if (other === null) return null;
  if (this._bundles === null) return null;
  var it = this._bundles.iterator;
  while (it.next()) {
    var b = it.value;
    if ((b.node1 === this && b.node2 === other && b.param1 === thisparam && b.param2 === otherparam) ||
        (b.node1 === other && b.node2 === this && b.param1 === otherparam && b.param2 === thisparam)) {
      return b;
    }
  }
  return null;
};


/**
* @ignore
* Call this method to notify that the some state has changed.
* This just calls the {@link #diagram}'s {@link Diagram#raiseChangedEvent} method.
* @this {Node}
* @param {EnumValue} change specifies the general nature of the change;
* permissible values include {@link ChangedEvent#Property}, {@link ChangedEvent#Insert},
* {@link ChangedEvent#Remove}, and {@link ChangedEvent#Transaction}.
* @param {string} propertyname names the property that was modified.
* @param {Object} obj the object that was modified, typically a {@link GraphObject}.
* @param {*} oldval the previous or older value.
* @param {*} newval the next or newer value.
* @param {*=} oldparam an optional value that helps describe the older value.
* @param {*=} newparam an optional value that helps describe the newer value.
*/
Node.prototype.raisePartChangedEvent = function(change, propertyname, obj, oldval, newval, oldparam, newparam) {
  if (change === ChangedEvent.Insert && propertyname === 'elements') {
    this._ports = null;  // invalidate ports map
  } else if (change === ChangedEvent.Remove && propertyname === 'elements') {
    var diagram = this.diagram;
    if (diagram === null) {
      this._ports = null;  // invalidate ports map
    } else if (oldval instanceof GraphObject) {
      this.walkVisualTree(oldval,
          function(node, x) {
            node.internalRemovePort(x, true);
          });
    }
  }
  Part.prototype.raisePartChangedEvent.call(this, change, propertyname, obj, oldval, newval, oldparam, newparam);
};

Node.prototype['invalidateConnectedLinks'] =
/**
* @ignore
* This invalidates all links connected to the node recursively
* @this {Node}
* @param {Set=} ignore
*/
Node.prototype.invalidateConnectedLinks = function(ignore) {
  if (ignore === undefined/*notpresent*/) ignore = null;
  var lit = this.linksConnected;
  while (lit.next()) {
    var link = lit.value;
    // maybe ignore this link?
    if (ignore !== null && ignore.contains(link)) continue;
    // remove any cached side connection info on either port of the link
    var from = link.fromPort;
    if (from !== null) from._portInfo = null;
    var to = link.toPort;
    if (to !== null && to !== from) to._portInfo = null;
    // and invalidate the route of that link
    link.invalidateRoute();
  }
};

/**
* @ignore
* A node is ready to be measured/arranged if is not a link label,
* or if it is a link label if its link has been arranged.
* @this {Node}
* @return {boolean}
*/
Node.prototype.isReadyToMeasureArrange = function() {
  // Always returns true, though with link labels they may not get a correct position until later
  return true;
};

/**
* Gets or sets whether this Node is to be avoided by {@link Link}s
* whose {@link Link#routing} is {@link Link#AvoidsNodes}.
* <p/>
* The initial value is true.
* @name Node#avoidable
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Node.prototype.avoidable;
Util.exportProperty(Node, 'avoidable', Node.prototype.avoidable);
Util.defineProperty(Node, { avoidable: 'avoidable'},
  /** @this {Node} */
  function() { return this._avoidable; },
  /** @this {Node} */
  function(val) {
    var old = this._avoidable;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', Node, 'avoidable');
      this._avoidable = val;
      var diagram = this.diagram;
      if (diagram !== null) diagram.invalidatePositionArray(this);
      this.raiseChanged('avoidable', old, val);
    }
  }
);

/**
* Gets or sets the margin around this Node in which avoidable links will not be routed.
* <p/>
* Value must be of type Margin.
* The default margin is Margin(2,2,2,2)
* @name Node#avoidableMargin
* @function.
* @return {Margin}
*/
/** @type {Margin} */
Node.prototype.avoidableMargin;
Util.exportProperty(Node, 'avoidableMargin', Node.prototype.avoidableMargin);
Util.defineProperty(Node, { avoidableMargin: 'avoidableMargin'},
  /** @this {Node} */
  function() { return this._avoidableMargin; },
  /** @this {Node} */
  function(val) {
    if (typeof val === 'number') {
      val = new Margin(val);
    } else {
      Util.checkClass(val, Margin, Node, 'avoidableMargin');
    }
    var old = this._avoidableMargin;
    if (!old.equals(val)) {
      val = val.copyFrozen();
      this._avoidableMargin = val;
      var diagram = this.diagram;
      if (diagram !== null) diagram.invalidatePositionArray(this);
      this.raiseChanged('avoidableMargin', old, val);
    }
  }
);

/**
* @ignore
* This predicate determines whether this node should be avoided in the routing
* of links whose {@link Link#routing} is {@link Link#AvoidsNodes}.
* This is not called for Nodes in temporary layers (which includes Tools and Adornments).
* @expose
* @this {Node}
* @return {boolean}
*/
Node.prototype.canAvoid = function() {
  return this.avoidable && !this.isLinkLabel;
};

Node.prototype['getAvoidableRectangle'] =
/**
* @ignore
* Return the area to be avoided for this node -- the node's {@link GraphObject#actualBounds}
* plus the {@link Node#avoidableMargin}.
* @expose
* @this {Node}
* @param {Rect} result  a {@link Rect} to be modified and returned.
* @return {Rect} the area in document coordinates.
*/
Node.prototype.getAvoidableRectangle = function(result) {
  result.set(this.actualBounds);
  result.addMargin(this.avoidableMargin);
  return result;
};

/**
* @ignore
* Starting with this node, walk up the chain of containingGroups to find a node that isVisible().
* @this {Node}
* @return {Node}
*/
Node.prototype.findVisibleNode = function() {
  var n = this;
  while (n !== null && !n.isVisible()) {
    n = n.containingGroup;
  }
  return n;
};


/**
* Gets an iterator over all of the {@link Link}s that are connected with this node.
* This includes both links that are coming out of this node as well as links that are going into this node.
* Setting {@link Link#fromNode} or {@link Link#toNode} to refer to this Node
* will add that {@link Link} to this collection.
* <p/>
* Use the {@link #findLinksConnected}, {@link #findLinksOutOf}, or {@link #findLinksInto} methods
* to get different subsets of the links, depending on direction or depending on connecting to a particular port.
* <p>
* A template should not have any links connected with it.
* @name Node#linksConnected
* @function.
* @return {Iterator}
*/
/** @type {Iterator} */
Node.prototype.linksConnected;
Util.defineReadOnlyProperty(Node, { linksConnected: 'linksConnected'},
  /** @this {Node} */
  function() { return this._linksConnected.iterator; }
);

Node.prototype['findLinksConnected'] =
/**
* Returns an iterator over all of the {@link Link}s that connect with this node in either direction,
* perhaps limited to the given port id on this node.
* @this {Node}
* @param {string|null=} pid A port identifier string; if null the link's portId is ignored and all links are included in the search.
* @return {Iterator}
*/
Node.prototype.findLinksConnected = function(pid) {
  if (pid === undefined/*notpresent*/) pid = null;
  if (pid === null) return this._linksConnected.iterator;
  // if PID is a string, see if it matches what the link specifies
  if (Debug) Util.checkPrimitive(pid, 'string', Node, 'findLinksConnected:pid');
  var it = new ListIterator(this._linksConnected);
  var node = this;
  /** @ignore */
  it.predicate = function(l) {
    return (l.fromNode === node && l.fromPortId === pid) ||
           (l.toNode === node && l.toPortId === pid);
  };
  return it;
};

Node.prototype['findLinksOutOf'] =
/**
* Returns an iterator over all of the {@link Link}s that come out of this node,
* perhaps limited to the given port id on this node.
* @this {Node}
* @param {string|null=} pid A port identifier string; if null the link's portId is ignored and all links are included in the search.
* @return {Iterator}
*/
Node.prototype.findLinksOutOf = function(pid) {
  if (pid === undefined/*notpresent*/) pid = null;
  if (Debug && pid !== null) Util.checkPrimitive(pid, 'string', Node, 'findLinksOutOf:pid');
  var it = new ListIterator(this._linksConnected);
  var node = this;
  /** @ignore */
  it.predicate = function(l) {
    if (l.fromNode !== node) return false;
    if (pid === null) return true;
    return l.fromPortId === pid;
  };
  return it;
};

Node.prototype['findLinksInto'] =
/**
* Returns an iterator over all of the {@link Link}s that go into this node,
* perhaps limited to the given port id on this node.
* @this {Node}
* @param {string|null=} pid A port identifier string; if null the link's portId is ignored and all links are included in the search.
* @return {Iterator}
*/
Node.prototype.findLinksInto = function(pid) {
  if (pid === undefined/*notpresent*/) pid = null;
  if (Debug && pid !== null) Util.checkPrimitive(pid, 'string', Node, 'findLinksInto:pid');
  var it = new ListIterator(this._linksConnected);
  var node = this;
  /** @ignore */
  it.predicate = function(l) {
    if (l.toNode !== node) return false;
    if (pid === null) return true;
    return l.toPortId === pid;
  };
  return it;
};

Node.prototype['findNodesConnected'] =
/**
* Returns an iterator over the {@link Node}s that are connected with this node
* in either direction, perhaps limited to the given port id on this node.
* @this {Node}
* @param {string|null=} pid A port identifier string; if null the link's portId is ignored and all links are included in the search.
* @return {Iterator}
*/
Node.prototype.findNodesConnected = function(pid) {
  if (pid === undefined/*notpresent*/) pid = null;
  if (Debug && pid !== null) Util.checkPrimitive(pid, 'string', Node, 'findNodesConnected:pid');
  var nodes = null;
  var firstnode = null;
  var it = this._linksConnected.iterator;
  while (it.next()) {
    var link = it.value;
    if (link.fromNode === this) {
      if (pid === null || link.fromPortId === pid) {
        // found a Node
        var to = link.toNode;
        if (nodes !== null) {  // found at least two before
          nodes.add(to);  // now more than two
        } else if (firstnode !== null && firstnode !== to) {  // found just one before
          nodes = new Set(Node);  // found second one
          nodes.add(firstnode);
          nodes.add(to);
        } else {  // first one found
          firstnode = to;  // just one found
        }
      }
    } else if (link.toNode === this) {  // avoid case where toNode === null
      if (pid === null || link.toPortId === pid) {
        // found a Node
        var from = link.fromNode;
        if (nodes !== null) {  // found at least two before
          nodes.add(from);  // now more than two
        } else if (firstnode !== null && firstnode !== from) {  // found just one before
          nodes = new Set(Node);  // found second one
          nodes.add(firstnode);
          nodes.add(from);
        } else {  // first one found
          firstnode = from;  // just one found
        }
      }
    }
  }
  if (nodes !== null) return nodes.iterator;
  if (firstnode !== null) return new SingletonIterator(firstnode);
  return Util.EmptyIterator;
};

Node.prototype['findNodesOutOf'] =
/**
* Returns an iterator over the {@link Node}s that are connected with this node
* by links coming out of this node, perhaps limited to the given port id on this node.
* @this {Node}
* @param {string|null=} pid A port identifier string; if null the link's portId is ignored and all links are included in the search.
* @return {Iterator}
*/
Node.prototype.findNodesOutOf = function(pid) {
  if (pid === undefined/*notpresent*/) pid = null;
  if (Debug && pid !== null) Util.checkPrimitive(pid, 'string', Node, 'findNodesOutOf:pid');
  var nodes = null;
  var firstnode = null;
  var it = this._linksConnected.iterator;
  while (it.next()) {
    var link = it.value;
    if (link.fromNode === this) {
      if (pid === null || link.fromPortId === pid) {
        // found a Node
        var to = link.toNode;
        if (nodes !== null) {  // found at least two before
          nodes.add(to);  // now more than two
        } else if (firstnode !== null && firstnode !== to) {  // found just one before
          nodes = new Set(Node);  // found second one
          nodes.add(firstnode);
          nodes.add(to);
        } else {  // first one found
          firstnode = to;  // just one found
        }
      }
    }
  }
  if (nodes !== null) return nodes.iterator;
  if (firstnode !== null) return new SingletonIterator(firstnode);
  return Util.EmptyIterator;
};

Node.prototype['findNodesInto'] =
/**
* Returns an iterator over the {@link Node}s that are connected with this node
* by links going into this node, perhaps limited to the given port id on this node.
* @this {Node}
* @param {string|null=} pid A port identifier string; if null the link's portId is ignored and all links are included in the search.
* @return {Iterator}
*/
Node.prototype.findNodesInto = function(pid) {
  if (pid === undefined/*notpresent*/) pid = null;
  if (Debug && pid !== null) Util.checkPrimitive(pid, 'string', Node, 'findNodesInto:pid');
  var nodes = null;
  var firstnode = null;
  var it = this._linksConnected.iterator;
  while (it.next()) {
    var link = it.value;
    if (link.toNode === this) {
      if (pid === null || link.toPortId === pid) {
        // found a Node
        var from = link.fromNode;
        if (nodes !== null) {  // found at least two before
          nodes.add(from);  // now more than two
        } else if (firstnode !== null && firstnode !== from) {  // found just one before
          nodes = new Set(Node);  // found second one
          nodes.add(firstnode);
          nodes.add(from);
        } else {  // first one found
          firstnode = from;  // just one found
        }
      }
    }
  }
  if (nodes !== null) return nodes.iterator;
  if (firstnode !== null) return new SingletonIterator(firstnode);
  return Util.EmptyIterator;
};

Node.prototype['findLinksBetween'] =
/**
* Returns an iterator over all of the {@link Link}s that go from this node to another node or vice-versa,
* perhaps limited to a given port id on this node and a port id on the other node.
* <p/>
* If you want all of the links between two nodes in just one direction, use {@link #findLinksTo}.
* @this {Node}
* @param {Node} othernode
* @param {string|null=} pid A port identifier string; if null the link's portId is ignored and all links are included in the search.
* @param {string|null=} otherpid A port identifier string; if null the link's portId is ignored and all links are included in the search.
* @return {Iterator}
* @since 1.2
*/
Node.prototype.findLinksBetween = function(othernode, pid, otherpid) {
  if (pid === undefined/*notpresent*/) pid = null;
  if (otherpid === undefined/*notpresent*/) otherpid = null;
  if (Debug) {
    Util.checkClass(othernode, Node, Node, 'findLinksBetween:othernode');
    if (pid !== null) Util.checkPrimitive(pid, 'string', Node, 'findLinksBetween:pid');
    if (otherpid !== null) Util.checkPrimitive(otherpid, 'string', Node, 'findLinksBetween:otherpid');
  }
  var it = new ListIterator(this._linksConnected);
  var node = this;
  /** @ignore */
  it.predicate = function(l) {
    if (l.fromNode === node && l.toNode === othernode && (pid === null || l.fromPortId === pid) && (otherpid === null || l.toPortId === otherpid)) return true;
    if (l.fromNode === othernode && l.toNode === node && (otherpid === null || l.fromPortId === otherpid) && (pid === null || l.toPortId === pid)) return true;
    return false;
  };
  return it;
};

Node.prototype['findLinksTo'] =
/**
* Returns an iterator over all of the {@link Link}s that go from this node to another node,
* perhaps limited to a given port id on this node and a port id on the other node.
* <p/>
* If you want all of the links between two nodes in both directions, use {@link #findLinksBetween}.
* @this {Node}
* @param {Node} othernode
* @param {string|null=} pid A port identifier string; if null the link's portId is ignored and all links are included in the search.
* @param {string|null=} otherpid A port identifier string; if null the link's portId is ignored and all links are included in the search.
* @return {Iterator}
* @since 1.2
*/
Node.prototype.findLinksTo = function(othernode, pid, otherpid) {
  if (pid === undefined/*notpresent*/) pid = null;
  if (otherpid === undefined/*notpresent*/) otherpid = null;
  if (Debug) {
    Util.checkClass(othernode, Node, Node, 'findLinksTo:othernode');
    if (pid !== null) Util.checkPrimitive(pid, 'string', Node, 'findLinksTo:pid');
    if (otherpid !== null) Util.checkPrimitive(otherpid, 'string', Node, 'findLinksTo:otherpid');
  }
  var it = new ListIterator(this._linksConnected);
  var node = this;
  /** @ignore */
  it.predicate = function(l) {
    if (l.fromNode !== node) return false;
    if (l.toNode !== othernode) return false;
    if (pid !== null && l.fromPortId !== pid) return false;
    if (otherpid !== null && l.toPortId === otherpid) return false;
    return true;
  };
  return it;
};


/**
* Gets or sets the function that is called after a {@link Link} has been connected with this Node.
* It is typically used to modify the appearance of the node.
* The first argument will be this Node.
* The second argument will be a Link that is now connected with this node.
* The third argument will be a GraphObject port indicating which port the link was connected with.
* <p/>
* If the value is a function, that function must not modify what this Node is connected with.
* The Link has already been added -- trying to remove it or another link may produce undefined behavior.
* However, the other end of the link may not yet have been connected with a node (and might never be),
* so you cannot depend on looking at what the link connects with.
* <p/>
* The default value is null -- no function is called.
* @name Node#linkConnected
* @function.
* @return {function(Node, Link, GraphObject) | null}
*/
/** @type {function(Node, Link, GraphObject) | null} */
Node.prototype.linkConnected;
Util.exportProperty(Node, 'linkConnected', Node.prototype.linkConnected);
Util.defineProperty(Node, { linkConnected: 'linkConnected' },
  /** @this {Node} */
  function() { return this._linkConnected; },
  /** @this {Node} */
  function(val) {
    var old = this._linkConnected;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', Node, 'linkConnected');
      this._linkConnected = val;
      this.raiseChanged('linkConnected', old, val);
    }
  }
);

/**
* Gets or sets the function that is called after a {@link Link} has been disconnected from this Node.
* It is typically used to modify the appearance of the node.
* The first argument will be this Node.
* The second argument will be a Link that had been connected with this node.
* The third argument will be a GraphObject port indicating which port the link had been connected with.
* <p/>
* If the value is a function, that function must not modify what this Node is connected with.
* The Link has already been removed -- trying to add it or another link may produce undefined behavior.
* The other end of the link may not yet have been disconnected from a node (and might never be),
* so you cannot depend on looking at what the link connects with.
* <p/>
* The default value is null -- no function is called.
* @name Node#linkDisconnected
* @function.
* @return {function(Node, Link, GraphObject) | null}
*/
/** @type {function(Node, Link, GraphObject) | null} */
Node.prototype.linkDisconnected;
Util.exportProperty(Node, 'linkDisconnected', Node.prototype.linkDisconnected);
Util.defineProperty(Node, { linkDisconnected: 'linkDisconnected' },
  /** @this {Node} */
  function() { return this._linkDisconnected; },
  /** @this {Node} */
  function(val) {
    var old = this._linkDisconnected;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', Node, 'linkDisconnected');
      this._linkDisconnected = val;
      this.raiseChanged('linkDisconnected', old, val);
    }
  }
);

/**
* @ignore
* @this {Node}
* @param {Link} link
* @param {GraphObject} port
*/
Node.prototype.addLinkInternal = function(link, port) {
  if (!this._linksConnected.contains(link)) {
    this._linksConnected.add(link);
    var func = this.linkConnected;
    if (func !== null) {
      var oldUpdatingModel = true;
      var diagram = this.diagram;
      if (diagram !== null) {
        oldUpdatingModel = diagram.isUpdatingModel;
        diagram.isUpdatingModel = true;
      }
      func(this, link, port);
      if (diagram !== null) {
        diagram.isUpdatingModel = oldUpdatingModel;
      }
    }
    if (!link.isTreeLink) return;  // non-tree-link cannot affect isTreeLeaf or treeParentNode
    var from = link.fromNode;
    var to = link.toNode;
    if (from !== null && to !== null && from !== to) {
      var treepathtochildren = true;
      var diagram = this.diagram;
      if (diagram !== null) treepathtochildren = diagram.isTreePathToChildren;
      var child = treepathtochildren ? to : from;
      var parent = treepathtochildren ? from : to;

      // update treeParentNode
      // if didn't know tree parent before or if there was no parent, set it;
      // otherwise don't change existing cached parent, in case of multiple "parent" links
      if (!child._treeParentNode) child._treeParentNode = parent;

      // update isTreeLeaf
      if (parent.isTreeLeaf) {
        if (diagram !== null && diagram.undoManager.isUndoingRedoing) return;
        if (treepathtochildren) {
          if (from === parent) parent.isTreeLeaf = false;
        } else {
          if (to === parent) parent.isTreeLeaf = false;
        }
      } else {
        // adding a link cannot change a non-leaf into a leaf
      }
    }
  }
};

/**
* @ignore
* @this {Node}
* @param {Link} link
* @param {GraphObject} port
*/
Node.prototype.removeLinkInternal = function(link, port) {
  if (this._linksConnected.remove(link)) {
    var func = this.linkDisconnected;
    var diagram = this.diagram;
    if (func !== null) {
      var oldUpdatingModel = true;
      if (diagram !== null) {
        oldUpdatingModel = diagram.isUpdatingModel;
        diagram.isUpdatingModel = true;
      }
      func(this, link, port);
      if (diagram !== null) {
        diagram.isUpdatingModel = oldUpdatingModel;
      }
    }
    if (!link.isTreeLink) return;  // non-tree-link cannot affect isTreeLeaf or treeParentNode
    var treepathtochildren = true;
    if (diagram !== null) treepathtochildren = diagram.isTreePathToChildren;
    var child = treepathtochildren ? link.toNode : link.fromNode;
    var parent = treepathtochildren ? link.fromNode : link.toNode;

    // update treeParentNode
    if (child !== null) child._treeParentNode = false;

    // update isTreeLeaf
    if (parent !== null && !parent.isTreeLeaf) {
      var numlinks = parent._linksConnected.count;
      if (numlinks === 0) {
        parent._treeParentNode = null;  // definitely no parent
        if (diagram !== null && diagram.undoManager.isUndoingRedoing) return;
        parent.isTreeLeaf = true;  // definitely no children
      } else {
        parent.updateTreeLeaf();
      }
    } else {
      // removing a link cannot change it from a leaf to a non-leaf
    }
  }
};

/**
* @ignore
* @this {Node}
*/
Node.prototype.updateTreeLeaf = function() {
  this._treeParentNode = false;  // clear cache
  if (this._linksConnected.count === 0) return;
  var treepathtochildren = true;
  var diagram = this.diagram;
  if (diagram !== null && diagram.undoManager.isUndoingRedoing) return;
  if (diagram !== null) treepathtochildren = diagram.isTreePathToChildren;
  var lit = this._linksConnected.iterator;
  while (lit.next()) {
    var l = lit.value;
    if (!l.isTreeLink) continue;
    if (treepathtochildren) {
      if (l.fromNode === this) {
        this.isTreeLeaf = false;
        return;
      }
    } else {
      if (l.toNode === this) {
        this.isTreeLeaf = false;
        return;
      }
    }
  }
  this.isTreeLeaf = true;
};


/**
* @ignore
* @this {Node}
*/
Node.prototype.internalAddProtected = function() {
  Part.prototype.internalAddProtected.call(this);

  this.updateTreeLeaf();

  var old = this._labeledLink;
  if (old !== null) old.addLabelNodeInternal(this);
};

/**
* @ignore
* @this {Node}
*/
Node.prototype.internalRemoveProtected = function() {
  Part.prototype.internalRemoveProtected.call(this);

  // do the following instead of: this.labeledLink = null;
  var old = this._labeledLink;
  if (old !== null) old.removeLabelNodeInternal(this);
};

/**
* @ignore
* @this {Node}
*/
Node.prototype.deleteCascade = function() {
  // delete connected links
  if (this._linksConnected.count > 0) {
    var diagram = this.diagram;
    if (diagram === null) return;
    var links = this._linksConnected.copy();
    var lit = links.iterator;
    while (lit.next()) {
      var link = lit.value;
      diagram.remove(link);
    }
  }

  // delete from any link for which this might be a label node
  this.labeledLink = null;

  Part.prototype.deleteCascade.call(this);
};


/**
* Gets whether a Node is a label node for a Link.
* @name Node#isLinkLabel
* @function.
* @return {boolean}
* @see #labeledLink
*/
/** @type {boolean} */
Node.prototype.isLinkLabel;
Util.defineReadOnlyProperty(Node, { isLinkLabel: 'isLinkLabel'},
  /** @this {Node} */
  function() { return this._labeledLink !== null; }
);

/**
* Gets or sets the {@link Link} for which this Node is acting as a smart label.
* Most nodes do not act as link labels.
* <p>
* A template should not be a label node for a link.
* @name Node#labeledLink
* @function.
* @return {Link}
* @see #isLinkLabel
*/
/** @type {Link} */
Node.prototype.labeledLink;
Util.exportProperty(Node, 'labeledLink', Node.prototype.labeledLink);
Util.defineProperty(Node, { labeledLink: 'labeledLink' },
  /** @this {Node} */
  function() { return this._labeledLink; },
  /** @this {Node} */
  function(val) {
    var old = this._labeledLink;
    if (old !== val) {
      if (Debug && val !== null) Util.checkClass(val, Link, Node, 'labeledLink');
      var diagram = this.diagram;
      var ndata = this.data;
      if (old !== null) {
        old.removeLabelNodeInternal(this);
        // no-op if isUndoingRedoing
        if (diagram !== null && ndata !== null && !diagram.undoManager.isUndoingRedoing) {
          var ldata = old.data;
          var model = diagram.model;
          if (ldata !== null && model instanceof GraphLinksModel) {
            var key = model.getKeyForNodeData(ndata);
            if (key !== undefined) model.removeLabelKeyForLinkData(ldata, key);
          }
        }
      }
      this._labeledLink = val;
      if (val !== null) {
        val.addLabelNodeInternal(this);
        // no-op if isUndoingRedoing
        if (diagram !== null && ndata !== null && !diagram.undoManager.isUndoingRedoing) {
          var ldata = val.data;
          var model = diagram.model;
          if (ldata !== null && model instanceof GraphLinksModel) {
            var key = model.getKeyForNodeData(ndata);
            if (key !== undefined) model.addLabelKeyForLinkData(ldata, key);
          }
        }
      }
      this.invalidateArrange();
      this.raiseChanged('labeledLink', old, val);
    }
  }
);


Node.prototype['findPort'] =
/**
* Find a {@link GraphObject} with a given {@link GraphObject#portId}.
* If no such GraphObject is found, search for one with the empty string as its port identifier.
* Finally, when failing to find a port with either the given name or the empty string,
* this method returns this whole node itself.
* @this {Node}
* @param {string} pid
* @return {GraphObject}
*/
Node.prototype.findPort = function(pid) {
  if (Debug) Util.checkPrimitive(pid, 'string', Node, 'findPort:pid');
  if (this._ports === null) {
    // if the ID is the default and there are no named ports, just return this Node
    if (pid === '' && this._hasNamedPorts === false) {
      return this;
    }
    // otherwise continue on as normal
    this._rebuildPorts();
  }
  if (this._ports !== null) {
    var p = this._ports.getValue(pid);
    if (p !== null) return p;
  }
  // if it wasn't already the empty string, look for one with the empty string
  if (pid !== '') {
    if (this._ports !== null) {
      var p = this._ports.getValue('');
      if (p !== null) return p;
    }
  }
  // Otherwise consider the whole node as the default port.
  // Make sure ._ports isn't null, to avoid repeated calls to _rebuildPorts
  if (this._ports === null) this._rebuildPorts();
  return this;
};

/**
* Get the primary {@link GraphObject} representing a port in this node.
* If there is a GraphObject whose {@link GraphObject#portId} is the empty string, return it.
* If there is no such element, just return this whole Node.
* @name Node#port
* @function.
* @return {GraphObject}
*/
/** @type {GraphObject} */
Node.prototype.port;
Util.defineReadOnlyProperty(Node, { port: 'port'},
  /** @this {Node} */
  function() { return this.findPort(''); }
);

/**
* Gets an iterator over all of the {@link GraphObject}s in this node that act as ports.
* @name Node#ports
* @function.
* @return {Iterator}
*/
/** @type {Iterator} */
Node.prototype.ports;
Util.defineReadOnlyProperty(Node, { ports: 'ports'},
  /** @this {Node} */
  function() {
    if (this._ports === null) this._rebuildPorts();
    if (this._ports !== null) return this._ports.iterator;
    return Util.EmptyIterator;
  }
);

/**
* @ignore
* @this {Node}
*/
Node.prototype._rebuildPorts = function() {
  // if there's already a Map, clear it
  if (this._ports !== null) this._ports.clear();
  // if there wasn't already a Map, only create it if we find some GraphObject with non-null portId
  this.walkVisualTree(this, function(n, o) { n.internalAddPort(o); });
};

/**
* @ignore
* @this {Node}
* @param {GraphObject} obj
*/
Node.prototype.internalAddPort = function(obj) {
  var pid = obj.portId;
  if (pid !== null) {
    if (this._ports === null) this._ports = new Map('string', GraphObject);
    this._ports.add(pid, obj);
  }
};

/**
* @ignore
* @this {Node}
* @param {GraphObject} obj
* @param {boolean=} removelinks
*/
Node.prototype.internalRemovePort = function(obj, removelinks) {
  var pid = obj.portId;
  if (pid !== null) {
    if (this._ports !== null) {
      this._ports.remove(pid);
    }
    var diagram = this.diagram;
    if (diagram !== null && removelinks) {
      var links = null;
      var lit = this.findLinksConnected(pid);
      while (lit.next()) {
        if (links === null) links = Util.tempArray();
        links.push(lit.value);
      }
      if (links !== null) {
        for (var i = 0; i < links.length; i++) {
          var link = links[i];
          diagram.remove(link);
        }
        Util.freeArray(links);
      }
    }
  }
};

Node.prototype['isInTreeOf'] =
/**
* This predicate is true if this node is a child of the given {@link Node}, perhaps indirectly as a descendant.
* <p/>
* If this node is a child of the given node according to {@link Diagram#isTreePathToChildren}, this returns true.
* Otherwise this searches recursively the chain of tree parents of this node,
* ignoring links for which {@link Link#isTreeLink} is false.
* A node cannot be in its own subtree.
* @this {Node}
* @param {Node} node the Node that might be a parent or ancestor of this node.
* @return {boolean}  true if the given node is an ancestor of this node, but false otherwise, including false if it is the same node.
* @see #findTreeRoot
*/
Node.prototype.isInTreeOf = function(node) {
  if (node === null || node === this) return false;
  var tochildren = true;
  var diagram = this.diagram;
  if (diagram !== null) tochildren = diagram.isTreePathToChildren;
  var child = this;
  var ancestor = node;
  if (tochildren) {
    while (child !== ancestor) {
      var parent = null;
      var it = child._linksConnected.iterator;
      while (it.next()) {
        var link = it.value;
        if (!link.isTreeLink) continue;
        parent = link.fromNode;
        if (parent !== child && parent !== this) break;  // if reflexive link or cycle, keep going
      }
      if (parent === this) return false;  // break the cycle
      if (parent === null || parent === child) return false;  // no parent? must not be in subtree
      child = parent;  // go up the chain of parents
    }
  } else {
    while (child !== ancestor) {
      var parent = null;
      var it = child._linksConnected.iterator;
      while (it.next()) {
        var link = it.value;
        if (!link.isTreeLink) continue;
        parent = link.toNode;
        if (parent !== child && parent !== this) break;  // if reflexive link or cycle, keep going
      }
      if (parent === this) return false;  // break the cycle
      if (parent === null || parent === child) return false;  // no parent? must not be in subtree
      child = parent;  // go up the chain of parents
    }
  }
  return true;
};

Node.prototype['findTreeRoot'] =
/**
* Return the {@link Node} that is at the root of the tree that this node is in, perhaps this node itself.
* <p/>
* This node will be {@link #isInTreeOf} the resulting node, unless the resulting node is this node itself.
* The graph traversal will ignore links for which {@link Link#isTreeLink} is false.
* @this {Node}
* @return {Node} If this Node has no "tree parent", this returns itself.
* @see Diagram#isTreePathToChildren
* @since 1.2
*/
Node.prototype.findTreeRoot = function() {
  var tochildren = true;
  var diagram = this.diagram;
  if (diagram !== null) tochildren = diagram.isTreePathToChildren;
  var root = this;  // root might be itself if it has no parent
  if (tochildren) {
    while (true) {
      var parent = null;
      var it = root._linksConnected.iterator;
      while (it.next()) {
        var link = it.value;
        if (!link.isTreeLink) continue;
        parent = link.fromNode;
        if (parent !== root && parent !== this) break;  // but if reflexive link or cycle, keep going
      }
      if (parent === this) return this;  // break the cycle
      if (parent === null || parent === root) return root;  // no parent? got the root!
      root = parent;  // go up the chain of parents
    }
  } else {
    while (true) {
      var parent = null;
      var it = root._linksConnected.iterator;
      while (it.next()) {
        var link = it.value;
        if (!link.isTreeLink) continue;
        parent = link.toNode;
        if (parent !== root && parent !== this) break;  // but if reflexive link or cycle, keep going
      }
      if (parent === this) return this;  // break the cycle
      if (parent === null || parent === root) return root;  // no parent? got the root!
      root = parent;  // go up the chain of parents
    }
  }
};

Node.prototype['findTreeParentLink'] =
/**
* Returns the {@link Link} that connects with the tree parent {@link Node} of this node if the graph is tree-structured,
* if there is such a link and {@link Link#isTreeLink} is true.
* @this {Node}
* @return {Link} The Link to the parent Node, or null if there is no parent node.
* @see #findTreeParentNode
* @see #findTreeChildrenLinks
* @see Diagram#isTreePathToChildren
* @since 1.1
*/
Node.prototype.findTreeParentLink = function() {
  var tochildren = true;
  var diagram = this.diagram;
  if (diagram !== null) tochildren = diagram.isTreePathToChildren;
  var it = this._linksConnected.iterator;
  if (tochildren) {
    while (it.next()) {
      var link = it.value;
      if (!link.isTreeLink) continue;
      if (link.fromNode !== this) return link;
    }
  } else {
    while (it.next()) {
      var link = it.value;
      if (!link.isTreeLink) continue;
      if (link.toNode !== this) return link;
    }
  }
  return null;
};

Node.prototype['findTreeParentNode'] =
/**
* Returns the {@link Node} that is the tree parent of this node if the graph is tree-structured, if there is a parent.
* Links for which {@link Link#isTreeLink} is false are ignored.
* @this {Node}
* @return {Node} The parent Node, or null if there is no parent node.
* @see #findTreeParentLink
* @see #findTreeChildrenNodes
* @see Diagram#isTreePathToChildren
* @since 1.1
*/
Node.prototype.findTreeParentNode = function() {
  // second half of if is just to clear compiler issue with boolean part of Node|boolean|null
  if (this._treeParentNode === null || this._treeParentNode instanceof Node) return this._treeParentNode;
  var tochildren = true;
  var diagram = this.diagram;
  if (diagram !== null) tochildren = diagram.isTreePathToChildren;
  var links = this._linksConnected._arr;
  var l = links.length;
  if (tochildren) {
    for (var i = 0; i < l; i++) {
      var link = links[i];
      if (!link.isTreeLink) continue;
      var node = link.fromNode;
      if (node !== this) { this._treeParentNode = node; return node; }
    }
  } else {
    for (var i = 0; i < l; i++) {
      var link = links[i];
      if (!link.isTreeLink) continue;
      var node = link.toNode;
      if (node !== this) { this._treeParentNode = node; return node; }
    }
  }
  { this._treeParentNode = null; return null; }
};

Node.prototype['findTreeChildrenLinks'] =
/**
* Returns an {@link Iterator} for the collection of {@link Link}s that connect with the immediate tree children of this node.
* Links for which {@link Link#isTreeLink} is false are ignored.
* <p/>
* This basically returns either {@link #findLinksOutOf} or {@link #findLinksInto},
* depending on {@link Diagram#isTreePathToChildren},
* but the results excludes links for which {@link Link#isTreeLink} is false.
* @see #findTreeParentLink
* @see #findTreeChildrenNodes
* @this {Node}
* @return {Iterator}
* @since 1.1
*/
Node.prototype.findTreeChildrenLinks = function() {
  var tochildren = true;
  var diagram = this.diagram;
  if (diagram !== null) tochildren = diagram.isTreePathToChildren;
  if (tochildren) {
    var it = new ListIterator(this._linksConnected);
    var node = this;
    /** @ignore */
    it.predicate = function(l) {
      if (!l.isTreeLink) return false;
      if (l.fromNode !== node) return false;
      return true;
    };
    return it;
  } else {
    var it = new ListIterator(this._linksConnected);
    var node = this;
    /** @ignore */
    it.predicate = function(l) {
      if (!l.isTreeLink) return false;
      if (l.toNode !== node) return false;
      return true;
    };
    return it;
  }
};

Node.prototype['findTreeChildrenNodes'] =
/**
* Returns an {@link Iterator} for the collection of {@link Node}s that are the immediate tree children of this node.
* Nodes only connected by links for which {@link Link#isTreeLink} is false are ignored.
* <p/>
* This basically returns either {@link #findNodesOutOf} or {@link #findNodesInto},
* depending on {@link Diagram#isTreePathToChildren}.
* @this {Node}
* @return {Iterator}
* @see #findTreeParentNode
* @see #findTreeChildrenLinks
* @since 1.1
*/
Node.prototype.findTreeChildrenNodes = function() {
  var tochildren = true;
  var diagram = this.diagram;
  if (diagram !== null) tochildren = diagram.isTreePathToChildren;
  var nodes = null;
  var firstnode = null;
  var it = this._linksConnected.iterator;
  if (tochildren) {
    while (it.next()) {
      var link = it.value;
      if (!link.isTreeLink) continue;
      if (link.fromNode === this) {
        // found a Node
        var to = link.toNode;
        if (nodes !== null) {  // found at least two before
          nodes.add(to);  // now more than two
        } else if (firstnode !== null && firstnode !== to) {  // found just one before
          nodes = new List(Node);  // found second one
          nodes.add(firstnode);
          nodes.add(to);
        } else {  // first one found
          firstnode = to;  // just one found
        }
      }
    }
  } else {
    while (it.next()) {
      var link = it.value;
      if (!link.isTreeLink) continue;
      if (link.toNode === this) {
        // found a Node
        var from = link.fromNode;
        if (nodes !== null) {  // found at least two before
          nodes.add(from);  // now more than two
        } else if (firstnode !== null && firstnode !== from) {  // found just one before
          nodes = new List(Node);  // found second one
          nodes.add(firstnode);
          nodes.add(from);
        } else {  // first one found
          firstnode = from;  // just one found
        }
      }
    }
  }
  if (nodes !== null) return nodes.iterator;
  if (firstnode !== null) return new SingletonIterator(firstnode);
  return Util.EmptyIterator;
};

Node.prototype['findTreeParts'] =
/**
* Return a collection of {@link Part}s including this {@link Node},
* all of the {@link Link}s going to child {@link Node}s, and all of their
* tree child nodes and links.
* Links for which {@link Link#isTreeLink} is false are ignored.
* <p/>
* Whether child nodes are found for a parent node by following links out of the parent node or
* by links coming into the parent node is determined by the value of {@link Diagram#isTreePathToChildren}.
* <p/>
* The result will include this, the "root" node.
* If any of the nodes are {@link Group}s, their member parts are not included.
* @this {Node}
* @param {number=} level How many levels of the tree, starting at this node, to include;
*    the default is Infinity, including all tree children of this node.  Values less than 1 are treated as 1.
* @return {Set} A Set of Nodes and Links.
*/
Node.prototype.findTreeParts = function(level) {
  if (level === undefined/*notpresent*/) level = Infinity;
  Util.checkPrimitive(level, 'number', Node, 'collapseTree:level');
  var coll = new Set(Part);
  CommandHandler.gatherCollection(coll, this, false, level);
  return coll;
};

Node.prototype['collapseTree'] =
/**
* Hide each child node and the connecting link,
* and recursively collapse each child node.
* This changes the value of {@link Part#isVisible} of the whole subtree and the parts owned by
* those nodes and links.
* However, this root node's visibility is unchanged.
* <p/>
* Links are assumed to go from the parent node to the children nodes,
* unless {@link Diagram#isTreePathToChildren} is false.
* Links for which {@link Link#isTreeLink} is false are ignored.
* <p/>
* This sets {@link #isTreeExpanded} to false on this node and on all of the children nodes.
* For those child nodes that were expanded when they were collapsed,
* {@link #wasTreeExpanded} is set to true.
* <p/>
* You can also pass in a number of levels to hide nodes beyond a certain level starting at this node.
* If you want to make sure that all nodes are expanded up to a particular level, call {@link #expandTree}.
* If you want to do both, call <code>expandTree</code> before calling <code>collapseTree</code> to
* collapse nodes expanded due to the {@link #wasTreeExpanded} flag.
* <p/>
* This method does not perform a transaction.
* You may want to call the {@link CommandHandler#collapseTree} command, which does perform a transaction
* and raise a {@link DiagramEvent}.
* @this {Node}
* @param {number=} level How many levels of the tree, starting at this node, to keep expanded if already expanded;
*    the default is 1, hiding all tree children of this node.  Values less than 1 are treated as 1.
* @see #expandTree
* @see #findTreeParts
*/
Node.prototype.collapseTree = function(level) {
  if (level === undefined/*notpresent*/) level = 1;
  Util.checkRealNumber(level, Node, 'collapseTree:level');
  if (level < 1) level = 1;
  var diagram = this.diagram;
  if (diagram === null) return;
  if (diagram.isCollapsingExpanding) return;
  diagram.isCollapsingExpanding = true;
  var tochildren = diagram.isTreePathToChildren;
  var coll = new Set(Node);
  coll.add(this);
  this._collapseTree2(coll, tochildren, level, this.isTreeExpanded);
  diagram.isCollapsingExpanding = false;

  // ?? not optimal, but invalidating draw on the specific nodes won't work
  //    since isVisible() is false, so they do not notify the diagram
  diagram.invalidateDraw();
};

/**
* @ignore
* Recurse through the requested levels to be collapsed, to actually collapse only at that level, not before.
* It's OK for nodes to remain collapsed at levels lower than requested.
* @this {Node}
* @param {Set} coll
* @param {boolean} tochildren
* @param {number} level
*/
Node.prototype._collapseTree2 = function(coll, tochildren, level, wasExpanded) {
  if (level > 1) {
    var cit = (tochildren ? this.findLinksOutOf() : this.findLinksInto());
    while (cit.next()) {
      var link = cit.value;
      if (!link.isTreeLink) continue;
      var child = link.getOtherNode(this);
      if (child !== null && child !== this && !coll.contains(child)) {
        coll.add(child);
        child._collapseTree2(coll, tochildren, level-1, child.isTreeExpanded);
      }
    }
  } else {
    this._collapseTree1(coll, tochildren, wasExpanded);
  }
};

/**
* @ignore
* This needs to handle non-tree-structured graphs.
* @this {Node}
* @param {Set} coll
* @param {boolean} tochildren
* @param {boolean} wasExpanded
*/
Node.prototype._collapseTree1 = function(coll, tochildren, wasExpanded) {
  this.isTreeExpanded = false;
  var cit = (tochildren ? this.findLinksOutOf() : this.findLinksInto());
  while (cit.next()) {
    var link = cit.value;
    if (wasExpanded) {
      link.clearAdornments();
    }
    if (!link.isTreeLink) continue;
    var child = link.getOtherNode(this);
    if (child !== null && child !== this && !coll.contains(child)) {
      coll.add(child);
      if (wasExpanded) {
        child.invalidateDraw();
      child.clearAdornments();
      child.invalidateContainingGroup();
      child.invalidateLayout(Part.LayoutHidden);  // no-op if isUndoingRedoing
      }
      if (child.isTreeExpanded) {
        child.wasTreeExpanded = child.isTreeExpanded;
        child._collapseTree1(coll, tochildren, child.wasTreeExpanded);
      }
    }
  }
};

Node.prototype['expandTree'] =
/**
* Show each child node and the connecting link,
* and perhaps recursively expand their child nodes.
* This may change the value of {@link Part#isVisible} of the whole subtree and the parts owned by
* those nodes and links.
* However, this root node's visibility is unchanged.
* <p/>
* This sets {@link #isTreeExpanded} to true on this node and on all of the children nodes.
* Links are assumed to go from the parent node to the children nodes,
* unless {@link Diagram#isTreePathToChildren} is false.
* Links for which {@link Link#isTreeLink} is false are ignored.
* <p/>
* This will expand a tree child node only if its {@link #wasTreeExpanded} property was true.
* <p/>
* You can also pass in a number of levels in order to be sure that all nodes
* starting at this node and up through that number of levels are visible.
* If you want to make sure that there are no nodes expanded after a particular level, call {@link #collapseTree}.
* If you want to do both, call <code>expandTree</code> before calling <code>collapseTree</code> to
* collapse nodes expanded due to the {@link #wasTreeExpanded} flag.
* <p/>
* This method does not perform a transaction.
* You may want to call the {@link CommandHandler#expandTree} command, which does perform a transaction
* and raise a {@link DiagramEvent}.
* @this {Node}
* @param {number=} level How many levels of the tree should be expanded;
*    the default is 2, showing all tree children of this node and potentially more.
*    Values less than 2 are treated as 2.
* @see #collapseTree
* @see #findTreeParts
*/
Node.prototype.expandTree = function(level) {
  if (level === undefined/*notpresent*/) level = 2;
  Util.checkRealNumber(level, Node, 'collapseTree:level');
  if (level < 2) level = 2;
  var diagram = this.diagram;
  if (diagram === null) return;
  if (diagram.isCollapsingExpanding) return;
  diagram.isCollapsingExpanding = true;
  var tochildren = diagram.isTreePathToChildren;
  var coll = new Set(Node);
  coll.add(this);
  this._expandTree1(coll, tochildren, level, this.isTreeExpanded);
  diagram.isCollapsingExpanding = false;
};

/**
* @ignore
* This needs to handle non-tree-structured graphs.
* @this {Node}
* @param {Set} coll
* @param {boolean} tochildren
* @param {number} level
* @param {boolean} wasExpanded
*/
Node.prototype._expandTree1 = function(coll, tochildren, level, wasExpanded) {
  this.isTreeExpanded = true;
  var cit = (tochildren ? this.findLinksOutOf() : this.findLinksInto());
  while (cit.next()) {
    var link = cit.value;
    if (!link.isTreeLink) continue;
    if (!wasExpanded) {
      link.updateAdornments();
    }
    var child = link.getOtherNode(this);
    if (child !== null && child !== this && !coll.contains(child)) {
      coll.add(child);
      if (!wasExpanded) {
        child.invalidateDraw();
      child.updateAdornments();
      child.invalidateContainingGroup();
      child.invalidateLayout(Part.LayoutShown);  // no-op if isUndoingRedoing
      }
      if (level > 2 || child.wasTreeExpanded) {
        child.wasTreeExpanded = false;
        child._expandTree1(coll, tochildren, level-1, child.isTreeExpanded);
      }
    }
  }
};

/**
* Gets or sets whether the subtree graph starting at this node is expanded.
* Changing this property's value will call {@link #collapseTree} or {@link #expandTree},
* and also will call the value of {@link #treeExpandedChanged} if it is a function.
* <p/>
* The initial value is true -- "tree-child" nodes, and the links to them, are shown.
* @name Node#isTreeExpanded
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Node.prototype.isTreeExpanded;
Util.exportProperty(Node, 'isTreeExpanded', Node.prototype.isTreeExpanded);
Util.defineProperty(Node, { isTreeExpanded : 'isTreeExpanded'},
  /** @this {Node} */
  function() { return this._isTreeExpanded; },
  /** @this {Node} */
  function(val) {
    var old = this._isTreeExpanded;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', Node, 'isTreeExpanded');
      this._isTreeExpanded = val;
      var diagram = this.diagram;
      this.raiseChanged('isTreeExpanded', old, val);
      var func = this.treeExpandedChanged;
      if (func !== null) {
        var oldUpdatingModel = true;
        if (diagram !== null) {
          oldUpdatingModel = diagram.isUpdatingModel;
          diagram.isUpdatingModel = true;
        }
        func(this);
        if (diagram !== null) {
          diagram.isUpdatingModel = oldUpdatingModel;
        }
      }
      if (diagram !== null && diagram.undoManager.isUndoingRedoing) return;
      if (val) {
        var level = 2;
        if (level < 2) level = 2;
        if (diagram === null) return;
        if (diagram.isCollapsingExpanding) return;
        diagram.isCollapsingExpanding = true;
        var tochildren = diagram.isTreePathToChildren;
        var coll = new Set(Node);
        coll.add(this);
        this._expandTree1(coll, tochildren, level, false);
        diagram.isCollapsingExpanding = false;
      } else {
        var level = 1;
        if (level < 1) level = 1;
        if (diagram === null) return;
        if (diagram.isCollapsingExpanding) return;
        diagram.isCollapsingExpanding = true;
        var tochildren = diagram.isTreePathToChildren;
        var coll = new Set(Node);
        coll.add(this);
        this._collapseTree2(coll, tochildren, level, true);
        diagram.isCollapsingExpanding = false;
      }
    }
  }
);

/**
* Gets or sets whether the subtree graph starting at this node
* had been collapsed by a call to {@link #expandTree} on the parent node.
* The initial value is false.
* @name Node#wasTreeExpanded
* @function.
* @return {boolean}
* @see #isTreeExpanded
*/
/** @type {boolean} */
Node.prototype.wasTreeExpanded;
Util.exportProperty(Node, 'wasTreeExpanded', Node.prototype.wasTreeExpanded);
Util.defineProperty(Node, { wasTreeExpanded: 'wasTreeExpanded' },
  /** @this {Node} */
  function() { return this._wasTreeExpanded; },
  /** @this {Node} */
  function(val) {
    var old = this._wasTreeExpanded;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', Node, 'wasTreeExpanded');
      this._wasTreeExpanded = val;
      this.raiseChanged('wasTreeExpanded', old, val);
    }
  }
);

/**
* Gets or sets the function that is called when {@link #isTreeExpanded} has changed value.
* The argument to that function will be this Node.
* <p/>
* If the value is a function, that function must not expand or collapse any trees of nodes and links.
* The Node has already been expanded or collapsed -- trying to change it again may produce undefined behavior.
* <p/>
* The default value is null -- no function is called.
* @name Node#treeExpandedChanged
* @function.
* @return {function(Node) | null}
*/
/** @type {function(Node) | null} */
Node.prototype.treeExpandedChanged;
Util.exportProperty(Node, 'treeExpandedChanged', Node.prototype.treeExpandedChanged);
Util.defineProperty(Node, { treeExpandedChanged: 'treeExpandedChanged' },
  /** @this {Node} */
  function() { return this._treeExpandedChanged; },
  /** @this {Node} */
  function(val) {
    var old = this._treeExpandedChanged;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', Node, 'treeExpandedChanged');
      this._treeExpandedChanged = val;
      this.raiseChanged('treeExpandedChanged', old, val);
    }
  }
);

/**
* Gets whether this node has no tree children.
* <p>
* The initial value is true, meaning that there are no links connected with child nodes
* in the direction given by {@link Diagram#isTreePathToChildren}.
* This value changes automatically as link connections are added to or removed from this node.
* Links for which {@link Link#isTreeLink} is false are ignored.
* @name Node#isTreeLeaf
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Node.prototype.isTreeLeaf;
Util.exportProperty(Node, 'isTreeLeaf', Node.prototype.isTreeLeaf);
Util.defineProperty(Node, { isTreeLeaf: 'isTreeLeaf' },
  /** @this {Node} */
  function() { return this._isTreeLeaf; },
  /** @this {Node} */
  function(val) {
    var old = this._isTreeLeaf;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', Node, 'isTreeLeaf');
      this._isTreeLeaf = val;
      this.raiseChanged('isTreeLeaf', old, val);
    }
  }
);

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
Link
*/

/**
 * Constructs an empty link that does not connect any nodes.
 * If you want the link to be seen, you must provide a {@link Shape} as an element
 * to be used as the visual path for the link.
 * @constructor
 * @extends Part
 * @class
 * A Link is a {@link Part} that connects {@link Node}s.
 * The link relationship is directional, going from {@link Link#fromNode} to {@link Link#toNode}.
 * A link can connect to a specific port element in a node, as named by the {@link Link#fromPortId}
 * and {@link Link#toPortId} properties.
 * <p class="box">
 * For more discussion, see <a href="../../intro/links.html">Introduction to Links</a>.
 * <p/>
 * To add a Link to a Diagram when using a {@link GraphLinksModel} you should do something like:
 * <pre>
 *   myDiagram.startTransaction("make new link");
 *   myDiagram.model.addLinkData({ from: "Alpha", to: "Beta" });
 *   myDiagram.commitTransaction("make new link");
 * </pre>
 * where you would substitute the keys of the actual nodes that you want to connect with a link.
 * This will cause a Link to be created (copying the template found in {@link Diagram#linkTemplateMap}),
 * added to the Diagram in some {@link Layer} (based on {@link Part#layerName}), and bound to the link data
 * (resulting in {@link Panel#data} referring to that link data object).
 * <p/>
 * If you are using a {@link TreeModel}, there are no link data objects, so you just need to call
 * {@link TreeModel#setParentKeyForNodeData} to specify the "parent" node's key for a "child" node data.
 * <p/>
 * To find a {@link Link} given a link data object in the {@link GraphLinksModel},
 * call {@link Diagram#findLinkForData}.  When using a {@link TreeModel}, call either {@link Diagram#findNodeForData}
 * or {@link Diagram#findNodeForKey} to get a Node, and then call {@link #findTreeParentLink} to get the Link, if any exists.
 * <p/>
 * To find a link that connects two nodes, call {@link #findLinksTo} or {@link #findLinksBetween}.
 * With the former method, the direction matters; with the latter method it returns links in either direction.
 * <p/>
 * A link's position and size are determined by the two nodes that it connects.
 * Normally there should be a {@link Shape} as the main element in this Link.
 * This shape is what users will see as the "line" or "wire" --
 * you can set its {@link Shape#stroke} and other "stroke..." properties to control its appearance.
 * <p/>
 * The link will compute a route (a sequence of points) going from the {@link #fromNode}'s port element
 * to the {@link #toNode}'s port element.
 * That route is used to generate the path of the main shape.
 * Properties that affect the nature of the route and the geometry of the path include:
 * <ul>
 *   <li>{@link #curve}</li>
 *   <li>{@link #curviness}</li>
 *   <li>{@link #corner}</li>
 *   <li>{@link #routing}</li>
 *   <li>{@link #smoothness}</li>
 *   <li>{@link #adjusting}</li>
 * </ul>
 * <p class="box">
 * For more discussion and examples, see <a href="../../intro/links.html">Links</a>.
 * <p/>
 * There are additional properties that affect how the end of the link connects to a port element of a node.
 * There are duplicate properties, ones for the "to" end and ones for the "from" end:
 * <ul>
 *   <li>{@link #fromSpot}, {@link #toSpot}</li>
 *   <li>{@link #fromEndSegmentLength}, {@link #toEndSegmentLength}</li>
 *   <li>{@link #fromShortLength}, {@link #toShortLength}</li>
 * </ul>
 * These properties normally have "default" values, causing the link's routing and path-geometry generating
 * to get the corresponding values from the connected port element.
 * This scheme permits an individual link to have its own specific connection to a port,
 * taking precedence over how the port normally expects links to connect to it.
 * For example, several of the {@link Layout} classes sets these properties on each Link
 * as part of their route computation for links.
 * <p class="box">
 * For more discussion and examples, see <a href="../../intro/connectionPoints.html">Link Points</a>.
 * <p/>
 * Elements other than the main {@link Shape} in the Link may act as decorations on the link, including arrowheads and labels.
 * You can control where they are located along the link route and how they are oriented.
 * Because these decorations may be any {@link GraphObject}, they are all properties of that class.
 * The properties include:
 * <ul>
 *   <li>{@link GraphObject#segmentIndex}</li>
 *   <li>{@link GraphObject#segmentFraction}</li>
 *   <li>{@link GraphObject#segmentOffset}</li>
 *   <li>{@link GraphObject#segmentOrientation}</li>
 * </ul>
 * If you do not set the {@link GraphObject#segmentIndex} property, the object is positioned
 * to be at the middle of the link.
 * <p class="box">
 * For more discussion and examples, see <a href="../../intro/linkLabels.html">Link Labels</a>.
 * <p/>
 * <b>GoJS</b> makes it easy to add arrowheads to your link template.
 * Just add a {@link Shape} with the appearance properties that you want,
 * and also set the {@link Shape#toArrow} or {@link Shape#fromArrow} property
 * to the name of the kind of arrowhead that you want.
 * Doing so automatically sets the "segment..." properties that are appropriate for the chosen arrowhead.
 * <p/>
 * More than one shape may automatically get the route geometry.
 * This is useful when you want to have multiple link shapes with different thicknesses
 * to create a gradient effect across the path of the link or to produce parallel lines along the path.
 * Just set {@link GraphObject#isPanelMain} to true on each such {@link Shape}.
 * <p/>
 * If you want the user to be able to reconnect a link, using the {@link RelinkingTool},
 * you need to set one or both of {@link #relinkableFrom} and {@link #relinkableTo} to true.
 * The {@link RelinkingTool} shows a {@link RelinkingTool#fromHandleArchetype} and/or a
 * {@link RelinkingTool#toHandleArchetype} when the link is selected.
 * Such a relink handle can be dragged by the user to start a relinking operation.
 * <p/>
 * If you want the user to be able to change the path of the link, using the {@link LinkReshapingTool},
 * set {@link Part#reshapable} to true.
 * The {@link LinkReshapingTool} shows reshape handles that the user can drag to shift the position
 * of a point in the link's route.
 * The {@link LinkReshapingTool#handleArchetype} is copied for each reshape handle.
 * <p/>
 * If a Link is {@link Part#reshapable}, it is also possible to allow the user to add and remove segments
 * from the link's route by setting {@link #resegmentable} to true.
 * This causes the {@link LinkReshapingTool} to add resegmenting handles at the midpoints of each segment.
 * The {@link LinkReshapingTool#midHandleArchetype} is copied for each resegment handle.
 * When the user drags such a resegmenting handle, a new segment is inserted into the route.
 * Also, when the user drags a reshape handle such that two adjacent segments end up in a straight line,
 * a segment is removed from the route.
 * <p class="box">
 * For more discussion and examples, see <a href="../../intro/links.html">Links</a>,
 * <a href="../../intro/linkLabels.html">Link Labels</a>, and
 * <a href="../../intro/connectionPoints.html">Link Points</a>.
 * <p class="box">
 * To control what links a user may draw or reconnect, please read about
 * <a href="../../intro/validation.html">Validation</a>.
 * <p/>
 * Only Links that are in Diagrams can have connections with Nodes.
 * Templates should not be connected with Nodes, be members of Groups, or have any Adornments.
 */
function Link() {
  Part.call(this, Panel.Link);

  /** @type {Node} */
  this._fromNode = null;  // related Node
  /** @type {string} */
  this._fromPortId = '';
  /** @type {function(Link, GraphObject, GraphObject) | null} */
  this._fromPortChanged = null;

  /** @type {Node} */
  this._toNode = null;  // related Node
  /** @type {string} */
  this._toPortId = '';
  /** @type {function(Link, GraphObject, GraphObject) | null} */
  this._toPortChanged = null;

  /** @type {boolean} */
  this._relinkableFrom = false;
  /** @type {boolean} */
  this._relinkableTo = false;
  /** @type {boolean} */
  this._resegmentable = false;

  /** @type {boolean} */
  this._isTreeLink = true;

  /** @type {EnumValue} */
  this._adjusting = Link.None;
  /** @type {number} */
  this._corner = 0;
  /** @type {EnumValue} */
  this._curve = Link.None;
  /** @type {number} */
  this._curviness = NaN;
  /** @type {EnumValue} */
  this._routing = Link.Normal;
  /** @type {number} */
  this._smoothness = 0.5;

  /** @type {Set} */
  this._labelNodes = null;  // owned Nodes

  /** @type {Shape} */
  this._path = null;  // must be in visual tree
  /** @type {List} */
  this._points = new List(Point).freeze();
  /** @type {List} */
  this._oldPoints = null;
  /** @type {boolean} */
  this._validRoute = false;
  /** @type {Rect} */
  this._previousBounds = null;
  /** @type {boolean} */
  this._suspendsRouting = false;
  /** @type {Geometry} */
  this._geometry = null;  // shared by "main" Shapes
  /** @type {?boolean} */
  this._effectiveBezier = null;
  /** @type {LinkBundle} */
  this._bundle = null;
  /** @type {number} */
  this._bundleIndex = 0;

  /** @type {List} */
  this._childrenBounds = new List(Rect);

  /** @type {Point} */
  this._tempOrigin = new Point();

  // There is no guarantee that these are useful unless _validRoute is true
  /** @type {Node} */
  this._tempFromNode = null;
  /** @type {Node} */
  this._tempToNode = null;

  /** @type {boolean} */
  this._computingPoints = false;

  /** @type {Object} */
  this._linkSettings = null;
}

Util.publish('Link', Link);

Util.inherit(Link, Part);

/**
* @ignore
* Copies properties to a cloned Link.
* @this {Link}
* @param {GraphObject} copy
*/
Link.prototype.cloneProtected = function(copy) {
  Part.prototype.cloneProtected.call(this, copy);

  //copy._fromNode  The copier should fix this reference
  copy._fromPortId = this._fromPortId;
  copy._fromPortChanged = this._fromPortChanged;
  //copy._toNode  The copier should fix this reference

  copy._toPortId = this._toPortId;
  copy._toPortChanged = this._toPortChanged;

  copy._relinkableFrom = this._relinkableFrom;
  copy._relinkableTo = this._relinkableTo;
  copy._resegmentable = this._resegmentable;

  copy._isTreeLink = this._isTreeLink;

  copy._adjusting = this._adjusting;
  copy._corner = this._corner;
  copy._curve = this._curve;
  copy._curviness = this._curviness;
  copy._routing = this._routing;
  copy._smoothness = this._smoothness;

  //copy._labelNodes  The copier should fix this reference

  // These all need to be recomputed on demand:
  //copy._path
  //copy._points
  //copy._previousBounds
  //copy._geometry
  //copy._bundle
  //copy._bundleIndex
  //copy._tempFromNode
  //copy._tempToNode

  // These all should have their default values:
  //copy._oldPoints
  //copy._validRoute
  //copy._suspendsRouting
  //copy._effectiveBezier
  //copy._childrenBounds
  //copy._tempOrigin
  //copy._computingPoints
};

/**
* @ignore
* Fix up references in the argument object so that the argument object can get a new visual tree
* @this {Link}
* @param {GraphObject} copy  The original Part whose category is being changed by displacing its visual tree with this Part's visual tree.
*/
Link.prototype.displaceProtected = function(copy) {
  Part.prototype.displaceProtected.call(this, copy);
  // hack: need to preserve the portIds
  // So we copy the portIds to the displacing Link so that cloneProtected copies them back
  this._fromPortId = copy._fromPortId;
  this._toPortId = copy._toPortId;

  copy._path = null;  // cached path Shape for a Link
  copy._oldPoints = null;
  copy.invalidateRoute();  // this also invalidates _geometry
  copy._bundle = this._bundle;
  copy._bundleIndex = this._bundleIndex;
};


// for routing:
/**
* Used as the default value for {@link Link#routing}:
* the route goes fairly straight between ports.
* @name Link#Normal
* @constant
* @static
* @return {EnumValue}
*/
Link['Normal'] = Link.Normal = Util.defineEnumValue(Link, 'Normal', 1);

/**
* Used as a value for {@link Link#routing}:
* each segment is horizontal or vertical.
* @name Link#Orthogonal
* @constant
* @static
* @return {EnumValue}
*/
Link['Orthogonal'] = Link.Orthogonal = Util.defineEnumValue(Link, 'Orthogonal', 2);

/**
* Used as a value for {@link Link#routing}:
* each segment is horizontal or vertical, but the route tries to avoid crossing over nodes.
* @name Link#AvoidsNodes
* @constant
* @static
* @return {EnumValue}
*/
Link['AvoidsNodes'] = Link.AvoidsNodes = Util.defineEnumValue(Link, 'AvoidsNodes', 3);


/**
* This is the default value for {@link Link#curve} and {@link Link#adjusting},
* to indicate that the path geometry consists of straight line segments and
* to indicate that the link route computation does not depend on any previous route points;
* this can also be used as a value for {@link GraphObject#segmentOrientation}
* to indicate that the object is never rotated along the link route -- its angle is unchanged.
* @name Link#None
* @constant
* @static
* @return {EnumValue}
*/
Link['None'] = Link.None = Util.defineEnumValue(Link, 'None', 0);


// for curve:  None or:
/**
* Used as a value for {@link Link#curve}, to indicate that
* the link path uses Bezier curve segments.
* @name Link#Bezier
* @constant
* @static
* @return {EnumValue}
*/
Link['Bezier'] = Link.Bezier = Util.defineEnumValue(Link, 'Bezier', 9);

/**
* Used as a value for {@link Link#curve}, to indicate that
* orthogonal link segments will be discontinuous where they cross over
* other orthogonal link segments that have a {@link Link#curve} or JumpOver or JumpGap.
* @name Link#JumpGap
* @constant
* @static
* @return {EnumValue}
*/
Link['JumpGap'] = Link.JumpGap = Util.defineEnumValue(Link, 'JumpGap', 10);

/**
* Used as a value for {@link Link#curve}, to indicate that
* orthogonal link segments will veer around where they cross over
* other orthogonal link segments that have a {@link Link#curve} or JumpOver or JumpGap.
* @name Link#JumpOver
* @constant
* @static
* @return {EnumValue}
*/
Link['JumpOver'] = Link.JumpOver = Util.defineEnumValue(Link, 'JumpOver', 11);


// for adjusting:  None or:
/**
* Used as a value for {@link Link#adjusting},
* to indicate that the link route computation should keep the
* intermediate points of the previous route, just modifying the first and/or last points;
* if the routing is orthogonal, it will only modify the first two and/or last two points.
* @name Link#End
* @constant
* @static
* @return {EnumValue}
*/
Link['End'] = Link.End = Util.defineEnumValue(Link, 'End', 17);

/**
* Used as a value for {@link Link#adjusting},
* to indicate that the link route computation should scale and rotate the intermediate points
* so that the link's shape looks approximately the same;
* if the routing is orthogonal, this value is treated as if it were {@link Link#End}.
* @name Link#Scale
* @constant
* @static
* @return {EnumValue}
*/
Link['Scale'] = Link.Scale = Util.defineEnumValue(Link, 'Scale', 18);

/**
* Used as a value for {@link Link#adjusting},
* to indicate that the link route computation should linearly interpolate the intermediate points
* so that the link's shape looks stretched;
* if the routing is orthogonal, this value is treated as if it were {@link Link#End}.
* @name Link#Stretch
* @constant
* @static
* @return {EnumValue}
*/
Link['Stretch'] = Link.Stretch = Util.defineEnumValue(Link, 'Stretch', 19);


/**
* This value for {@link GraphObject#segmentOrientation} results in
* the GraphObject turned to have the same angle as the route:
* the GraphObject's angle is always the same as the angle of the link's route
* at the segment where the GraphObject is attached;
* use this orientation for arrow heads.
* @name Link#OrientAlong
* @constant
* @static
* @return {EnumValue}
*/
Link['OrientAlong'] = Link.OrientAlong = Util.defineEnumValue(Link, 'OrientAlong', 21);

/**
* This value for {@link GraphObject#segmentOrientation} results in
* the GraphObject is turned clockwise to be perpendicular to the route:
* the GraphObject's angle is always 90 degrees more than the angle of the link's route
* at the segment where the GraphObject is attached.
* @name Link#OrientPlus90
* @constant
* @static
* @return {EnumValue}
*/
Link['OrientPlus90'] = Link.OrientPlus90 = Util.defineEnumValue(Link, 'OrientPlus90', 22);

/**
* This value for {@link GraphObject#segmentOrientation} results in
* the GraphObject being turned counter-clockwise to be perpendicular to the route:
* the GraphObject's angle is always 90 degrees less than the angle of the link's route
* at the segment where the GraphObject is attached.
* @name Link#OrientMinus90
* @constant
* @static
* @return {EnumValue}
*/
Link['OrientMinus90'] = Link.OrientMinus90 = Util.defineEnumValue(Link, 'OrientMinus90', 23);

/**
* This value for {@link GraphObject#segmentOrientation} results in
* the GraphObject's angle always being 180 degrees opposite from the angle of the link's route
* at the segment where the GraphObject is attached.
* @name Link#OrientOpposite
* @constant
* @static
* @return {EnumValue}
*/
Link['OrientOpposite'] = Link.OrientOpposite = Util.defineEnumValue(Link, 'OrientOpposite', 24);

/**
* This value for {@link GraphObject#segmentOrientation} results in
* the GraphObject turned to have the same angle as the route, just like {@link Link#OrientAlong}, but is never upside down:
* the GraphObject's angle always following the angle of the link's route
* at the segment where the GraphObject is attached;
* this is typically only used for {@link TextBlock}s or {@link Panel}s that contain text.
* @name Link#OrientUpright
* @constant
* @static
* @return {EnumValue}
*/
Link['OrientUpright'] = Link.OrientUpright = Util.defineEnumValue(Link, 'OrientUpright', 25);

/**
* This value for {@link GraphObject#segmentOrientation} results in
* the GraphObject turned clockwise to be perpendicular to the route, just like {@link Link#OrientPlus90}, but is never upside down:
* the GraphObject's angle always being 90 degrees more than the angle of the link's route
* at the segment where the GraphObject is attached;
* this is typically only used for {@link TextBlock}s or {@link Panel}s that contain text.
* @name Link#OrientPlus90Upright
* @constant
* @static
* @return {EnumValue}
*/
Link['OrientPlus90Upright'] = Link.OrientPlus90Upright = Util.defineEnumValue(Link, 'OrientPlus90Upright', 26);

/**
* This value for {@link GraphObject#segmentOrientation} results in
* the GraphObject turned counter-clockwise to be perpendicular to the route, just like {@link Link#OrientMinus90}, but is never upside down:
* the GraphObject's angle always being 90 degrees less than the angle of the link's route
* at the segment where the GraphObject is attached;
* this is typically only used for {@link TextBlock}s or {@link Panel}s that contain text.
* @name Link#OrientMinus90Upright
* @constant
* @static
* @return {EnumValue}
*/
Link['OrientMinus90Upright'] = Link.OrientMinus90Upright = Util.defineEnumValue(Link, 'OrientMinus90Upright', 27);

/**
* This value for {@link GraphObject#segmentOrientation} results in
* the GraphObject's angle always following the angle of the link's route
* at the segment where the GraphObject is attached, but never upside down
* and never angled more than +/- 45 degrees:
* when the route's angle is within 45 degrees of vertical (90 or 270 degrees),
* the GraphObject's angle is set to zero;
* this is typically only used for {@link TextBlock}s or {@link Panel}s that contain text.
* @name Link#OrientUpright45
* @constant
* @static
* @return {EnumValue}
*/
Link['OrientUpright45'] = Link.OrientUpright45 = Util.defineEnumValue(Link, 'OrientUpright45', 28);

/**
* @ignore
* @this {Link}
*/
Link.prototype.initLinkSettings = function() {
  this._linkSettings = {
    _fromSpot: Spot.Default,
    _toSpot: Spot.Default,
    _fromEndSegmentLength: NaN,
    _toEndSegmentLength: NaN,
    _fromEndSegmentDirection: Node.DirectionDefault,
    _toEndSegmentDirection: Node.DirectionDefault,
    _fromShortLength: NaN,
    _toShortLength: NaN
  }
};

/**
 * @ignore
 * @this {Link}
 * @param {Node} e
 * @param {number} numpts
 * @param {List} pts
 */
Link.prototype._arrangeLabelNode = function(e, numpts, pts) {
  // get the properties controlling where the "label" should be along the route
  var index = e.segmentIndex;
  var frac = e.segmentFraction;
  var align = e.alignmentFocus;
  if (align.isNoSpot()) align = Spot.Center;
  var orient = e.segmentOrientation;
  var offset = e.segmentOffset;

  var itemX;  // model coordinates
  var itemY;
  var labelangle = 0;
  if (index < -numpts || index >= numpts) {  // beyond range? assume at the MidPoint, with the MidAngle
    var mid = this.midPoint;  // in document coordinates
    var segangle = this.midAngle;
    // maybe rotate the label
    if (orient !== Link.None) {
      labelangle = this.computeAngle(e, orient, segangle);
      e.angle = labelangle;
    }
    itemX = mid.x;
    itemY = mid.y;  // model coordinates
  } else {  // on a particular segment, given by Index, at a point given by Fraction
    // negative index means start from last point, going "backwards"
    var a, b; // points
    if (index >= 0) {
      a = pts._arr[index];
      b = (index < numpts - 1) ? pts._arr[index + 1] : a;
    } else {
      var idx = numpts + index;  // remember that index is negative here
      a = pts._arr[idx];
      b = (idx > 0) ? pts._arr[idx - 1] : a;
    }
    var segangle = (index >= 0 ? a.directionPoint(b) : b.directionPoint(a));
    // maybe rotate the label
    if (orient !== Link.None) {
      labelangle = this.computeAngle(e, orient, segangle);
      e.angle = labelangle;
    }
    // compute the fractional point along the line, in model coordinates
    itemX = a.x + (b.x - a.x) * frac;
    itemY = a.y + (b.y - a.y) * frac;
  }

  // now determine the label/arrowhead's bounds
  var et = Util.tempTransform();
  et.reset();
  et.scale(e.scale, e.scale);
  et.rotate(e.angle, 0, 0);

  // find the transformed alignment point inside the element
  var ns = e.naturalBounds;
  var nb = Util.tempRectAt(0, 0, ns.width, ns.height);
  var alignpt = Util.tempPoint();
  alignpt.setRectSpot(nb, align);
  et.transformPoint(alignpt);
  var dx = -alignpt.x;
  var dy = -alignpt.y;

  // maybe the alignment point is away from the line
  var offsetpt = offset.copy();
  if (isNaN(offsetpt.x)) {
    if (index >= 0) {
      offsetpt.x = alignpt.x + 3;
    } else {
      offsetpt.x = -(alignpt.x + 3);
    }
  }
  if (isNaN(offsetpt.y)) {
    offsetpt.y = -(alignpt.y + 3);
  }
  offsetpt.rotate(segangle);
  itemX += offsetpt.x;
  itemY += offsetpt.y;

  // find the bounds of the transformed rectangle that the alignment spot is in
  et.transformRect(nb);
  dx += nb.x;
  dy += nb.y;
  var epos = Util.tempPointAt(itemX + dx, itemY + dy);
  e.move(epos);  // don't set position -- gotta call move in case it's a Group
  Util.freePoint(epos);
  Util.freePoint(alignpt);
  Util.freeRect(nb);
  Util.freeTransform(et);
};


/**
 * @ignore
 * A link is ready to be measure/arranged if both of its nodes have been arranged
 * @this {Link}
 * @return {boolean}
 */
Link.prototype.isReadyToMeasureArrange = function() {
  var f = this.fromNode;
  if (f !== null) {
    if (f.getInvalidArrange() || f.getInvalidPosition()) return false;
  }
  var t = this.toNode;
  if (t !== null) {
    if (t.getInvalidArrange() || t.getInvalidPosition()) return false;
  }
  return true;
};

/**
* @ignore
* @this {Part}
* @return {boolean}
*/
Link.prototype.isNodeLike = function() {
  return false;
};

/**
 * @ignore
 * Dynamically compute the desired angle of a GraphObject along a segment of the route.
 * This method is only called when the GraphObject's {@link GraphObject#segmentOrientation} property value is
 * not {@link Link#None}.
 * @expose
 * @this {Link}
 * @param {GraphObject} elt The {@link GraphObject} being rotated.
 * @param {EnumValue} orient A {@link Link} constant <code>Orient...</code> that indicates how the angle should be computed.
 * @param {number} angle The angle of the segment of the route where the GraphObject is attached.
 * @return {number} The intended angle for the GraphObject.
 */
Link.prototype.computeAngle = function(elt, orient, angle) {
  var a;
  switch (orient) {
    default:
    case Link.None: a = 0; break;
    case Link.OrientAlong: a = angle; break;
    case Link.OrientPlus90: a = angle + 90; break;
    case Link.OrientMinus90: a = angle - 90; break;
    case Link.OrientOpposite: a = angle + 180; break;
    case Link.OrientUpright:  // like Along
      a = Geo.normalizeAngle(angle);
      if (a > 90 && a < 270) a -= 180;  // make sure never upside-down
      break;
    case Link.OrientPlus90Upright:  // like Plus90
      a = Geo.normalizeAngle(angle + 90);
      if (a > 90 && a < 270) a -= 180;  // make sure never upside-down
      break;
    case Link.OrientMinus90Upright:  // like Minus90
      a = Geo.normalizeAngle(angle - 90);
      if (a > 90 && a < 270) a -= 180;  // make sure never upside-down
      break;
    case Link.OrientUpright45:  // like Along
      a = Geo.normalizeAngle(angle);
      if (a > 45 && a < 135) return 0;  // make sure never angled too much
      if (a > 225 && a < 315) return 0;
      if (a > 90 && a < 270) a -= 180;  // make sure never upside-down
      break;
  }
  return Geo.normalizeAngle(a);
};


/**
* Gets or sets the {@link Node} that this link comes from.
* The {@link #fromPortId} specifies which port the link comes from.
* The default value is null -- this link is not coming from any node.
* <p>
* A template should not be connected with any node.
* @name Link#fromNode
* @function.
* @return {Node}
*/
/** @type {Node} */
Link.prototype.fromNode;
Util.exportProperty(Link, 'fromNode', Link.prototype.fromNode);
Util.defineProperty(Link, { fromNode: 'fromNode'},
  /** @this {Link} */
  function() { return this._fromNode; },
  /** @this {Link} */
  function(val) {
    var old = this._fromNode;
    if (old !== val) {
      if (Debug && val !== null) Util.checkClass(val, Node, Link, 'fromNode');
      var oldport = this.fromPort;
      if (old !== null) {
        if (this._toNode !== old) old.removeLinkInternal(this, oldport);
        if (oldport !== null) oldport._portInfo = null;
        this.updateLinkBundleRemove();
        old.invalidateLayout(Part.LayoutRemoved);  // no-op if isUndoingRedoing
      }
      this._fromNode = val;
      this._effectiveBezier = null;
      this.invalidateRoute();

      // update model
      //??? no-op if isUndoingRedoing
      var diagram = this.diagram;
      if (diagram !== null) {
        var data = this.data;
        var model = diagram.model;
        if (data !== null) {
          if (model instanceof GraphLinksModel) {
            // if VAL is null or if VAL.data is null, the link data's node key is set to undefined
            var ndata = (val !== null ? val.data : null);
            model.setFromKeyForLinkData(data, model.getKeyForNodeData(ndata));
          } else if (model instanceof TreeModel) {
            // NOTE: data is now the child node data, not a link data
            // if VAL is null or if VAL.data is null, the parent key is set to undefined
            var ndata = (val !== null ? val.data : null);
            if (diagram.isTreePathToChildren) {
              model.setParentKeyForNodeData(data, model.getKeyForNodeData(ndata));
            } else {
              if (old !== null) {
                model.setParentKeyForNodeData(old.data, undefined);
              }
              var pdata = (this._toNode !== null ? this._toNode.data : null);
              model.setParentKeyForNodeData(ndata, model.getKeyForNodeData(pdata));
            }
          }
        }
      }

      var newport = this.fromPort;
      // different node, thus must be different port: must notify
      var func = this.fromPortChanged;
      if (func !== null) {
        var oldUpdatingModel = true;
        if (diagram !== null) {
          oldUpdatingModel = diagram.isUpdatingModel;
          diagram.isUpdatingModel = true;
        }
        func(this, oldport, newport);
        if (diagram !== null) {
          diagram.isUpdatingModel = oldUpdatingModel;
        }
      }

      if (val !== null) {
        if (this._toNode !== val) val.addLinkInternal(this, newport);
        if (newport !== null) newport._portInfo = null;
        this.updateLinkBundleAdd();
        val.invalidateLayout(Part.LayoutAdded);  // no-op if isUndoingRedoing
      }
      this.raiseChanged('fromNode', old, val);
      this.updateContainingGroup();
    }
  }
);

/**
* Gets or sets the identifier of the port that this link comes from.
* The default value is the empty string.
* @name Link#fromPortId
* @function.
* @return {string}
*/
/** @type {string} */
Link.prototype.fromPortId;
Util.exportProperty(Link, 'fromPortId', Link.prototype.fromPortId);
Util.defineProperty(Link, { fromPortId: 'fromPortId'},
  /** @this {Link} */
  function() { return this._fromPortId; },
  /** @this {Link} */
  function(val) {
    var old = this._fromPortId;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'string', Link, 'fromPortId');
      var oldport = this.fromPort;
      if (oldport !== null) oldport._portInfo = null;
      this.updateLinkBundleRemove();
      this._fromPortId = val;
      var newport = this.fromPort;
      if (newport !== null) newport._portInfo = null;

      // update model
      //??? no-op if isUndoingRedoing
      var diagram = this.diagram;
      if (diagram !== null) {
        var data = this.data;
        var model = diagram.model;
        if (data !== null) {
          if (model instanceof GraphLinksModel) {
            model.setFromPortIdForLinkData(data, val);
          }  // do nothing if TreeModel
        }
      }

      // notify if port actually changed:
      if (oldport !== newport) {
        this._effectiveBezier = null;
        this.invalidateRoute();
        var func = this.fromPortChanged;
        if (func !== null) {
          var oldUpdatingModel = true;
          if (diagram !== null) {
            oldUpdatingModel = diagram.isUpdatingModel;
            diagram.isUpdatingModel = true;
          }
          func(this, oldport, newport);
          if (diagram !== null) {
            diagram.isUpdatingModel = oldUpdatingModel;
          }
        }
      }
      this.updateLinkBundleAdd();
      this.raiseChanged('fromPortId', old, val);
    }
  }
);

/**
* Gets a {@link GraphObject} that is the "from" port that this link is connected from.
* The {@link #fromNode} provides the node that the link is coming from.
* The {@link #fromPortId} provides the identifier for which port this link is coming from.
* This method may return null.
* @name Link#fromPort
* @function.
* @return {GraphObject}
*/
/** @type {GraphObject} */
Link.prototype.fromPort;
Util.defineReadOnlyProperty(Link, { fromPort: 'fromPort'},
  /** @this {Link} */
  function() {
    //??? cache this reference
    var node = this._fromNode;
    if (node === null) return null;
    var pid = this._fromPortId;
    return node.findPort(pid);
  }
);

/**
* Gets or sets the function that is called after this Link changes which Node or port it connects from.
* The first argument will be this Link.
* The second argument will be the old GraphObject port.
* The third argument will be the new GraphObject port.
* <p/>
* If the value is a function, that function must not modify which nodes or links this link connects with.
* The "from" node and/or port has already been changed -- trying to change it again may produce undefined behavior.
* <p/>
* The default value is null -- no function is called.
* @name Link#fromPortChanged
* @function.
* @return {function(Link, GraphObject, GraphObject) | null}
*/
/** @type {function(Link, GraphObject, GraphObject) | null} */
Link.prototype.fromPortChanged;
Util.exportProperty(Link, 'fromPortChanged', Link.prototype.fromPortChanged);
Util.defineProperty(Link, { fromPortChanged: 'fromPortChanged' },
  /** @this {Link} */
  function() { return this._fromPortChanged; },
  /** @this {Link} */
  function(val) {
    var old = this._fromPortChanged;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', Link, 'fromPortChanged');
      this._fromPortChanged = val;
      this.raiseChanged('fromPortChanged', old, val);
    }
  }
);

/**
* Gets or sets the {@link Node} that this link goes to.
* The {@link #toPortId} specifies which port the link goes to.
* The default value is null -- this link is not going to any node.
* <p>
* A template should not be connected with any node.
* @name Link#toNode
* @function.
* @return {Node}
*/
/** @type {Node} */
Link.prototype.toNode;
Util.exportProperty(Link, 'toNode', Link.prototype.toNode);
Util.defineProperty(Link, { toNode: 'toNode' },
  /** @this {Link} */
  function() { return this._toNode; },
  /** @this {Link} */
  function(val) {
    var old = this._toNode;
    if (old !== val) {
      if (Debug && val !== null) Util.checkClass(val, Node, Link, 'toNode');
      var oldport = this.toPort;
      if (old !== null) {
        if (this._fromNode !== old) old.removeLinkInternal(this, oldport);
        if (oldport !== null) oldport._portInfo = null;
        this.updateLinkBundleRemove();
        old.invalidateLayout(Part.LayoutRemoved);  // no-op if isUndoingRedoing
      }
      this._toNode = val;
      this._effectiveBezier = null;
      this.invalidateRoute();

      // update model
      //??? no-op if isUndoingRedoing
      var diagram = this.diagram;
      if (diagram !== null) {
        var data = this.data;
        var model = diagram.model;
        if (data !== null) {
          if (model instanceof GraphLinksModel) {
            // if VAL is null or if VAL.data is null, the link data's node key is set to undefined
            var ndata = (val !== null ? val.data : null);
            model.setToKeyForLinkData(data, model.getKeyForNodeData(ndata));
          } else if (model instanceof TreeModel) {
            // NOTE: data is now the child node data, not a link data
            // if VAL is null or if VAL.data is null, the link data's node key is set to undefined
            var ndata = (val !== null ? val.data : null);
            if (diagram.isTreePathToChildren) {
              if (old !== null) {
                model.setParentKeyForNodeData(old.data, undefined);
              }
              var pdata = (this._fromNode !== null ? this._fromNode.data : null);
              model.setParentKeyForNodeData(ndata, model.getKeyForNodeData(pdata));
            } else {
              model.setParentKeyForNodeData(data, model.getKeyForNodeData(ndata));
            }
          }
        }
      }

      var newport = this.toPort;
      // different node, thus must be different port: must notify
      var func = this.toPortChanged;
      if (func !== null) {
        var oldUpdatingModel = true;
        if (diagram !== null) {
          oldUpdatingModel = diagram.isUpdatingModel;
          diagram.isUpdatingModel = true;
        }
        func(this, oldport, newport);
        if (diagram !== null) {
          diagram.isUpdatingModel = oldUpdatingModel;
        }
      }

      if (val !== null) {
        if (this._fromNode !== val) val.addLinkInternal(this, newport);
        if (newport !== null) newport._portInfo = null;
        this.updateLinkBundleAdd();
        val.invalidateLayout(Part.LayoutAdded);  // no-op if isUndoingRedoing
      }
      this.raiseChanged('toNode', old, val);
      this.updateContainingGroup();
    }
  }
);

/**
* Gets or sets the identifier of the port that this link goes to.
* The default value is the empty string.
* @name Link#toPortId
* @function.
* @return {string}
*/
/** @type {string} */
Link.prototype.toPortId;
Util.exportProperty(Link, 'toPortId', Link.prototype.toPortId);
Util.defineProperty(Link, { toPortId: 'toPortId' },
  /** @this {Link} */
  function() { return this._toPortId; },
  /** @this {Link} */
  function(val) {
    var old = this._toPortId;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'string', Link, 'toPortId');
      var oldport = this.toPort;
      if (oldport !== null) oldport._portInfo = null;
      this.updateLinkBundleRemove();
      this._toPortId = val;
      var newport = this.toPort;
      if (newport !== null) newport._portInfo = null;

      // update model
      //??? no-op if isUndoingRedoing
      var diagram = this.diagram;
      if (diagram !== null) {
        var data = this.data;
        var model = diagram.model;
        if (data !== null) {
          if (model instanceof GraphLinksModel) {
            model.setToPortIdForLinkData(data, val);
          }  // do nothing if TreeModel
        }
      }

      // notify if port actually changed:
      if (oldport !== newport) {
        this._effectiveBezier = null;
        this.invalidateRoute();
        var func = this.toPortChanged;
        if (func !== null) {
          var oldUpdatingModel = true;
          if (diagram !== null) {
            oldUpdatingModel = diagram.isUpdatingModel;
            diagram.isUpdatingModel = true;
          }
          func(this, oldport, newport);
          if (diagram !== null) {
            diagram.isUpdatingModel = oldUpdatingModel;
          }
        }
      }
      this.updateLinkBundleAdd();
      this.raiseChanged('toPortId', old, val);
    }
  }
);

/**
* Gets a {@link GraphObject} that is the "to" port that this link is connected to.
* The {@link #toNode} provides the node that the link is going to.
* The {@link #toPortId} provides the identifier for which port this link is going to.
* This method may return null.
* @name Link#toPort
* @function.
* @return {GraphObject}
*/
/** @type {GraphObject} */
Link.prototype.toPort;
Util.defineReadOnlyProperty(Link, { toPort: 'toPort'},
  /** @this {Link} */
  function() {
    //??? cache this reference
    var node = this._toNode;
    if (node === null) return null;
    var pid = this._toPortId;
    return node.findPort(pid);
  }
);

/**
* Gets or sets the function that is called after this Link changes which Node or port it connects to.
* The first argument will be this Link.
* The second argument will be the old GraphObject port.
* The third argument will be the new GraphObject port.
* <p/>
* If the value is a function, that function must not modify which nodes or links this link connects with.
* The "to" node and/or port has already been changed -- trying to change it again may produce undefined behavior.
* <p/>
* The default value is null -- no function is called.
* @name Link#toPortChanged
* @function.
* @return {function(Link, GraphObject, GraphObject) | null}
*/
/** @type {function(Link, GraphObject, GraphObject) | null} */
Link.prototype.toPortChanged;
Util.exportProperty(Link, 'toPortChanged', Link.prototype.toPortChanged);
Util.defineProperty(Link, { toPortChanged: 'toPortChanged' },
  /** @this {Link} */
  function() { return this._toPortChanged; },
  /** @this {Link} */
  function(val) {
    var old = this._toPortChanged;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', Link, 'toPortChanged');
      this._toPortChanged = val;
      this.raiseChanged('toPortChanged', old, val);
    }
  }
);

/// Properties describing how this link should connect to the fromPort

/**
* Gets or sets where this link should connect at the {@link #fromPort}.
* The default value is {@link Spot#Default}, meaning that the value
* actually comes from the {@link GraphObject#fromSpot} property of the {@link #fromPort}.
* @name Link#fromSpot
* @function.
* @return {Spot}
* @see #toSpot
* @see GraphObject#fromSpot
*/
Util.defineProperty(Link, { fromSpot: 'fromSpot'},
  /** @this {Link} */
  function() { return this._linkSettings !== null ? this._linkSettings._fromSpot : Spot.Default; },
  /** @this {Link} */
  function(val) {
    if (this._linkSettings === null) this.initLinkSettings();
    var old = this._linkSettings._fromSpot;
    if (!old.equals(val)) {
      if (Debug) Util.checkClass(val, Spot, Link, 'fromSpot');
      val = val.copyFrozen();
      this._linkSettings._fromSpot = val;
      this.raiseChanged('fromSpot', old, val);
      this.invalidateRoute();
    }
  }
);

/**
* Gets or sets the length of the last segment.
* The default value is NaN.
* @name Link#fromEndSegmentLength
* @function.
* @return {number}
* @see #toEndSegmentLength
* @see GraphObject#fromEndSegmentLength
*/
Util.defineProperty(Link, { fromEndSegmentLength: 'fromEndSegmentLength'},
  /** @this {Link} */
  function() { return this._linkSettings !== null ? this._linkSettings._fromEndSegmentLength : NaN; },
  /** @this {Link} */
  function(val) {
    if (this._linkSettings === null) this.initLinkSettings();
    var old = this._linkSettings._fromEndSegmentLength;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'number', Link, 'fromEndSegmentLength');
      if (val < 0) Util.throwRangeError(val, '>= 0', Link, 'fromEndSegmentLength');
      this._linkSettings._fromEndSegmentLength = val;
      this.raiseChanged('fromEndSegmentLength', old, val);
      this.invalidateRoute();
    }
  }
);

/**
* Gets or sets how the direction of the last segment is computed when the node is rotated.
* The value must be one of {@link Node#DirectionAbsolute},
* {@link Node#DirectionRotatedNode}, {@link Node#DirectionRotatedNodeOrthogonal},
* or the default value {@link Node#DirectionDefault} which indicates
* that the value actually comes from the {@link #fromPort}.
* @name Link#fromEndSegmentDirection
* @function.
* @return {EnumValue}
* @see #toEndSegmentDirection
* @see GraphObject#fromEndSegmentDirection
*/
Util.defineProperty(Link, { fromEndSegmentDirection: 'fromEndSegmentDirection'},
  /** @this {Link} */
  function() { return this._linkSettings !== null ? this._linkSettings._fromEndSegmentDirection : Node.DirectionDefault; },
  /** @this {Link} */
  function(val) {
    if (this._linkSettings === null) this.initLinkSettings();
    var old = this._linkSettings._fromEndSegmentDirection;
    if (old !== val) {
      if (Debug) Util.checkEnumValue(val, Node, Link, 'fromEndSegmentDirection');
      this._linkSettings._fromEndSegmentDirection = val;
      this.raiseChanged('fromEndSegmentDirection', old, val);
      this.invalidateRoute();
    }
  }
);

/**
* Gets or sets how far the end segment stops short of the actual port.
* Negative values cause the link to extend into the port.
* The default value is NaN -- the value actually comes from the
* {@link GraphObject#fromShortLength} property of the {@link #fromPort}.
* @name Link#fromShortLength
* @function.
* @return {number}
* @see #toShortLength
* @see GraphObject#fromShortLength
*/
Util.defineProperty(Link, { fromShortLength: 'fromShortLength'},
  /** @this {Link} */
  function() { return this._linkSettings !== null ? this._linkSettings._fromShortLength : NaN; },
  /** @this {Link} */
  function(val) {
    if (this._linkSettings === null) this.initLinkSettings();
    var old = this._linkSettings._fromShortLength;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'number', Link, 'fromShortLength');
      this._linkSettings._fromShortLength = val;
      this.raiseChanged('fromShortLength', old, val);
      this.invalidateRoute();
    }
  }
);

/// Properties describing how this link should connect to the toPort

/**
* Gets or sets where this link should connect at the {@link #toPort}.
* The default value is {@link Spot#Default}, meaning that the value
* actually comes from the {@link GraphObject#toSpot} property of the {@link #toPort}.
* @name Link#toSpot
* @function.
* @return {Spot}
* @see #fromSpot
* @see GraphObject#toSpot
*/
Util.defineProperty(Link, { toSpot: 'toSpot'},
  /** @this {Link} */
  function() { return this._linkSettings !== null ? this._linkSettings._toSpot : Spot.Default; },
  /** @this {Link} */
  function(val) {
    if (this._linkSettings === null) this.initLinkSettings();
    var old = this._linkSettings._toSpot;
    if (!old.equals(val)) {
      if (Debug) Util.checkClass(val, Spot, Link, 'toSpot');
      val = val.copyFrozen();
      this._linkSettings._toSpot = val;
      this.raiseChanged('toSpot', old, val);
      this.invalidateRoute();
    }
  }
);

/**
* Gets or sets the length of the last segment.
* The default value is NaN.
* @name Link#toEndSegmentLength
* @function.
* @return {number}
* @see #fromEndSegmentLength
* @see GraphObject#toEndSegmentLength
*/
Util.defineProperty(Link, { toEndSegmentLength: 'toEndSegmentLength'},
  /** @this {Link} */
  function() { return this._linkSettings !== null ? this._linkSettings._toEndSegmentLength : NaN; },
  /** @this {Link} */
  function(val) {
    if (this._linkSettings === null) this.initLinkSettings();
    var old = this._linkSettings._toEndSegmentLength;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'number', Link, 'toEndSegmentLength');
      if (val < 0) Util.throwRangeError(val, '>= 0', Link, 'toEndSegmentLength');
      this._linkSettings._toEndSegmentLength = val;
      this.raiseChanged('toEndSegmentLength', old, val);
      this.invalidateRoute();
    }
  }
);

/**
* Gets or sets how the direction of the last segment is computed when the node is rotated.
* The value must be one of {@link Node#DirectionAbsolute},
* {@link Node#DirectionRotatedNode}, {@link Node#DirectionRotatedNodeOrthogonal},
* or the default value {@link Node#DirectionDefault}, which indicates
* that the value actually comes from the {@link #toPort}.
* @name Link#toEndSegmentDirection
* @function.
* @return {EnumValue}
* @see #fromEndSegmentDirection
* @see GraphObject#toEndSegmentDirection
*/
Util.defineProperty(Link, { toEndSegmentDirection: 'toEndSegmentDirection'},
  /** @this {Link} */
  function() { return this._linkSettings !== null ? this._linkSettings._toEndSegmentDirection : Node.DirectionDefault; },
  /** @this {Link} */
  function(val) {
    if (this._linkSettings === null) this.initLinkSettings();
    var old = this._linkSettings._toEndSegmentDirection;
    if (old !== val) {
      if (Debug) Util.checkEnumValue(val, Node, Link, 'toEndSegmentDirection');
      this._linkSettings._toEndSegmentDirection = val;
      this.raiseChanged('toEndSegmentDirection', old, val);
      this.invalidateRoute();
    }
  }
);

/**
* Gets or sets how far the end segment stops short of the actual port.
* Negative values cause the link to extend into the port.
* The default value is NaN -- the value actually comes from the
* {@link GraphObject#toShortLength} property of the {@link #toPort}.
* @name Link#toShortLength
* @function.
* @return {number}
* @see #fromShortLength
* @see GraphObject#toShortLength
*/
Util.defineProperty(Link, { toShortLength: 'toShortLength'},
  /** @this {Link} */
  function() { return this._linkSettings !== null ? this._linkSettings._toShortLength : NaN; },
  /** @this {Link} */
  function(val) {
    if (this._linkSettings === null) this.initLinkSettings();
    var old = this._linkSettings._toShortLength;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'number', Link, 'toShortLength');
      this._linkSettings._toShortLength = val;
      this.raiseChanged('toShortLength', old, val);
      this.invalidateRoute();
    }
  }
);

/**
* @ignore
* @this {Link}
*/
Link.prototype.updateContainingGroup = function() {
  var fromnode = this.fromNode;
  var tonode = this.toNode;
  // Don't set the Part.containingGroup property:
  // avoid Link check and raiseChanged by calling th internal set method instead.
  if (fromnode !== null && tonode !== null) {
    this.setContainingGroup(fromnode.findCommonContainingGroup(tonode));
  } else {
    this.setContainingGroup(null);
  }
};

/**
* @ignore
* Just used by {@link Link#updateContainingGroup}
* @this {Link}
* @param {Group} val
*/
Link.prototype.setContainingGroup = function(val) {
  var old = this._containingGroup;
  if (old !== val) {
    if (old !== null) old.removeMemberInternal(this);
    this._containingGroup = val;
    if (val !== null) val.addMemberInternal(this);
    var func = this.containingGroupChanged;
    if (func !== null) {
      var oldUpdatingModel = true;
      var diagram = this.diagram;
      if (diagram !== null) {
        oldUpdatingModel = diagram.isUpdatingModel;
        diagram.isUpdatingModel = true;
      }
      func(this, old, val);
      if (diagram !== null) {
        diagram.isUpdatingModel = oldUpdatingModel;
      }
    }
    // If the route was valid this link may have been pointing at its old group,
    // and that to/from node may no longer be a valid target
    if (this._validRoute && (this._tempFromNode === old || this._tempToNode === old))
      this.invalidateRoute();
  }
};

Link.prototype['getOtherNode'] =
/**
* Given a {@link Node}, return the node at the other end of this link.
* @this {Link}
* @param {Node} node
* @return {Node} This may return the same node, if the link is reflexive.
*/
Link.prototype.getOtherNode = function(node) {
  if (Debug) Util.checkClass(node, Node, Link, 'getOtherNode:node');
  var from = this.fromNode;
  if (node === from)
    return this.toNode;
  else
    return from;
};

Link.prototype['getOtherPort'] =
/**
* Given a {@link GraphObject} that is a "port", return the port at the other end of this link.
* @this {Link}
* @param {GraphObject} port
* @return {GraphObject} This may return the same object, if the link is reflexive.
*/
Link.prototype.getOtherPort = function(port) {
  if (Debug) Util.checkClass(port, GraphObject, Link, 'getOtherPort:port');
  var from = this.fromPort;
  if (port === from)
    return this.toPort;
  else
    return from;
};


/**
* This read-only property is true when this Link has any label Nodes, {@link Node}s that are owned by this Link
* and are arranged along its path.
* @name Link#isLabeledLink
* @function.
* @return {boolean}
* @see #labelNodes
* @since 1.1
*/
/** @type {boolean} */
Link.prototype.isLabeledLink;
Util.defineReadOnlyProperty(Link, { isLabeledLink: 'isLabeledLink' },
  /** @this {Link} */
  function() {
    if (this._labelNodes === null) return false;
    return this._labelNodes.count > 0;
  }
);

/**
* Gets an iterator over the {@link Node}s that act as labels on this Link.
* Setting {@link Node#labeledLink} to refer to this Link
* will add that {@link Node} to this collection.
* <p/>
* Do not confuse these {@link Node}s with the {@link GraphObject}s that
* are part of this {@link Link} {@link Panel}.
* Those objects can also be used as "labels", but not as objects to which
* there can be link connections, because those panel elements cannot be {@link Node}s.
* Those panel objects can be used for other purposes too, such as arrowheads.
* <p>
* A template should not have any label nodes.
* @name Link#labelNodes
* @function.
* @return {Iterator}
* @see #isLabeledLink
*/
/** @type {Iterator} */
Link.prototype.labelNodes;
Util.defineReadOnlyProperty(Link, { labelNodes: 'labelNodes'},
  /** @this {Link} */
  function() {
    if (this._labelNodes === null) return Util.EmptyIterator;
    return this._labelNodes.iterator;
  }
);

/**
* @ignore
* @this {Link}
* @param {Node} node
*/
Link.prototype.addLabelNodeInternal = function(node) {
  if (this._labelNodes === null) this._labelNodes = new Set(Node);
  this._labelNodes.add(node);
  this.invalidateMeasure();
};

/**
* @ignore
* @this {Link}
* @param {Node} node
*/
Link.prototype.removeLabelNodeInternal = function(node) {
  if (this._labelNodes === null) return;
  this._labelNodes.remove(node);
  this.invalidateMeasure();
};


/**
* @ignore
* @this {Link}
*/
Link.prototype.internalAddProtected = function() {
  Part.prototype.internalAddProtected.call(this);

  if (this._jumpsOver()) this.invalidateOtherJumpOvers(this.actualBounds);

  var from = this._fromNode;
  var to = this._toNode;

  if (from !== null) {
    var port = this.fromPort;
    if (port !== null) port._portInfo = null;
    from.addLinkInternal(this, port);
    this.updateLinkBundleAdd();
  }

  if (to !== null) {
    var port = this.toPort;
    if (port !== null) port._portInfo = null;
    to.addLinkInternal(this, port);
    this.updateLinkBundleAdd();
  }
};

/**
* @ignore
* @this {Link}
*/
Link.prototype.internalRemoveProtected = function() {
  Part.prototype.internalRemoveProtected.call(this);

  if (this._jumpsOver()) this.invalidateOtherJumpOvers(this.actualBounds);

  var from = this._fromNode;
  var to = this._toNode;

  // do the following instead of: this.fromNode = null;
  if (from !== null) {
    var port = this.fromPort;
    if (port !== null) port._portInfo = null;
    from.removeLinkInternal(this, port);
    this.updateLinkBundleRemove();
  }

  // do the following instead of: this.toNode = null;
  if (to !== null) {
    var port = this.toPort;
    if (port !== null) port._portInfo = null;
    to.removeLinkInternal(this, port);
    this.updateLinkBundleRemove();
  }
};

/**
* @ignore
* @this {Link}
*/
Link.prototype.deleteCascade = function() {
  // delete any label nodes
  if (this._labelNodes !== null) {
    var diagram = this.diagram;
    if (diagram === null) return;
    var nodes = this._labelNodes.copy();
    var nit = nodes.iterator;
    while (nit.next()) {
      var node = nit.value;
      diagram.remove(node);
    }
  }

  // don't call the base method!
  //Part.prototype.deleteCascade.call(this);
  // handle link data differently:
  var data = this.data;
  if (data !== null) {
    var diagram = this.diagram;
    if (diagram !== null) {
      var model = diagram.model;
      if (model instanceof GraphLinksModel) {
        model.removeLinkData(data);
      } else if (model instanceof TreeModel) {
        model.setParentKeyForNodeData(data, undefined);
      }
    }
  }
};


Link.prototype['move'] =
/**
* Move this link to a new position.
* This also shifts all of the Points in the route accordingly.
* @this {Link}
* @param {Point} newpos a new {@link Point} in document coordinates.
*/
Link.prototype.move = function(newpos) {
  var oldpos = this.position;
  var oldx = oldpos.x;
  if (isNaN(oldx)) oldx = 0;
  var oldy = oldpos.y;
  if (isNaN(oldy)) oldy = 0;
  var dx = newpos.x - oldx;
  var dy = newpos.y - oldy;
  Part.prototype.move.call(this, newpos);
  this.movePoints(dx, dy);
  var lit = this.labelNodes;
  while (lit.next()) {
    var lab = lit.value;
    var oldp = lab.position;
    lab.moveTo(oldp.x + dx, oldp.y + dy);
  }
};


/**
* Gets or sets whether the user may reconnect an existing link at the "from" end.
* This affects the behavior of the {@link RelinkingTool}.
* <p>
* The initial value is false.
* @name Link#relinkableFrom
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Link.prototype.relinkableFrom;
Util.exportProperty(Link, 'relinkableFrom', Link.prototype.relinkableFrom);
Util.defineProperty(Link, { relinkableFrom: 'relinkableFrom'},
  /** @this {Link} */
  function() { return this._relinkableFrom; },
  /** @this {Link} */
  function(val) {
    var old = this._relinkableFrom;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', Link, 'relinkableFrom');
      this._relinkableFrom = val;
      this.raiseChanged('relinkableFrom', old, val);
    }
  }
);


/**
* Gets or sets whether the user may reconnect an existing link at the "to" end.
* This affects the behavior of the {@link RelinkingTool}.
* <p>
* The initial value is false.
* @name Link#relinkableTo
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Link.prototype.relinkableTo;
Util.exportProperty(Link, 'relinkableTo', Link.prototype.relinkableTo);
Util.defineProperty(Link, { relinkableTo: 'relinkableTo'},
  /** @this {Link} */
  function() { return this._relinkableTo; },
  /** @this {Link} */
  function(val) {
    var old = this._relinkableTo;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', Link, 'relinkableTo');
      this._relinkableTo = val;
      this.raiseChanged('relinkableTo', old, val);
    }
  }
);

/**
* This predicate returns true if {@link #relinkableFrom} is true,
* if the layer's {@link Layer#allowRelink} is true, and
* if the diagram's {@link Diagram#allowRelink} is true.
* @expose
* @this {Link}
* @return {boolean} true if the user may relink the From end of this link.
*/
Link.prototype.canRelinkFrom = function() {
  if (!this.relinkableFrom) return false;
  var layer = this.layer;
  if (layer !== null && !layer.allowRelink) return false;
  var diagram = layer.diagram;
  if (diagram !== null && !diagram.allowRelink) return false;
  return true;
};

/**
* This predicate returns true if {@link #relinkableTo} is true,
* if the layer's {@link Layer#allowRelink} is true, and
* if the diagram's {@link Diagram#allowRelink} is true.
* @expose
* @this {Link}
* @return {boolean} true if the user may relink the To end of this link.
*/
Link.prototype.canRelinkTo = function() {
  if (!this.relinkableTo) return false;
  var layer = this.layer;
  if (layer !== null && !layer.allowRelink) return false;
  var diagram = layer.diagram;
  if (diagram !== null && !diagram.allowRelink) return false;
  return true;
};


/**
* Gets or sets whether the user may change the number of segments in this Link,
* if the link has straight segments.
* This affects the behavior of the {@link LinkReshapingTool} when {@link #curve} is not {@link Link.Bezier}.
* <p>
* The initial value is false.
* @name Link#resegmentable
* @function.
* @return {boolean}
* @since 1.2
*/
/** @type {boolean} */
Link.prototype.resegmentable;
Util.exportProperty(Link, 'resegmentable', Link.prototype.resegmentable);
Util.defineProperty(Link, { resegmentable: 'resegmentable'},
  /** @this {Link} */
  function() { return this._resegmentable; },
  /** @this {Link} */
  function(val) {
    var old = this._resegmentable;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', Link, 'resegmentable');
      this._resegmentable = val;
      this.raiseChanged('resegmentable', old, val);
    }
  }
);

/**
* Gets or sets whether this Link is part of the tree for tree operations
* such as {@link Node#findTreeChildrenNodes} or {@link Node#collapseTree}.
* <p>
* The initial value is true.
* @name Link#isTreeLink
* @function.
* @return {boolean}
* @since 1.2
*/
/** @type {boolean} */
Link.prototype.isTreeLink;
Util.exportProperty(Link, 'isTreeLink', Link.prototype.isTreeLink);
Util.defineProperty(Link, { isTreeLink: 'isTreeLink' },
  /** @this {Link} */
  function() { return this._isTreeLink; },
  /** @this {Link} */
  function(val) {
    var old = this._isTreeLink;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'boolean', Link, 'isTreeLink');
      this._isTreeLink = val;
      this.raiseChanged('isTreeLink', old, val);
    }
  }
);


/**
* Gets the {@link Shape} representing the path of this Link.
* <p/>
* The value depends on there being an element in this Link that is
* a {@link Shape} and that has {@link GraphObject#isPanelMain} set to true.
* This shape is what displays the stroke going from one node to another node.
* <p/>
* This path shape's geometry is automatically generated based on the {@link #points}
* of this link's route, depending on other properties such as {@link #curve}.
* <p/>
* If there is no Shape with {@link GraphObject#isPanelMain} set to true,
* the Link will use the first Shape for its path.
* @name Link#path
* @function.
* @return {Shape}
*/
/** @type {Shape} */
Link.prototype.path;
Util.defineReadOnlyProperty(Link, { path: 'path'},
  /** @this {Link} */
  function() {
    var path = this._path;
    if (path !== null) return path;
    var children = this._elements;
    var l = children.length;
    var main = this.getMainChild(children, l);
    if (main instanceof Shape) {
      this._path = main;  // cache this object
      return main;
    }
    return null;
  }
);

/**
* @ignore
* @this {Link}
*/
Link.prototype._getPath = function() {
  return this.path;
};

/**
* @ignore
* @this {Link}
*/
Link.prototype._getPoints = function() {
  return this._points;
};

/**
* @ignore
* Gets the bounds of the points of the route, in document coordinates.
* @this {Link}
* @return {Rect}
*/
Link.prototype._getRouteBounds = function() {
  //??? cache the _routeBounds
  this.updateRoute();
  var rb = new Rect();
  this.computeBounds(rb);
  this._previousBounds = rb;
  return rb;
};

/**
* @ignore
* Gets the bounds of the points of the route, in document coordinates.
* @this {Link}
* @return {Rect}
*/
Link.prototype._getPreviousBounds = function() {
  return this._previousBounds;
};

/**
* @ignore
* @this {Link}
* @param {Rect} result
* @return {Rect}
*/
Link.prototype.computeBounds = function(result) {
  var bx = Infinity;
  var by = Infinity;
  var numpts = this.pointsCount;
  if (numpts === 0) {
    result._set(NaN, NaN, 0, 0);  // no location means call UpdatePoints/ComputeBounds again
    return result;
  } else if (numpts === 1) {
    var p = this.getPoint(0);
    bx = Math.min(p.x, bx);
    by = Math.min(p.y, by);
    result._set(p.x, p.y, 0, 0);
  } else if (numpts === 2) {
    var p0 = this.getPoint(0);
    var p1 = this.getPoint(1);
    bx = Math.min(p0.x, p1.x);
    by = Math.min(p0.y, p1.y);
    result._set(p0.x, p0.y, 0, 0);
    result.unionPoint(p1);
  } else {
    if (this.computeCurve() === Link.Bezier && numpts >= 3 && !this.isOrthogonal) {
      var start = this.getPoint(0);
      bx = start.x;
      by = start.y;
      result._set(bx, by, 0, 0);
      if (numpts === 3) {
        var ctrl = this.getPoint(1);
        bx = Math.min(ctrl.x, bx);
        by = Math.min(ctrl.y, by);
        var end = this.getPoint(2);
        bx = Math.min(end.x, bx);
        by = Math.min(end.y, by);
        Geo.bezierBounds(start.x, start.y, ctrl.x, ctrl.y, ctrl.x, ctrl.y, end.x, end.y, 0.5, result);
      } else {
        var startControl, endControl, end;
        for (var i = 3; i < numpts; i += 3) {
          startControl = this.getPoint(i - 2);
          // if it's the last segment, use the last two points
          if (i + 3 >= numpts)
            i = numpts - 1;
          endControl = this.getPoint(i - 1);
          end = this.getPoint(i);
          Geo.bezierBounds(start.x, start.y, startControl.x, startControl.y, endControl.x, endControl.y, end.x, end.y, 0.5, result);  //?? epsilon
          bx = Math.min(end.x, bx);
          by = Math.min(end.y, by);
          start = end;
        }
      }
    } else {
      var p0 = this.getPoint(0);
      var p1 = this.getPoint(1);
      bx = Math.min(p0.x, p1.x);
      by = Math.min(p0.y, p1.y);
      result._set(p0.x, p0.y, 0, 0);
      result.unionPoint(p1);
      for (var i = 2; i < numpts; i++) {
        var pt = this.getPoint(i);
        bx = Math.min(pt.x, bx);
        by = Math.min(pt.y, by);
        result.unionPoint(pt);
      }

    }
  }
  this._tempOrigin._set(bx - result.x, by - result.y);
  return result;
};

/**
* Gets the point at the middle of the path.
* @name Link#midPoint
* @function.
* @return {Point}
*/
/** @type {Point} */
Link.prototype.midPoint;
Util.defineReadOnlyProperty(Link, { midPoint: 'midPoint'},
  /** @this {Link} */
  function() {
    this.updateRoute();
    return this.computeMidPoint(new Point());  //??? cache value
  }
);

/**
* @ignore
* Compute the point at the middle of the route.
* @expose
* @this {Link}
* @param {Point} result
* @return {Point}
*/
Link.prototype.computeMidPoint = function(result) {
  var numpts = this.pointsCount;
  if (numpts === 0) {  // no point means call UpdatePoints/ComputeMidPoint again
    result.assign(Geo.NoPoint);
    return result;
  } else if (numpts === 1) {
    result.assign(this.getPoint(0));
    return result;
  } else if (numpts === 2) {
    var a = this.getPoint(0);
    var b = this.getPoint(1);
    result._set((a.x + b.x) / 2, (a.y + b.y) / 2);
    return result;
  }

  if (this.computeCurve() === Link.Bezier && numpts >= 3 && !this.isOrthogonal) {
    if (numpts === 3) return this.getPoint(1);
    var numsegs = ((numpts - 1) / 3) | 0;
    var idx = ((numsegs / 2) | 0) * 3;
    if (numsegs % 2 === 1) {
      var a = this.getPoint(idx);
      var b = this.getPoint(idx + 1);
      var c = this.getPoint(idx + 2);
      var d = this.getPoint(idx + 3);
      Geo.bezierMidPoint(a.x, a.y, b.x, b.y, c.x, c.y, d.x, d.y, result);
      return result;
    } else {
      result.assign(this.getPoint(idx));
      return result;
    }
  }

  var distanceAlongRoute = 0;
  var segmentDistanceQueue = Util.tempArray();
  for (var i = 0; i < numpts - 1; i++) {
    var segmentDistance;
    var a = this.getPoint(i);
    var b = this.getPoint(i + 1);

    //Handle computationally simple Orthogonal cases
    if (Geo.isApproxEqual(a.x, b.x)) {
      segmentDistance = b.y - a.y;
      if (segmentDistance < 0) segmentDistance = -segmentDistance;
      segmentDistanceQueue.push(segmentDistance);
      distanceAlongRoute += segmentDistance;
    } else if (Geo.isApproxEqual(a.y, b.y)) {
      segmentDistance = b.x - a.x;
      if (segmentDistance < 0) segmentDistance = -segmentDistance;
      segmentDistanceQueue.push(segmentDistance);
      distanceAlongRoute += segmentDistance;
    } else {
      //Handle non-Orthogonal lines
      segmentDistance = Math.sqrt(a.distanceSquaredPoint(b));
      segmentDistanceQueue.push(segmentDistance);
      distanceAlongRoute += segmentDistance;
    }
  }

  var currentDistance = 0;
  var currentPointIndex = 0;
  var nextSegmentLength = 0;
  while (currentDistance < distanceAlongRoute / 2 && currentPointIndex < numpts) {
    nextSegmentLength = segmentDistanceQueue[currentPointIndex];
    if (currentDistance + nextSegmentLength > distanceAlongRoute / 2) break;
    currentDistance += nextSegmentLength;
    currentPointIndex++;
  }
  Util.freeArray(segmentDistanceQueue);
  var currentPoint = this.getPoint(currentPointIndex);
  var nextPoint = this.getPoint(currentPointIndex + 1);

  // Handle Orthogonal cases first
  if (currentPoint.x === nextPoint.x) {
    if (currentPoint.y > nextPoint.y)
      result._set(currentPoint.x, currentPoint.y - (distanceAlongRoute / 2 - currentDistance));
    else
      result._set(currentPoint.x, currentPoint.y + (distanceAlongRoute / 2 - currentDistance));
  } else if (currentPoint.y === nextPoint.y) {
    if (currentPoint.x > nextPoint.x)
      result._set(currentPoint.x - (distanceAlongRoute / 2 - currentDistance), currentPoint.y);
    else
      result._set(currentPoint.x + (distanceAlongRoute / 2 - currentDistance), currentPoint.y);
  } else { // Handle non-Orthogonal lines
    var similarTriangleRatio = (distanceAlongRoute / 2 - currentDistance) / nextSegmentLength;
    var dx = similarTriangleRatio * (nextPoint.x - currentPoint.x);
    var dy = similarTriangleRatio * (nextPoint.y - currentPoint.y);

    result._set(currentPoint.x + dx, currentPoint.y + dy);
  }
  return result;
};

/**
* Gets the angle of the path at the {@link #midPoint}.
* @name Link#midAngle
* @function.
* @return {number}
*/
/** @type {number} */
Link.prototype.midAngle;
Util.defineReadOnlyProperty(Link, { midAngle: 'midAngle'},
  /** @this {Link} */
  function() {
    this.updateRoute();
    return this.computeMidAngle();  //??? cache value
  }
);

/**
* @ignore
* Compute the angle of the route at the {@link #midPoint}.
* @expose
* @this {Link}
* @return {number}
*/
Link.prototype.computeMidAngle = function() {
  var numpts = this.pointsCount;
  if (numpts < 2) return NaN;  // no angle means call ComputeMidAngle again

  if (this.computeCurve() === Link.Bezier && numpts >= 4 && !this.isOrthogonal) {
    var numsegs = ((numpts - 1) / 3) | 0;
    var idx = ((numsegs / 2) | 0) * 3;
    if (numsegs % 2 === 1) {
      idx = Math.floor(idx);
      var a = this.getPoint(idx);
      var b = this.getPoint(idx + 1);
      var c = this.getPoint(idx + 2);
      var d = this.getPoint(idx + 3);
      return Geo.bezierMidAngle(a.x, a.y, b.x, b.y, c.x, c.y, d.x, d.y);
    } else {
      if (idx > 0 && idx + 1 < numpts) {
        var a = this.getPoint(idx - 1);
        var b = this.getPoint(idx + 1);
        return a.directionPoint(b);
      }
      // else drop through and treat as a non-Bezier-curve
    }
  }

  var midEnd = (numpts / 2) | 0;
  if (numpts % 2 === 0) {  // even number of points means odd number of segments
    // get the middle segment (perhaps the only one)
    var a = this.getPoint(midEnd - 1);
    var b = this.getPoint(midEnd);
    return a.directionPoint(b);
  } else {
    // also find the points on either side of the middle point
    // then figure out if one segment is much longer than the other
    var a = this.getPoint(midEnd - 1);
    var b = this.getPoint(midEnd);
    var c = this.getPoint(midEnd + 1);
    var d1 = a.distanceSquaredPoint(b);
    var d2 = b.distanceSquaredPoint(c);
    if (d1 > d2)
      return a.directionPoint(b);
    else
      return b.directionPoint(c);
  }
};

//* If you do want to modify the route without replacing the whole list of points,
//* call {@link #startRoute} first, some number of calls to
//* methods such as {@link #addPoint} or {@link #setPoint},
//* followed by a call to {@link #commitRoute}.

/**
* Gets or sets the {@link List} of {@link Point}s in the route.
* Although this list may be replaced by setting this property,
* one must not modify the contents of the List directly.
* <p/>
* Ownership of the {@link List} and all of its {@link Point}s that is provided to the setter
* is transferred to this Link.
* @name Link#points
* @function.
* @return {List}
*/
/** @type {List} */
Link.prototype.points;
Util.exportProperty(Link, 'points', Link.prototype.points);
Util.defineProperty(Link, { points: 'points'},
  /** @this {Link} */
  function() { return this._points; },
  /** @this {Link} */
  function(val) {
    if (Debug) Util.checkClass(val, List, Link, 'points');
    var old = this._points;
    if (old !== val && val !== null) {
      // gotta allocate a new List for undo/redo recognition
      // but the Points are not copied from the original VAL
      val = val.copy();
      // freeze the new List and each of its Points
      var pit = val.iterator;
      while (pit.next()) {
        var p = pit.value;
        p.freeze();
      }
      val.freeze();
      this._points = val;
      this.invalidateGeometry();
      this._validateRoute();
      this.raiseChanged('points', old, val);
    }
  }
);

/**
* Gets the number of points in the route.
* @name Link#pointsCount
* @function.
* @return {number}
*/
/** @type {number} */
Link.prototype.pointsCount;
Util.defineReadOnlyProperty(Link, { pointsCount: 'pointsCount'},
  /** @this {Link} */
  function() { return this._points.count; }
);

Link.prototype['getPoint'] =
/**
* Gets a particular point of the route.
* @this {Link}
* @param {number} i  The zero-based index of the desired point.
* @return {Point}
*/
Link.prototype.getPoint = function(i) {
  return this._points._arr[i];
};

Link.prototype['setPoint'] =
/**
* @ignore
* Sets a particular point of the route.
* <p/>
* Before modifying the points of this link's route,
* you must first open up the route by calling {@link #startRoute}.
* Afterwards you must call {@link #commitRoute} in order to commit the changes.
* @this {Link}
* @param {number} i  The zero-based index of the desired point.
* @param {Point} p  The new point, which should not have infinite or NaN coordinate values.
*/
Link.prototype.setPoint = function(i, p) {
  if (Debug) {
    Util.checkClass(p, Point, Link, 'setPoint');
    if (!p.isReal()) Util.throwError('Link.setPoint called with a Point that does not have real numbers: ' + p.toString());
  }
  if (this._oldPoints === null) Util.throwError('Call Link.startRoute before modifying the points of the route.');
  this._points.setElt(i, p);
};

Link.prototype['setPointAt'] =
/**
* @ignore
* Sets a particular point of the route.
* <p/>
* Before modifying the points of this link's route,
* you must first open up the route by calling {@link #startRoute}.
* Afterwards you must call {@link #commitRoute} in order to commit the changes.
* @this {Link}
* @param {number} i  The zero-based index of the desired point.
* @param {number} x  The new X, which should not be infinite or NaN.
* @param {number} y  The new Y, which should not be infinite or NaN.
*/
Link.prototype.setPointAt = function(i, x, y) {
  if (Debug) {
    Util.checkRealNumber(x, Link, 'setPointAt:x');
    Util.checkRealNumber(y, Link, 'setPointAt:y');
  }
  if (this._oldPoints === null) Util.throwError('Call Link.startRoute before modifying the points of the route.');
  this._points.setElt(i, new Point(x, y));
};

Link.prototype['insertPoint'] =
/**
* @ignore
* Insert a point at a particular position in the route, without replacing an existing point.
* <p/>
* Before modifying the points of this link's route,
* you must first open up the route by calling {@link #startRoute}.
* Afterwards you must call {@link #commitRoute} in order to commit the changes.
* @this {Link}
* @param {number} i  The zero-based index of the new point.
* @param {Point} p  The new point, which should not have infinite or NaN coordinate values.
*/
Link.prototype.insertPoint = function(i, p) {
  if (Debug) {
    Util.checkClass(p, Point, Link, 'insertPoint');
    if (!p.isReal()) Util.throwError('Link.insertPoint called with a Point that does not have real numbers: ' + p.toString());
  }
  if (this._oldPoints === null) Util.throwError('Call Link.startRoute before modifying the points of the route.');
  this._points.insertAt(i, p);
};

Link.prototype['insertPointAt'] =
/**
* @ignore
* Insert a point at a particular position in the route, without replacing an existing point.
* <p/>
* Before modifying the points of this link's route,
* you must first open up the route by calling {@link #startRoute}.
* Afterwards you must call {@link #commitRoute} in order to commit the changes.
* @this {Link}
* @param {number} i  The zero-based index of the new point.
* @param {number} x  The new X, which should not be infinite or NaN.
* @param {number} y  The new Y, which should not be infinite or NaN.
*/
Link.prototype.insertPointAt = function(i, x, y) {
  if (Debug) {
    Util.checkRealNumber(x, Link, 'insertPointAt:x');
    Util.checkRealNumber(y, Link, 'insertPointAt:y');
  }
  if (this._oldPoints === null) Util.throwError('Call Link.startRoute before modifying the points of the route.');
  this._points.insertAt(i, new Point(x, y));
};

Link.prototype['addPoint'] =
/**
* @ignore
* Add a point at the end of the route.
* <p/>
* Before modifying the points of this link's route,
* you must first open up the route by calling {@link #startRoute}.
* Afterwards you must call {@link #commitRoute} in order to commit the changes.
* @this {Link}
* @param {Point} p  The new point, which should not have infinite or NaN coordinate values.
*/
Link.prototype.addPoint = function(p) {
  if (Debug) {
    Util.checkClass(p, Point, Link, 'addPoint');
    if (!p.isReal()) Util.throwError('Link.addPoint called with a Point that does not have real numbers: ' + p.toString());
  }
  if (this._oldPoints === null) Util.throwError('Call Link.startRoute before modifying the points of the route.');
  this._points.add(p);
};

Link.prototype['addPointAt'] =
/**
* @ignore
* Add a point at the end of the route.
* <p/>
* Before modifying the points of this link's route,
* you must first open up the route by calling {@link #startRoute}.
* Afterwards you must call {@link #commitRoute} in order to commit the changes.
* @this {Link}
* @param {number} x  The new X, which should not be infinite or NaN.
* @param {number} y  The new Y, which should not be infinite or NaN.
*/
Link.prototype.addPointAt = function(x, y) {
  if (Debug) {
    Util.checkRealNumber(x, Link, 'insertPointAt:x');
    Util.checkRealNumber(y, Link, 'insertPointAt:y');
  }
  if (this._oldPoints === null) Util.throwError('Call Link.startRoute before modifying the points of the route.');
  this._points.add(new Point(x, y));
};

Link.prototype['removePoint'] =
/**
* @ignore
* Remove a particular point from the route.
* <p/>
* Before modifying the points of this link's route,
* you must first open up the route by calling {@link #startRoute}.
* Afterwards you must call {@link #commitRoute} in order to commit the changes.
* @this {Link}
* @param {number} i  The zero-based index of the point to extract.
*/
Link.prototype.removePoint = function(i) {
  if (this._oldPoints === null) Util.throwError('Call Link.startRoute before modifying the points of the route.');
  this._points.removeAt(i);
};

Link.prototype['clearPoints'] =
/**
* @ignore
* Remove all of the points from this link's route.
* <p/>
* Before modifying the points of this link's route,
* you must first open up the route by calling {@link #startRoute}.
* Afterwards you must call {@link #commitRoute} in order to commit the changes.
* @this {Link}
*/
Link.prototype.clearPoints = function() {
  if (this._oldPoints === null) Util.throwError('Call Link.startRoute before modifying the points of the route.');
  this._points.clear();
};

Link.prototype['movePoints'] =
/**
* @ignore
* Shift all of the {@link Point}s in the {@link #points} list by a given offsets.
* <p/>
* You do need not call {@link #startRoute} and {@link #commitRoute} around calling this method,
* because it makes a copy of the list of points and then sets the {@link #points} property.
* @this {Link}
* @param {number} dx
* @param {number} dy
*/
Link.prototype.movePoints = function(dx, dy) {
  var newpts = new List(Point);
  var pit = this._points.iterator;
  while (pit.next()) {
    var p = pit.value;
    newpts.add(new Point(p.x + dx, p.y + dy));
  }
  this.points = newpts;
};

Link.prototype['startRoute'] =
/**
* @ignore
* Allow calls to {@link #setPoint}, {@link #addPoint}, {@link #insertPoint},
* {@link #removePoint}, and {@link #clearPoints}.
* You must call {@link #commitRoute} when you are done modifying the route.
* @this {Link}
*/
Link.prototype.startRoute = function() {
  if (this._oldPoints === null) {
    this._oldPoints = this._points;
    this._points = this._points.copy();  // now the current List is modifiable
  }
};

Link.prototype['commitRoute'] =
/**
* @ignore
* Call this method after a call to {@link #startRoute} and calls to methods that modify the route.
* @this {Link}
*/
Link.prototype.commitRoute = function() {
  if (this._oldPoints === null) return;
  var oldpts = this._oldPoints;
  var pts = this._points;

  // find the old offset
  var ox = Infinity;
  var oy = Infinity;
  var onum = oldpts.count;
  for (var i = 0; i < onum; i++) {
    var p = oldpts._arr[i];
    ox = Math.min(p.x, ox);
    oy = Math.min(p.y, oy);
  }

  // find the new offset
  var nx = Infinity;
  var ny = Infinity;
  var nnum = pts.count;
  for (var i = 0; i < nnum; i++) {
    var p = pts._arr[i];
    nx = Math.min(p.x, nx);
    ny = Math.min(p.y, ny);
    p.freeze();  // make sure all Points in the List are frozen
  }
  pts.freeze();  // and freeze the List itself

  if (nnum === onum) {
    for (var i = 0; i < nnum; i++) {
      var o = oldpts._arr[i];
      var n = pts._arr[i];
      if (o.x - ox !== n.x - nx || o.y - oy !== n.y - ny) {
        this.invalidateGeometry();
        break;
      }
    }
  }

  this._oldPoints = null;
  this._validateRoute();
  this.raiseChanged('points', oldpts, pts);
};

Link.prototype['rollbackRoute'] =
/**
* @ignore
* Call this method instead of {@link #commitRoute} if you need to cancel changes to the route.
* @this {Link}
*/
Link.prototype.rollbackRoute = function() {
  if (this._oldPoints === null) return;
  this._points = this._oldPoints;
  this._oldPoints = null;
};

/**
* @ignore
* @this {Link}
*/
Link.prototype._validateRoute = function() {
  if (this._points.count === 0) {
    this._validRoute = false;
    return;
  }
  this._validRoute = true;
  this._invalidateOtherJumpOversMaybe(false);
};

Link.prototype['invalidateRoute'] =
/**
* @ignore
* @this {Link}
*/
Link.prototype.invalidateRoute = function() {
  if (this._suspendsRouting) return;
  if (this.diagram && this.diagram.undoManager.isUndoingRedoing) return;
  var stroke = this._getPath();
  if (stroke === null) return; // no stroke, no use checking further
  this._validRoute = false;
  this.invalidateGeometry();
  stroke.invalidateMeasure();
};

/** @ignore */
/** @type {boolean} */
Link.prototype.suspendsRouting;
Util.defineProperty(Link, { suspendsRouting: null },
  /** @this {Link} */
  function() { return this._suspendsRouting; },
  /** @this {Link} */
  function(val) { this._suspendsRouting = val; }
);


/**
* @ignore
* This method recomputes the route if the route is invalid.
* This method calls {@link #computePoints} in order to calculate a new route.
* If you just want to make sure the points are up-to-date, call {@link #updateRoute} instead.
* <p/>
* The route may become invalid if either connected node is moved,
* or if various properties are modified, such as {@link #routing}.
* @expose
* @this {Link}
*/
Link.prototype.updateRoute = function() {
  if (this._validRoute) return;
  if (this._computingPoints) return;
  var calc = true;
  try {
    this._computingPoints = true;
    this.startRoute();
    calc = this.computePoints();
  } finally {
    this._computingPoints = false;
    if (calc) this.commitRoute();
    else this.rollbackRoute(); // in case the route is started but never finished
  }
};

/**
* @ignore
* The code that constructs a new route by modifying the {@link #points}.
* It is only called by {@link #updateRoute}.
* @expose
* @this {Link}
*/
Link.prototype.computePoints = function() {
  var fromnode = this.fromNode;
  var fromport = null;
  if (fromnode === null) {
    //??? no fromnNode in computePoints
    fromport = null;
  } else {
    fromport = this.fromPort;
  }
  if (fromport !== null) {
    // is fromport not visible?  try containing elements
    var visfromport = fromport.findVisiblePort();
    if (visfromport === fromnode || !fromnode.isVisible()) {  // fromport and its parents aren't visible
      var visfromnode = fromnode.findVisibleNode();  // is fromnode itself visible?
      if (visfromnode !== null && visfromnode !== fromnode) {  // no, found a containing group
        fromnode = visfromnode;  // use it instead
        fromport = visfromnode.findPort('');  // no parameter -- it wouldn't apply to a different node anyway
      } else {
        fromnode = visfromnode;  // might be null if everything is not visible
      }
    } else {  // either fromport or a parent element within the node is visible
      fromport = visfromport;
    }
  }
  this._tempFromNode = fromnode;
  if (fromnode === null || fromport === null) return false;
  var fromloc = fromnode.location;
  if (!fromloc.isReal()) return false;

  var tonode = this.toNode;
  var toport = null;
  if (tonode === null) {
    //??? no toNode in computePoints
    toport = null;
  } else {
    toport = this.toPort;
  }
  if (toport !== null) {
    // is toport not visible?  try containing elements
    var vistoport = toport.findVisiblePort();
    if (vistoport === tonode || !tonode.isVisible()) {  // toport and its parents aren't visible
      var vistonode = tonode.findVisibleNode();  // is tonode itself visible?
      if (vistonode !== null && vistonode !== tonode) {  // no, found a containing group
        tonode = vistonode;  // use it instead
        toport = vistonode.findPort('');  // no parameter -- it wouldn't apply to a different node anyway
      } else {
        tonode = vistonode;  // might be null if everything is not visible
      }
    } else {  // either toport or a parent element within the node is visible
      toport = vistoport;
    }
  }
  this._tempToNode = tonode;
  if (tonode === null || toport === null) return false;
  var toloc = tonode.location;
  if (!toloc.isReal()) return false;

  var num = this.pointsCount;

  var fromspot = this._getFromSpot(fromport);  // link's Spot takes precedence, if defined
  var tospot = this._getToSpot(toport);  // link's Spot takes precedence, if defined

  var selfloop = (fromport === toport);
  var ortho = this.isOrthogonal;
  var bezier = (this.curve === Link.Bezier);
  if (selfloop && !ortho) {
    bezier = true;
    this._effectiveBezier = true;
  } else {
    this._effectiveBezier = false;
  }
  var calc = (this.adjusting === Link.None) || selfloop;

  if (!ortho && fromspot === Spot.None && tospot === Spot.None && !selfloop) {
    var adjusted = false;
    if (!calc && num >= 3) {
      var pA = this.getLinkPoint(fromnode, fromport, Spot.None, true, false, tonode, toport);
      var pB = this.getLinkPoint(tonode, toport, Spot.None, false, false, fromnode, fromport);
      adjusted = this.adjustPoints(0, pA, num - 1, pB);
    }
    if (!adjusted) {
      this.clearPoints();
      if (bezier) {
        this.calculateBezierNoSpot(fromnode, fromport, tonode, toport);
      } else {
        this.calculateLineNoSpot(fromnode, fromport, tonode, toport);
      }
    }
  } else {  // three segments (four points)
    var avoidsnodes = (this.routing === Link.AvoidsNodes);
    if (calc && ((ortho && avoidsnodes) || selfloop)) this.clearPoints();
    var curviness = this.computeCurviness();

    var fromPoint = this.getLinkPoint(fromnode, fromport, fromspot, true, ortho, tonode, toport);  // newly allocated result
    var Bx = 0;
    var By = 0;
    var fromDir = 0;
    if (ortho || fromspot !== Spot.None || selfloop) {
      // get the length of the beginning segment
      var fromSeg = this.computeEndSegmentLength(fromnode, fromport, fromspot, true);

      // calculate the end point of the initial segment
      fromDir = this.getLinkDirection(fromnode, fromport, fromPoint, fromspot, true, ortho, tonode, toport);
      if (selfloop) {
        fromDir -= (ortho ? 90 : 30);
        if (curviness < 0) {
          fromDir -= 180;
        }
      }
      if (fromDir < 0) fromDir += 360;
      else if (fromDir >= 360) fromDir -= 360;

      if (selfloop) fromSeg += Math.abs(curviness);

      // handle common cases more quickly than by calling Cos and Sin
      if (fromDir === 0) {
        Bx = fromSeg;
      } else if (fromDir === 90) {
        By = fromSeg;
      } else if (fromDir === 180) {
        Bx = -fromSeg;
      } else if (fromDir === 270) {
        By = -fromSeg;
      } else {
        Bx = fromSeg * Math.cos(fromDir * Math.PI / 180);
        By = fromSeg * Math.sin(fromDir * Math.PI / 180);
      }

      // try to accomodate self-loops on nodes that have no spot
      if (fromspot.isNoSpot() && selfloop) {
        var ctr = fromport.getDocumentPoint(Spot.Center, Util.tempPoint());
        var temp = Util.tempPointAt(ctr.x + Bx * 1000, ctr.y + By * 1000);
        this.getLinkPointFromPoint(fromnode, fromport, ctr, temp, true, fromPoint);
        Util.freePoint(ctr);
        Util.freePoint(temp);
      }
    }

    var toPoint = this.getLinkPoint(tonode, toport, tospot, false, ortho, fromnode, fromport);  // newly allocated result
    var Cx = 0;
    var Cy = 0;
    var toDir = 0;
    if (ortho || tospot !== Spot.None || selfloop) {
      // get the length of the ending segment
      var toSeg = this.computeEndSegmentLength(tonode, toport, tospot, false);

      // calculate the start point of the final segment
      toDir = this.getLinkDirection(tonode, toport, toPoint, tospot, false, ortho, fromnode, fromport);
      if (selfloop) {
        toDir += (ortho ? 0 : 30);
        if (curviness < 0) {
          toDir += 180;
        }
      }
      if (toDir < 0) toDir += 360;
      else if (toDir >= 360) toDir -= 360;

      if (selfloop) toSeg += Math.abs(curviness);

      // handle common cases more quickly than by calling Cos and Sin
      if (toDir === 0) {
        Cx = toSeg;
      } else if (toDir === 90) {
        Cy = toSeg;
      } else if (toDir === 180) {
        Cx = -toSeg;
      } else if (toDir === 270) {
        Cy = -toSeg;
      } else {
        Cx = toSeg * Math.cos(toDir * Math.PI / 180);
        Cy = toSeg * Math.sin(toDir * Math.PI / 180);
      }

      // try to accommodate self-loops on nodes that have no spot
      if (tospot.isNoSpot() && selfloop) {
        var ctr = toport.getDocumentPoint(Spot.Center, Util.tempPoint());
        var temp = Util.tempPointAt(ctr.x + Cx * 1000, ctr.y + Cy * 1000);
        this.getLinkPointFromPoint(tonode, toport, ctr, temp, false, toPoint);
        Util.freePoint(ctr);
        Util.freePoint(temp);
      }
    }

    // determine intermediate/control points
    var b = fromPoint;
    if (ortho || fromspot !== Spot.None || selfloop)
      b = new Point(fromPoint.x + Bx, fromPoint.y + By);
    var c = toPoint;
    if (ortho || tospot !== Spot.None || selfloop)
      c = new Point(toPoint.x + Cx, toPoint.y + Cy);

    // only call AdjustPoints when AdjustingStyle is not Calculate, and if it returns true, it was successful
    if (!calc && !ortho && fromspot.isNoSpot() && num > 3 && this.adjustPoints(0, fromPoint, num - 2, c)) {
      this.setPoint(num - 1, toPoint);
    } else if (!calc && !ortho && tospot.isNoSpot() && num > 3 && this.adjustPoints(1, b, num - 1, toPoint)) {
      this.setPoint(0, fromPoint);
    } else if (!calc && !ortho && num > 4 && this.adjustPoints(1, b, num - 2, c)) {
      this.setPoint(0, fromPoint);
      this.setPoint(num - 1, toPoint);
    } else if (!calc && ortho && num >= 6 && !avoidsnodes && this.adjustPoints(1, b, num - 2, c)) {
      this.setPoint(0, fromPoint);
      this.setPoint(num - 1, toPoint);
    } else {  // calculate standard four (non-ortho) or six (ortho) point stroke
      this.clearPoints();

      // add the initial point
      this.addPoint(fromPoint);

      if (ortho || fromspot !== Spot.None || selfloop)
        this.addPoint(b);

      if (ortho) {
        this.addOrthoPoints(b, fromDir, c, toDir, fromnode, tonode);
      }

      if (ortho || tospot !== Spot.None || selfloop)
        this.addPoint(c);

      // add the final endpoint
      this.addPoint(toPoint);
    }
  }
  // there was an "???" here for no reason, look at goxam to make sure nothing is missing
  return true;
};

/**
* @ignore
* @this {Link}
* @param {Point} c  the central point.
* @param {Point} p  the orientation point; this is then modified and returned.
* @return {Point}  this has either X or Y be a huge value.
*/
Link.prototype._orthoPointToward = function(c, p) {
  if (Math.abs(p.x - c.x) > Math.abs(p.y - c.y)) {
    if (p.x >= c.x)
      p.x = c.x + 9e9;
    else
      p.x = c.x - 9e9;
    p.y = c.y;
  } else {
    if (p.y >= c.y)
      p.y = c.y + 9e9;
    else
      p.y = c.y - 9e9;
    p.x = c.x;
  }
  return p;
};

/**
* Compute the intersection point for the edge of a particular port GraphObject, given a point,
* when no particular spot or side has been specified.
* @expose
* @this {Link}
* @param {Node} node
* @param {GraphObject} port the {@link GraphObject} representing a port on the node.
* @param {Point} focus the point in document coordinates to/from which the link should point,
*   normally the center of the port.
* @param {Point} p often this point is far away from the node, to give a general direction,
*   particularly an orthogonal one.
* @param {boolean} from true if the link is coming out of the port; false if going to the port.
* @param {Point=} result an optional Point that is modified and returned; otherwise it allocates and returns a new Point
* @return {Point} the point in document coordinates of the intersection point on the edge of the port.
* @since 1.2
*/
Link.prototype.getLinkPointFromPoint = function(node, port, focus, p, from, result) {
  if (result === undefined/*notpresent*/) result = new Point();
  if (node === null || port === null) {
    result.assign(focus);
    return result;
  }
  if (!node.isVisible()) {
    var vnode = node.findVisibleNode();
    if (vnode !== null && vnode !== node) {
      node = vnode;
      port = node.port;
    }
  }

  //??? var portb = node.getDocumentBounds(port);
  //??? if (!portb.containsPoint(focus)) focus = portb.center;
  // if the "distant" point is inside the port, just use the port's center, to reduce visual confusion
  //??? if (portb.containsPoint(p)) { result.assign(focus); return result; }

  /*
  // otherwise get the closest edge point on the line from P to CTR
  var nodeLoc = node.location;
  // Convert p1/p2 to node coordinates
  var p1x = p.x - nodeLoc.x;
  var p1y = p.y - nodeLoc.y;
  var p2x = focus.x - nodeLoc.x;
  var p2y = focus.y - nodeLoc.y;
  */

  var p1x, p1y, p2x, p2y;
  var tt = null;
  if (port.panel === null) {
    p1x = p.x;
    p1y = p.y;
    p2x = focus.x;
    p2y = focus.y;
  } else {
    tt = port.panel.allTransforms;
    // inverted transform point:
    var d = 1 / (tt.m11 * tt.m22 - tt.m12 * tt.m21);
    var m0 = tt.m22 * d;
    var m1 = -tt.m12 * d;
    var m2 = -tt.m21 * d;
    var m3 = tt.m11 * d;
    var m4 = d * (tt.m21 * tt.dy - tt.m22 * tt.dx);
    var m5 = d * (tt.m12 * tt.dx - tt.m11 * tt.dy);
    p1x = p.x * m0 + p.y * m2 + m4;
    p1y = p.x * m1 + p.y * m3 + m5;

    p2x = focus.x * m0 + focus.y * m2 + m4;
    p2y = focus.x * m1 + focus.y * m3 + m5;
  }

  // get the element whose edge we'll use (which is normally the same element)
  port.getNearestIntersectionPoint2(p1x, p1y, p2x, p2y, result);
  if (tt) result.transform(tt);
  return result;
};

/**
* @ignore
* @this {Link}
* @param {GraphObject} port
* @param {Link} link
* @return {LinkInfo}
*/
Link.prototype._findExistingLinkInfo = function(port, link) {  // does not update
  var knot = port._portInfo;
  if (knot !== null) return knot.findLinkInfo(link);
  return null;
};

/**
* @ignore
* @this {Link}
* @param {GraphObject} port
* @param {Link} link
* @return {LinkInfo}
*/
Link.prototype._findLinkInfo = function(port, link) {  // updates if needed
  var knot = port._portInfo;
  if (knot === null) {
    knot = new Knot();
    knot.port = port;
    knot.node = port.part;
    port._portInfo = knot;
  }
  return knot.findLinkInfo(link);
};

/**
* Compute the point on a node/port at which the route of a link should end.
* @expose
* @this {Link}
* @param {Node} node
* @param {GraphObject} port the {@link GraphObject} representing a port on the node.
* @param {Spot} spot a {@link Spot} value describing where the link should connect.
* @param {boolean} from true if the link is coming out of the port; false if going to the port.
* @param {boolean} ortho whether the link should have orthogonal segments.
* @param {Node} othernode the node at the other end of the link.
* @param {GraphObject} otherport the {@link GraphObject} port at the other end of the link.
* @param {Point=} result an optional Point that is modified and returned; otherwise it allocates and returns a new Point
* @return {Point} in document coordinates.
* @since 1.2
*/
Link.prototype.getLinkPoint = function(node, port, spot, from, ortho, othernode, otherport, result) {
  if (result === undefined/*notpresent*/) result = new Point();

  if (spot.isSpot()) {
    port.getDocumentPoint(spot, result);
    return result;
  } else if (spot.isSide()) {
    var info = this._findLinkInfo(port, this);
    if (info !== null) {
      var ilp = info.linkPoint;  // specific value for that link
      // if there's no port extension, just return the FOCUS point
      /*??? if (port1 === port) */
      result.assign(ilp);
      return result;
    }
  }

  var focus = port.getDocumentPoint(Spot.Center, Util.tempPoint());
  var temp = null;
  var far;
  // no defined spot or side -- need to calculate nearest intersection
  // of port's edge with line to focus point from some "far" point
  if (this.pointsCount > (ortho ? 6 : 2)) {  // try using the existing points in the route
    far = from ? this.getPoint(1) : this.getPoint(this.pointsCount - 2);
    if (ortho) {
      far = this._orthoPointToward(focus, far.copy());
    } else {
      // if the far point is inside the port, try another point "farther" along the route
      //??? var b = port.getDocumentBounds();
      //??? var i = 2;
      //??? while (b.containsPoint(far) && i < this.pointsCount) {
      //???   far = from ? this.getPoint(i) : this.getPoint(this.pointsCount-1-i);
      //???   i++;
      //??? }
      //??? if (i >= this.pointsCount) far = otherport.getDocumentPoint(Spot.Center, ???);

      //???far = from ? this.getPoint(this.pointsCount-1) : this.getPoint(0);  //???
    }
  } else {
    temp = Util.tempPoint();
    far = otherport.getDocumentPoint(Spot.Center, temp);
    if (ortho) {
      far = this._orthoPointToward(focus, far);
    }
  }

  this.getLinkPointFromPoint(node, port, focus, far, from, result);
  Util.freePoint(focus);
  if (temp !== null) Util.freePoint(temp);
  return result;
};

/**
* Compute the direction in which a link should go from a given connection point.
* @expose
* @this {Link}
* @param {Node} node
* @param {GraphObject} port the {@link GraphObject} representing a port on the node.
* @param {Point} linkpoint the connection point, in document coordinates.
* @param {Spot} spot a {@link Spot} value describing where the link should connect.
* @param {boolean} from true if the link is coming out of the port; false if going to the port.
* @param {boolean} ortho whether the link should have orthogonal segments.
* @param {Node} othernode the node at the other end of the link.
* @param {GraphObject} otherport the {@link GraphObject} port at the other end of the link.
* @return {number} the absolute angle, in degrees.
* @since 1.2
*/
Link.prototype.getLinkDirection = function(node, port, linkpoint, spot, from, ortho, othernode, otherport) {
  var angle = this._getLinkDirection1(node, port, linkpoint, spot, from, ortho, othernode, otherport);
  var dirtype = Node.DirectionDefault;
  if (from) {
    dirtype = this.fromEndSegmentDirection;
  } else {
    dirtype = this.toEndSegmentDirection;
  }
  if (dirtype === Node.DirectionDefault) {
    if (from) {
      dirtype = port.fromEndSegmentDirection;
    } else {
      dirtype = port.toEndSegmentDirection;
    }
  }
  switch (dirtype) {
    case Node.DirectionAbsolute:
      break;
    case Node.DirectionRotatedNode: {
      var rot = port.getDocumentAngle();
      angle += rot;
      if (angle >= 360) angle -= 360;
      break;
    }
    case Node.DirectionDefault:
    case Node.DirectionRotatedNodeOrthogonal: {
      var rot = port.getDocumentAngle();
      if (rot === 0) break;
      if (45 <= rot && rot < 135) angle += 90;
      else if (135 <= rot && rot < 225) angle += 180;
      else if (225 <= rot && rot < 315) angle += 270;
      if (angle >= 360) angle -= 360;
      break;
    }
  }
  return angle;
};

/**
* @ignore
* @this {Link}
* @param {Node} node
* @param {GraphObject} port the {@link GraphObject} representing a port on the node.
* @param {Point} linkpoint the connection point, in document coordinates.
* @param {Spot} spot a {@link Spot} value describing where the link should connect.
* @param {boolean} from true if the link is coming out of the port; false if going to the port.
* @param {boolean} ortho whether the link should have orthogonal segments.
* @param {Node} othernode the node at the other end of the link.
* @param {GraphObject} otherport the {@link GraphObject} port at the other end of the link.
* @return {number} the absolute angle, in degrees.
*/
Link.prototype._getLinkDirection1 = function(node, port, linkpoint, spot, from, ortho, othernode, otherport) {
  if (spot.isSpot()) {  // specific spot is defined
    if (spot.x > spot.y) {
      if (spot.x > 1 - spot.y) {
        return 0;
      } else if (spot.x < 1 - spot.y) {
        return 270;
      } else {
        return 315;
      }
    } else if (spot.x < spot.y) {
      if (spot.x > 1 - spot.y) {
        return 90;
      } if (spot.x < 1 - spot.y) {
        return 180;
      } else {
        return 135;
      }
    } else {
      if (spot.x < 0.5) {
        return 225;
      } else if (spot.x > 0.5) {
        return 45;
      } else {
        return 0;
      }
    }
  }
  if (spot.isSide()) {
    var info = this._findLinkInfo(port, this);
    if (info !== null) {
      switch (info.side) {
        case Util.MTop: return 270;
        case Util.MLeft: return 180;
        default:
        case Util.MRight: return 0;
        case Util.MBottom: return 90;
      }
    }
  }
  // no defined spot -- guess direction based on other points
  // in the route, if any
  var c = port.getDocumentPoint(Spot.Center, Util.tempPoint());
  var temp = null;
  var far;
  if (this.pointsCount > (ortho ? 6 : 2)) {
    far = from ? this.getPoint(1) : this.getPoint(this.pointsCount - 2);
    if (ortho) {
      far = this._orthoPointToward(c, far.copy());
    } else {
      far = linkpoint;
    }
  } else {
    temp = Util.tempPoint();
    far = otherport.getDocumentPoint(Spot.Center, temp);
  }
  var result;
  if (Math.abs(far.x - c.x) > Math.abs(far.y - c.y)) {
    if (far.x >= c.x)
      result = 0;
    else
      result = 180;
  } else {
    if (far.y >= c.y)
      result = 90;
    else
      result = 270;
  }
  Util.freePoint(c);
  if (temp !== null) Util.freePoint(temp);
  return result;
};

/**
* @ignore
* Get the length of the end segment, typically a short distance, in document units.
* @expose
* @this {Link}
* @param {Node} node
* @param {GraphObject} port the {@link GraphObject} representing a port on the node.
* @param {Spot} spot a {@link Spot} value describing where the link should connect.
* @param {boolean} from true if the link is coming out of the port; false if going to the port.
* @return {number} a distance in document coordinates.
*/
Link.prototype.computeEndSegmentLength = function(node, port, spot, from) {
  if (spot.isSide()) {
    var info = this._findLinkInfo(port, this);
    if (info !== null) return info.endSegmentLength;  // specific value for that link
  }
  var esl = NaN;
  if (from) {
    esl = this.fromEndSegmentLength;
  } else {
    esl = this.toEndSegmentLength;
  }
  if (isNaN(esl)) {
    if (from) {
      esl = port.fromEndSegmentLength;
    } else {
      esl = port.toEndSegmentLength;
    }
  }
  if (isNaN(esl)) esl = 10;
  return esl;
};


/**
* @ignore
* @expose
* @this {Link}
* @param {boolean} from
* @return {Spot}
*/
Link.prototype.computeSpot = function(from) {
  if (from) {
    return this._getFromSpot(this.fromPort);
  } else {
    return this._getToSpot(this.toPort);
  }
};

/**
* @ignore
* @this {Link}
* @param {GraphObject=} port
* @return {Spot}
*/
Link.prototype._getFromSpot = function(port) {
  var s = this.fromSpot;
  if (s.isDefault()) {
    if (port === undefined/*notpresent*/) port = this.fromPort;
    if (port !== null) {
      s = port.fromSpot;
    }
  }
  if (s === Spot.Default) return Spot.None;
  return s;
};

/**
* @ignore
* @this {Link}
* @param {GraphObject=} port
* @return {Spot}
*/
Link.prototype._getToSpot = function(port) {
  var s = this.toSpot;
  if (s.isDefault()) {
    if (port === undefined/*notpresent*/) port = this.toPort;
    if (port !== null) {
      s = port.toSpot;
    }
  }
  if (s === Spot.Default) return Spot.None;
  return s;
};


/**
* @ignore
* @expose
* @this {Link}
* @param {boolean} from
* @return {number}
*/
Link.prototype.computeShortLength = function(from) {
  if (from) {
    return this._getFromShortLength();
  } else {
    return this._getToShortLength();
  }
};

/**
* @ignore
* @this {Link}
* @return {number}
*/
Link.prototype._getFromShortLength = function() {
  var s = this.fromShortLength;
  if (isNaN(s)) {
    var port = this.fromPort;
    if (port !== null) {
      s = port.fromShortLength;
    }
  }
  if (isNaN(s)) return 0;
  return s;
};

/**
* @ignore
* @this {Link}
* @return {number}
*/
Link.prototype._getToShortLength = function() {
  var s = this.toShortLength;
  if (isNaN(s)) {
    var port = this.toPort;
    if (port !== null) {
      s = port.toShortLength;
    }
  }
  if (isNaN(s)) return 0;
  return s;
};

/**
* @ignore
* @this {Panel}
* @param {Rect} r A Rect in container coordinates.
* @param {function(GraphObject):GraphObject | null} navig A function taking a GraphObject and
* returning a GraphObject, defaulting to the identity.
* @param {function(GraphObject):boolean | null} pred A function taking the GraphObject
* returned by navig and returning true if that object should be returned,
* defaulting to a predicate that always returns true.
* @param {boolean} partialInclusion True if objects are to be included when they
* intersect.
* @param {List|Set} list A List (or Set) to add the results to.
* @param {Transform=} txfm
* @return {boolean} Whether or not this object is included.
*/
Link.prototype.findObjectsIn = function(r, navig, pred, partialInclusion, list, txfm) {
  if (this.pickable === false) return false;
  if (navig === undefined/*notpresent*/) navig = null;
  if (pred === undefined/*notpresent*/) pred = null;
  var transform = txfm;
  if (txfm === undefined/*notpresent*/) {
    transform = Util.tempTransform();
    transform.reset();
  }

  // ??? how do we ensure this works when trueTransform is false?

  transform.multiply(this.transform);
  if (this.containedInRect(r, transform)) { // first 'yes'
    // add to the list "part" and everything inside of "part",
    // going down the object tree using a special function that only tests pred and nothing geometrical,c
    // because by everything inside is already completely within r
    this.addObjs(navig, pred, list);
    if (txfm === undefined/*notpresent*/) Util.freeTransform(transform);
    return true;
  } else if (this.intersectsRect(r, transform)) { // first 'no'
    // 1. We have to go through all the children of "part", invoking "findObjectsIn" on each.
    // We do it regardless of partialInclusion or not, because "part" might have a child that is entirely included,
    // or it may not, and we have no way of knowing yet.
    var result = false;
    if (!this._isAtomic) {
      var l = this._elements.length;
      for (var i = l; i--; ) {
        var child = this._elements._arr[i];
        if (!child.visible && child !== this.locationObject) continue;
        var cab = child.actualBounds;
        var ab = this.naturalBounds;
        if (cab.x > ab.width || cab.y > ab.height || cab.x + cab.width < 0 || cab.y + cab.height < 0) continue;

        var obj = child;
        var tt = Util.tempTransform();
        tt.set(transform);
        if (obj instanceof Panel) {
          result = obj.findObjectsIn(r, navig, pred, partialInclusion, list, tt);
        } else {
          if (this.path === obj) {
            result = obj.findObjectInPath(r, partialInclusion, tt);
          } else {
            result = obj.findObjectIn(r, partialInclusion, tt);
          }
        }
        if (result) {
          if (navig !== null) obj = navig(obj);
          if (obj && (pred === null || pred(obj))) {
            list.add(obj);
          }
        }
        Util.freeTransform(tt);
      }
    }
    if (txfm === undefined/*notpresent*/) Util.freeTransform(transform);
    return (result || this.background !== null || this.areaBackground !== null); // instead of partialInclusion
  }
  // second 'no'
  // nothing added to the list, we are done.
  if (txfm === undefined/*notpresent*/) Util.freeTransform(transform);
  return false;
};

/**
* This read-only property true if {@link #routing} is a value that implies that the points
* of the route should be orthogonal, such that each point shares a common X or a common Y value
* with the immediately previous and next points.
* This property is completely dependent on the {@link #routing} property.
* Values of {@link Link.Orthogonal} and {@link Link.AvoidsNodes} causes this property to be true.
* <p/>
* The points in the route might not actually form an orthogonal route, but when the route is computed
* the intent is to maintain orthogonality.
* @name Link#isOrthogonal
* @function.
* @return {boolean}
* @since 1.2
*/
/** @type {boolean} */
Link.prototype.isOrthogonal;
Util.defineReadOnlyProperty(Link, { isOrthogonal: 'isOrthogonal'},
/** @this {Link} */
  function() {
    var rout = this._routing;
    return rout === Link.Orthogonal || rout === Link.AvoidsNodes;
  }
);

/**
* @ignore
* @param {EnumValue} v
* @return {boolean}
*/
Link.isOrthogonalRouting = function(v) {
  return v === Link.Orthogonal || v === Link.AvoidsNodes;
};

/**
* @ignore
* Returns the {@link #curve}, unless this link is supposed to pretend to be curved.
* @expose
* @this {Link}
* @return {EnumValue}
*/
Link.prototype.computeCurve = function() {
  if (this._effectiveBezier === null) {
    var selfloop = (this.fromPort === this.toPort);
    var ortho = this.isOrthogonal;
    this._effectiveBezier = (selfloop && !ortho);
  }
  if (this._effectiveBezier) return Link.Bezier;
  return this.curve;
};

/**
* @ignore
* Returns the {@link #corner}, if it's a non-negative number, or else 10.
* @expose
* @this {Link}
* @return {number}
*/
Link.prototype.computeCorner = function() {
  if (this.curve === Link.Bezier) return 0;
  var c = this.corner;
  if (isNaN(c) || c < 0) c = 10;
  return c;
};

/**
* @ignore
* Returns the {@link #curviness}, if it's a number,
* or else a computed value based on how many links connect this pair of nodes/ports.
* @expose
* @this {Link}
* @return {number}
*/
Link.prototype.computeCurviness = function() {
  var c = this.curviness;
  if (isNaN(c)) {
    var bundleindex = this._bundleIndex;
    if (bundleindex !== 0) {
      var bundle = this._bundle;
      var spacing = (bundle !== null ? bundle.spacing : 10);
      var i = Math.abs(bundleindex);
      c = spacing / 2 + (((i - 1) / 2) | 0) * spacing;  // i.e. +/- 5/15/25/etc from center
      if (i % 2 === 0) c = -c;  // alternate sides
      if (bundleindex < 0) c = -c;  // other direction
    } else {
      c = 10;
    }
  }
  return c;
};

/**
* @ignore
* Returns true if an extra or a different point is needed based on {@link #curviness}.
* @this {Link}
* @return {boolean}
*/
Link.prototype.hasCurviness = function() {
  var c = this.curviness;
  return !isNaN(c) || (this._bundleIndex !== 0 && !this.isOrthogonal);
};

/**
* @ignore
* @this {Link}
* @param {Node} fromnode
* @param {GraphObject} fromport
* @param {Node} tonode
* @param {GraphObject} toport
*/
Link.prototype.calculateLineNoSpot = function(fromnode, fromport, tonode, toport) {
  var frompt = this.getLinkPoint(fromnode, fromport, Spot.None, true, false, tonode, toport);
  var topt = this.getLinkPoint(tonode, toport, Spot.None, false, false, fromnode, fromport);
  // dont need to clear points, caller already did
  if (this.hasCurviness()) {
    var Dx = topt.x - frompt.x;
    var Dy = topt.y - frompt.y;
    var rad = this.computeCurviness();
    var off = rad;

    var Mx = frompt.x + Dx / 2;
    var My = frompt.y + Dy / 2;
    var C1x = Mx;
    var C1y = My;
    if (Geo.isApprox(Dy, 0)) {
      if (Dx > 0)
        C1y -= off;
      else
        C1y += off;
    } else {
      var slope = -Dx / Dy;
      var E = Math.sqrt(off * off / (slope * slope + 1));
      if (rad < 0) E = -E;
      C1x = (Dy < 0 ? -1 : 1) * E + Mx;
      C1y = slope * (C1x - Mx) + My;
    }
    this.addPoint(frompt);
    this.addPointAt(C1x, C1y);
    this.addPoint(topt);
  } else {
    this.addPoint(frompt);
    this.addPoint(topt);
  }
};

/**
* @ignore
* @this {Link}
* @param {Node} fromnode
* @param {GraphObject} fromport
* @param {Node} tonode
* @param {GraphObject} toport
*/
Link.prototype.calculateBezierNoSpot = function(fromnode, fromport, tonode, toport) {
  var pA = this.getLinkPoint(fromnode, fromport, Spot.None, true, false, tonode, toport);
  var pB = this.getLinkPoint(tonode, toport, Spot.None, false, false, fromnode, fromport);

  var Dx = pB.x - pA.x;
  var Dy = pB.y - pA.y;
  var rad = this.computeCurviness();
  var slope = 0;  // can't calculate this now, if Dy is close to zero
  var E = 0;

  var Mx = pA.x + Dx / 3;
  var My = pA.y + Dy / 3;
  var C1x = Mx;
  var C1y = My;
  if (Geo.isApprox(Dy, 0)) {
    if (Dx > 0)
      C1y -= rad;
    else
      C1y += rad;
  } else {
    slope = -Dx / Dy;
    E = Math.sqrt(rad * rad / (slope * slope + 1));
    if (rad < 0) E = -E;
    C1x = (Dy < 0 ? -1 : 1) * E + Mx;
    C1y = slope * (C1x - Mx) + My;
  }

  Mx = pA.x + 2 * Dx / 3;
  My = pA.y + 2 * Dy / 3;
  var C2x = Mx;
  var C2y = My;
  if (Geo.isApprox(Dy, 0)) {
    if (Dx > 0)
      C2y -= rad;
    else
      C2y += rad;
  } else {
    // slope and E have been initialized earlier, when Dy !== 0
    C2x = (Dy < 0 ? -1 : 1) * E + Mx;
    C2y = slope * (C2x - Mx) + My;
  }

  this.clearPoints();
  this.addPoint(pA);
  this.addPointAt(C1x, C1y);
  this.addPointAt(C2x, C2y);
  this.addPoint(pB);
  // adjust end points so that they appear to come from the control points
  this.setPoint(0, this.getLinkPoint(fromnode, fromport, Spot.None, true, false, tonode, toport));
  this.setPoint(3, this.getLinkPoint(tonode, toport, Spot.None, false, false, fromnode, fromport));
};

/**
* @ignore
* Adjust all of the existing points in this link's stroke in an inclusive range
* according to new first and last stroke points.
* <p/>
* This is primarily useful to help maintain intermediate inflection points
* in a link when one or both ports moves.
* By default this just calls {@link #rescalePoints}, {@link #stretchPoints},
* or {@link #modifyEndPoints}.
* This method is not called when there are no existing points to be adjusted
* or when {@link #adjusting} is None.
* <p/>
* When this link is orthogonal, an {@link #adjusting} of
* Scale will just return false to result in the standard orthogonal path.
* An {@link #adjusting} of Stretch
* for an orthogonal link is treated as if it were End.
* @expose
* @this {Link}
* @param {number} startIndex the zero-based index of the first point to be changed, to be
* the value of the newFromPoint argument.
* @param {Point} newFromPoint a Point in document coordinates.
* @param {number} endIndex the zero-based index of the last point to be changed, to be
* the value of the newToPoint argument.
* @param {Point} newToPoint a Point in document coordinates.
* @return {boolean} This method should return true if the stroke points were adjusted.
* Return false to tell {@link #computePoints} to plot the standard path.
*/
Link.prototype.adjustPoints = function(startIndex, newFromPoint, endIndex, newToPoint) {
  var s = this.adjusting;
  if (this.isOrthogonal) {
    if (s === Link.Scale)
      return false;
    if (s === Link.Stretch)
      s = Link.End;
  }
  switch (s) {
    case Link.Scale: return this.rescalePoints(startIndex, newFromPoint, endIndex, newToPoint);
    case Link.Stretch: return this.stretchPoints(startIndex, newFromPoint, endIndex, newToPoint);
    case Link.End: return this.modifyEndPoints(startIndex, newFromPoint, endIndex, newToPoint);
    default: return false;
  }
};

/**
* @ignore
* Maintain the same shape for the stroke, but scale and rotate according to the
* new point arguments newFromPoint and newToPoint.
* @this {Link}
* @param {number} startIndex the zero-based index of the first point to be changed, to be
* the value of the newFromPoint argument.
* @param {Point} newFromPoint a Point in document coordinates.
* @param {number} endIndex the zero-based index of the last point to be changed, to be
* the value of the newToPoint argument.
* @param {Point} newToPoint a Point in document coordinates.
* @return {boolean} This method should return true if the stroke points were adjusted.
* Return false to tell {@link #computePoints} to plot the standard path.
*/
Link.prototype.rescalePoints = function(startIndex, newFromPoint, endIndex, newToPoint) {
  var oldFromPt = this.getPoint(startIndex);
  var oldToPt = this.getPoint(endIndex);
  if (oldFromPt.equals(newFromPoint) && oldToPt.equals(newToPoint)) return true;

  var Ax = oldFromPt.x;
  var Ay = oldFromPt.y;
  var Bx = oldToPt.x;
  var By = oldToPt.y;
  var Dx = Bx - Ax;
  var Dy = By - Ay;
  var oldDist = Math.sqrt(Dx * Dx + Dy * Dy);
  if (Geo.isApprox(oldDist, 0))
    return true;
  var oldAngle;
  if (Geo.isApprox(Dx, 0)) {
    if (Dy < 0)
      oldAngle = -Math.PI / 2;
    else
      oldAngle = Math.PI / 2;
  } else {
    oldAngle = Math.atan(Dy / Math.abs(Dx));
    if (Dx < 0)
      oldAngle = Math.PI - oldAngle;
  }

  var A2x = newFromPoint.x;
  var A2y = newFromPoint.y;
  var B2x = newToPoint.x;
  var B2y = newToPoint.y;
  var D2x = B2x - A2x;
  var D2y = B2y - A2y;
  var newDist = Math.sqrt(D2x * D2x + D2y * D2y);
  var newAngle;
  if (Geo.isApprox(D2x, 0)) {
    if (D2y < 0)
      newAngle = -Math.PI / 2;
    else
      newAngle = Math.PI / 2;
  } else {
    newAngle = Math.atan(D2y / Math.abs(D2x));
    if (D2x < 0)
      newAngle = Math.PI - newAngle;
  }

  var DistRatio = (newDist / oldDist);
  var AngleDiff = (newAngle - oldAngle);

  this.setPoint(startIndex, newFromPoint);
  for (var i = startIndex + 1; i < endIndex; i++) {
    var p = this.getPoint(i);
    Dx = p.x - Ax;
    Dy = p.y - Ay;
    var pDist = Math.sqrt(Dx * Dx + Dy * Dy);
    if (Geo.isApprox(pDist, 0))
      continue;
    var pAngle;
    if (Geo.isApprox(Dx, 0)) {
      if (Dy < 0)
        pAngle = -Math.PI / 2;
      else
        pAngle = Math.PI / 2;
    } else {
      pAngle = Math.atan(Dy / Math.abs(Dx));
      if (Dx < 0)
        pAngle = Math.PI - pAngle;
    }

    var p2Angle = pAngle + AngleDiff;
    var p2Dist = pDist * DistRatio;
    var P2x = A2x + p2Dist * Math.cos(p2Angle);
    var P2y = A2y + p2Dist * Math.sin(p2Angle);
    this.setPointAt(i, P2x, P2y);
  }
  this.setPoint(endIndex, newToPoint);
  return true;
};

/**
* @ignore
* Stretch the points of this stroke by interpolating the points
* from startIndex to endIndex between the
* new point arguments newFromPoint and newToPoint.
* @this {Link}
* @param {number} startIndex the zero-based index of the first point to be changed, to be
* the value of the newFromPoint argument.
* @param {Point} newFromPoint a Point in document coordinates.
* @param {number} endIndex the zero-based index of the last point to be changed, to be
* the value of the newToPoint argument.
* @param {Point} newToPoint a Point in document coordinates.
* @return {boolean} This method should return true if the stroke points were adjusted.
* Return false to tell {@link #computePoints} to plot the standard path.
*/
Link.prototype.stretchPoints = function(startIndex, newFromPoint, endIndex, newToPoint) {
  var a = this.getPoint(startIndex);
  var b = this.getPoint(endIndex);
  if (a.equals(newFromPoint) && b.equals(newToPoint)) return true;

  var Ax = a.x;
  var Ay = a.y;
  var Bx = b.x;
  var By = b.y;
  var L = ((Bx - Ax) * (Bx - Ax) + (By - Ay) * (By - Ay));

  var Cx = newFromPoint.x;
  var Cy = newFromPoint.y;
  var Dx = newToPoint.x;
  var Dy = newToPoint.y;
  var M = 0;
  var m2 = 1;
  if (Dx - Cx !== 0)
    M = (Dy - Cy) / (Dx - Cx);
  else
    M = 9e9;
  if (M !== 0)
    m2 = Math.sqrt(1 + (1 / (M * M)));

  this.setPoint(startIndex, newFromPoint);
  for (var i = startIndex + 1; i < endIndex; i++) {
    var p = this.getPoint(i);
    var Px = p.x;
    var Py = p.y;

    var Q = 0.5;
    if (L !== 0)
      Q = ((Ax - Px) * (Ax - Bx) + (Ay - Py) * (Ay - By)) / L;

    // find point on old line
    var Vx = Ax + Q * (Bx - Ax);
    var Vy = Ay + Q * (By - Ay);
    // distance from P to point V, on old line
    var dV = Math.sqrt((Px - Vx) * (Px - Vx) + (Py - Vy) * (Py - Vy));
    if (Py < M * (Px - Vx) + Vy)
      dV = -dV;
    if (M > 0)
      dV = -dV;

    // find point on new line
    var Wx = Cx + Q * (Dx - Cx);
    var Wy = Cy + Q * (Dy - Cy);

    if (M !== 0) {
      // compute new point for P off of new line, distance dV from W
      var x = Wx + dV / m2;
      var y = Wy - (x - Wx) / M;
      this.setPointAt(i, x, y);
    } else {
      this.setPointAt(i, Wx, Wy + dV);
    }
  }
  this.setPoint(endIndex, newToPoint);
  return true;
};

/**
* @ignore
* Modify only the end points of this stroke to match any new
* newFromPoint or newToPoint points;
* intermediate points are not changed.
* <p/>
* The startIndex'th point should be set to the newFromPoint argument,
* and the endIndex'th point should be set to the newToPoint argument,
* and the intermediate points should be not be changed unless needed to maintain orthogonality.
* @this {Link}
* @param {number} startIndex the zero-based index of the first point to be changed, to be
* the value of the newFromPoint argument.
* @param {Point} newFromPoint a Point in document coordinates.
* @param {number} endIndex the zero-based index of the last point to be changed, to be
* the value of the newToPoint argument.
* @param {Point} newToPoint a Point in document coordinates.
* @return {boolean} This method should return true if the stroke points were adjusted.
* Return false to tell {@link #computePoints} to plot the standard path.
*/
Link.prototype.modifyEndPoints = function(startIndex, newFromPoint, endIndex, newToPoint) {
  if (this.isOrthogonal) {
    var a = this.getPoint(startIndex);
    var b = this.getPoint(startIndex + 1);
    var c = this.getPoint(startIndex + 2);
    if (Geo.isApprox(a.y, b.y)) {
      if (Geo.isApprox(b.x, c.x)) {
        this.setPointAt(startIndex + 1, b.x, newFromPoint.y);
      } else if (Geo.isApprox(b.y, c.y)) {
        this.setPointAt(startIndex + 1, newFromPoint.x, b.y);
      }
    } else if (Geo.isApprox(a.x, b.x)) {
      if (Geo.isApprox(b.y, c.y)) {
        this.setPointAt(startIndex + 1, newFromPoint.x, b.y);
      } else if (Geo.isApprox(b.x, c.x)) {
        this.setPointAt(startIndex + 1, b.x, newFromPoint.y);
      }
    }
    a = this.getPoint(endIndex);
    b = this.getPoint(endIndex - 1);
    c = this.getPoint(endIndex - 2);
    if (Geo.isApprox(a.y, b.y)) {
      if (Geo.isApprox(b.x, c.x)) {
        this.setPointAt(endIndex - 1, b.x, newToPoint.y);
      } else if (Geo.isApprox(b.y, c.y)) {
        this.setPointAt(endIndex - 1, newToPoint.x, b.y);
      }
    } else if (Geo.isApprox(a.x, b.x)) {
      if (Geo.isApprox(b.y, c.y)) {
        this.setPointAt(endIndex - 1, newToPoint.x, b.y);
      } else if (Geo.isApprox(b.x, c.x)) {
        this.setPointAt(endIndex - 1, b.x, newToPoint.y);
      }
    }
  }
  this.setPoint(startIndex, newFromPoint);
  this.setPoint(endIndex, newToPoint);
  return true;
};

/**
* @ignore
* This method is called by {@link #computePoints} when the link is orthogonal
* and at least one port has a link spot that is not {@link Spot#isNoSpot}.
* <p/>
* {@link #computePoints} is responsible for adding the first two
* and the last two points of the stroke, including the startFrom and endTo values.
* This method is responsible for adding any additional points in the middle of the stroke.
* This method calls {@link #computeMidOrthoPosition} to determine the
* distance of the middle segment between the two ports.
* It also tries to avoid the source node and the destination node.
* When the {@link #routing} property is not Normal,
* this method uses another, more computationally expensive,
* method for determining the proper path of the link, which may have many segments.
* @expose
* @this {Link}
* @param {Point} startFrom this {@link Point} will already have been added to the stroke by {@link #computePoints} before calling this method.
* @param {number} fromDir Normally 0, 90, 180, or 270 degrees.
* @param {Point} endTo {@link #computePoints} will add this {@link Point} after calling this method.
* @param {number} toDir Normally 0, 90, 180, or 270 degrees.
* @param {Node} fromnode the {@link Node} that the link is coming from.
* @param {Node} tonode the {@link Node} that the link is going to.
*/
Link.prototype.addOrthoPoints = function(startFrom, fromDir, endTo, toDir, fromnode, tonode) {
  var RIGHT = 0;
  var DOWN = 90;
  var LEFT = 180;
  var UP = 270;

  if (RIGHT - 45 <= fromDir && fromDir < RIGHT + 45)
    fromDir = RIGHT;
  else if (DOWN - 45 <= fromDir && fromDir < DOWN + 45)
    fromDir = DOWN;
  else if (LEFT - 45 <= fromDir && fromDir < LEFT + 45)
    fromDir = LEFT;
  else
    fromDir = UP;
  if (RIGHT - 45 <= toDir && toDir < RIGHT + 45)
    toDir = RIGHT;
  else if (DOWN - 45 <= toDir && toDir < DOWN + 45)
    toDir = DOWN;
  else if (LEFT - 45 <= toDir && toDir < LEFT + 45)
    toDir = LEFT;
  else
    toDir = UP;

  var s = startFrom;
  var t = endTo;

  var fromR = fromnode.actualBounds.copy();  // handle rotated nodes
  var toR = tonode.actualBounds.copy();
  if (!fromR.isReal() || !toR.isReal()) return;
  fromR.inflate(8, 8);
  toR.inflate(8, 8);
  fromR.unionPoint(startFrom);
  toR.unionPoint(endTo);

  // do normal routing
  var m2;
  var m3;
  if (fromDir === RIGHT) {
    if (t.x > s.x ||
        (toDir === UP && t.y < s.y && toR.right > s.x) ||
        (toDir === DOWN && t.y > s.y && toR.right > s.x)) {
      m2 = new Point(t.x, s.y);
      m3 = new Point(t.x, (s.y + t.y) / 2);
      if (toDir === LEFT) {
        m2.x = this.computeMidOrthoPosition(s.x, t.x, false);
        m3.x = m2.x;
        m3.y = t.y;
      } else if ((toDir === UP && t.y < s.y) || (toDir === DOWN && t.y > s.y)) {
        if (s.x < toR.left)
          m2.x = this.computeMidOrthoPosition(s.x, toR.left, false);
        else if (s.x < toR.right && ((toDir === UP && s.y < toR.top) || (toDir === DOWN && s.y > toR.bottom)))
          m2.x = this.computeMidOrthoPosition(s.x, t.x, false);
        else
          m2.x = toR.right;
        m3.x = m2.x;
        m3.y = t.y;
      } else if (toDir === RIGHT && s.x < toR.left && s.y > toR.top && s.y < toR.bottom) {
        m2.x = s.x;
        if (s.y < t.y)
          m2.y = Math.min(t.y, toR.top);
        else
          m2.y = Math.max(t.y, toR.bottom);
        m3.y = m2.y;
      }
    } else {
      m2 = new Point(s.x, t.y);
      m3 = new Point((s.x + t.x) / 2, t.y);
      if (toDir === LEFT ||
          (toDir === DOWN && t.y < fromR.top) ||
          (toDir === UP && t.y > fromR.bottom)) {
        if (toDir === LEFT && (toR.containsPoint(s) || fromR.containsPoint(t)))  // close to each other
          m2.y = this.computeMidOrthoPosition(s.y, t.y, true);
        else if (t.y < s.y && (toDir === LEFT || toDir === DOWN))
          m2.y = this.computeMidOrthoPosition(fromR.top, Math.max(t.y, toR.bottom), true);
        else if (t.y > s.y && (toDir === LEFT || toDir === UP))
          m2.y = this.computeMidOrthoPosition(fromR.bottom, Math.min(t.y, toR.top), true);
        m3.x = t.x;
        m3.y = m2.y;
      }
      if (m2.y > fromR.top && m2.y < fromR.bottom) {
        if ((t.x >= fromR.left && t.x <= s.x) || (s.x <= toR.right && s.x >= t.x)) {
          if (toDir === DOWN || toDir === UP) {
            m2 = new Point(Math.max((s.x + t.x) / 2, s.x), s.y);
            m3 = new Point(m2.x, t.y);
          }
        } else {
          if (toDir === UP || ((toDir === RIGHT || toDir === LEFT) && t.y < s.y)) {
            m2.y = Math.min(t.y, ((toDir === RIGHT) ? fromR.top : Math.min(fromR.top, toR.top)));
          } else {
            m2.y = Math.max(t.y, ((toDir === RIGHT) ? fromR.bottom : Math.max(fromR.bottom, toR.bottom)));
          }
          m3.x = t.x;
          m3.y = m2.y;
        }
      }
    }
  } else if (fromDir === LEFT) {
    if (t.x < s.x ||
        (toDir === UP && t.y < s.y && toR.left < s.x) ||
        (toDir === DOWN && t.y > s.y && toR.left < s.x)) {
      m2 = new Point(t.x, s.y);
      m3 = new Point(t.x, (s.y + t.y) / 2);
      if (toDir === RIGHT) {
        m2.x = this.computeMidOrthoPosition(s.x, t.x, false);
        m3.x = m2.x;
        m3.y = t.y;
      } else if ((toDir === UP && t.y < s.y) || (toDir === DOWN && t.y > s.y)) {
        if (s.x > toR.right)
          m2.x = this.computeMidOrthoPosition(s.x, toR.right, false);
        else if (s.x > toR.left && ((toDir === UP && s.y < toR.top) || (toDir === DOWN && s.y > toR.bottom)))
          m2.x = this.computeMidOrthoPosition(s.x, t.x, false);
        else
          m2.x = toR.left;
        m3.x = m2.x;
        m3.y = t.y;
      } else if (toDir === LEFT && s.x > toR.right && s.y > toR.top && s.y < toR.bottom) {
        m2.x = s.x;
        if (s.y < t.y)
          m2.y = Math.min(t.y, toR.top);
        else
          m2.y = Math.max(t.y, toR.bottom);
        m3.y = m2.y;
      }
    } else {
      m2 = new Point(s.x, t.y);
      m3 = new Point((s.x + t.x) / 2, t.y);
      if (toDir === RIGHT ||
          (toDir === DOWN && t.y < fromR.top) ||
          (toDir === UP && t.y > fromR.bottom)) {
        if (toDir === RIGHT && (toR.containsPoint(s) || fromR.containsPoint(t)))  // close to each other
          m2.y = this.computeMidOrthoPosition(s.y, t.y, true);
        else if (t.y < s.y && (toDir === RIGHT || toDir === DOWN))
          m2.y = this.computeMidOrthoPosition(fromR.top, Math.max(t.y, toR.bottom), true);
        else if (t.y > s.y && (toDir === RIGHT || toDir === UP))
          m2.y = this.computeMidOrthoPosition(fromR.bottom, Math.min(t.y, toR.top), true);
        m3.x = t.x;
        m3.y = m2.y;
      }
      if (m2.y > fromR.top && m2.y < fromR.bottom) {
        if ((t.x <= fromR.right && t.x >= s.x) || (s.x >= toR.left && s.x <= t.x)) {
          if (toDir === DOWN || toDir === UP) {
            m2 = new Point(Math.min((s.x + t.x) / 2, s.x), s.y);
            m3 = new Point(m2.x, t.y);
          }
        } else {
          if (toDir === UP || ((toDir === RIGHT || toDir === LEFT) && t.y < s.y)) {
            m2.y = Math.min(t.y, ((toDir === LEFT) ? fromR.top : Math.min(fromR.top, toR.top)));
          } else {
            m2.y = Math.max(t.y, ((toDir === LEFT) ? fromR.bottom : Math.max(fromR.bottom, toR.bottom)));
          }
          m3.x = t.x;
          m3.y = m2.y;
        }
      }
    }
  } else if (fromDir === DOWN) {
    if (t.y > s.y ||
        (toDir === LEFT && t.x < s.x && toR.bottom > s.y) ||
        (toDir === RIGHT && t.x > s.x && toR.bottom > s.y)) {
      m2 = new Point(s.x, t.y);
      m3 = new Point((s.x + t.x) / 2, t.y);
      if (toDir === UP) {
        m2.y = this.computeMidOrthoPosition(s.y, t.y, true);
        m3.x = t.x;
        m3.y = m2.y;
      } else if ((toDir === LEFT && t.x < s.x) || (toDir === RIGHT && t.x > s.x)) {
        if (s.y < toR.top)
          m2.y = this.computeMidOrthoPosition(s.y, toR.top, true);
        else if (s.y < toR.bottom && ((toDir === LEFT && s.x < toR.left) || (toDir === RIGHT && s.x > toR.right)))
          m2.y = this.computeMidOrthoPosition(s.y, t.y, true);
        else
          m2.y = toR.bottom;
        m3.x = t.x;
        m3.y = m2.y;
      } else if (toDir === DOWN && s.y < toR.top && s.x > toR.left && s.x < toR.right) {
        if (s.x < t.x)
          m2.x = Math.min(t.x, toR.left);
        else
          m2.x = Math.max(t.x, toR.right);
        m2.y = s.y;
        m3.x = m2.x;
      }
    } else {
      m2 = new Point(t.x, s.y);
      m3 = new Point(t.x, (s.y + t.y) / 2);
      if (toDir === UP ||
          (toDir === RIGHT && t.x < fromR.left) ||
          (toDir === LEFT && t.x > fromR.right)) {
        if (toDir === UP && (toR.containsPoint(s) || fromR.containsPoint(t)))  // close to each other
          m2.x = this.computeMidOrthoPosition(s.x, t.x, false);
        else if (t.x < s.x && (toDir === UP || toDir === RIGHT))
          m2.x = this.computeMidOrthoPosition(fromR.left, Math.max(t.x, toR.right), false);
        else if (t.x > s.x && (toDir === UP || toDir === LEFT))
          m2.x = this.computeMidOrthoPosition(fromR.right, Math.min(t.x, toR.left), false);
        m3.x = m2.x;
        m3.y = t.y;
      }
      if (m2.x > fromR.left && m2.x < fromR.right) {
        if ((t.y >= fromR.top && t.y <= s.y) || (s.y <= toR.bottom && s.y >= t.y)) {
          if (toDir === RIGHT || toDir === LEFT) {
            m2 = new Point(s.x, Math.max((s.y + t.y) / 2, s.y));
            m3 = new Point(t.x, m2.y);
          }
        } else {
          if (toDir === LEFT || ((toDir === DOWN || toDir === UP) && t.x < s.x)) {
            m2.x = Math.min(t.x, ((toDir === DOWN) ? fromR.left : Math.min(fromR.left, toR.left)));
          } else {
            m2.x = Math.max(t.x, ((toDir === DOWN) ? fromR.right : Math.max(fromR.right, toR.right)));
          }
          m3.x = m2.x;
          m3.y = t.y;
        }
      }
    }
  } else {  // fromDir === UP
    if (t.y < s.y ||
        (toDir === LEFT && t.x < s.x && toR.top < s.y) ||
        (toDir === RIGHT && t.x > s.x && toR.top < s.y)) {
      m2 = new Point(s.x, t.y);
      m3 = new Point((s.x + t.x) / 2, t.y);
      if (toDir === DOWN) {
        m2.y = this.computeMidOrthoPosition(s.y, t.y, true);
        m3.x = t.x;
        m3.y = m2.y;
      } else if ((toDir === LEFT && t.x < s.x) || (toDir === RIGHT && t.x >= s.x)) {
        if (s.y > toR.bottom)
          m2.y = this.computeMidOrthoPosition(s.y, toR.bottom, true);
        else if (s.y > toR.top && ((toDir === LEFT && s.x < toR.left) || (toDir === RIGHT && s.x > toR.right)))
          m2.y = this.computeMidOrthoPosition(s.y, t.y, true);
        else
          m2.y = toR.top;
        m3.x = t.x;
        m3.y = m2.y;
      } else if (toDir === UP && s.y > toR.bottom && s.x > toR.left && s.x < toR.right) {
        if (s.x < t.x)
          m2.x = Math.min(t.x, toR.left);
        else
          m2.x = Math.max(t.x, toR.right);
        m2.y = s.y;
        m3.x = m2.x;
      }
    } else {
      m2 = new Point(t.x, s.y);
      m3 = new Point(t.x, (s.y + t.y) / 2);
      if (toDir === DOWN ||
          (toDir === RIGHT && t.x < fromR.left) ||
          (toDir === LEFT && t.x > fromR.right)) {
        if (toDir === DOWN && (toR.containsPoint(s) || fromR.containsPoint(t)))  // close to each other
          m2.x = this.computeMidOrthoPosition(s.x, t.x, false);
        else if (t.x < s.x && (toDir === DOWN || toDir === RIGHT))
          m2.x = this.computeMidOrthoPosition(fromR.left, Math.max(t.x, toR.right), false);
        else if (t.x > s.x && (toDir === DOWN || toDir === LEFT))
          m2.x = this.computeMidOrthoPosition(fromR.right, Math.min(t.x, toR.left), false);
        m3.x = m2.x;
        m3.y = t.y;
      }
      if (m2.x > fromR.left && m2.x < fromR.right) {
        if ((t.y <= fromR.bottom && t.y >= s.y) || (s.y >= toR.top && s.y <= t.y)) {
          if (toDir === RIGHT || toDir === LEFT) {
            m2 = new Point(s.x, Math.min((s.y + t.y) / 2, s.y));
            m3 = new Point(t.x, m2.y);
          }
        } else {
          if (toDir === LEFT || ((toDir === DOWN || toDir === UP) && t.x < s.x)) {
            m2.x = Math.min(t.x, ((toDir === UP) ? fromR.left : Math.min(fromR.left, toR.left)));
          } else {
            m2.x = Math.max(t.x, ((toDir === UP) ? fromR.right : Math.max(fromR.right, toR.right)));
          }
          m3.x = m2.x;
          m3.y = t.y;
        }
      }
    }
  }

  // maybe do AvoidsNodes routing
  if (this.maybeAvoidsNodes(startFrom, fromDir, m2, m3, endTo, toDir, fromnode, tonode, fromR, toR)) return;
  // otherwise use the default ortho routing
  this.addPoint(m2);
  this.addPoint(m3);
};

/**
* @ignore
* @this {Link}
* @param {Point} startFrom this {@link Point} will already have been added to the stroke by {@link #computePoints} before calling this method.
* @param {number} fromDir Normally 0, 90, 180, or 270 degrees.
* @param {Point} m2 first default ortho midpoint.
* @param {Point} m3 second default ortho midpoint.
* @param {Point} endTo {@link #computePoints} will add this {@link Point} after calling this method.
* @param {number} toDir Normally 0, 90, 180, or 270 degrees.
* @param {Node} fromnode the {@link Node} that the link is coming from.
* @param {Node} tonode the {@link Node} that the link is going to.
* @param {Rect} fromR inflated fromnode.actualBounds.
* @param {Rect} toR inflated tonode.actualBounds.
* @return {boolean}
*/
Link.prototype.maybeAvoidsNodes = function(startFrom, fromDir, m2, m3, endTo, toDir, fromnode, tonode, fromR, toR) {
  if (this.routing !== Link.AvoidsNodes) return false;
  var diagram = this.diagram;
  if (diagram === null) return false;
  if (fromR.containsPoint(endTo) || toR.containsPoint(startFrom)) return false;  // ignore AvoidsNodes if overlapping
  if (fromnode === tonode || this.layer.isTemporary) return false;  // ignore AvoidsNodes if self-loop or temporary
  //??? if (this.delayedRouting) return false;  // or when rebuilding

  //Debug.trace("AvoidsNodes route search: " + diagram.nodes.count.toString() + " " + this.toString());
  var positions = diagram.getPositions(true, this, null);

  // see if the current route crosses over any nodes
  if (// from startFrom to m2
      positions.isUnoccupied(Math.min(startFrom.x, m2.x), Math.min(startFrom.y, m2.y), Math.abs(startFrom.x - m2.x), Math.abs(startFrom.y - m2.y)) &&
      // from m2 to m3
      positions.isUnoccupied(Math.min(m2.x, m3.x), Math.min(m2.y, m3.y), Math.abs(m2.x - m3.x), Math.abs(m2.y - m3.y)) &&
      // from m3 to endTo
      positions.isUnoccupied(Math.min(m3.x, endTo.x), Math.min(m3.y, endTo.y), Math.abs(m3.x - endTo.x), Math.abs(m3.y - endTo.y))) {
    return false;
  }

  // first try to find a path that is within the bounds of the
  // rectangle formed by the two nodes--this should cover most cases
  // more efficiently than searching the whole document
  var minbounds = fromR.copy().unionRect(toR);
  minbounds.inflate(positions.cellWidth * 2, positions.cellHeight * 2);
  positions.propagate(startFrom, fromDir, endTo, toDir, minbounds);  // may set .abort
  var endval = positions.getDistance(endTo.x, endTo.y);
  if (!positions.abort && endval === PositionArray.MAX) {
    // try again with larger area, which should cover a lot of cases where
    // there is another node overlapping with either the source or the destination node
    positions.clearAllUnoccupied();
    var margin = positions.smallMargin;
    minbounds.inflate(positions.cellWidth * margin, positions.cellHeight * margin);
    positions.propagate(startFrom, fromDir, endTo, toDir, minbounds);  // may set .abort
    endval = positions.getDistance(endTo.x, endTo.y);
  }
  if (!positions.abort && endval === PositionArray.MAX) {
    // try again with larger area, which should cover a lot of cases where
    // there is another node overlapping with either the source or the destination node
    positions.clearAllUnoccupied();
    var margin = positions.largeMargin;
    minbounds.inflate(positions.cellWidth * margin, positions.cellHeight * margin);
    positions.propagate(startFrom, fromDir, endTo, toDir, minbounds);  // may set .abort
    endval = positions.getDistance(endTo.x, endTo.y);
  }
  if (!positions.abort && endval === PositionArray.MAX && positions.wholeDocument) {
    // try again with larger area, the whole document
    positions.clearAllUnoccupied();
    positions.propagate(startFrom, fromDir, endTo, toDir, positions.bounds);  // may set .abort
    endval = positions.getDistance(endTo.x, endTo.y);
  }

  // if the propagation succeeded, get the points of the stroke
  if (!positions.abort && endval < PositionArray.MAX && !positions.isOccupied(endTo.x, endTo.y)) {
    this.traversePositions(positions, endTo.x, endTo.y, toDir, true);

    var RIGHT = 0;
    var DOWN = 90;
    var LEFT = 180;
    var UP = 270;

    // hook up the first segment with the grid-aligned points produced by TraversePositions
    var two = this.getPoint(2);
    if (this.pointsCount < 4) {
      if (fromDir === RIGHT || fromDir === LEFT) {
        two.x = startFrom.x;
        two.y = endTo.y;
      } else {
        two.x = endTo.x;
        two.y = startFrom.y;
      }
      this.setPointAt(2, two.x, two.y);
      this.insertPointAt(3, two.x, two.y);
    } else {
      var three = this.getPoint(3);
      if (fromDir === RIGHT || fromDir === LEFT) {
        if (Geo.isApprox(two.x, three.x)) {
          var newx = (fromDir === RIGHT) ? Math.max(two.x, startFrom.x) : Math.min(two.x, startFrom.x);
          this.setPointAt(2, newx, startFrom.y);
          this.setPointAt(3, newx, three.y);
        } else if (Geo.isApprox(two.y, three.y)) {
          if (Math.abs(startFrom.y - two.y) <= positions.cellHeight / 2) {
            this.setPointAt(2, two.x, startFrom.y);
            this.setPointAt(3, three.x, startFrom.y);
          }
          this.insertPointAt(2, two.x, startFrom.y);
        } else {
          this.setPointAt(2, startFrom.x, two.y);
        }
      } else if (fromDir === DOWN || fromDir === UP) {
        if (Geo.isApprox(two.y, three.y)) {
          var newy = (fromDir === DOWN) ? Math.max(two.y, startFrom.y) : Math.min(two.y, startFrom.y);
          this.setPointAt(2, startFrom.x, newy);
          this.setPointAt(3, three.x, newy);
        } else if (Geo.isApprox(two.x, three.x)) {
          if (Math.abs(startFrom.x - two.x) <= positions.cellWidth / 2) {
            this.setPointAt(2, startFrom.x, two.y);
            this.setPointAt(3, startFrom.x, three.y);
          }
          this.insertPointAt(2, startFrom.x, two.y);
        } else {
          this.setPointAt(2, two.x, startFrom.y);
        }
      }
    }
    return true;  // success with special route
  }
  // otherwise, just depend on default behavior
  return false;
};

/**
* @ignore
* This method is called by {@link #addOrthoPoints} to determine the distance
* of the middle segment between the two ports.
* @expose
* @this {Link}
* @param {number} fromPosition The first point's X or Y coordinate, depending on the direction.
* @param {number} toPosition The last point's X or Y coordinate, depending on the direction.
* @param {boolean} vertical Whether the mid-position is along the vertical axis or horizontal axis.
* @return {number}
*/
Link.prototype.computeMidOrthoPosition = function(fromPosition, toPosition, vertical) {
  if (this.hasCurviness()) {
    var c = this.computeCurviness();
    return (fromPosition + toPosition) / 2 + c;
  }
  return (fromPosition + toPosition) / 2;
};


/**
* @ignore
* @this {Link}
* @param {PositionArray} positions
* @param {number} px
* @param {number} py
* @param {number} dir
* @param {boolean} first
*/
Link.prototype.traversePositions = function(positions, px, py, dir, first) {
  var RIGHT = 0;
  var DOWN = 90;
  var LEFT = 180;
  var UP = 270;

  var cellw = positions.cellWidth;
  var cellh = positions.cellHeight;
  var val = positions.getDistance(px, py);
  var qx = px;
  var qy = py;

  // try going forward
  var fx = qx;
  var fy = qy;
  if (dir === RIGHT)
    fx += cellw;
  else if (dir === DOWN)
    fy += cellh;
  else if (dir === LEFT)
    fx -= cellw;
  else
    fy -= cellh;
  // keep going forward until we can't
  while (val > PositionArray.START && positions.getDistance(fx, fy) === val - PositionArray.STEP) {
    qx = fx;
    qy = fy;
    if (dir === RIGHT)
      fx += cellw;
    else if (dir === DOWN)
      fy += cellh;
    else if (dir === LEFT)
      fx -= cellw;
    else
      fy -= cellh;
    val -= PositionArray.STEP;
  }

  // line up the points to be in the middle of the grid
  if (first) {
    if (val > PositionArray.START) {
      if (dir === LEFT || dir === RIGHT)
        qx = Math.floor(qx / cellw) * cellw + cellw / 2;
      else if (dir === DOWN || dir === UP)
        qy = Math.floor(qy / cellh) * cellh + cellh / 2;
    }
  } else {
    qx = Math.floor(qx / cellw) * cellw + cellw / 2;
    qy = Math.floor(qy / cellh) * cellh + cellh / 2;
  }

  if (val > PositionArray.START) {
    var newdir = dir;
    // try turning right
    var rx = qx;
    var ry = qy;
    if (dir === RIGHT) {
      newdir = DOWN;
      ry += cellh;
    } else if (dir === DOWN) {
      newdir = LEFT;
      rx -= cellw;
    } else if (dir === LEFT) {
      newdir = UP;
      ry -= cellh;
    } else if (dir === UP) {
      newdir = RIGHT;
      rx += cellw;
    }
    if (positions.getDistance(rx, ry) === val - PositionArray.STEP) {
      this.traversePositions(positions, rx, ry, newdir, false);
    } else {
      // try turning left
      var lx = qx;
      var ly = qy;
      if (dir === RIGHT) {
        newdir = UP;
        ly -= cellh;
      } else if (dir === DOWN) {
        newdir = RIGHT;
        lx += cellw;
      } else if (dir === LEFT) {
        newdir = DOWN;
        ly += cellh;
      } else if (dir === UP) {
        newdir = LEFT;
        lx -= cellw;
      }
      if (positions.getDistance(lx, ly) === val - PositionArray.STEP)
        this.traversePositions(positions, lx, ly, newdir, false);
    }
  }
  this.addPointAt(qx, qy);
};

Link.prototype['findClosestSegment'] =
/**
* Find the index of the segment that is closest to a given point.
* This assume the route only has straight line segments.
* It ignores any jump-overs or jump-gaps.
* @this {Link}
* @param {Point} p the Point, in document coordinates.
* @return {number} the index of the segment, from zero to the number of points minus 2.
*/
Link.prototype.findClosestSegment = function(p) {
  if (Debug) Util.checkClass(p, Point, Link, 'findClosestSegment:p');
  var px = p.x;
  var py = p.y;
  var q = this.getPoint(0);
  var l = this.getPoint(1);
  var cdist = Point.distanceLineSegmentSquared(px, py, q.x, q.y, l.x, l.y);
  var ci = 0;  // closest index
  for (var i = 1; i < this.pointsCount - 1; i++) {
    q = this.getPoint(i + 1);
    var dist = Point.distanceLineSegmentSquared(px, py, l.x, l.y, q.x, q.y);
    l = q;
    if (dist < cdist) {
      ci = i;
      cdist = dist;
    }
  }
  return ci;
};


// the Geometry for the Route

Link.prototype['invalidateGeometry'] =
/**
* @ignore
* @this {Link}
*/
Link.prototype.invalidateGeometry = function() {
  this._geometry = null;
  this._path = null;
  this.invalidateMeasure();
};

/**
* @ignore
* @this {Link}
*/
Link.prototype._getGeometry = function() {
  return this.geometry;
};

/**
* Gets the {@link Geometry} that is used by the {@link #path}, the link {@link Shape} based on the route points.
* <p/>
* This geometry is automatically generated using the route points and other properties
* such as the {@link #curve}.
* <p/>
* More than one {@link Shape} may share this geometry as its {@link Shape#geometry},
* if there is more than one shape element in the Link with {@link GraphObject#isPanelMain} set to true.
* @name Link#geometry
* @function.
* @return {Geometry}
*/
/** @type {Geometry} */
Link.prototype.geometry;
Util.defineReadOnlyProperty(Link, { geometry: 'geometry'},
  /** @this {Link} */
  function() {
    if (this._geometry === null) {
      this.updateRoute();
      this._geometry = this.makeGeometry();
    }
    return this._geometry;
  }
);

/**
* @ignore
* @this {Link}
*/
Link.prototype.makeShapeGeometry = function() {
  if (this._geometry !== null) return;
  if (this._validRoute === false) return;

  this._geometry = this.makeGeometry();
  var stroke = this._getPath();  // may be null
  if (stroke === null) return; // possible there are no children of a link
  stroke._geometry = this._geometry;  // shared Geometry
  //stroke.measure(Infinity, Infinity);

  var children = this._elements;
  var l = children.length;
  for (var i = 0; i < l; i++) {
    var e = children._arr[i];
    if (e === stroke) continue;  // already measured the stroke, above
    // Take all shapes that have panelMain = true and give them a specific, shared geometry
    if (e.isPanelMain && e instanceof Shape) {
      e._geometry = this._geometry;  // all must share same Geometry
      //e.measure(Infinity, Infinity);
    }
  }
};

/**
* @ignore
* Produce a {@link Geometry} given the points of this route,
* depending on the value of {@link #curve} and {@link #corner} and perhaps other properties.
* @expose
* @this {Link}
* @return {Geometry}
*/
Link.prototype.makeGeometry = function() {
  var numpts = this.pointsCount;
  if (numpts < 2) {
    var geo = new Geometry(Geometry.Path);
    var fig = new PathFigure(0, 0);
    geo.figures.add(fig);
    return geo;
  }

  var bx;
  var by;
  var p0 = this.getPoint(0).copy();
  var p = p0.copy();
  var curve = this.computeCurve();
  if (curve === Link.Bezier && numpts >= 3 && !Geo.isApproxEqual(this.smoothness, 0)) {
    if (numpts === 3) {
      var e = this.getPoint(1);
      bx = Math.min(p0.x, e.x);
      by = Math.min(p0.y, e.y);
      e = this.getPoint(2);
      bx = Math.min(bx, e.x);
      by = Math.min(by, e.y);
    } else {
      if (this.isOrthogonal) {
        for (var i = 0; i < numpts; i++) {
          var p2 = this._points._arr[i];
          p.x = Math.min(p2.x, p.x);
          p.y = Math.min(p2.y, p.y);
        }
        bx = p.x;
        by = p.y;
      } else {
        var startControl, endControl, end;
        for (var i = 3; i < numpts; i += 3) {
          startControl = this.getPoint(i - 2);
          // if it's the last segment, use the last two points
          if (i + 3 >= numpts)
            i = numpts - 1;
          end = this.getPoint(i);
          p.x = Math.min(end.x, p.x);
          p.y = Math.min(end.y, p.y);
        }
        bx = p.x;
        by = p.y;
      }
    }
  } else {
    for (var i = 0; i < numpts; i++) {
      var p2 = this._points._arr[i];
      p.x = Math.min(p2.x, p.x);
      p.y = Math.min(p2.y, p.y);
    }
    bx = p.x;
    by = p.y;
  }

  // in case the geometric origin is not actually a real point, because of a bezier/quadtratic
  bx -= this._tempOrigin.x;
  by -= this._tempOrigin.y;

  // need to shift all points back by bx/by, since the Link/LinkLayer will be translating them
  p0.x -= bx;
  p0.y -= by;

  if (numpts === 2) {
    var p1 = this.getPoint(1).copy();
    p1.x -= bx;
    p1.y -= by;
    if (this._getFromShortLength() !== 0) this._shiftPointByShortLength(p0, true, p);
    if (this._getToShortLength() !== 0) this._shiftPointByShortLength(p1, false, p);
    var geo = new Geometry(Geometry.Line);
    geo.startX = p0.x;
    geo.startY = p0.y;
    geo.endX = p1.x;
    geo.endY = p1.y;
    return geo;
  } else {
    var g = Util.tempStreamGeometryContext();
    if (this._getFromShortLength() !== 0) this._shiftPointByShortLength(p0, true, p);
    g.beginFigure(p0.x, p0.y, false, false);
    if (curve === Link.Bezier && numpts >= 3 && !Geo.isApproxEqual(this.smoothness, 0)) {
      if (numpts === 3) {
        var c = this.getPoint(1);
        var cx = c.x - bx;
        var cy = c.y - by;
        var e = this.getPoint(2).copy();
        e.x -= bx;
        e.y -= by;
        if (this._getToShortLength() !== 0) this._shiftPointByShortLength(e, false, p);
        g.bezierTo(cx, cy, cx, cy, e.x, e.y /*, true, true*/);
      } else {
        if (this.isOrthogonal) {
          var cp10 = new Point(bx, by);
          var cp11 = this.getPoint(1).copy();
          var cp20 = new Point(bx, by);
          var cp21 = new Point(bx, by);
          var prev = this.getPoint(0);
          var curr = null;
          //Precalculate this so it isn't calculated with every call of _getOrthogonalBezierControls
          var controlComponentLength = this.smoothness / 3;

          for (var i = 1; i < this.pointsCount - 1; i++) {
            curr = this.getPoint(i);

            var cp0 = prev;
            var cp1 = curr;
            var cp2 = this.getPoint(this._furthestPoint(curr, i, false));
            //If the curr lies on a straight line with the previous and next points, ignore it. One of these conditionals will be true if
            if (Geo.isApproxEqual(cp0.x, cp1.x) && Geo.isApproxEqual(cp1.x, cp2.x))
              continue;
            if (Geo.isApproxEqual(cp0.y, cp1.y) && Geo.isApproxEqual(cp1.y, cp2.y))
              continue;

            this._getOrthogonalBezierControls(cp0, cp1, cp2, controlComponentLength, cp20, cp21);

            if (i === 1) { //special case where there is no intermediate point between the start point and the first corner.
              cp11.x = (prev.x + curr.x) * 0.5;
              cp11.y = (prev.y + curr.y) * 0.5;
            } else if (i === 2 && // case where point 1 is on the line connecting point 2 and point 0, use midpoint of line as control point
                       Geo.isApproxEqual(prev.x, this.getPoint(0).x) &&
                       Geo.isApproxEqual(prev.y, this.getPoint(0).y)) {
              cp11.x = (prev.x + curr.x) * 0.5;
              cp11.y = (prev.y + curr.y) * 0.5;
            }

            //Account for control point overlap due to large values of Smoothness and/or small segments

            g.bezierTo(cp11.x - bx, cp11.y - by, cp20.x - bx, cp20.y - by, curr.x - bx, curr.y - by /*, true, false*/);

            cp10.set(cp20);
            cp11.set(cp21);
            prev = curr;
          }

          //Point endControl = this.getPoint(this.pointsCount-2).copy();
          var endControlX = prev.x;
          var endControlY = prev.y;
          var endPoint = this.getPoint(this.pointsCount - 1);
          //if (Geo.isApproxEqual(endControl, prev))
          endControlX = 0.5 * (endControlX + endPoint.x);
          endControlY = 0.5 * (endControlY + endPoint.y);

          g.bezierTo(cp21.x - bx, cp21.y - by, endControlX - bx, endControlY - by, endPoint.x - bx, endPoint.y - by /*, true, false*/);
        } else {
          var startControl, endControl, end;
          for (var i = 3; i < numpts; i += 3) {
            startControl = this.getPoint(i - 2);
            // if it's the last segment, use the last two points
            if (i + 3 >= numpts)
              i = numpts - 1;
            endControl = this.getPoint(i - 1);
            end = this.getPoint(i);
            if (i === numpts - 1 && this._getToShortLength() !== 0) {
              end = end.copy();
              this._shiftPointByShortLength(end, false, Geo.Origin);
            }
            g.bezierTo(startControl.x - bx, startControl.y - by,
                        endControl.x - bx, endControl.y - by,
                        end.x - bx, end.y - by /*, true, true*/);
          }
        }
      }
    } else {
      var from = Util.tempPoint();
      from.assign(this.getPoint(0));
      var i = 1;
      while (i < numpts) {
        i = this._furthestPoint(from, i, (i > 1));
        var to = this.getPoint(i);
        if (i >= numpts - 1) {
          if (from !== to) {
            if (this._getToShortLength() !== 0) {
              to = to.copy();
              this._shiftPointByShortLength(to, false, Geo.Origin);
            }
            this._addLine(g, -bx, -by, from, to);
          }
          break;
        }
        var j = this._furthestPoint(to, i + 1, (i < numpts - 3));
        var next = this.getPoint(j);
        this._addLineAndCorner(g, -bx, -by, from, to, next, from);
        i = j;
      }
      Util.freePoint(from);
    }
    var geo = g.geo;
    Util.freeStreamGeometryContext(g);
    return geo;
  }
};

/**
* @ignore
* @this {Link}
* @param {number} ax
* @param {number} ay
* @param {number} bx
* @param {number} by
* @return {number}
*/
Link.prototype._getDistanceBetweenLinkPoints = function(ax, ay, bx, by) {
  var dx = bx - ax;
  if (isNaN(dx) || dx === Infinity || dx === -Infinity) return NaN;
  if (dx < 0) dx = -dx;
  var dy = by - ay;
  if (isNaN(dy) || dy === Infinity || dy === -Infinity) return NaN;
  if (dy < 0) dy = -dy;
  if (Geo.isApproxEqual(dx, 0)) return dy;
  if (Geo.isApproxEqual(dy, 0)) return dx;
  return Math.sqrt(dx * dx + dy * dy);
};

/**
* @ignore
* @this {Link}
* @param {Point} a
* @param {Point} b
* @param {Point} c
* @param {number} ratio the control point distance ratio.
* @param {Point} cp0 a Point to be modified to hold the results.
* @param {Point} cp1 a Point to be modified to hold the results.
*/
Link.prototype._getOrthogonalBezierControls = function(a, b, c, ratio, cp0, cp1) {
  if (isNaN(ratio)) { //set to default value
    ratio = this.smoothness / 3;
  }

  var ax = a.x;
  var ay = a.y;
  var bx = b.x;
  var by = b.y;
  var cx = c.x;
  var cy = c.y;

  var length1 = ratio * this._getDistanceBetweenLinkPoints(ax, ay, bx, by);
  var length2 = ratio * this._getDistanceBetweenLinkPoints(bx, by, cx, cy);

  if (Geo.isApproxEqual(ay, by) && Geo.isApproxEqual(bx, cx)) {  // horizontal then vertical
    if (bx > ax) {  // right
      if (cy > by) {  // right then down
        cp0.x = bx - length1;
        cp0.y = by - length1;
        cp1.x = bx + length2;
        cp1.y = by + length2;
      } else {  // right then up
        cp0.x = bx - length1;
        cp0.y = by + length1;
        cp1.x = bx + length2;
        cp1.y = by - length2;
      }
    } else {  // left
      if (cy > by) {  // left then down
        cp0.x = bx + length1;
        cp0.y = by - length1;
        cp1.x = bx - length2;
        cp1.y = by + length2;
      } else {  // left then up
        cp0.x = bx + length1;
        cp0.y = by + length1;
        cp1.x = bx - length2;
        cp1.y = by - length2;
      }
    }
  }

  if (Geo.isApproxEqual(ax, bx) && Geo.isApproxEqual(by, cy)) {  // vertical then horizontal
    if (by > ay) {  // down
      if (cx > bx) {  // down then right
        cp0.x = bx - length1;
        cp0.y = by - length1;
        cp1.x = bx + length2;
        cp1.y = by + length2;
      } else {  // down then left
        cp0.x = bx + length1;
        cp0.y = by - length1;
        cp1.x = bx - length2;
        cp1.y = by + length2;
      }
    } else {  // up
      if (cx > bx) {  // up then right
        cp0.x = bx - length1;
        cp0.y = by + length1;
        cp1.x = bx + length2;
        cp1.y = by - length2;
      } else {  // up then left
        cp0.x = bx + length1;
        cp0.y = by + length1;
        cp1.x = bx - length2;
        cp1.y = by - length2;
      }
    }
  }

  if ((Geo.isApproxEqual(ax, bx) && Geo.isApproxEqual(bx, cx)) ||
      (Geo.isApproxEqual(ay, by) && Geo.isApproxEqual(by, cy))) {  // parallel segments
    var midpointX = 0.5 * (ax + cx);
    var midpointY = 0.5 * (ay + cy);
    cp0.x = midpointX;
    cp0.y = midpointY;
    cp1.x = midpointX;
    cp1.y = midpointY;
  }
};

/**
* @ignore
* @this {Link}
* @param {Point} pt the Point to be modified with the result, in geometry coordinates.
* @param {boolean} from
* @param {Point} offset the translation from document to geometry coordinates.
*/
Link.prototype._shiftPointByShortLength = function(pt, from, offset) {
  var numpts = this.pointsCount;
  if (numpts < 2) return;
  if (from) {
    var otherPt = this.getPoint(1);
    var otherX = otherPt.x - offset.x;
    var otherY = otherPt.y - offset.y;
    var segmentLength = this._getDistanceBetweenLinkPoints(pt.x, pt.y, otherX, otherY);
    if (segmentLength === 0) return;
    var max = (numpts === 2) ? segmentLength * 0.5 : segmentLength;
    var short = this._getFromShortLength();
    if (short > max) short = max;
    var ox = short * (otherX - pt.x) / segmentLength;
    var oy = short * (otherY - pt.y) / segmentLength;
    pt.x += ox;
    pt.y += oy;
  } else {  // "to" end
    var otherPt = this.getPoint(numpts - 2);
    var otherX = otherPt.x - offset.x;
    var otherY = otherPt.y - offset.y;
    var segmentLength = this._getDistanceBetweenLinkPoints(pt.x, pt.y, otherX, otherY);
    if (segmentLength === 0) return;
    var max = (numpts === 2) ? segmentLength * 0.5 : segmentLength;
    var short = this._getToShortLength();
    if (short > max) short = max;
    var ox = short * (pt.x - otherX) / segmentLength;
    var oy = short * (pt.y - otherY) / segmentLength;
    pt.x -= ox;
    pt.y -= oy;
  }
};

/**
* @ignore
* @this {Link}
* @param {Point} a
* @param {number} i
* @param {boolean} oneway
* @return {number}
*/
Link.prototype._furthestPoint = function(a, i, oneway) {
  var numpts = this.pointsCount;
  // look for a different point, to give a direction from A to B
  var b = a;
  while (Geo.isApproxEqual(a.x, b.x) && Geo.isApproxEqual(a.y, b.y)) {
    if (i >= numpts)
      return numpts - 1;
    b = this.getPoint(i++);
  }
  // now A !== B, so we have a direction
  // make sure the direction is orthogonal
  if (!Geo.isApproxEqual(a.x, b.x) && !Geo.isApproxEqual(a.y, b.y))
    return i - 1;
  // now a.x === b.x || a.y === b.y
  // keep going in the orthogonal direction
  var c = b;
  while ((Geo.isApproxEqual(a.x, b.x) && Geo.isApproxEqual(b.x, c.x) && (!oneway || (a.y >= b.y ? b.y >= c.y : b.y <= c.y))) ||
         (Geo.isApproxEqual(a.y, b.y) && Geo.isApproxEqual(b.y, c.y) && (!oneway || (a.x >= b.x ? b.x >= c.x : b.x <= c.x)))) {
    if (i >= numpts)
      return numpts - 1;
    c = this.getPoint(i++);
  }
  // now B !== C, so C is off the A-B line
  return i - 2;
};

//?? NYI only perpendicular lines supported
/**
* @ignore
* @this {Link}
* @param {StreamGeometryContext} g
* @param {number} offx
* @param {number} offy
* @param {Point} a
* @param {Point} b
* @param {Point} c
* @param {Point} end this is modified to be the end point of this operation
*/
Link.prototype._addLineAndCorner = function(g, offx, offy, a, b, c, end) {
  if (Geo.isApprox(a.y, b.y) && Geo.isApprox(b.x, c.x)) {  // horizontal then vertical
    var corner = this.computeCorner();
    var dx = Math.min(corner, Math.abs(b.x - a.x) / 2);
    var dy = Math.min(dx /* corner */, Math.abs(c.y - b.y) / 2);
    dx = dy;  // assume square corners
    if (Geo.isApprox(dx, 0)) {
      this._addLine(g, offx, offy, a, b);
      end.assign(b);
      return;
    }
    var arc1x = b.x;
    var arc1y = b.y;
    var arc2x = arc1x;
    var arc2y = arc1y;
    if (b.x > a.x) {  // right
      arc1x = b.x - dx;
      if (c.y > b.y) {  // right and down
        arc2y = b.y + dy;
      } else {  // right and up
        arc2y = b.y - dy;
      }
    } else {  // left
      arc1x = b.x + dx;
      if (c.y > b.y) {  // left and down
        arc2y = b.y + dy;
      } else {  // left and up
        arc2y = b.y - dy;
      }
    }
    this._addLine(g, offx, offy, a, new Point(arc1x, arc1y));
    g.quadraticBezierTo(b.x + offx, b.y + offy, arc2x + offx, arc2y + offy);
    end._set(arc2x, arc2y);
  } else if (Geo.isApprox(a.x, b.x) && Geo.isApprox(b.y, c.y)) { // vertical then horizontal
    var corner = this.computeCorner();
    var dy = Math.min(corner, Math.abs(b.y - a.y) / 2);
    var dx = Math.min(dy /* corner */, Math.abs(c.x - b.x) / 2);
    dy = dx;  // assume square corners
    if (Geo.isApprox(dx, 0)) {
      this._addLine(g, offx, offy, a, b);
      end.assign(b);
      return;
    }
    var arc1x = b.x;
    var arc1y = b.y;
    var arc2x = arc1x;
    var arc2y = arc1y;
    if (b.y > a.y) {  // down
      arc1y = b.y - dy;
      if (c.x > b.x) {  // down and right
        arc2x = b.x + dx;
      } else {  // down and left
        arc2x = b.x - dx;
      }
    } else {  // up
      arc1y = b.y + dy;
      if (c.x > b.x) {  // up and right
        arc2x = b.x + dx;
      } else {  // up and left
        arc2x = b.x - dx;
      }
    }
    this._addLine(g, offx, offy, a, new Point(arc1x, arc1y));
    g.quadraticBezierTo(b.x + offx, b.y + offy, arc2x + offx, arc2y + offy);
    end._set(arc2x, arc2y);
  } else {
    this._addLine(g, offx, offy, a, b);
    end.assign(b);
  }
};

/**
* @ignore
* @this {Link}
* @param {StreamGeometryContext} g
* @param {number} offx
* @param {number} offy
* @param {Point} from
* @param {Point} to
*/
Link.prototype._addLine = function(g, offx, offy, from, to) {
  if (!this._jumpsOver()) {
    g.lineTo(to.x + offx, to.y + offy /*, true, true*/);
  } else {
    var curve = 10;  //??
    var curve2 = curve / 2;
    var vec = new List('number');
    var numints = this._getIntersections(from, to, vec);
    var lastX = from.x;
    var lastY = from.y;
    if (numints > 0) {
      if (Geo.isApprox(from.y, to.y)) {
        // vec is sorted by increasing values
        if (from.x < to.x) {
          var j = 0;
          while (j < numints) {
            var closer = Math.max(from.x, Math.min(vec._arr[j++] - curve2, to.x - curve));
            g.lineTo(closer + offx, to.y + offy /*, true, true*/);
            lastX = closer + offx;
            lastY = to.y + offy;
            var farther = Math.min(closer + curve, to.x);
            while (j < numints) {
              var next = vec._arr[j];
              if (next < farther + curve) {
                j++;
                farther = Math.min(next + curve2, to.x);
              } else {
                break;  // leave J as is for next lineTo call
              }
            }
            var controlX = (closer + farther) / 2 + offx;
            var controlY = to.y - curve + offy;
            var endX = farther + offx;
            var endY = to.y + offy;
            if (this.curve === Link.JumpGap)
              g.beginFigure(endX, endY, false, false);
            else  //this.curve === Link.JumpOver
              g.bezierTo(lastX, controlY, endX, controlY, endX, endY /*, true, true*/);
            lastX = endX;
            lastY = endY;
          }
        } else {  // from.x > to.x
          var j = numints - 1;
          while (j >= 0) {
            var closer = Math.min(from.x, Math.max(vec._arr[j--] + curve2, to.x + curve));
            g.lineTo(closer + offx, to.y + offy /*, true, true*/);
            lastX = closer + offx;
            lastY = to.y + offy;
            var farther = Math.max(closer - curve, to.x);
            while (j >= 0) {
              var next = vec._arr[j];
              if (next > farther - curve) {
                j--;
                farther = Math.max(next - curve2, to.x);
              } else {
                break;  // leave J as is for next lineTo call
              }
            }
            var controlX = (closer + farther) / 2 + offx;
            var controlY = to.y - curve + offy;
            var endX = farther + offx;
            var endY = to.y + offy;
            if (this.curve === Link.JumpGap)
              g.beginFigure(endX, endY, false, false);
            else  //this.curve === Link.JumpOver
              g.bezierTo(lastX, controlY, endX, controlY, endX, endY /*, true, true*/);
            lastX = endX;
            lastY = endY;
          }
        }
      } else if (Geo.isApprox(from.x, to.x)) {
        // vec is sorted by increasing values
        if (from.y < to.y) {
          var j = 0;
          while (j < numints) {
            var closer = Math.max(from.y, Math.min(vec._arr[j++] - curve2, to.y - curve));
            g.lineTo(to.x + offx, closer + offy /*, true, true*/);
            lastX = to.x + offx;
            lastY = closer + offy;
            var farther = Math.min(closer + curve, to.y);
            while (j < numints) {
              var next = vec._arr[j];
              if (next < farther + curve) {
                j++;
                farther = Math.min(next + curve2, to.y);
              } else {
                break;  // leave J as is for next lineTo call
              }
            }
            var controlX = to.x - curve + offx;
            var controlY = (closer + farther) / 2 + offy;
            var endX = to.x + offx;
            var endY = farther + offy;
            if (this.curve === Link.JumpGap)
              g.beginFigure(endX, endY, false, false);
            else  //this.curve === Link.JumpOver
              g.bezierTo(controlX, lastY, controlX, endY, endX, endY /*, true, true*/);
            lastX = endX;
            lastY = endY;
          }
        } else {  // from.y > to.y
          var j = numints - 1;
          while (j >= 0) {
            var closer = Math.min(from.y, Math.max(vec._arr[j--] + curve2, to.y + curve));
            g.lineTo(to.x + offx, closer + offy /*, true, true*/);
            lastX = to.x + offx;
            lastY = closer + offy;
            var farther = Math.max(closer - curve, to.y);
            while (j >= 0) {
              var next = vec._arr[j];
              if (next > farther - curve) {
                j--;
                farther = Math.max(next - curve2, to.y);
              } else {
                break;  // leave J as is for next lineTo call
              }
            }
            var controlX = to.x - curve + offx;
            var controlY = (closer + farther) / 2 + offy;
            var endX = to.x + offx;
            var endY = farther + offy;
            if (this.curve === Link.JumpGap)
              g.beginFigure(endX, endY, false, false);
            else  //this.curve === Link.JumpOver
              g.bezierTo(controlX, lastY, controlX, endY, endX, endY /*, true, true*/);
            lastX = endX;
            lastY = endY;
          }
        }
      }
    }
    g.lineTo(to.x + offx, to.y + offy /*, true, true*/);
  }
};

/**
* @ignore
* @this {Link}
* @param {Point} A
* @param {Point} B
* @param {List} v of numbers.
* @return {number}
*/
Link.prototype._getIntersections = function(A, B, v) {
  var diagram = this.diagram;
  if (diagram === null) return 0;

  var minx = Math.min(A.x, B.x);
  var miny = Math.min(A.y, B.y);
  var maxx = Math.max(A.x, B.x);
  var maxy = Math.max(A.y, B.y);
  var lit = diagram.layers;
  while (lit.next()) {
    var layer = lit.value;
    if (layer !== null && layer.visible) {
      var arr = layer.getOrthoLinksArray();
      var pitlen = arr.length;
      for (var pit = 0; pit < pitlen; pit++) {
        var otherlink = arr[pit];
        // done searching for links underneath this one
        if (otherlink === this) {
          if (v.length > 0) {
            v.sort(
              /** @return {number} */
              function(a,b) { return a - b; });
          }
          return v.length;
        }
        if (!(otherlink instanceof Link)) continue;
        // ignore invisible links
        if (!this.isVisible()) continue;
        if (!otherlink.isVisible()) continue;
        // ignore links that don't also JumpOver or JumpGap
        if (!otherlink._jumpsOver()) continue;
        // ignore links that are far away
        var rb = otherlink._getRouteBounds();
        if (!rb.isReal()) continue;
        if (!this._getRouteBounds().intersectsRect(rb)) continue;
        // ignore links that connect to the same nodes as this link does
        if (this.usesSamePort(otherlink)) continue;
        // ignore link with no or invisible path
        var shape = otherlink.path;
        if (shape === null) continue;
        if (!shape.isVisibleObject()) continue;
        this._getIntersections2(A, B, v, otherlink);
      }
    }
  }
  if (v.length > 0) {

    v.sort(
      /** @return {number} */
      function(a,b) { return a - b; });
  }
  return v.length;
};

/**
* @ignore
* @this {Link}
* @param {Point} A
* @param {Point} B
* @param {List} v  of numbers.
* @param {Link} route
*/
Link.prototype._getIntersections2 = function(A, B, v, route) {
  var numpts = route.pointsCount;
  for (var i = 1; i < numpts; i++) {
    var from = route.getPoint(i - 1);
    var to = route.getPoint(i);
    var temp = Util.tempPoint();
    if (this._getOrthoSegmentIntersection(A, B, from, to, temp)) {
      if (Geo.isApprox(A.y, B.y))
        v.add(temp.x);
      else
        v.add(temp.y);
    }
    Util.freePoint(temp);
  }
};

/**
* @ignore
* @this {Link}
* @param {Point} A
* @param {Point} B
* @param {Point} C
* @param {Point} D
* @param {Point} result
* @return {boolean}
*/
Link.prototype._getOrthoSegmentIntersection = function(A, B, C, D, result) {
  if (!Geo.isApprox(A.x, B.x)) {
    // A.y === B.y : AB is horizontal, so CD must be vertical
    if (Geo.isApprox(C.x, D.x) &&
      Math.min(A.x, B.x) <= C.x &&
      Math.max(A.x, B.x) >= C.x &&
      Math.min(C.y, D.y) <= A.y &&
      Math.max(C.y, D.y) >= A.y &&
      !Geo.isApprox(C.y, D.y)) {
      result.x = C.x;
      result.y = A.y;
      return true;
    }
  } else {
    // A.x === B.x : AB is vertical, so CD must be horizontal
    if (Geo.isApprox(C.y, D.y) &&
      Math.min(A.y, B.y) <= C.y &&
      Math.max(A.y, B.y) >= C.y &&
      Math.min(C.x, D.x) <= A.x &&
      Math.max(C.x, D.x) >= A.x &&
      !Geo.isApprox(C.x, D.x)) {
      result.x = A.x;
      result.y = C.y;
      return true;
    }
  }
  result.x = 0;
  result.y = 0;
  return false;
};

/**
* @ignore
* @name Link#firstPickIndex
* @function.
* @return {number}
*/
/** @type {number} */
Link.prototype.firstPickIndex;
Util.defineReadOnlyProperty(Link, { firstPickIndex: 'firstPickIndex'},
  /** @this {Link} */
  function() {
    var n = this.pointsCount;
    if (n <= 2) return 0;
    if (this.isOrthogonal || this._getFromSpot() !== Spot.None) return 1;
    return 0;
  }
);

/**
* @ignore
* @name Link#lastPickIndex
* @function.
* @return {number}
*/
/** @type {number} */
Link.prototype.lastPickIndex;
Util.defineReadOnlyProperty(Link, { lastPickIndex: 'lastPickIndex'},
  /** @this {Link} */
  function() {
    var n = this.pointsCount;
    if (n === 0) return 0;
    if (n <= 2) return n - 1;
    if (this.isOrthogonal || this._getToSpot() !== Spot.None) return n - 2;
    return n - 1;
  }
);


/**
* @ignore
* @this {Link}
*/
Link.prototype._jumpsOver = function() {
  var c = this.curve;
  return (c === Link.JumpOver || c === Link.JumpGap);
};

/**
* @ignore
* @this {Link}
* @param {boolean} force
*/
Link.prototype._invalidateOtherJumpOversMaybe = function(force) {
  if (force || this._jumpsOver()) {
    var diagram = this.diagram;
    if (diagram !== null && !diagram._delayedGeometries.contains(this) && this._previousBounds !== null) {
      diagram._delayedGeometries.add(this, this._previousBounds);
    }
  }
};

/**
* @ignore
* Maybe invalidate the geometries of other links that jump or gap over this link
* @this {Link}
* @param {Rect} prevbounds
*/
Link.prototype.invalidateOtherJumpOvers = function(prevbounds) {
  var thislayer = this.layer;
  if (thislayer === null || !thislayer.visible || thislayer.isTemporary) return;
  var diagram = thislayer.diagram;
  if (diagram === null) return;
  var foundlayer = false;
  var lit = diagram.layers;
  while (lit.next()) {
    // only consider visible LinkLayers
    var layer = lit.value;
    if (!layer.visible) continue;
    // skip over layers before THISLAYER
    if (layer === thislayer) {
      foundlayer = true;
      var foundlink = false;
      var arr = layer.getOrthoLinksArray();
      var pitlen = arr.length;
      for (var pit = 0; pit < pitlen; pit++) {
        var link = arr[pit];
        if (!(link instanceof Link)) continue;
        // skip over links before THISLINK
        if (link === this) {
          foundlink = true;
        } else if (foundlink) {  // for any Link after THISLINK
          this._invalidateJumpOvers(link, prevbounds);
        }
      }
    } else if (foundlayer) {  // for any LinkLayer after THISLAYER
      var arr = layer.getOrthoLinksArray();
      var pitlen = arr.length;
      for (var pit = 0; pit < pitlen; pit++) {
        var link = arr[pit];
        if (!(link instanceof Link)) continue;
        this._invalidateJumpOvers(link, prevbounds);
      }
    }
  }
};

/**
* @ignore
* @this {Link}
* @param {Link} otherlink
* @param {Rect} prevbounds
*/
Link.prototype._invalidateJumpOvers = function(otherlink, prevbounds) {
  // OTHERLINK needs to have a JumpOver or JumpGap curve and intersecting bounds
  if (otherlink === null) return;
  if (!otherlink._jumpsOver()) return;
  if (otherlink._geometry === null) return;
  var rb = otherlink._getRouteBounds();
  if (!rb.isReal()) return;
  if (!this._getRouteBounds().intersectsRect(rb) && !prevbounds.intersectsRect(rb)) return;
  // if it uses the same port, don't jump-over
  if (this.usesSamePort(otherlink)) return;
  otherlink.invalidateGeometry();
};

/**
* @ignore
* @expose
* @this {Link}
* @param {Link} otherlink
* @return {boolean}
*/
Link.prototype.usesSamePort = function(otherlink) {
  var numpts = this.pointsCount;
  var otherpts = otherlink.pointsCount;
  if (numpts > 0 && otherpts > 0) {
    // assume no jump-overs when links come from or go to the same point;
    // the Points are in document coordinates, not the local coordinates of geometries
    var start = this.getPoint(0);
    var ostart = otherlink.getPoint(0);
    if (start.equalsAbout(ostart)) return true;
    var end = this.getPoint(numpts - 1);
    var oend = otherlink.getPoint(otherpts - 1);
    if (end.equalsAbout(oend)) return true;
  } else {
    // assume no jump-overs when crossing a link from/to the same node
    if (this.fromNode === otherlink.fromNode) return true;
    if (this.toNode === otherlink.toNode) return true;
  }
  return false;
};


/**
* Gets or sets how the route is computed, including whether it uses the points of its old route to determine the new route.
* The value must be one of {@link #None}, {@link #End}, {@link #Scale}, or {@link #Stretch}.
* The default value is {@link #None}.
* @name Link#adjusting
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
Link.prototype.adjusting;
Util.exportProperty(Link, 'adjusting', Link.prototype.adjusting);
Util.defineProperty(Link, { adjusting: 'adjusting'},
  /** @this {Link} */
  function() { return this._adjusting; },
  /** @this {Link} */
  function(val) {
    var old = this._adjusting;
    if (old !== val) {
      if (Debug) Util.checkEnumValue(val, Link, Link, 'adjusting');
      this._adjusting = val;
      this.raiseChanged('adjusting', old, val);
      // no immediate effect -- just used when reshaping
    }
  }
);

/**
* Gets or sets how rounded the corners are for adjacent line segments when the {@link #curve}
* is {@link #None} {@link #JumpGap}, or {@link #JumpOver} and
* the two line segments are orthogonal to each other.
* This defaults to zero.
* @name Link#corner
* @function.
* @return {number}
*/
/** @type {number} */
Link.prototype.corner;
Util.exportProperty(Link, 'corner', Link.prototype.corner);
Util.defineProperty(Link, { corner: 'corner'},
  /** @this {Link} */
  function() { return this._corner; },
  /** @this {Link} */
  function(val) {
    var old = this._corner;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'number', Link, 'corner');
      this._corner = val;
      this.invalidateGeometry();
      this.raiseChanged('corner', old, val);
    }
  }
);

/**
* Gets or sets the way the path is generated from the route's points.
* The value must be one of {@link #None}, {@link #Bezier}, {@link #JumpGap}, or {@link #JumpOver}.
* <p>
* Setting this property to {@link #JumpOver} requires the Diagram to do
* considerable computation when calculating Link routes. Consider not using
* the {@link #JumpOver} with Diagrams that contain large amounts of Links
* if you are targeting slow or mobile devices.
* <p>
* The default value is {@link #None}.
* @name Link#curve
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
Link.prototype.curve;
Util.exportProperty(Link, 'curve', Link.prototype.curve);
Util.defineProperty(Link, { curve: 'curve'},
  /** @this {Link} */
  function() { return this._curve; },
  /** @this {Link} */
  function(val) {
    var old = this._curve;
    if (old !== val) {
      if (Debug) Util.checkEnumValue(val, Link, Link, 'curve');
      this._curve = val;
      this.invalidateRoute();
      this._invalidateOtherJumpOversMaybe(old === Link.JumpGap || old === Link.JumpOver ||
                                          val === Link.JumpGap || val === Link.JumpOver);
      this.raiseChanged('curve', old, val);
    }
  }
);

/**
* Gets or sets how far the control points are offset when the {@link #curve} is {@link #Bezier}
* or when there are multiple links between the same two ports.
* This defaults to NaN.
* @name Link#curviness
* @function.
* @return {number}
*/
/** @type {number} */
Link.prototype.curviness;
Util.exportProperty(Link, 'curviness', Link.prototype.curviness);
Util.defineProperty(Link, { curviness: 'curviness'},
  /** @this {Link} */
  function() { return this._curviness; },
  /** @this {Link} */
  function(val) {
    var old = this._curviness;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'number', Link, 'curviness');
      this._curviness = val;
      this.invalidateRoute();
      this.raiseChanged('curviness', old, val);
    }
  }
);

/**
* Gets or sets whether the link's path tries to avoid other nodes.
* The value must be one of {@link #Normal}, {@link #Orthogonal}, or {@link #AvoidsNodes}.
* <p>
* Setting this property to {@link #AvoidsNodes} requires the Diagram to do
* considerable computation when calculating Link routes. Consider not using
* the {@link #AvoidsNodes} with Diagrams that contain large amounts of Nodes and Links
* if you are targeting slow or mobile devices.
* <p>
* The default value is {@link #Normal}.
* @name Link#routing
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
Link.prototype.routing;
Util.exportProperty(Link, 'routing', Link.prototype.routing);
Util.defineProperty(Link, { routing: 'routing'},
  /** @this {Link} */
  function() { return this._routing; },
  /** @this {Link} */
  function(val) {
    var old = this._routing;
    if (old !== val) {
      if (Debug) Util.checkEnumValue(val, Link, Link, 'routing');
      this._routing = val;
      this._effectiveBezier = null;
      this.invalidateRoute();
      this._invalidateOtherJumpOversMaybe(Link.isOrthogonalRouting(old) || Link.isOrthogonalRouting(val));
      this.raiseChanged('routing', old, val);
    }
  }
);

/**
* Gets or sets how far the control points are from the points of the route
* when {@link #routing} is {@link #Orthogonal} and {@link #curve} is {@link #Bezier}.
* The default value is 0.5.
* <p/>
* Values of this property typically fall in the range of 0.0 to 1.0.
* A value of 0.0 indicates that the control points of the curve are at the end points,
* which will result in straight line segments.
* A value of 1.0 indicates that the control points are one-third of the link's
* length away from the end point along the direction of the link,
* and the same distance away in a perpendicular direction.
* The distance scales linearly with the value of this property,
* even with negative values and values greater than 1.0.
* @name Link#smoothness
* @function.
* @return {number}
*/
/** @type {number} */
Link.prototype.smoothness;
Util.exportProperty(Link, 'smoothness', Link.prototype.smoothness);
Util.defineProperty(Link, { smoothness: 'smoothness'},
  /** @this {Link} */
  function() { return this._smoothness; },
  /** @this {Link} */
  function(val) {
    var old = this._smoothness;
    if (old !== val) {
      if (Debug) Util.checkPrimitive(val, 'number', Link, 'smoothness');
      this._smoothness = val;
      this.invalidateGeometry();
      this.raiseChanged('smoothness', old, val);
    }
  }
);


/**
* @ignore
* @this {Link}
*/
Link.prototype.updateLinkBundleAdd = function() {
  //?? some way not to participate in link bundling?
  //?? bundling all links between nodes, not specifically between pairs of ports
  var fromnode = this._fromNode;
  if (fromnode === null) return;
  var tonode = this._toNode;
  if (tonode === null) return;

  // see if there's an existing LinkBundle between the nodes/ports
  var fromparam = this._fromPortId;
  var toparam = this._toPortId;
  var bundle = fromnode.findBundle(tonode, fromparam, toparam);
  var bundledlinks = null;  // if set to a list, we'll need a LinkBundle if one doesn't already exist
  var firstlink = null;

  var lit = fromnode._linksConnected._arr;
  var length = lit.length;
  for (var i = 0; i < length; i++) {
    var l = lit[i];
    if (!(l._fromNode === fromnode && l._fromPortId === fromparam && l._toNode === tonode && l._toPortId === toparam) &&
        !(l._fromNode === tonode && l._fromPortId === toparam && l._toNode === fromnode && l._toPortId === fromparam)) {
      continue;
    }
    if (firstlink === null) {  // found first link
      firstlink = l;
    } else {
      if (bundledlinks === null) {  // found second link: need bundle!
        bundledlinks = new List(Link);
        bundledlinks.add(firstlink);
      }
      // found any link after the first one
      bundledlinks.add(l);
    }
  }

  if (bundledlinks !== null) {  // need a LinkBundle
    if (bundle === null) {
      bundle = new LinkBundle();
      bundle.node1 = fromnode;
      bundle.param1 = fromparam;
      bundle.node2 = tonode;
      bundle.param2 = toparam;
      fromnode.addBundle(bundle);
      tonode.addBundle(bundle);
    }
    bundle.links = bundledlinks;
    for (var i = 0; i < bundledlinks.count; i++) {
      var l = bundledlinks._arr[i];
      if (l._bundleIndex === 0) {
        var idx = 1;  // always finds a positive index
        for (var j = 0; j < bundledlinks.count; j++) {
          var l2 = bundledlinks._arr[j];
          if (Math.abs(l2._bundleIndex) === idx) {
            idx++;
            j = -1;  // start search over again with new IDX value
          }
        }
        l._bundle = bundle;  // update the back pointers
        l._bundleIndex = ((l.fromNode === bundle.node1) ? idx : -idx);  // negative if links go the other way
        l.invalidateRoute();
      }
    }
  }
};

/**
* @ignore
* @this {Link}
*/
Link.prototype.updateLinkBundleRemove = function() {
  // see if there's an existing LinkBundle for this link
  var bundle = this._bundle;
  if (bundle !== null) {
    var oldindex = this._bundleIndex;
    this._bundle = null;
    this._bundleIndex = 0;
    this.invalidateRoute();
    bundle.links.remove(this);
    // if one or none left, remove the LinkBundle from both nodes
    if (bundle.links.count < 2) {
      // if there's only one link left in the LinkBundle, assume it shouldn't have one at all
      if (bundle.links.count === 1) {
        var otherlink = bundle.links._arr[0];
        otherlink._bundle = null;
        otherlink._bundleIndex = 0;
        otherlink.invalidateRoute();
      }
      bundle.node1.removeBundle(bundle);
      bundle.node2.removeBundle(bundle);
    } else {  // two or more links left in bundle
      // oldindex value no longer used: shift down BundleIndex values > oldindex, ignoring sign,
      // if they are on the same side as oldindex (i.e., if even, all even BundleIndexes that are larger than oldindex)
      oldindex = Math.abs(oldindex);
      var even = oldindex % 2 === 0;
      var lit = bundle.links.iterator;
      while (lit.next()) {
        var l = lit.value;
        var idx = Math.abs(l._bundleIndex);
        var e = idx % 2 === 0;
        if (idx > oldindex && even === e) {
          if (l._bundleIndex > 0) {
            l._bundleIndex -= 2;
          } else {
            l._bundleIndex += 2;
          }
          l.invalidateRoute();
        }
      }
    }
  }
};


/**
* @ignore
* @constructor
* @class
*/
function LinkBundle() {
  Util.uniqueHash(this);
  /** @ignore @type {Node} */
  this.node1 = null;
  /** @ignore @type {?string} */
  this.param1 = null;
  /** @ignore @type {Node} */
  this.node2 = null;
  /** @ignore @type {?string} */
  this.param2 = null;
  /** @ignore @type {List} */
  this.links = null;
  /** @ignore @type {number} */
  this.spacing = 10;
}

Util.defineDataProperties(LinkBundle, {
  node1: true,
  param1: true,
  node2: true,
  param2: true,
  links: true,
  spacing: true
});


/**
* @ignore
* @constructor
* @class
*/
function PositionArray() {
  Util.uniqueHash(this);
  /** @ignore @type {Group} */
  this.group = null;
  /** @ignore @type {boolean} */
  this.invalid = true;
  /** @ignore @type {boolean} */
  this.abort = false;
  /** @type {number} */
  this._minX = 1;
  /** @type {number} */
  this._minY = 1;
  /** @type {number} */
  this._maxX = -1;
  /** @type {number} */
  this._maxY = -1;
  /** @type {number} */
  this._cellX = 8;
  /** @type {number} */
  this._cellY = 8;
  /** @type {Array} */
  this._array = null;
  /** @type {number} */
  this._upperBoundX;
  /** @type {number} */
  this._upperBoundY;
  /** @ignore @type {boolean} */
  this.wholeDocument = false;  // whether to search the whole document for a valid route
  /** @ignore @type {number} */
  this.smallMargin = 22;  // how many cells to inflate around the link's nodes' bounds to search
  /** @ignore @type {number} */
  this.largeMargin = 111;  // how many cells to inflate around the link's nodes' bounds to search
}

Util.defineDataProperties(PositionArray, {
  group: true,
  invalid: true,
  abort: true,
  wholeDocument: true,
  smallMargin: true,
  largeMargin: true
});

/** @ignore @const @static @type {number} */
PositionArray.OCCUPIED = 0;
/** @ignore @const @static @type {number} */
PositionArray.START = 1;
/** @ignore @const @static @type {number} */
PositionArray.STEP = 1;
/** @ignore @const @static @type {number} */
PositionArray.MAX = 999999999;
/** @ignore @const @static @type {number} */
PositionArray.UNOCCUPIED = PositionArray.MAX;

/**
* @ignore
* @this {PositionArray}
* @param {Rect} rect
*/
PositionArray.prototype.initialize = function(rect) {
  if (rect.width <= 0 || rect.height <= 0) return;
  var minx = rect.x;
  var miny = rect.y;
  var maxx = rect.x + rect.width;
  var maxy = rect.y + rect.height;
  // add a row and a column on all sides
  this._minX = Math.floor((minx - this._cellX) / this._cellX) * this._cellX;
  this._minY = Math.floor((miny - this._cellY) / this._cellY) * this._cellY;
  this._maxX = Math.ceil((maxx + 2 * this._cellX) / this._cellX) * this._cellX;
  this._maxY = Math.ceil((maxy + 2 * this._cellY) / this._cellY) * this._cellY;
  var xrange = 1 + (Math.ceil((this._maxX - this._minX) / this._cellX) | 0);
  var yrange = 1 + (Math.ceil((this._maxY - this._minY) / this._cellY) | 0);
  if (this._array === null || this._upperBoundX < xrange - 1 || this._upperBoundY < yrange - 1) {
    //initialize like: this._array = new int[xrange, yrange];
    var a = [];
    for (var x = 0; x <= xrange; x++) {
      var b = [];
      for (var y = 0; y <= yrange; y++) {
        b[y] = 0;
      }
      a[x] = b;
    }
    this._array = a;
    this._upperBoundX = xrange - 1;
    this._upperBoundY = yrange - 1;
  }
  this.setAll(PositionArray.UNOCCUPIED);
};

/** @type {Rect} */
PositionArray.prototype.bounds;
Util.defineReadOnlyProperty(PositionArray, { bounds: null},
  /** @this {PositionArray} */
  function() { return new Rect(this._minX, this._minY, this._maxX - this._minX, this._maxY - this._minY); }
);

/** @type {number} */
PositionArray.prototype.cellWidth;
Util.exportProperty(PositionArray, 'cellWidth', PositionArray.prototype.cellWidth);
Util.defineProperty(PositionArray, { cellWidth: null},
  /** @this {PositionArray} */
  function() { return this._cellX; },
  /** @this {PositionArray} */
  function(val) {
    if (val > 0 && val !== this._cellX) {
      this._cellX = val;
      this.initialize(this.bounds);
    }
  }
);

/** @type {number} */
PositionArray.prototype.cellHeight;
Util.exportProperty(PositionArray, 'cellHeight', PositionArray.prototype.cellHeight);
Util.defineProperty(PositionArray, { cellHeight: null},
  /** @this {PositionArray} */
  function() { return this._cellY; },
  /** @this {PositionArray} */
  function(val) {
    if (val > 0 && val !== this._cellY) {
      this._cellY = val;
      this.initialize(this.bounds);
    }
  }
);

/**
* @ignore
* @this {PositionArray}
* @param {number} x  in document coordinates.
* @param {number} y
* @return {boolean}
*/
PositionArray.prototype.inBounds = function(x, y) {
  return (this._minX <= x && x <= this._maxX && this._minY <= y && y <= this._maxY);
};

/**
* @ignore
* @this {PositionArray}
* @param {number} x  in document coordinates.
* @param {number} y
* @return {number}
*/
PositionArray.prototype.getDistance = function(x, y) {
  if (!this.inBounds(x, y)) return 0;
  x -= this._minX;
  x /= this._cellX;
  y -= this._minY;
  y /= this._cellY;
  var ix = x | 0;
  var iy = y | 0;
  return this._array[ix][iy];
};

/**
* @ignore
* @this {PositionArray}
* @param {number} x  in document coordinates.
* @param {number} y
*/
PositionArray.prototype.setOccupied = function(x, y) {
  if (!this.inBounds(x, y)) return;
  x -= this._minX;
  x /= this._cellX;
  y -= this._minY;
  y /= this._cellY;
  var ix = x | 0;
  var iy = y | 0;
  this._array[ix][iy] = PositionArray.OCCUPIED;
};

/**
* @ignore
* @this {PositionArray}
* @param {number} v
*/
PositionArray.prototype.setAll = function(v) {
  if (this._array === null) return;
  for (var ix = 0; ix <= this._upperBoundX; ix++) {
    for (var iy = 0; iy <= this._upperBoundY; iy++) {
      this._array[ix][iy] = v;
    }
  }
};

/**
* @ignore
* @this {PositionArray}
*/
PositionArray.prototype.clearAllUnoccupied = function() {
  if (this._array === null) return;
  for (var ix = 0; ix <= this._upperBoundX; ix++) {
    for (var iy = 0; iy <= this._upperBoundY; iy++) {
      if (this._array[ix][iy] >= PositionArray.START) {
        this._array[ix][iy] |= PositionArray.MAX;
      }
    }
  }
};

/**
* @ignore
* @this {PositionArray}
* @param {number} x  in document coordinates.
* @param {number} y
* @return {boolean}
*/
PositionArray.prototype.isOccupied = function(x, y) {
  return this.getDistance(x, y) === PositionArray.OCCUPIED;
};

/**
* @ignore
* @this {PositionArray}
* @param {number} x  in document coordinates.
* @param {number} y
* @param {number} w
* @param {number} h
* @return {boolean}
*/
PositionArray.prototype.isUnoccupied = function(x, y, w, h) {
  if (x > this._maxX) return true;
  if (x + w < this._minX) return true;
  if (y > this._maxY) return true;
  if (y + h < this._minY) return true;
  var ix = ((x - this._minX) / this._cellX) | 0;
  var iy = ((y - this._minY) / this._cellY) | 0;
  var iw = ((Math.max(0, w) / this._cellX) + 1) | 0;
  var ih = ((Math.max(0, h) / this._cellY) + 1) | 0;
  if (ix < 0) {
    iw += ix;  // decrease width
    ix = 0;
  }
  if (iy < 0) {
    ih += iy;  // decrease height
    iy = 0;
  }
  if (iw < 0) return true;
  if (ih < 0) return true;
  var mx = Math.min(ix + iw - 1, this._upperBoundX) | 0;
  var my = Math.min(iy + ih - 1, this._upperBoundY) | 0;
  for (var i = ix; i <= mx; i++) {
    for (var j = iy; j <= my; j++) {
      if (this._array[i][j] === PositionArray.OCCUPIED) {
        return false;
      }
    }
  }
  return true;
};

/**
* @ignore
* @this {PositionArray}
* @param {number} x
* @param {number} y
* @param {boolean} vert
* @param {number} lowx
* @param {number} hix
* @param {number} lowy
* @param {number} hiy
* @return {number}
*/
PositionArray.prototype.ray = function(x, y, inc, vert, lowx, hix, lowy, hiy) {
  x = x | 0;
  y = y | 0;
  var val = this._array[x][y];
  if (val >= PositionArray.START && val < PositionArray.MAX) {
    if (vert)
      y += inc;
    else
      x += inc;
    val += PositionArray.STEP;
    while (lowx <= x && x <= hix && lowy <= y && y <= hiy) {
      var oldval = this._array[x][y];
      if (val >= oldval) break;
      this._array[x][y] = val;
      val += PositionArray.STEP;
      if (vert)
        y += inc;
      else
        x += inc;
    }
  }
  if (vert)
    return y;
  else
    return x;
};

/**
* @ignore
* @this {PositionArray}
* @param {number} x
* @param {number} y
* @param {boolean} vert
* @param {number} lowx
* @param {number} hix
* @param {number} lowy
* @param {number} hiy
*/
PositionArray.prototype.spread = function(x, y, inc, vert, lowx, hix, lowy, hiy) {
  if (x < lowx || x > hix || y < lowy || y > hiy)
    return;
  var end = this.ray(x, y, inc, vert, lowx, hix, lowy, hiy);
  if (vert) {
    if (inc > 0) {
      for (var yy = y + inc; yy < end; yy += inc) {
        this.spread(x, yy, 1, !vert, lowx, hix, lowy, hiy);
        this.spread(x, yy, -1, !vert, lowx, hix, lowy, hiy);
      }
    } else {
      for (var yy = y + inc; yy > end; yy += inc) {
        this.spread(x, yy, 1, !vert, lowx, hix, lowy, hiy);
        this.spread(x, yy, -1, !vert, lowx, hix, lowy, hiy);
      }
    }
  } else {
    if (inc > 0) {
      for (var xx = x + inc; xx < end; xx += inc) {
        this.spread(xx, y, 1, !vert, lowx, hix, lowy, hiy);
        this.spread(xx, y, -1, !vert, lowx, hix, lowy, hiy);
      }
    } else {
      for (var xx = x + inc; xx > end; xx += inc) {
        this.spread(xx, y, 1, !vert, lowx, hix, lowy, hiy);
        this.spread(xx, y, -1, !vert, lowx, hix, lowy, hiy);
      }
    }
  }
};

/**
* @ignore
* @this {PositionArray}
* @param {number} x1
* @param {number} y1
* @param {number} x2
* @param {number} y2
* @param {number} inc
* @param {boolean} vert
* @param {number} lowx
* @param {number} hix
* @param {number} lowy
* @param {number} hiy
* @return {number}
*/
PositionArray.prototype.breakOut = function(x1, y1, x2, y2, inc, vert, lowx, hix, lowy, hiy) {
  var x = x1 | 0;
  var y = y1 | 0;
  var oldval = this._array[x][y];
  while (oldval === 0 && x > lowx && x < hix && y > lowy && y < hiy) {
    if (vert)
      y += inc;
    else
      x += inc;
    oldval = this._array[x][y];
    if (Math.abs(x - x2) <= 1 && Math.abs(y - y2) <= 1) {
      this.abort = true;  // abort--use default algorithm
      return 0;
    }
  }

  x = x1 | 0;
  y = y1 | 0;
  oldval = this._array[x][y];
  var val = PositionArray.START;
  this._array[x][y] = val;
  while (oldval === 0 && x > lowx && x < hix && y > lowy && y < hiy) {
    if (vert)
      y += inc;
    else
      x += inc;
    oldval = this._array[x][y];
    this._array[x][y] = val;
    val += PositionArray.STEP;
  }
  if (vert)
    return y;
  else
    return x;
};

/**
* @ignore
* @this {PositionArray}
* @param {number} x1
* @param {number} y1
* @param {number} x2
* @param {number} y2
* @param {number} inc
* @param {boolean} vert
* @param {number} lowx
* @param {number} hix
* @param {number} lowy
* @param {number} hiy
*/
PositionArray.prototype.breakIn = function(x1, y1, x2, y2, inc, vert, lowx, hix, lowy, hiy) {
  var x = x2 | 0;
  var y = y2 | 0;
  var oldval = this._array[x][y];
  while (oldval === 0 && x > lowx && x < hix && y > lowy && y < hiy) {
    if (vert)
      y += inc;
    else
      x += inc;
    oldval = this._array[x][y];
    if (Math.abs(x - x1) <= 1 && Math.abs(y - y1) <= 1) {
      this.abort = true;  // abort--use default algorithm
      return;
    }
  }

  x = x2 | 0;
  y = y2 | 0;
  oldval = this._array[x][y];
  this._array[x][y] = PositionArray.UNOCCUPIED;
  while (oldval === 0 && x > lowx && x < hix && y > lowy && y < hiy) {
    if (vert)
      y += inc;
    else
      x += inc;
    oldval = this._array[x][y];
    this._array[x][y] = PositionArray.UNOCCUPIED;
  }
};

/**
* @ignore
* @this {PositionArray}
* @param {Point} p1
* @param {number} fromDir
* @param {Point} p2
* @param {number} toDir
* @param {Rect} bounds
*/
PositionArray.prototype.propagate = function(p1, fromDir, p2, toDir, bounds) {
  if (this._array === null) return;
  this.abort = false;

  var x1 = p1.x;
  var y1 = p1.y;
  if (!this.inBounds(x1, y1)) return;
  x1 -= this._minX;
  x1 /= this._cellX;
  y1 -= this._minY;
  y1 /= this._cellY;

  var x2 = p2.x;
  var y2 = p2.y;
  if (!this.inBounds(x2, y2)) return;
  x2 -= this._minX;
  x2 /= this._cellX;
  y2 -= this._minY;
  y2 /= this._cellY;

  if (Math.abs(x1 - x2) <= 1 && Math.abs(y1 - y2) <= 1) {
    // if start and end are at the same cell, never mind, just use the default algorithm
    this.abort = true;
    return;
  }

  var bx1 = bounds.x;
  var by1 = bounds.y;
  var bx2 = bounds.x + bounds.width;
  var by2 = bounds.y + bounds.height;
  bx1 -= this._minX;
  bx1 /= this._cellX;
  by1 -= this._minY;
  by1 /= this._cellY;
  bx2 -= this._minX;
  bx2 /= this._cellX;
  by2 -= this._minY;
  by2 /= this._cellY;

  var lowx = Math.max(0, Math.min(this._upperBoundX, bx1 | 0));
  var hix = Math.min(this._upperBoundX, Math.max(0, bx2 | 0));
  var lowy = Math.max(0, Math.min(this._upperBoundY, by1 | 0));
  var hiy = Math.min(this._upperBoundY, Math.max(0, by2 | 0));

  var RIGHT = 0;
  var DOWN = 90;
  var LEFT = 180;
  var UP = 270;

  var ix1 = x1 | 0;
  var iy1 = y1 | 0;
  var ix2 = x2 | 0;
  var iy2 = y2 | 0;
  var ix = ix1;
  var iy = iy1;
  var inc = ((fromDir === RIGHT || fromDir === DOWN) ? 1 : -1);
  var vert = (fromDir === DOWN || fromDir === UP);
  if (vert)
    iy = this.breakOut(ix1, iy1, ix2, iy2, inc, vert, lowx, hix, lowy, hiy);
  else
    ix = this.breakOut(ix1, iy1, ix2, iy2, inc, vert, lowx, hix, lowy, hiy);
  //Diagram.Debug("BreakOut " + Diagram.Str(new Point(ix1, iy1)) + Diagram.Str(new Point(ix2, iy2)) + inc.ToString() + " " + vert.ToString() + "  --> " + (vert ? iy : ix).ToString());

  if (this.abort) return;

  this.breakIn(ix1, iy1, ix2, iy2, ((toDir === RIGHT || toDir === DOWN) ? 1 : -1), (toDir === DOWN || toDir === UP), lowx, hix, lowy, hiy);
  //Diagram.Debug("  In " + ((toDir === RIGHT || toDir === DOWN) ? 1 : -1).ToString() + " " + (toDir === DOWN || toDir === UP).ToString());

  if (this.abort) return;

  this.spread(ix, iy, 1, false, lowx, hix, lowy, hiy);
  this.spread(ix, iy, -1, false, lowx, hix, lowy, hiy);
  this.spread(ix, iy, 1, true, lowx, hix, lowy, hiy);
  this.spread(ix, iy, -1, true, lowx, hix, lowy, hiy);
};


/**
* @ignore
* @constructor
* @class
*/
function Knot() {  // also used by Parts
  Util.uniqueHash(this);
  /** @ignore @type {Node} */
  this.node = null;
  /** @ignore @type {GraphObject} */
  this.port = null;

  /** @ignore @type {Array} */
  this.mySortedLinks = [];
  /** @ignore @type {boolean} */
  this.myRespreading = false;
}

Util.defineDataProperties(Knot, {
  node: true,
  port: true,
  mySortedLinks: true,
  myRespreading: true
});

/**
* @ignore
* @this {Knot}
* @return {string}
*/
Knot.prototype.toString = function() {
  var arr = this.mySortedLinks;
  var msg = this.node.toString() + ' ' + arr.length.toString() + ':';
  for (var i = 0; i < arr.length; i++) {
    var info = arr[i];
    if (info === null) continue;
    msg += '\n  ' + info.toString();
  }
  return msg;
};

/**
* @ignore
* @this {Knot}
* @param {Rect} rect
* @param {Spot} spot
* @param {number} generalangle
* @param {boolean} ortho
* @return {number}
*/
Knot.prototype.getSideAngle = function(rect, spot, generalangle, ortho) {
  var sides = spot.offsetY;
  switch (sides) {
    case Util.MBottom: return 90;
    case Util.MLeft: return 180;
    case Util.MTop: return 270;
    case Util.MRight: return 0;
  }
  var A = generalangle;
  switch (sides) {
    case Util.MBottom | Util.MTop: if (A > 180) return 270; else return 90;
    case Util.MLeft | Util.MRight: if (A > 90 && A <= 270) return 180; else return 0;
  }
  var R = Math.atan2(rect.height, rect.width) * 180 / Math.PI;
  switch (sides) {
    case Util.MLeft | Util.MTop: if (A > R && A <= 180 + R) return 180; else return 270;
    case Util.MTop | Util.MRight: if (A > 180 - R && A <= 360 - R) return 270; else return 0;
    case Util.MRight | Util.MBottom: if (A > R && A <= 180 + R) return 90; else return 0;
    case Util.MBottom | Util.MLeft: if (A > 180 - R && A <= 360 - R) return 180; else return 90;
    case Util.MLeft | Util.MTop | Util.MRight: if (A > 90 && A <= 180 + R) return 180; else if (A > 180 + R && A <= 360 - R) return 270; else return 0;
    case Util.MTop | Util.MRight | Util.MBottom: if (A > 180 && A <= 360 - R) return 270; else if (A > R && A <= 180) return 90; else return 0;
    case Util.MRight | Util.MBottom | Util.MLeft: if (A > R && A <= 180 - R) return 90; else if (A > 180 - R && A <= 270) return 180; else return 0;
    case Util.MBottom | Util.MLeft | Util.MTop: if (A > 180 - R && A <= 180 + R) return 180; else if (A > 180 + R) return 270; else return 90;
  }
  if (ortho && sides !== (Util.MLeft | Util.MTop | Util.MRight | Util.MBottom)) {
    A -= 15;
    if (A < 0) A += 360;
  }
  if (A > R && A < 180 - R)
    return 90;
  else if (A >= 180 - R && A <= 180 + R)
    return 180;
  else if (A > 180 + R && A < 360 - R)
    return 270;
  else
    return 0;
};

/**
* @ignore
* First updates any needed data structures...
* @this {Knot}
* @param {Link} link
* @return {LinkInfo}
*/
Knot.prototype.findLinkInfo = function(link) {
  var arr = this.mySortedLinks;
  if (arr.length === 0) {
    this.getLinkInfos();
    arr = this.mySortedLinks;
  }
  for (var i = 0; i < arr.length; i++) {
    var info = arr[i];
    if (info !== null && info.link === link) return info;
  }
  return null;
};

//??? what about self-loops
/**
* @ignore
* First updates any needed data structures...
* @this {Knot}
* @return {Array}
*/
Knot.prototype.getLinkInfos = function() {
  if (!this.myRespreading) {
    var oldRespreading = this.myRespreading;
    this.myRespreading = true;
    var connectedlinks = this.node.linksConnected;
    var linkscount = connectedlinks.count;
    this.mySortedLinks.length = 0;
    var i = 0;

    var tlpt = this.port.getDocumentPoint(Spot.TopLeft, Util.tempPoint());
    var brpt = this.port.getDocumentPoint(Spot.BottomRight, Util.tempPoint());
    var thisrect = Util.tempRectAt(tlpt.x, tlpt.y, 0, 0);
    thisrect.unionPoint(brpt);
    Util.freePoint(tlpt);
    Util.freePoint(brpt);

    var thisrectcenter = Util.tempPointAt(thisrect.x+thisrect.width/2, thisrect.y+thisrect.height/2);
    var othertemp = Util.tempPoint();
    var lit = connectedlinks.iterator;
    while (lit.next()) {
      var l = lit.value;
      if (!l.isVisible()) continue;
      var spot = Spot.None;
      if (l.fromPort === this.port) {
        spot = l._getFromSpot(this.port);  // link's Spot takes precedence, if defined
      } else {
        spot = l._getToSpot(this.port);  // link's Spot takes precedence, if defined
      }
      if (!spot.isSide()) continue;
      var otherport;
      if (l.fromPort === this.port) {
        otherport = l.toPort;
      } else {
        otherport = l.fromPort;
      }
      if (otherport === null) continue;
      var othernode = otherport.part;
      if (othernode === null) continue;
      var otherpoint = otherport.getDocumentPoint(Spot.Center, othertemp);
      var otherinfo = l._findExistingLinkInfo(otherport, l);
      if (otherinfo !== null) {
        otherpoint = otherinfo.linkPoint;
      }
      var angle = thisrectcenter.directionPoint(otherpoint);
      var dir = this.getSideAngle(thisrect, spot, angle, l.isOrthogonal);
      var side;
      if (dir === 0) {
        side = Util.MRight;
        if (angle > 180) angle -= 360;
      } else if (dir === 90) {
        side = Util.MBottom;
      } else if (dir === 180) {
        side = Util.MLeft;
      } else {
        side = Util.MTop;
      }
      var info = this.mySortedLinks[i];
      if (!info) {
        info = new LinkInfo(l, angle, side);
        this.mySortedLinks[i] = info;
      } else {
        info.link = l;
        info.angle = angle;
        info.side = side;
      }
      info.otherPoint.set(otherpoint);
      i++;
    }
    Util.freePoint(thisrectcenter);
    Util.freePoint(othertemp);

    this.sortLinkInfos(this.mySortedLinks);
    // now assign IndexOnSide for each set of LinkInfos with the same Side
    var numlinks = this.mySortedLinks.length;
    var currside = -1;
    var numonside = 0;
    for (i = 0; i < numlinks; i++) {
      var info = this.mySortedLinks[i];
      if (info === null) continue;
      if (info.side !== currside) {
        currside = info.side;
        numonside = 0;
      }
      info.indexOnSide = numonside;
      numonside++;
    }
    // the highest IndexOnSide now also indicates how many there are
    // with the same Side--assign CountOnSide correspondingly;
    // also compute the LinkPoint
    currside = -1;
    numonside = 0;
    for (i = numlinks - 1; i >= 0; i--) {  // backwards!
      var info = this.mySortedLinks[i];
      if (info === null) continue;
      if (info.side !== currside) {
        currside = info.side;
        numonside = info.indexOnSide + 1;
      }
      info.countOnSide = numonside;
    }
    this.assignLinkPoints(this.mySortedLinks);
    this.assignEndSegmentLengths(this.mySortedLinks);
    this.myRespreading = oldRespreading;
    Util.freeRect(thisrect);

//    Debug.trace(this.toString());
//    for (i = 0; i < this.mySortedLinks.length; i++) {
//      var info = this.mySortedLinks[i];
//      if (info === null) continue;
//      var link = info.link;
//      if (link === null || link.pointsCount < 2) continue;
//      var pt1 = link.getPoint(0);
//      var pt2 = link.getPoint(link.pointsCount-1);
//      if (!info.linkPoint.equalsApprox(pt1) && !info.linkPoint.equalsApprox(pt2)) {
//        Debug.trace("  OUT-OF-DATE: " + link.toString() + " " + pt1.toString() + " " + pt2.toString());
//      }
//    }
  }
  return this.mySortedLinks;
};

/**
* @ignore
* Sorting all of the link's other ports in circular order.
* @this {Knot}
* @param {LinkInfo} a
* @param {LinkInfo} b
* @return {number}
*/
Knot.prototype.myComparer = function(a, b) {
  if (a === b) return 0;
  if (a === null) return -1;
  if (b === null) return 1;
  if (a.side < b.side) {
    return -1;
  } else if (a.side > b.side) {
    return 1;
  } else {
    if (a.angle < b.angle)
      return -1;
    else if (a.angle > b.angle)
      return 1;
    else
      return 0;
  }
};

/**
* @ignore
* Sort an array of angle and side information about the links connected to this port.
* By default this just sorts by {@link LinkInfo#side} group, and by {@link LinkInfo#angle} for each side.
* @this {Knot}
* @param {Array} linkinfos an array of {@link LinkInfo}s that is modified.
*/
Knot.prototype.sortLinkInfos = function(linkinfos) {
  linkinfos.sort(Knot.prototype.myComparer);
};

/**
* @ignore
* Given a sorted array of angle and side information about the links connected to this port,
* assign the actual {@link LinkInfo#linkPoint}.
* By default this just spreads the link points evenly along each side.
* @this {Knot}
* @param {Array} linkinfos an array of {@link LinkInfo} that are modified.
*/
Knot.prototype.assignLinkPoints = function(linkinfos) {
  for (var i = 0; i < linkinfos.length; i++) {
    var info = linkinfos[i];
    if (info === null) continue;
    this.assignSideLinkPoint(info);
  }
};

/**
* @ignore
* Given a sorted array of angle, side, and link-point information about the links
* connected to this port, assign the actual {@link LinkInfo#endSegmentLength}.
* By default this just specifies shorter values for links at the ends of each side,
* and longer values for links in the middle of each side.
* @this {Knot}
* @param {Array} linkinfos an array of {@link LinkInfo} that are modified.
*/
Knot.prototype.assignEndSegmentLengths = function(linkinfos) {
  for (var i = 0; i < linkinfos.length; i++) {
    var info = linkinfos[i];
    if (info === null) continue;
    info.endSegmentLength = this.computeEndSegmentLength(info);
  }
};

/**
* @ignore
* @this {Knot}
* @param {LinkInfo} info
*/
Knot.prototype.assignSideLinkPoint = function(info) {
  var port = this.port;
  var a = Util.tempPoint();
  var b = Util.tempPoint();
  switch (info.side) {
    case Util.MBottom:
      port.getDocumentPoint(Spot.BottomRight, a);
      port.getDocumentPoint(Spot.BottomLeft, b);
      break;
    case Util.MLeft:
      port.getDocumentPoint(Spot.BottomLeft, a);
      port.getDocumentPoint(Spot.TopLeft, b);
      break;
    case Util.MTop:
      port.getDocumentPoint(Spot.TopLeft, a);
      port.getDocumentPoint(Spot.TopRight, b);
      break;
    default:
    case Util.MRight:
      port.getDocumentPoint(Spot.TopRight, a);
      port.getDocumentPoint(Spot.BottomRight, b);
      break;
  }
  var dx = b.x - a.x;
  var dy = b.y - a.y;
  var part = (info.indexOnSide + 1) / (info.countOnSide + 1);
  var p = info.linkPoint;
  p.x = a.x + dx * part;
  p.y = a.y + dy * part;
  Util.freePoint(a);
  Util.freePoint(b);
};

/**
* @ignore
* @this {Knot}
* @param {LinkInfo} info
* @return {number}
*/
Knot.prototype.computeEndSegmentLength = function(info) {
  var link = info.link;
  var from = link.fromPort === this.port;
  // get default EndSegmentLength
  var esl = link.computeEndSegmentLength(this.node, this.port, Spot.None, from);

  var idx = info.indexOnSide;
  if (idx < 0) return esl;  // if unused, don't extend length
  var count = info.countOnSide;
  if (count <= 1) return esl;  // if there's just one, don't bother

  var ortho = link.isOrthogonal;
  if (!ortho) return esl;

  var pc = info.otherPoint;
  var thisc = info.linkPoint;
  // indexed clockwise, not by absolute positions
  if (info.side === Util.MLeft || info.side === Util.MBottom) idx = count - 1 - idx;
  var step = 8;
  var horiz = (info.side === Util.MLeft || info.side === Util.MRight);
  if (horiz ? pc.y < thisc.y : pc.x < thisc.x)
    return esl + idx * step;
  else if (horiz ? pc.y === thisc.y : pc.x === thisc.x)
    return esl;
  else
    return esl + (count - 1 - idx) * step;
};


/**
* @ignore
* @constructor
* @param {Link} l
* @param {number} a
* @param {number} s
* @class
* This is used by Knot.SortLinkInfos, Knot.AssignLinkPoints, and Knot.AssignEndSegmentLengths
* only when Knot.LinkPointsSpread is true.
* This information is transient, just used when calculating link points.
*/
function LinkInfo(l, a, s) {
  // The {@link Link} whose link point is being sorted around the port.
  /** @ignore @type {Link} */
  this.link = l;

  // The effective angle at which the link connects with another node;
  // this value corresponds to the result of calling GetAngle.
  // The angle in degrees from this port to the other port.
  /** @ignore @type {number} */
  this.angle = a;

  // The side at which the link connects;
  // this value corresponds to the result of calling GetDirection.
  // One of Util.MiddleRight, Util.MiddleBottom, Util.MiddleLeft, Util.MiddleTop.
  /** @ignore @type {number} */
  this.side = s;

  /** @ignore @type {Point} */
  this.otherPoint = new Point();

  /** @ignore @type {number} */
  this.indexOnSide = 0;

  // How many links are connected on this side;
  // computed after calling SortLinkInfos and before calling AssignLinkPoints.
  /** @ignore @type {number} */
  this.countOnSide = 0;

  // The index of this link on this side;
  // computed after calling SortLinkInfos and before calling AssignLinkPoints.
  /** @ignore @type {number} */
  this.indexOnSide = 0;

  // The document point at which the link should terminate;
  // should be set in AssignLinkPoints.
  /** @ignore @type {Point} */
  this.linkPoint = new Point();

  // The value of length of the last segment for this link at this port;
  // should be set in AssignEndSegmentLengths.
  /** @ignore @type {number} */
  this.endSegmentLength = 0;
}

Util.defineDataProperties(LinkInfo, {
  link: true,
  angle: true,
  side: true,
  otherPoint: true,
  indexOnSide: true,
  countOnSide: true,
  linkPoint: true,
  endSegmentLength: true
});

/**
* @ignore
* @this {LinkInfo}
* @return {string}
*/
LinkInfo.prototype.toString = function() {
  return this.link.toString() + ' ' + this.angle.toString() + ' ' +
    this.side.toString() + ':' + this.indexOnSide.toString() + '/' + this.countOnSide.toString() + ' ' +
    this.linkPoint.toString() + ' ' + this.endSegmentLength.toString() + ' ' + this.otherPoint.toString();
};

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
Group
Placeholder
*/


/**
 * Constructs an empty Group with no visual elements and no member parts;
 * normally a Group will have some visual elements surrounding a {@link Placeholder}.
 * @constructor
 * @param {EnumValue=} type if not supplied, the default Panel type is {@link Panel#Position}.
 * @extends Node
 * @class
 * A Group is a {@link Node} that can contain a subgraph of {@link Node}s and {@link Link}s,
 * which are members of the group.
 * <p class="box">
 * For more discussion, see <a href="../../intro/groups.html">Introduction to Groups</a>.
 * <p/>
 * Although you can create a Group and {@link Diagram#add} it to a Diagram, this does not update the Model.
 * It is more common to create a group by adding a node data object to the model
 * by calling {@link Model#addNodeData}. For example:
 * <pre>
 *   myDiagram.startTransaction("make new group");
 *   myDiagram.model.addNodeData({ key: "Omega", isGroup: true });
 *   myDiagram.commitTransaction("make new group");
 * </pre>
 * This will cause a Group to be created (copying the template found in {@link Diagram#groupTemplateMap}),
 * added to the Diagram in some {@link Layer} (based on {@link Part#layerName}), and bound to the group data
 * (resulting in {@link Panel#data} referring to that group data object).
 * <p/>
 * The member Parts of a Group, which you can access as the {@link #memberParts} collection,
 * belong to the group but are not in the visual tree of the group.
 * All {@link Part}s are directly in {@link Layer}s -- they cannot be inside a {@link Panel}.
 * This allows group member parts to be in a different layer than the group.
 * <p/>
 * You can change the membership of a {@link Node} or a simple {@link Part} in a Group by setting
 * its {@link Part#containingGroup} property.
 * This is done automatically for you by the diagram if you initialize the <code>group</code> property on the node data
 * in the model to be the key of the containing group node data.
 * You can also change the relationship dynamically by calling {@link GraphLinksModel#setGroupKeyForNodeData}.
 * Note that just changing the value of {@link Part#containingGroup} will not update the model.
 * Thus you should do something like:
 * <pre>
 *   myDiagram.startTransaction("add new member");
 *   myDiagram.model.addNodeData({ group: someexistinggroup.data.key, ... });
 *   myDiagram.commitTransaction("add new member");
 * </pre>
 * where you would make sure the node data object included all of the properties you need.
 * <p/>
 * The membership of {@link Link}s is computed automatically for you by the diagram based on the membership of
 * the connected {@link Node}s.
 * For example, if the {@link Link#fromNode} is a top-level node but the {@link Link#toNode} is a member of a group,
 * the link is a top-level link.
 * If the two connected nodes both belong to the same group, the link is a member of that group.
 * If the two connected nodes belong to different groups, the link belongs to the common container group, if there is any.
 * <p/>
 * As the membership of a group changes, you may want to update the appearance of the group.
 * You can set the {@link #memberAdded} and {@link #memberRemoved} properties to be functions that are called.
 * These functions must not modify any membership relationships -- the properties just exist to update the appearance of the group.
 * <p/>
 * The area occupied by the subgraph is represented in the group's visual tree by a {@link Placeholder}.
 * As the group {@link #placeholder} grows and shrinks based on the sizes and positions of the member nodes and links,
 * the group will grow and shrink accordingly.
 * The placeholder is always the {@link Part#locationObject},
 * although you may specify any {@link Spot} as the {@link Part#locationSpot}.
 * A Group need not have a placeholder, but it may have at most one.
 * <p/>
 * A group has its own {@link #layout} property that is used to position the member nodes and route the member links.
 * <p/>
 * The Group class also supports the notion of expanding and collapsing the subgraph,
 * causing the member nodes and links to be shown or hidden.
 * Principally this is a matter of setting {@link #isSubGraphExpanded}.
 * Changes to this property will result in calls to {@link #collapseSubGraph} or {@link #expandSubGraph}, as appropriate.
 * <p/>
 * If you want to change the appearance of the group you can do so in a function that you assign to
 * the {@link #subGraphExpandedChanged} property.
 * This function must not modify any member relationships or expand or collapse any groups -- the property just exists
 * to update the appearance of the group.
 * <p class="box">
 * For more discussion and examples, see <a href="../../intro/subgraphs.html">SubGraphs</a>.
 * <p/>
 * If you want the user to be able to create a Group out of the currently
 * selected Parts using the {@link CommandHandler#groupSelection} command,
 * you need to first set the {@link CommandHandler#archetypeGroupData} property
 * to a data object with <code>isGroup</code> set to true.
 * If you want the user to be able to ungroup a Group,
 * using the {@link CommandHandler#ungroupSelection} command,
 * you need to set {@link #ungroupable} to true.
 * <p class="box">
 * For more discussion and examples, see <a href="../../intro/groups.html">Groups</a>,
 * <a href="../../intro/subgraphs.html">SubGraphs</a>, and
 * <a href="../../intro/sizedGroups.html">Sized Groups</a>.
 * <p/>
 * Only Groups that are in Diagrams can have member Parts or connections via Links.
 * Templates should not be connected with Links, be labels of Links, be members of Groups, have any member Parts, or have any Adornments.
 */
function Group(type) {
  if (arguments.length === 0)
    Node.call(this, Panel.Position);
  else
    Node.call(this, type);

  /** @type {Set} */
  this._memberParts = new Set(Part);  // owned Parts
  /** @type {Set} */
  this._nestedGroups = new Set(Group);
  /** @type {function(Group, Part) | null} */
  this._memberAdded = null;
  /** @type {function(Group, Part) | null} */
  this._memberRemoved = null;
  /** @type {function(Group, Part):boolean | null} */
  this._memberValidation = null;
  /** @type {boolean} */
  this._ungroupable = false;

  /** @type {boolean} */
  this._isSubGraphExpanded = true;
  /** @type {boolean} */
  this._wasSubGraphExpanded = false;
  /** @type {function(Group) | null} */
  this._subGraphExpandedChanged = null;

  /** @type {Placeholder} */
  this._placeholder = null;
  /** @type {boolean} */
  this._computesBoundsAfterDrag = false;

  /** @type {Layout} */
  this._layout = new Layout();
  this._layout.group = this;  // set backpointer
}

Util.publish('Group', Group);

Util.inherit(Group, Node);

/**
* @ignore
* Copies properties to a cloned Group.
* @this {Group}
* @param {GraphObject} copy
*/
Group.prototype.cloneProtected = function(copy) {
  Node.prototype.cloneProtected.call(this, copy);

  //copy._memberParts references should be handled by copier
  // _nestedGroups will be updated automatically along with _memberParts
  copy._memberAdded = this._memberAdded;
  copy._memberRemoved = this._memberRemoved;
  copy._memberValidation = this._memberValidation;
  copy._ungroupable = this._ungroupable;

  copy._isSubGraphExpanded = this._isSubGraphExpanded;
  copy._wasSubGraphExpanded = this._wasSubGraphExpanded;
  copy._subGraphExpandedChanged = this._subGraphExpandedChanged;

  var place = copy.searchVisualTree(function(g) { return g instanceof Placeholder; });
  if (place instanceof Placeholder) {
    copy._placeholder = place;
  } else {
    copy._placeholder = null;
  }
  copy._computesBoundsAfterDrag = this._computesBoundsAfterDrag;

  if (this._layout !== null) {
    copy._layout = this._layout.copy();
    if (copy instanceof Group) copy._layout.group = copy; // always true, for closure compiler's type checking
  } else {
    if (copy._layout !== null) copy._layout.group = null;
    copy._layout = null;
  }
};

/**
* @ignore
* Fix up references in the argument object so that the argument object can get a new visual tree
* @this {Group}
* @param {GraphObject} copy  The original Part whose category is being changed by displacing its visual tree with this Part's visual tree.
*/
Group.prototype.displaceProtected = function(copy) {
  Node.prototype.displaceProtected.call(this, copy);

  var allmembers = copy.findSubGraphParts();
  var cit = copy.memberParts;
  while (cit.next()) {
    var member = cit.value;
    member.invalidateMeasure();
    member.invalidateLayout(Part.LayoutHidden);
    member.clearAdornments();
    if (member instanceof Group) {
      member.wasSubGraphExpanded = member.isSubGraphExpanded;
      member._collapseSubGraph1(allmembers);
    }
    if (member instanceof Node) {
      member.invalidateConnectedLinks(allmembers);
    } else if (member instanceof Link) {
      var lit = member.labelNodes;
      while (lit.next()) {
        var lab = lit.value;
        lab.invalidateConnectedLinks(allmembers);
      }
    }
  }

  // nothing else special to do for Group
  // until _placeholder can be computed automatically
};

/**
* @ignore
* Call this method to notify that the some state has changed.
* This just calls the {@link #diagram}'s {@link Diagram#raiseChangedEvent} method.
* @this {Group}
* @param {EnumValue} change specifies the general nature of the change;
* permissible values include {@link ChangedEvent#Property}, {@link ChangedEvent#Insert},
* {@link ChangedEvent#Remove}, and {@link ChangedEvent#Transaction}.
* @param {string} propertyname names the property that was modified.
* @param {Object} obj the object that was modified, typically a {@link GraphObject}.
* @param {*} oldval the previous or older value.
* @param {*} newval the next or newer value.
* @param {*=} oldparam an optional value that helps describe the older value.
* @param {*=} newparam an optional value that helps describe the newer value.
*/
Group.prototype.raisePartChangedEvent = function(change, propertyname, obj, oldval, newval, oldparam, newparam) {
  // maintain Placeholder
  if (change === ChangedEvent.Insert && propertyname === 'elements') {
    if (newval instanceof Placeholder) {
      if (this._placeholder === null) {
        this._placeholder = newval;
      } else if (this._placeholder !== newval) {
        Util.throwError('Cannot insert a second Placeholder into the visual tree of a Group.');
      }
    } else if (newval instanceof Panel) {
      var place = newval.searchVisualTree(function(g) { return g instanceof Placeholder; });
      if (place instanceof Placeholder) {
        if (this._placeholder === null) {
          this._placeholder = place;
        } else if (this._placeholder !== place) {
          Util.throwError('Cannot insert a second Placeholder into the visual tree of a Group.');
        }
      }
    }
  } else if (change === ChangedEvent.Remove && propertyname === 'elements') {
    if (oldval === this._placeholder) {
      this._placeholder = null;
    } else if (oldval instanceof Panel && this._placeholder.isContainedBy(oldval)) {
      this._placeholder = null;
    }
  }
  Node.prototype.raisePartChangedEvent.call(this, change, propertyname, obj, oldval, newval, oldparam, newparam);
};


// They inherit them from Panel and
// Groups do not have their own measure and arrange protected methods

/**
 * @ignore
 * Causes a Group to arrange it's children.
 * @this {Group}
 * @param {number} fx
 * @param {number} fy
 * @param {number} fw
 * @param {number} fh
 */
Group.prototype.arrangeProtected = function(fx, fy, fw, fh) {
  this._locationObject = this._placeholder;
  Panel.prototype.arrangeProtected.call(this, fx, fy, fw, fh);

  /*
  // @@@ This seems unneeded because (and incorrect) because of Placeholder.prototype.measureProtected
  //     Which properly sets the Group location
  // If the Group has a placeholder, make sure the group is put into the right location
  if (this._placeholder !== null) {
    var loc = this._placeholder._savedBounds;

    // I need to know the difference between my
    this.location = new Point(loc.x, loc.y);
  }
  */
};

/**
 * @ignore
 * @this {Group}
 * @return {boolean}
 */
Group.prototype.isReadyToMeasureArrange = function() {
  if (!Node.prototype.isReadyToMeasureArrange.call(this)) return false;
  var itr = this.memberParts;

  while (itr.next()) {
    var m = itr.value;
    if (m instanceof Node) {
      if (!m.isVisible()) continue;
      if (m.getInvalidArrange()) return false;
    } else if (m instanceof Link) {
      if (!m.isVisible()) continue;
      // OK if the link connects to the group itself
      if (m.getInvalidArrange() && m.fromNode !== this && m.toNode !== this) return false;
    }
  }
  return true;
};

/**
* Gets a {@link Placeholder} that this group may contain in its visual tree.
* @name Group#placeholder
* @function.
* @return {Placeholder}
*/
/** @type {Placeholder} */
Group.prototype.placeholder;
Util.defineReadOnlyProperty(Group, { placeholder: 'placeholder'},
  /** @this {Group} */
  function() { return this._placeholder; }
);

/**
* Gets or sets whether the size of the area of the {@link Group}'s {@link #placeholder}
* should remain the same during a {@link DraggingTool} move until a drop occurs.
* <p/>
* In other words, when the value is true, re-computing the bounds of the
* members is suspended until a drop occurs, at which time the border is recomputed,
* perhaps not including some members that had been dragged out and reparented.
* The initial value is false.
* @name Group#computesBoundsAfterDrag
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Group.prototype.computesBoundsAfterDrag;
Util.exportProperty(Group, 'computesBoundsAfterDrag', Group.prototype.computesBoundsAfterDrag);
Util.defineProperty(Group, { computesBoundsAfterDrag: 'computesBoundsAfterDrag'},
  /** @this {Group} */
  function() { return this._computesBoundsAfterDrag; },
  /** @this {Group} */
  function(val) {
    var old = this._computesBoundsAfterDrag;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Group, 'computesBoundsAfterDrag');
      this._computesBoundsAfterDrag = val;
      this.raiseChanged('computesBoundsAfterDrag', old, val);
    }
  }
);

/**
* Gets an iterator over the member {@link Part}s of this Group.
* Setting {@link Part#containingGroup} to refer to this Group
* will add that part to this collection.
* The Parts can be {@link Node}s, {@link Link}s, {@link Group}s, or simple {@link Part}s.
* <p>
* A template should not have any member parts.
* @name Group#memberParts
* @function.
* @return {Iterator}
*/
/** @type {Iterator} */
Group.prototype.memberParts;
Util.defineReadOnlyProperty(Group, { memberParts: 'memberParts'},
  /** @this {Group} */
  function() { return this._memberParts.iterator; }
);

/**
* @ignore
* @this {Group}
* @param {Part} part
*/
Group.prototype.addMemberInternal = function(part) {
  if (this._memberParts.add(part)) {
    if (part instanceof Group) {
      this._nestedGroups.add(part);
    }
    var func = this.memberAdded;
    if (func !== null) {
      var oldUpdatingModel = true;
      var diagram = this.diagram;
      if (diagram !== null) {
        oldUpdatingModel = diagram.isUpdatingModel;
        diagram.isUpdatingModel = true;
      }
      func(this, part);
      if (diagram !== null) {
        diagram.isUpdatingModel = oldUpdatingModel;
      }
    }
  }
  var ph = this._placeholder;
  if (ph === null) ph = this;
  ph.invalidateMeasure();
};

/**
* @ignore
* @this {Group}
* @param {Part} part
*/
Group.prototype.removeMemberInternal = function(part) {
  if (this._memberParts.remove(part)) {
    if (part instanceof Group) {
      this._nestedGroups.remove(part);
    }
    var func = this.memberRemoved;
    if (func !== null) {
      var oldUpdatingModel = true;
      var diagram = this.diagram;
      if (diagram !== null) {
        oldUpdatingModel = diagram.isUpdatingModel;
        diagram.isUpdatingModel = true;
      }
      func(this, part);
      if (diagram !== null) {
        diagram.isUpdatingModel = oldUpdatingModel;
      }
    }
  }
  var ph = this._placeholder;
  if (ph === null) ph = this;
  ph.invalidateMeasure();
};

/**
* @ignore
* @this {Group}
*/
Group.prototype.deleteCascade = function() {
  // delete all member parts
  if (this._memberParts.count > 0) {
    var diagram = this.diagram;
    if (diagram === null) return;
    var parts = this._memberParts.copy();
    var pit = parts.iterator;
    while (pit.next()) {
      var part = pit.value;
      diagram.remove(part);
    }
  }

  Node.prototype.deleteCascade.call(this);
};

/**
* @ignore
* @this {Group}
*/
Group.prototype.sortZOrder = function() {
  var lay = this.layer;
  if (lay !== null) lay.sortZOrder(this);
};


/**
* Gets or sets the {@link Layout} used to position all of the immediate member nodes and links in this group.
* By default this property is an instance of {@link Layout} -- no special layout is used, which just makes
* sure each member node has a valid location.
* @name Group#layout
* @function.
* @return {Layout}
*/
/** @type {Layout} */
Group.prototype.layout;
Util.exportProperty(Group, 'layout', Group.prototype.layout);
Util.defineProperty(Group, { layout: 'layout' },
  /** @this {Group} */
  function() { return this._layout; },
  /** @this {Group} */
  function(val) {
    var old = this._layout;
    if (old !== val) {
      if (val !== null) Util.checkClass(val, Layout, Group, 'layout');
      if (old !== null) {
        old.diagram = null;
        old.group = null;
      }
      this._layout = val;
      if (val !== null) {
        val.diagram = this.diagram;
        val.group = this;
      }
      this.raiseChanged('layout', old, val);
    }
  }
);


/**
* Gets or sets the function that is called after a member {@link Part} has been added to this Group.
* It is typically used to modify the appearance of the group.
* The first argument will be this Group.
* The second argument will be a Part, typically a Node, but may be a simple Part or a Link.
* <p/>
* If the value is a function, that function must not modify the group's collection of members.
* The member Part has already been added -- trying to remove it or adding or removing another member or the Group itself may produce undefined behavior.
* <p/>
* The default value is null -- no function is called.
* @name Group#memberAdded
* @function.
* @return {function(Group, Part) | null}
*/
/** @type {function(Group, Part) | null} */
Group.prototype.memberAdded;
Util.exportProperty(Group, 'memberAdded', Group.prototype.memberAdded);
Util.defineProperty(Group, { memberAdded: 'memberAdded' },
  /** @this {Group} */
  function() { return this._memberAdded; },
  /** @this {Group} */
  function(val) {
    var old = this._memberAdded;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', Group, 'memberAdded');
      this._memberAdded = val;
      this.raiseChanged('memberAdded', old, val);
    }
  }
);

/**
* Gets or sets the function that is called after a member {@link Part} has been removed from this Group.
* It is typically used to modify the appearance of the group.
* The first argument will be this Group.
* The second argument will be a Part, typically a Node, but may be a simple Part or a Link.
* <p/>
* If the value is a function, that function must not modify the group's collection of members.
* The member Part has already been removed -- trying to add it or adding or removing another member or the Group itself may produce undefined behavior.
* <p/>
* The default value is null -- no function is called.
* @name Group#memberRemoved
* @function.
* @return {function(Group, Part) | null}
*/
/** @type {function(Group, Part) | null} */
Group.prototype.memberRemoved;
Util.exportProperty(Group, 'memberRemoved', Group.prototype.memberRemoved);
Util.defineProperty(Group, { memberRemoved: 'memberRemoved' },
  /** @this {Group} */
  function() { return this._memberRemoved; },
  /** @this {Group} */
  function(val) {
    var old = this._memberRemoved;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', Group, 'memberRemoved');
      this._memberRemoved = val;
      this.raiseChanged('memberRemoved', old, val);
    }
  }
);

/**
* Gets or sets the predicate that determines whether or not a Part may become a member of this group.
* The default predicate is null, which is equivalent to simply returning true.
* The first argument will be this Group.
* The second argument will be a Part, typically a Node, but will not be a Link or an Adornment.
* <p/>
* The function, if supplied, must not have any side-effects.
* @name Group#memberValidation
* @function.
* @return {function(Group, Part):boolean | null}
*/
/** @type {function(Group, Part):boolean | null} */
Group.prototype.memberValidation;
Util.exportProperty(Group, 'memberValidation', Group.prototype.memberValidation);
Util.defineProperty(Group, { memberValidation: 'memberValidation' },
  /** @this {Group} */
  function() { return this._memberValidation; },
  /** @this {Group} */
  function(val) {
    var old = this._memberValidation;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', Group, 'memberValidation');
      this._memberValidation = val;
      this.raiseChanged('memberValidation', old, val);
    }
  }
);


Group.prototype['canAddMembers'] =
/**
* See if the given collection of {@link Part}s contains non-Links all for which
* {@link CommandHandler#isValidMember} returns true.
* <p/>
* The CommandHandler predicate will use {@link CommandHandler#memberValidation}
* and {@link #memberValidation}, if either or both are defined.
* @this {Group}
* @param {Iterable} coll
* @return {boolean} true.
*/
Group.prototype.canAddMembers = function(coll) {
  var diagram = this.diagram;
  if (diagram === null) return false;
  var cmd = diagram.commandHandler;
  // get all of the simple Parts and Nodes or Groups, but not Links,
  // that are not members of other parts in the given collection
  var unnested = cmd.findUnnestedNodes(coll);
  var it = unnested.iterator;
  while (it.next()) {
    var node = it.value;
    if (!cmd.isValidMember(this, node)) return false;
  }
  return true;
};

Group.prototype['addMembers'] =
/**
* Add the {@link Part}s in the given collection as members of this Group
* for those Parts for which {@link CommandHandler#isValidMember} returns true.
* If the check argument to this method is not supplied or false,
* this will set {@link Part#containingGroup} on each part unconditionally, not calling {@link CommandHandler#isValidMember}.
* <p/>
* The CommandHandler predicate will use {@link CommandHandler#memberValidation}
* and {@link #memberValidation}, if either or both are defined.
* @this {Group}
* @param {Iterable} coll
* @param {boolean=} check whether to call {@link CommandHandler#isValidMember} to confirm that it is valid to add the Part to be a member of this Group.
* @return {boolean} true if all non-Links were added to this Group; false if some Parts or Nodes were not able to be added.
*/
Group.prototype.addMembers = function(coll, check) {
  var diagram = this.diagram;
  if (diagram === null) return false;
  var cmd = diagram.commandHandler;
  // get all of the simple Parts and Nodes or Groups, but not Links,
  // that are not members of other parts in the given collection
  var unnested = cmd.findUnnestedNodes(coll);
  var ok = true;
  var it = unnested.iterator;
  while (it.next()) {
    var node = it.value;
    if (!check || cmd.isValidMember(this, node)) {
      node.containingGroup = this;
    } else {
      ok = false;
    }
  }
  return ok;
};


/**
* Gets or sets whether the user may ungroup this group.
* The initial value is false.
* @name Group#ungroupable
* @function.
* @return {boolean}
* @see Group#canUngroup
*/
/** @type {boolean} */
Group.prototype.ungroupable;
Util.exportProperty(Group, 'ungroupable', Group.prototype.ungroupable);
Util.defineProperty(Group, { ungroupable: 'ungroupable'},
  /** @this {Group} */
  function() { return this._ungroupable; },
  /** @this {Group} */
  function(val) {
    var old = this._ungroupable;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Group, 'ungroupable');
      this._ungroupable = val;
      this.raiseChanged('ungroupable', old, val);
    }
  }
);

/**
* This predicate returns true if {@link #ungroupable} is true,
* if the layer's {@link Layer#allowUngroup} is true, and
* if the diagram's {@link Diagram#allowUngroup} is true.
* @expose
* @this {Group}
* @return {boolean} true if the user may ungroup this object.
*/
Group.prototype.canUngroup = function() {
  if (!this.ungroupable) return false;
  var layer = this.layer;
  if (layer !== null && !layer.allowUngroup) return false;
  var diagram = layer.diagram;
  if (diagram !== null && !diagram.allowUngroup) return false;
  return true;
};


Group.prototype['findExternalLinksConnected'] =
/**
* @ignore
* Returns an iterator over all of the {@link Link}s that connect with this group or any node contained by this group,
* in either direction, but that are not internal to this group.
* <p>
* Links that are contained by this group (even in nested groups) are not included in the result collection.
* @this {Group}
* @return {Iterator}
* @see Node#findLinksConnected
*/
Group.prototype.findExternalLinksConnected = function() {
  var allmembers = this.findSubGraphParts();
  allmembers.add(this);  // also iterate over the links connecting directly with this group
  var result = new Set(Link);
  var nit = allmembers.iterator;
  while (nit.next()) {
    var node = nit.value;
    if (!(node instanceof go.Node)) continue;  // skip member Links
    var lit = node.linksConnected;
    while (lit.next()) {
      var link = lit.value;
      if (allmembers.contains(link)) continue;  // skip Links that are contained by this group
      result.add(link);
    }
  }
  return result.iterator;
};

Group.prototype['findExternalNodesConnected'] =
/**
* @ignore
* Returns an iterator over all of the {@link Node}s that are connected with this group or any node contained by this group,
* by a link in either direction, but that are not internal to this group.
* <p>
* Nodes that are contained by this group (even in nested groups) are not included in the result collection.
* However this group itself might be in the results if there is a reflexive link connected to this group,
* or if there is a link connecting this group with a node contained by this group.
* @this {Group}
* @return {Iterator}
* @see Node#findNodesConnected
*/
Group.prototype.findExternalNodesConnected = function() {
  var allmembers = this.findSubGraphParts();
  allmembers.add(this);  // also iterate over the links connecting directly with this group
  var result = new Set(Node);
  var nit = allmembers.iterator;
  while (nit.next()) {
    var node = nit.value;
    if (!(node instanceof go.Node)) continue;  // skip member Links
    var lit = node.linksConnected;
    while (lit.next()) {
      var link = lit.value;
      var from = link.fromNode;
      if (!allmembers.contains(from) || from === this) result.add(from);
      var to = link.toNode;
      if (!allmembers.contains(to) || to === this) result.add(to);
    }
  }
  return result.iterator;
};


Group.prototype['findSubGraphParts'] =
/**
* Return a collection of {@link Part}s that are all of the nodes and links
* that are members of this group, including inside nested groups,
* but excluding this group itself.
* <p/>
* For member nodes that are {@link Group}s, this will include its members recursively.
* <p/>
* If you want only the immediate members of this group, use the {@link #memberParts} property.
* @this {Group}
* @return {Set}
*/
Group.prototype.findSubGraphParts = function() {
  var coll = new Set(Part);
  CommandHandler.gatherCollection(coll, this, true, 0);
  coll.remove(this);
  return coll;
};

Group.prototype['collapseSubGraph'] =
/**
* Hide each of the member nodes and links of this group,
* and recursively collapse any member groups.
* This changes the value of {@link Part#isVisible} of the whole subgraph and the parts owned by
* those member nodes and links.
* However, this group's visibility is unchanged.
* <p/>
* This sets {@link #isSubGraphExpanded} to false on this group and on all of the nested {@link Group}s.
* For those nested {@link Group}s that were expanded,
* {@link #wasSubGraphExpanded} is set to true.
* @this {Group}
*/
Group.prototype.collapseSubGraph = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  if (diagram.isCollapsingExpanding) return;
  diagram.isCollapsingExpanding = true;
  var allmembers = this.findSubGraphParts();
  this._collapseSubGraph1(allmembers);
  diagram.isCollapsingExpanding = false;
};

/**
* @ignore
* @this {Group}
* @param {Set} allmembers
*/
Group.prototype._collapseSubGraph1 = function(allmembers) {
  this.isSubGraphExpanded = false;
  var cit = this.memberParts;
  while (cit.next()) {
    var member = cit.value;
    member.invalidateMeasure();
    member.invalidateLayout(Part.LayoutHidden);  // no-op if isUndoingRedoing
    member.clearAdornments();
    if (member instanceof Group) {
      member.wasSubGraphExpanded = member.isSubGraphExpanded;
      member._collapseSubGraph1(allmembers);
    }
    if (member instanceof Node) {
      member.invalidateConnectedLinks(allmembers);
    } else if (member instanceof Link) {
      var lit = member.labelNodes;
      while (lit.next()) {
        var lab = lit.value;
        lab.invalidateConnectedLinks(allmembers);
      }
    }
  }
};

Group.prototype['expandSubGraph'] =
/**
* Show each member node and link,
* and perhaps recursively expand nested subgraphs.
* This may change the value of {@link Part#isVisible} of the whole subgraph and the parts owned by
* those member nodes and links.
* However, this group's visibility is unchanged.
* <p/>
* This sets {@link #isSubGraphExpanded} to true on this group and on all of the nested {@link Group}s.
* This will expand a nested group only if its {@link #wasSubGraphExpanded} property was true.
* @this {Group}
*/
Group.prototype.expandSubGraph = function() {
  var diagram = this.diagram;
  if (diagram === null) return;
  if (diagram.isCollapsingExpanding) return;
  diagram.isCollapsingExpanding = true;
  var allmembers = this.findSubGraphParts();
  this._expandSubGraph1(allmembers);
  diagram.isCollapsingExpanding = false;
};

/**
* @ignore
* @this {Group}
* @param {Set} allmembers
*/
Group.prototype._expandSubGraph1 = function(allmembers) {
  this.isSubGraphExpanded = true;
  var cit = this.memberParts;
  while (cit.next()) {
    var member = cit.value;
    member.invalidateMeasure();
    member.invalidateLayout(Part.LayoutShown);  // no-op if isUndoingRedoing
    member.updateAdornments();
    if (member instanceof Group && member.wasSubGraphExpanded) {
      member._expandSubGraph1(allmembers);
    }
    if (member instanceof Node) {
      member.invalidateConnectedLinks(allmembers);
    } else if (member instanceof Link) {
      var lit = member.labelNodes;
      while (lit.next()) {
        var lab = lit.value;
        lab.invalidateConnectedLinks(allmembers);
      }
    }
  }
};

/**
* Gets or sets whether the subgraph contained by this group is expanded.
* Changing this property's value will call {@link #collapseSubGraph} or {@link #expandSubGraph},
* and also will call the value of {@link #subGraphExpandedChanged} if it is a function.
* <p/>
* The initial value is true -- this group's member parts are shown.
* @name Group#isSubGraphExpanded
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Group.prototype.isSubGraphExpanded;
Util.exportProperty(Group, 'isSubGraphExpanded', Group.prototype.isSubGraphExpanded);
Util.defineProperty(Group, { isSubGraphExpanded: 'isSubGraphExpanded'},
  /** @this {Group} */
  function() { return this._isSubGraphExpanded; },
  /** @this {Group} */
  function(val) {
    var old = this._isSubGraphExpanded;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Group, 'isSubGraphExpanded');
      this._isSubGraphExpanded = val;
      var diagram = this.diagram;
      this.raiseChanged('isSubGraphExpanded', old, val);
      var func = this.subGraphExpandedChanged;
      if (func !== null) {
        var oldUpdatingModel = true;
        if (diagram !== null) {
          oldUpdatingModel = diagram.isUpdatingModel;
          diagram.isUpdatingModel = true;
        }
        func(this);
        if (diagram !== null) {
          diagram.isUpdatingModel = oldUpdatingModel;
        }
      }
      if (diagram !== null && diagram.undoManager.isUndoingRedoing) return;
      if (val) {
        this.expandSubGraph();
      } else {
        this.collapseSubGraph();
      }
    }
  }
);

/**
* Gets or sets whether the subgraph starting at this group
* had been collapsed by a call to {@link #expandSubGraph} on the containing {@link Group}.
* The initial value is false.
* @name Group#wasSubGraphExpanded
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Group.prototype.wasSubGraphExpanded;
Util.exportProperty(Group, 'wasSubGraphExpanded', Group.prototype.wasSubGraphExpanded);
Util.defineProperty(Group, { wasSubGraphExpanded: 'wasSubGraphExpanded'},
  /** @this {Group} */
  function() { return this._wasSubGraphExpanded; },
  /** @this {Group} */
  function(val) {
    var old = this._wasSubGraphExpanded;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Group, 'wasSubGraphExpanded');
      this._wasSubGraphExpanded = val;
      this.raiseChanged('wasSubGraphExpanded', old, val);
    }
  }
);

/**
* Gets or sets the function that is called when {@link #isSubGraphExpanded} has changed value.
* The argument to that function will be this Group.
* <p/>
* If the value is a function, that function must not expand or collapse any groups.
* The Group has already been expanded or collapsed -- trying to change it again may produce undefined behavior.
* <p/>
* The default value is null -- no function is called.
* @name Group#subGraphExpandedChanged
* @function.
* @return {function(Group) | null}
*/
/** @type {function(Group) | null} */
Group.prototype.subGraphExpandedChanged;
Util.exportProperty(Group, 'subGraphExpandedChanged', Group.prototype.subGraphExpandedChanged);
Util.defineProperty(Group, { subGraphExpandedChanged: 'subGraphExpandedChanged' },
  /** @this {Group} */
  function() { return this._subGraphExpandedChanged; },
  /** @this {Group} */
  function(val) {
    var old = this._subGraphExpandedChanged;
    if (old !== val) {
      if (val !== null) Util.checkPrimitive(val, 'function', Group, 'subGraphExpandedChanged');
      this._subGraphExpandedChanged = val;
      this.raiseChanged('subGraphExpandedChanged', old, val);
    }
  }
);


Group.prototype['move'] =
/**
* Move this Group and all of its member parts, recursively.
* @this {Group}
* @param {Point} newpos a new {@link Point} in document coordinates.
*/
Group.prototype.move = function(newpos) {
  var oldpos = this.position;
  var oldx = oldpos.x;
  if (isNaN(oldx)) oldx = 0;
  var oldy = oldpos.y;
  if (isNaN(oldy)) oldy = 0;
  var dx = newpos.x - oldx;
  var dy = newpos.y - oldy;
  Node.prototype.move.call(this, newpos);
  var all = this.findSubGraphParts();
  var it = all.iterator;
  while (it.next()) {
    var part = it.value;
    var oldp = part.position;
    Node.prototype.move.call(part, new Point(oldp.x + dx, oldp.y + dy));
  }
};



/**
* This normally does not need any initialization,
* except for maybe setting {@link #padding}.
* @constructor
* @extends GraphObject
* @class
* If a Placeholder is in the visual tree of a {@link Group}, it represents the area of all of the member {@link Part}s of that Group.
* If a Placeholder is in the visual tree of an {@link Adornment}, it represents the area of the {@link Adornment#adornedObject}.
* It can only be used in the visual tree of a Group node or an Adornment.
* There can be at most one Placeholder in a Group or an Adornment.
*/
function Placeholder() {
  GraphObject.call(this);
  /** @type {Margin} */
  this._padding = Geo.ZeroMargin;
  /** @type {Rect} */
  this._savedBounds = new Rect(NaN, NaN, NaN, NaN);
}

Util.publish('Placeholder', Placeholder);

Util.inherit(Placeholder, GraphObject);

/**
* @ignore
* Copies properties to a cloned Placeholder.
* @this {Placeholder}
* @param {GraphObject} copy
*/
Placeholder.prototype.cloneProtected = function(copy) {
  GraphObject.prototype.cloneProtected.call(this, copy);
  copy._padding = this._padding.copyFrozen();
  copy._savedBounds = this._savedBounds.copy();
};

/**
 * @ignore
 * We also need to consider the {@link GraphObject#background} and {@link GraphObject#areaBackground} --
 * if both are non-null this will return false.
 * Otherwise this just checks whether the given point is in the rectangle formed
 * by the {@link GraphObject#naturalBounds}.
 * @this {Placeholder}
 * @param {Point} p
 * @return {boolean}
 */
Placeholder.prototype.containsPointProtected = function(p) {
  if (this.background === null && this.areaBackground === null) return false;
  // get the natural size because the point p is already transformed
  var sz = this.naturalBounds;
  return Rect.contains(0, 0, sz.width, sz.height, p.x, p.y);
};

/**
* @ignore
* @this {Placeholder}
* @param {number} width
* @param {number} height
* @param {number=} minw
* @param {number=} minh
*/
Placeholder.prototype.measureProtected = function(width, height, minw, minh) {
  var sg = this.part;
  if (sg === null || (!(sg instanceof Group) && !(sg instanceof Adornment))) {
    Util.throwError('Placeholder is not inside a Group or Adornment.');
  }

  if (sg instanceof Group) {
    var b = this.computeBorder(this._savedBounds);
    var nb = this._naturalBounds;
    nb.setWidthHeight(b.width || 0, b.height || 0);
    this._measureRect(0, 0, nb.width, nb.height);

    // don't assign Location if there aren't any visible member nodes
    var itr = sg.memberParts;
    var visible = false;
    while (itr.next()) {
      var mem = itr.value;
      if (mem.isVisible()) {
        visible = true;
        break;
      }
    }

    // can't set the location of the Group yet because the group is not yet done arranging
    // This gets set later on anyway by arrange
    if (visible && !isNaN(b.x) && !isNaN(b.y)) {
      //var wasma = sg.isMeasuringArranging;
      //sg.isMeasuringArranging = false;
      var p = new Point();
      p.setRectSpot(b, sg.locationSpot);
      sg.location = new Point(p.x, p.y);
      //sg.isMeasuringArranging = wasma;
    }
  } else { // Adornment
    var b = this.desiredSize;
    var nb = this._naturalBounds;
    var pad = this.padding;
    var pw = pad.left + pad.right;
    var ph = pad.top + pad.bottom;
    if (b.isReal()) {
      nb.setWidthHeight((b.width + pw) || 0, (b.height + ph) || 0);
      this._measureRect(-pad.left, -pad.top, nb.width, nb.height);
    } else {
      // Determine size based on adorned object
      var part = this.part;
      var ao = part.adornedObject;
      var p1 = ao.getDocumentPoint(Spot.TopLeft, Util.tempPoint());
      b = Util.tempRectAt(p1.x, p1.y, 0, 0);
      b.unionPoint(ao.getDocumentPoint(Spot.BottomRight, p1));
      b.unionPoint(ao.getDocumentPoint(Spot.TopRight, p1));
      b.unionPoint(ao.getDocumentPoint(Spot.BottomLeft, p1));
      part._location._set(b.x, b.y);

      nb.setWidthHeight((b.width + pw) || 0, (b.height + ph) || 0);
      this._measureRect(-pad.left, -pad.top, nb.width, nb.height);

      Util.freePoint(p1);
      Util.freeRect(b);
    }

  }
};

/**
 * @ignore
 * Just set the {@link GraphObject#actualBounds}.
 * @this {Placeholder}
 * @param {number} fx
 * @param {number} fy
 * @param {number} fw
 * @param {number} fh
 */
Placeholder.prototype.arrangeProtected = function(fx, fy, fw, fh) {
  var ab = this.actualBounds;
  ab.x = fx;
  ab.y = fy;
  ab.width = fw;
  ab.height = fh;
};

/**
 * @ignore
 * This is only called when the Placeholder is inside a {@link Group}.
 * Normally this just returns the result of {@link #computeMemberBounds} expanded by the {@link #padding}.
 * However, if {@link Group#computesBoundsAfterDrag} is true,
 * and if the {@link Diagram#currentTool} is the {@link DraggingTool},
 * and if this {@link Group} is not being dragged,
 * this method returns the last value of {@link #computeBorder} before dragging began.
 * @this {Placeholder}
 * @param {Rect} result
 * @return {Rect} in model coordinates.
 */
Placeholder.prototype.computeBorder = function(result) {
  var sg = this.part;
  if (sg instanceof Group && sg.computesBoundsAfterDrag && this._savedBounds.isReal()) {
    var diagram = sg.diagram;
    if (diagram !== null) {
      var tool = diagram.currentTool;
      if (tool instanceof DraggingTool && !tool._dropped && tool.draggedParts !== null && !tool.draggedParts.contains(sg)) {
        result.assign(this._savedBounds);
        return result;
      }
    }
  }

  var temp = Util.tempRect();
  var r = this.computeMemberBounds(temp);
  var pad = this.padding;
  result._set(r.x - pad.left, r.y - pad.top, r.width + pad.left + pad.right, r.height + pad.top + pad.bottom);
  Util.freeRect(temp);
  return result;
};

/**
 * @ignore
 * Compute the union of the Bounds of this Placeholder's parent's Group.memberParts.
 * If there are no members, this returns a <c>Rect</c> with Width and Height of zero
 * and an X and Y that are this panel's original location in model coordinates.
 * This is only called when the Placeholder is inside a {@link Group}.
 * @this {Placeholder}
 * @param {Rect} result
 * @return {Rect} in model coordinates.
 */
Placeholder.prototype.computeMemberBounds = function(result) {
  var sg = this.part;
  if (!(sg instanceof Group)) {
    result._set(0, 0, 0, 0);
    return result;
  }

  var minx = Infinity;
  var miny = Infinity;
  var maxx = -Infinity;
  var maxy = -Infinity;

  var itr = sg.memberParts;

  while (itr.next()) {
    var m = itr.value;
    if (!m.isVisible()) continue;
    if (m instanceof Link) {
      if (m.getInvalidMeasure()) continue;  //???
      // ignore links connecting to this Group
      if (m.fromNode === sg || m.toNode === sg) continue;
    } else {
      // support rotation of whole node
    }
    var b = m.actualBounds; // replaced GetElementBounds
    if (b.left < minx) minx = b.left;
    if (b.top < miny) miny = b.top;
    if (b.right > maxx) maxx = b.right;
    if (b.bottom > maxy) maxy = b.bottom;
  }

  if (!isFinite(minx) || !isFinite(miny)) {
    var loc = sg.location;
    var pad = this.padding;
    result._set(loc.x + pad.left, loc.y + pad.top, 0, 0);
  } else {
    result._set(minx, miny, maxx - minx, maxy - miny);
  }
  return result;
};


/**
 * Gets or sets the padding around the members of the {@link Group} or around the {@link Adornment#adornedObject} {@link GraphObject}.
 * The initial value is a {@link Margin} of zero on all sides.
 * Paddings cannot contain negative numbers.
 * @name Placeholder#padding
 * @function.
 * @return {Margin|number}
 */
/** @type {Margin|number} */
Placeholder.prototype.padding;
Util.exportProperty(Placeholder, 'padding', Placeholder.prototype.padding);
Util.defineProperty(Placeholder, { padding: 'padding'},
  /** @this {Placeholder} */
  function() { return this._padding; },
  /** @this {Placeholder} */
  function(val) {
    if (typeof val === 'number') {
      if (val < 0) Util.throwRangeError(val, '>= 0', Placeholder, 'padding');
      val = new Margin(val);
    } else {
      Util.checkClass(val, Margin, Placeholder, 'padding');
      if (val.left < 0) Util.throwRangeError(val.left, '>= 0', Placeholder, 'padding:val.left');
      if (val.right < 0) Util.throwRangeError(val.right, '>= 0', Placeholder, 'padding:val.right');
      if (val.top < 0) Util.throwRangeError(val.top, '>= 0', Placeholder, 'padding:val.top');
      if (val.bottom < 0) Util.throwRangeError(val.bottom, '>= 0', Placeholder, 'padding:val.bottom');
    }
    var old = this._padding;
    if (!old.equals(val)) {
      val = val.copyFrozen();
      this._padding = val;
      this.raiseChanged('padding', old, val);
    }
  }
);

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
Layout
LayoutNetwork
LayoutVertex
LayoutEdge
*/

/**
 * Create a minimal layout that only positions {@link Node}s that do not have a location.
 * @constructor
 * @category Layout
 * @class
 * This is the base class for all of the predefined diagram layout implementations.
 * They only arrange {@link Part}s (primarily {@link Node}s and {@link Link}s) in a {@link Diagram},
 * not to {@link GraphObject}s in {@link Panel}s (i.e. panel layout).
 * <p/>
 * The layout classes include {@link TreeLayout}, {@link ForceDirectedLayout},
 * {@link LayeredDigraphLayout}, {@link CircularLayout}, and {@link GridLayout}.
 * This base class is not abstract -- in fact an instance of this base class is the default
 * value for {@link Diagram#layout} and for {@link Group#layout}.
 * <p/>
 * An instance of a Layout class will be the value of {@link Diagram#layout}.
 * That layout positions the graph of top-level nodes and links.
 * Nodes and links that belong to a {@link Group} are laid out by that group's {@link Group#layout}.
 * The Diagram will automatically perform all nested group layouts before laying out the whole diagram.
 * <p/>
 * If you have position information for all of the nodes when you load a model,
 * you will typically have data bound the {@link Part#location} to some property on your node data.
 * In order to avoid an initial layout causing those saved node positions to be discarded,
 * you can either not set the {@link Diagram#layout} to a predefined layout or you can
 * set {@link #isInitial} to false.
 * <p/>
 * Because performing layouts can be expensive in space and time, automatic layouts
 * are performed only on "invalid" layouts, and only well after a layout has been invalidated.
 * This state is held by the {@link #isValidLayout} property.
 * Many standard operations, such as adding or removing nodes or links, will cause
 * the layout that is responsible for positioning those nodes or routing those links
 * to be invalidated.
 * Such invalidation is performed by calling {@link #invalidateLayout},
 * which not only clears the {@link #isValidLayout} state but also requests that the diagram
 * do an automatic layout soon.
 * You can avoid such invalidations by setting {@link #isOngoing} to false.
 * <p/>
 * Layouts will ignore parts that have {@link Part#isLayoutPositioned} set to false
 * or parts that are not {@link GraphObject#visible}.
 * Layouts will also ignore parts that are in layers that are {@link Layer#isTemporary}.
 * <p/>
 * Various operations on {@link Part}s will cause the responsible Layout to be invalidated.
 * This includes adding or removing parts, changing their visibility, and changing their size.
 * You can disable such automatic layout invalidations by setting {@link Part#layoutConditions}
 * to the combination of Part flags named "Layout..." that you want.
 * <p/>
 * But operations on parts are not the only way in which layouts become invalidated.
 * Setting most properties on the layouts, thereby changing their behavior, will invalidate that layout.
 * Replacing the {@link Diagram#layout} or {@link Group#layout} will automatically invalidate the new layout.
 * If {@link #isViewportSized} is true, when a diagram's {@link Diagram#viewportBounds} changes size,
 * the {@link Diagram#layout} is invalidated.
 * (This is normally only true for {@link GridLayout}s when its {@link GridLayout#wrappingWidth} is <code>NaN</code>.
 * Most layouts do not care about the size of the viewport.)
 * <p/>
 * You can also explicitly call {@link Diagram#layoutDiagram}, which can invalidate all layouts and
 * then perform them all.
 * But we recommend that you avoid doing so, to allow the normal updating process perform layouts as needed.
 * <p/>
 * If an automatic layout is the first time that a layout has been performed for the model,
 * the diagram first raises the {@link DiagramEvent} named "InitialLayoutCompleted".
 * Whenever a Diagram finishes an automatic layout, it raises the DiagramEvent named "LayoutCompleted".
 * <p/>
 * It is also possible to call {@link #doLayout} explicitly, but this is uncommon and only used with
 * instances of Layout that are not the {@link Diagram#layout} or {@link Group#layout}.
 * It should only be needed when you want to layout a collection of nodes and links that is not
 * the normal graph of top-level parts of a Diagram or a subgraph of a Group.
 * <p/>
 * An instance of this base class provides a rudimentary default layout that will position
 * all of the parts that have no position (i.e. the {@link Part#location} is (NaN,NaN).
 * Parts that already have a position are ignored.
 * This primitive layout class does not make use of a {@link LayoutNetwork} because
 * it ignores all links.
 * <p/>
 * To implement your own custom layouts, you can inherit from either this class or
 * from one of the other predefined layout classes.
 * If you inherit from this base class, you will want to override the {@link #doLayout} method.
 * You can call the {@link Part#move} method to re-position a part, including whole groups.
 */
function Layout() {
  if (arguments.length > 0) {
    Util.throwError('Layout constructor cannot take any arguments.');
  }
  Util.uniqueHash(this);
  /** @type {Diagram} */
  this._diagram = null;
  /** @type {Group} */
  this._group = null;
  /** @type {boolean} */
  this._isOngoing = true;
  /** @type {boolean} */
  this._isInitial = true;
  /** @type {boolean} */
  this._isValidLayout = false;
  /** @type {boolean} */
  this._isViewportSized = false;
  /** @type {Point} */
  this._arrangementOrigin = new Point(0, 0).freeze();
  /** @type {boolean} */
  this._isRouting = true;
  /** @type {LayoutNetwork} */
  this._network = null;
  /** @type {boolean} */
  this._isRealtime = true;
}

Util.publish('Layout', Layout);

/**
* @ignore
* Copies properties from this object to the given object, which is of the same class.
* This is called by {@link #copy}.
* @expose
* @this {Layout}
* @param {Layout} copy
*/
Layout.prototype.cloneProtected = function(copy) {
  // new owner needs to set _diagram and _group
  copy._isOngoing = this._isOngoing;
  copy._isInitial = this._isInitial;
  if (!this._isInitial) copy._isValidLayout = true;  // special treatment in isInitial setter
  copy._isViewportSized = this._isViewportSized;
  copy._arrangementOrigin.assign(this._arrangementOrigin);
  // _network = null
  copy._isRealtime = this._isRealtime;
};

/**
* Creates a copy of this Layout and returns it.
* @expose
* @this {Layout}
* @return {Layout}
*/
Layout.prototype.copy = function() {
  var copy = new this.constructor;
  this.cloneProtected(copy);
  return copy;
};


/**
* @ignore
* @this {Layout}
* @return {string}
*/
Layout.prototype.toString = function() {
  var str = Util.getClassName(Object.getPrototypeOf(this));
  str += '(';
  if (this.group !== null) str += ' in ' + this.group;
  if (this.diagram !== null) str += ' for ' + this.diagram;
  str += ')';
  return str;
};


/**
* Gets the {@link Diagram} that owns this layout, if it is the value of {@link Diagram#layout}.
* @name Layout#diagram
* @function.
* @return {Diagram}
*/
/** @type {Diagram} */
Layout.prototype.diagram;
Util.exportProperty(Layout, 'diagram', Layout.prototype.diagram);
Util.defineProperty(Layout, { diagram: 'diagram' },
  /** @this {Layout} */
  function() { return this._diagram; },
  /** @this {Layout} */
  function(val) {
    var old = this._diagram;
    if (old !== val) {
      if (val !== null) Util.checkClass(val, Diagram, Layout, 'diagram');
      this._diagram = val;
    }
  }
);


/**
* Gets the {@link Group} that uses this layout, if it is the value of a group's {@link Group#layout}.
* @name Layout#group
* @function.
* @return {Group}
*/
/** @type {Group} */
Layout.prototype.group;
Util.exportProperty(Layout, 'group', Layout.prototype.group);
Util.defineProperty(Layout, { group: 'group' },
  /** @this {Layout} */
  function() { return this._group; },
  /** @this {Layout} */
  function(val) {
    var old = this._group;
    if (old !== val) {
      if (val !== null) Util.checkClass(val, Group, Layout, 'group');
      this._group = val;
    }
  }
);


/**
* Gets or sets whether this layout can be invalidated by {@link #invalidateLayout}.
* Set this to false to prevent actions such as adding or removing Parts from invalidating this layout.
* The default value is true.
* Setting this property does not invalidate this layout.
* <p/>
* If you set both {@link #isInitial} and {@link #isOngoing} to false,
* there will be no automatic layout invalidation, because {@link #invalidateLayout}
* will not set {@link #isValidLayout} to false.
* @name Layout#isOngoing
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Layout.prototype.isOngoing;
Util.exportProperty(Layout, 'isOngoing', Layout.prototype.isOngoing);
Util.defineProperty(Layout, { isOngoing: 'isOngoing' },
  /** @this {Layout} */
  function() { return this._isOngoing; },
  /** @this {Layout} */
  function(val) {
    var old = this._isOngoing;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Layout, 'isOngoing');
      this._isOngoing = val;
    }
  }
);

/**
* Gets or sets whether this layout is performed on an initial layout.
* The default value is true.
* Setting this property to false causes {@link #isValidLayout} to be set to true
* so that the diagram does not perform this layout.
* <p/>
* If you set both {@link #isInitial} and {@link #isOngoing} to false,
* there will be no automatic layout invalidation, because {@link #invalidateLayout}
* will not set {@link #isValidLayout} to false.
* @name Layout#isInitial
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Layout.prototype.isInitial;
Util.exportProperty(Layout, 'isInitial', Layout.prototype.isInitial);
Util.defineProperty(Layout, { isInitial: 'isInitial' },
  /** @this {Layout} */
  function() { return this._isInitial; },
  /** @this {Layout} */
  function(val) {
    Util.checkPrimitive(val, 'boolean', Layout, 'isInitial');
    this._isInitial = val;
    if (!val) {  // do this side-effect unconditionally
      this._isValidLayout = true;
    }
  }
);

/**
* Gets or sets whether this layout needs to be performed again.
* This is often set to false by a call to {@link #invalidateLayout}.
* @name Layout#isValidLayout
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Layout.prototype.isValidLayout;
Util.exportProperty(Layout, 'isValidLayout', Layout.prototype.isValidLayout);
Util.defineProperty(Layout, { isValidLayout: 'isValidLayout' },
  /** @this {Layout} */
  function() { return this._isValidLayout; },
  /** @this {Layout} */
  function(val) {
    var old = this._isValidLayout;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Layout, 'isValidLayout');
      this._isValidLayout = val;
      if (!val) {
        var diagram = this.diagram;
        if (diagram !== null) {
          diagram._anyLayoutInvalid = true;  // optimization for detecting whether any layout is invalid
        }
      }
    }
  }
);

Layout.prototype['invalidateLayout'] =
/**
* If {@link #isOngoing} is true and if an initial layout has not yet been performed,
* set the {@link #isValidLayout} property to false, and ask to perform another layout in the near future.
* If {@link #isInitial} is true, this layout is invalidated only when the {@link Diagram#model} is replaced,
* not under the normal circumstances such as when parts are added or removed or
* due to other calls to {@link Layout#invalidateLayout}.
* <p/>
* If you set both {@link #isInitial} and {@link #isOngoing} to false,
* there will be no automatic layout invalidation, because this method
* will not set {@link #isValidLayout} to false.
* However you can still set {@link #isValidLayout} explicitly.
* <p/>
* This is typically called when a layout property value has changed,
* or when a Part is added or removed or changes visibility.
* @this {Layout}
*/
Layout.prototype.invalidateLayout = function() {
  if (this._isValidLayout) {
    var diagram = this.diagram;
    if (diagram === null) return;
    if (diagram.undoManager.isUndoingRedoing) return;
    if ((this.isOngoing && diagram._initialLayoutCompleted) ||
        (this.isInitial && !diagram._initialLayoutCompleted)) {
      this.isValidLayout = false;
      diagram.requestUpdate(true);
    }
  }
};

/**
* Gets or sets whether this layout be performed in real-time, before the end of a transaction.
* All layouts that are invalidated will be performed at the end of a transaction.
* @name Layout#isRealtime
* @function.
* @return {boolean}
* @since 1.2
*/
/** @type {boolean} */
Layout.prototype.isRealtime;
Util.exportProperty(Layout, 'isRealtime', Layout.prototype.isRealtime);
Util.defineProperty(Layout, { isRealtime: 'isRealtime' },
  /** @this {Layout} */
  function() { return this._isRealtime; },
  /** @this {Layout} */
  function(val) {
    var old = this._isRealtime;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Layout, 'isRealtime');
      this._isRealtime = val;
    }
  }
);

/**
* Gets or sets whether this layout depends on the {@link Diagram#viewportBounds}'s size.
* This only applies to diagram layouts, not to group layouts.
* The default value is false.
* Setting this property to true will invalidate this layout.
* @name Layout#isViewportSized
* @function.
* @return {boolean}
*/
/** @type {boolean} */
Layout.prototype.isViewportSized;
Util.exportProperty(Layout, 'isViewportSized', Layout.prototype.isViewportSized);
Util.defineProperty(Layout, { isViewportSized: 'isViewportSized' },
  /** @this {Layout} */
  function() { return this._isViewportSized; },
  /** @this {Layout} */
  function(val) {
    var old = this._isViewportSized;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Layout, 'isViewportSized');
      this._isViewportSized = val;
      if (val) this.invalidateLayout();
    }
  }
);

/**
* Gets or sets whether this layout routes {@link Link}s.
* The default value is true.
* When false, this layout will not explicitly set the {@link Link#points},
* and the default routing of each individual Link will take place after the Nodes are moved by {@link #commitLayout}.
* Setting this property does not invalidate this layout.
* <p/>
* Some layouts ignore links, in which case this property is ignored.
* @name Layout#isRouting
* @function.
* @return {boolean}
* @since 1.1
*/
/** @type {boolean} */
Layout.prototype.isRouting;
Util.exportProperty(Layout, 'isRouting', Layout.prototype.isRouting);
Util.defineProperty(Layout, { isRouting: 'isRouting' },
  /** @this {Layout} */
  function() { return this._isRouting; },
  /** @this {Layout} */
  function(val) {
    var old = this._isRouting;
    if (old !== val) {
      Util.checkPrimitive(val, 'boolean', Layout, 'isRouting');
      this._isRouting = val;
    }
  }
);


/**
* Gets or sets the {@link LayoutNetwork} used by this Layout, if any.
* The default value is null.
* Not all kinds of layout make use of a {@link LayoutNetwork}.
* Call {@link #createNetwork} or {@link #makeNetwork} to create a network.
* @name Layout#network
* @function.
* @return {LayoutNetwork}
*/
/** @type {LayoutNetwork} */
Layout.prototype.network;
Util.exportProperty(Layout, 'network', Layout.prototype.network);
Util.defineProperty(Layout, { network: 'network' },
  /** @this {Layout} */
  function() { return this._network; },
  /** @this {Layout} */
  function(val) {
    var old = this._network;
    if (old !== val) {
      if (val !== null) Util.checkClass(val, LayoutNetwork, Layout, 'network');
      if (old !== null) old.setLayout(null);
      this._network = val;
      if (val !== null) val.setLayout(this);
    }
  }
);

/**
* Create a new {@link LayoutNetwork} of {@link LayoutVertex}es and {@link LayoutEdge}s.
* This may be overridden in Layout subclasses to create instances of subclasses of
* {@link LayoutNetwork}.
* @expose
* @this {Layout}
* @return {LayoutNetwork} a new {@link LayoutNetwork}.
*/
Layout.prototype.createNetwork = function() {
  var net = new LayoutNetwork();
  net.setLayout(this);
  return net;
};

/**
* Create and initialize a {@link LayoutNetwork} with the given nodes and links.
* This should be called by {@link #doLayout} when this layout uses a {@link #network}.
* This method calls {@link #createNetwork} to allocate the network.
* This may be overridden in Layout subclasses to customize the initialization.
* @expose
* @this {Layout}
* @param {Diagram|Group|Iterable} coll A {@link Diagram} or a {@link Group} or a collection of {@link Part}s.
*/
Layout.prototype.makeNetwork = function(coll) {
  var net = this.createNetwork();
  if (coll instanceof Diagram) {
    net.addParts(coll.nodes, true);
    net.addParts(coll.links, true);
  } else if (coll instanceof Group) {
    net.addParts(coll.memberParts);
  } else {
    net.addParts(coll.iterator);
  }
  return net;
};

/**
* When using a {@link LayoutNetwork}, update the "physical" node positionings and link routings.
* This should be called by {@link #doLayout} when this layout uses a {@link #network}.
* This calls {@link #commitLayout} to actually set {@link Node} positions and route {@link Link}s.
* This performs the changes within a transaction.
* @expose
* @this {Layout}
*/
Layout.prototype.updateParts = function() {
  var diagram = this.diagram;
  if (diagram === null && this.network !== null) {
    // look for a Node.diagram
    var it = this.network.vertexes.iterator;
    while (it.next()) {
      var v = it.value;
      var n = v.node;
      if (n !== null) {
        diagram = n.diagram;
        if (diagram !== null) break;
      }
    }
  }
  this.isValidLayout = true;  // prevent unintentional recursive layout
  if (diagram !== null) diagram.startTransaction('Layout');
  this.commitLayout();
  if (diagram !== null) diagram.commitTransaction('Layout');
};

/**
* When using a {@link LayoutNetwork}, commit changes to the diagram
* by setting {@link Node} positions and by routing the {@link Link}s.
* This is called by {@link #updateParts} within a transaction.
* <p/>
* You should not call this method -- it is a "protected virtual" method.
* This should be overridden by subclasses of Layout --
* by default this method does nothing.
* @expose
* @this {Layout}
*/
Layout.prototype.commitLayout = function() {
};



/**
* Position all of the nodes that do not have an assigned {@link Part#location}
* in the manner of a simple rectangular array.
* The default implementation ignores all {@link Group}s and {@link Link}s;
* many subclasses of {@link Layout} ignore all instances of {@link Part}s
* that are not {@link Node}s or {@link Link}s.
* <p/>
* You can override this method to do whatever node positioning and link routing
* that you wish.
* <p/>
* When the layout makes use of a {@link LayoutNetwork},
* this method should call {@link #makeNetwork} and {@link #updateParts}.
* Override {@link #commitLayout} to actually position nodes and route links.
* The {@link #updateParts} method will call {@link #commitLayout} within a transaction.
* <p/>
* When the layout does not make use of a {@link LayoutNetwork},
* this method should make direct changes to {@link Node}s and {@link Link}s
* within a transaction.
* @expose
* @this {Layout}
* @param {Diagram|Group|Iterable} coll A {@link Diagram} or a {@link Group} or a collection of {@link Part}s.
*/
Layout.prototype.doLayout = function(coll) {
  if (!coll) Util.throwError('Layout.doLayout(collection) argument must not be null but a Diagram, a Group, or an Iterable of Parts');
  var allparts = new Set(Part);
  if (coll === this.diagram) {
    // include top-level nodes/groups/parts, but not links
    this.collectAllParts(allparts, coll.nodes, true, this.needsLocation, true, false, true);
    // skip Diagram.links
    this.collectAllParts(allparts, coll.parts, true, this.needsLocation, true, false, true);
  } else if (coll === this.group) {
    // include nodes/groups/parts, but not links
    this.collectAllParts(allparts, coll.memberParts, false, this.needsLocation, true, false, true);
  } else {
    // include all given parts
    allparts.addAll(coll.iterator);
  }
  var num = allparts.count;  // all non-links
  if (num > 0) {
    var diagram = this.diagram;
    if (diagram !== null) diagram.startTransaction('Layout');
    var sqrt = Math.ceil(Math.sqrt(num));
    var originx = this.arrangementOrigin.x;
    var originy = this.arrangementOrigin.y;
    var x = originx;
    var y = originy;
    var i = 0;
    var maxh = 0;
    var idx = allparts.iterator;
    while (idx.next()) {
      var part = idx.value;
      part.ensureBounds();
      var b = part.measuredBounds;
      var w = b.width;
      var h = b.height;
      part.moveTo(x, y);
      delete part._needsLocation;
      x += Math.max(w, 50) + 20;
      maxh = Math.max(maxh, Math.max(h, 50));
      if (i >= sqrt - 1) {
        i = 0;
        x = originx;
        y += maxh + 20;
        maxh = 0;
      } else {
        i++;
      }
    }
    if (diagram !== null) diagram.commitTransaction('Layout');
  }
  this.isValidLayout = true;
};

/**
* @ignore
* @this {Layout}
* @param {Part} part
* @return {boolean}
*/
Layout.prototype.needsLocation = function(part) {
  var loc = part.location;
  if (!loc.isReal()) return true;
  // hack: when a Group didn't have a real Location before it got laid out by Diagram.updateGroupLayouts,
  // it might get a Location anyway, but that would cause the above test to think that the Group doesn't need to be moved.
  if (part instanceof Group && part._needsLocation) return true;
  return false;
};

/**
* @ignore
* @this {Layout}
* @param {Set} allparts
* @param {Iterable} parts
* @param {boolean} toplevelonly
* @param {function(Part):boolean | null} pred
* @param {boolean} includenodes
* @param {boolean} includelinks
* @param {boolean} includeparts
*/
Layout.prototype.collectAllParts = function(allparts, parts, toplevelonly, pred, includenodes, includelinks, includeparts) {
  var it = parts.iterator;
  while (it.next()) {
    var part = it.value;
    if (toplevelonly && !part.isTopLevel) continue;
    if (pred && !pred(part)) continue;
    if (!part.canLayout()) continue;
    if (includenodes && part instanceof Node) {
      if (part.isLinkLabel) continue;
      // don't include a Group with no Group.layout, but do include all of its memberParts
      if (part instanceof Group && part.layout === null) {
        this.collectAllParts(allparts, part.memberParts, false, pred, includenodes, includelinks, includeparts);
      } else {  // plain Node or a Group with a Group.layout (treated as an atomic node)
        allparts.add(part);
      }
    } else if (includelinks && part instanceof Link) {
      allparts.add(part);
    } else if (includeparts && part.isNodeLike() && !(part instanceof Node)) {
      allparts.add(part);
    }
  }
};


/**
* Gets or sets the top-left point for where the graph should be positioned when laid out.
* Setting this property invalidates this layout.
* @name Layout#arrangementOrigin
* @function.
* @return {Point}
*/
/** @type {Point} */
Layout.prototype.arrangementOrigin;
Util.exportProperty(Layout, 'arrangementOrigin', Layout.prototype.arrangementOrigin);
Util.defineProperty(Layout, { arrangementOrigin: 'arrangementOrigin' },
  /** @this {Layout} */
  function() { return this._arrangementOrigin; },
  /** @this {Layout} */
  function(val) {
    var old = this._arrangementOrigin;
    if (!old.equals(val)) {
      Util.checkClass(val, Point, Layout, 'arrangementOrigin');
      this._arrangementOrigin.assign(val);
      this.invalidateLayout();
    }
  }
);

/**
* @ignore
* @this {Layout}
* @param {Point} origin
* @return {Point}
*/
Layout.prototype.initialOrigin = function(origin) {
  var group = this.group;
  if (group !== null) {
    var loc = group.location;
    if (isNaN(loc.x) || isNaN(loc.y)) return origin;
    var gp = group.placeholder;
    if (gp !== null) {
      loc = gp.getDocumentPoint(Spot.TopLeft);
      loc.x += gp.padding.left;
      loc.y += gp.padding.top;
    } else {
      loc = group.position.copy();
    }
    return loc;
  }
  return origin;
};


/**
 * This constructs an empty network.
 * It is commonplace to call {@link #addParts} to build up the network
 * to have the same structure as a {@link Diagram}'s or {@link Group}'s nodes and links.
 * @constructor
 * @category Layout
 * @class
 * This provides an abstract view of a diagram as a
 * network (graph) of vertexes and directed edges.
 * The network contains vertexes and edges corresponding to {@link Node}s and {@link Link}s.
 * <p/>
 * This class provides a framework for manipulating the
 * state of nodes and links without modifying the structure of the diagram.
 * Having a separate representation also permits adding or removing vertexes or edges
 * from the network so that the graph that is laid out is not isomorphic to the diagram's graph.
 * <p/>
 * Modifying a {@link LayoutNetwork} or a {@link LayoutVertex} or a {@link LayoutEdge} does not
 * invalidate the {@link Layout} or raise any changed events.
 */
function LayoutNetwork() {
  Util.uniqueHash(this);
  /** @ignore @type {Layout} */
  this._layout = null;
  this.clear();
}

Util.publish('LayoutNetwork', LayoutNetwork);

/**
* @ignore
* Removes all vertexes and edges from the network, resulting in an empty network.
* @this {LayoutNetwork}
*/
LayoutNetwork.prototype.clear = function() {
  if (this.vertexes) {
    var it = this.vertexes.iterator;
    while (it.next()) {
      var v = it.value;
      v.clear();
      v.network = null;
    }
  }
  if (this.edges) {
    var it = this.edges.iterator;
    while (it.next()) {
      var e = it.value;
      e.clear();
      e.network = null;
    }
  }

  /**
  * Gets a collection of all of the {@link LayoutVertex}es in this network.
  * Do not modify this collection directly.
  * Instead, call {@link #addVertex}, {@link #deleteVertex}, {@link #addNode}, or {@link #deleteNode}.
  * @name LayoutNetwork#vertexes
  * @function.
  * @return {Set}
  */
  /** @expose @type {Set} */
  this.vertexes = new Set(LayoutVertex);

  /**
  * Gets a collection of all of the {@link LayoutEdge}s in this network.
  * Do not modify this collection directly.
  * Instead, call {@link #addEdge}, {@link #deleteEdge}, {@link #addLink}, or {@link #deleteLink}.
  * @name LayoutNetwork#edges
  * @function.
  * @return {Set}
  */
  /** @expose @type {Set} */
  this.edges = new Set(LayoutEdge);

  // internal state
  /** @ignore @type {Map} */
  this.nodeToVertexMap = new Map(Node, LayoutVertex);
  /** @ignore @type {Map} */
  this.linkToEdgeMap = new Map(Link, LayoutEdge);
};

/**
* @ignore
* @this {LayoutNetwork}
* @return {string}
*/
LayoutNetwork.prototype.toString = function() {
  return 'LayoutNetwork' + (this.layout !== null ? '(' + this.layout.toString() + ')' : '');
};


/**
* Gets the {@link Layout} that uses this network
* of {@link LayoutVertex}es and {@link LayoutEdge}s.
* The default value is null.
* It is set automatically for you when this setting {@link Layout#network}.
* @name LayoutNetwork#layout
* @function.
* @return {Layout}
*/
/** @type {Layout} */
LayoutNetwork.prototype.layout;
Util.defineReadOnlyProperty(LayoutNetwork, { layout: 'layout' },
  /** @this {LayoutNetwork} */
  function() { return this._layout; }
);

/**
* @ignore
* @this {LayoutNetwork}
* @param {Layout} val
*/
LayoutNetwork.prototype.setLayout = function(val) {
  if (Debug && val !== null) Util.checkClass(val, Layout, LayoutNetwork, 'setLayout');
  this._layout = val;
};


/**
* Allocate a new instance of {@link LayoutVertex}.
* This is overridden in LayoutNetwork subclasses to create instances of subclasses of {@link LayoutVertex}.
* @expose
* @this {LayoutNetwork}
* @return {LayoutVertex}
*/
LayoutNetwork.prototype.createVertex = function() {
  return new LayoutVertex();
};

/**
* Allocate a new instance of {@link LayoutEdge}.
* This is overridden in LayoutNetwork subclasses to create instances of subclasses of {@link LayoutEdge}.
* @expose
* @this {LayoutNetwork}
* @return {LayoutEdge}
*/
LayoutNetwork.prototype.createEdge = function() {
  return new LayoutEdge();
};


LayoutNetwork.prototype['addParts'] =
/**
* Creates a network of {@link LayoutVertex}es and {@link LayoutEdge}s
* corresponding to the given {@link Node}s and {@link Link}s.
* This is usually more convenient than repeatedly calling {@link #addNode} and {@link #addLink}.
* This method ignores all instances of {@link Part}s that are not Nodes or Links.
* This will recurse through {@link Group}s that have no {@link Group#layout}.
* @this {LayoutNetwork}
* @param {Iterable} parts A collection of {@link Node}s or {@link Link}s.
* @param {boolean=} toplevelonly whether to skip Parts in the given collection that are contained by Groups.
*/
LayoutNetwork.prototype.addParts = function(parts, toplevelonly) {
  if (parts === null) return;
  if (toplevelonly === undefined/*notpresent*/) toplevelonly = false;
  Util.checkPrimitive(toplevelonly, 'boolean', LayoutNetwork, 'addParts:toplevelonly');
  // First, add all Nodes in the collection, that are not links,
  //  as vertexes to the network.
  var it = parts.iterator;
  while (it.next()) {
    var node = it.value;
    if (!(node instanceof Node)) continue;
    if (toplevelonly && !node.isTopLevel) continue;
    if (!node.canLayout()) continue;
    if (node.isLinkLabel) continue;
    if (node instanceof Group && node.layout === null) {
      this.addParts(node.memberParts, false);
    } else {
      if (this.findVertex(node) !== null) continue;
      var pNetworkNode = this.createVertex();
      pNetworkNode.node = node;
      this.addVertex(pNetworkNode);
    }
  }

  // Second, add all node-level Links as links to the network.
  // Note: a link cannot be added to the network unless both of
  //  its to and from nodes are in the network.  Hence, it is possible
  //  to select a Link without selecting the Nodes at its
  //  endpoints, but the Link will not be added to the network.
  it.reset();
  while (it.next()) {
    var link = it.value;
    if (!(link instanceof Link)) continue;
    if (toplevelonly && !link.isTopLevel) continue;
    if (!link.canLayout()) continue;
    if (this.findEdge(link) !== null) continue;

    var fromNode = link.fromNode;
    var toNode = link.toNode;
    if (fromNode === toNode) continue;

    // Verify that the top-level Vertexes for the from and to nodes
    //  are in the network and add a link between them.
    var fromVertex = this.findGroupVertex(fromNode);
    var toVertex = this.findGroupVertex(toNode);
    if (fromVertex !== null && toVertex !== null) {
      this.linkVertexes(fromVertex, toVertex, link);
    }
  }
};

LayoutNetwork.prototype['findGroupVertex'] =
/**
* @ignore
* @this {LayoutNetwork}
* @param {Node} n
* @return {LayoutVertex}
*/
LayoutNetwork.prototype.findGroupVertex = function(n) {
  if (n === null) return null;
  var visn = n.findVisibleNode();
  if (visn === null) return null;
  var v = this.findVertex(visn);
  if (v !== null) return v;
  var g = visn.containingGroup;
  if (g !== null) {
    v = this.findVertex(g);
    if (v !== null) return v;
  }
  return null;
};

LayoutNetwork.prototype['addVertex'] =
/**
* Adds a {@link LayoutVertex} to the network.
* @this {LayoutNetwork}
* @param {LayoutVertex} vertex
*/
LayoutNetwork.prototype.addVertex = function(vertex) {
  if (vertex === null) return;
  if (Debug) Util.checkClass(vertex, LayoutVertex, LayoutNetwork, 'addVertex:vertex');
  this.vertexes.add(vertex);
  var n = vertex.node;
  if (n !== null) {
    this.nodeToVertexMap.add(n, vertex);
  }
  vertex.network = this;
};

LayoutNetwork.prototype['addNode'] =
/**
* This convenience method makes sure there is a {@link LayoutVertex}
* in this network corresponding to a {@link Node}.
* @this {LayoutNetwork}
* @param {Node} node
* @return {LayoutVertex} a vertex in this network.
*/
LayoutNetwork.prototype.addNode = function(node) {
  if (node === null) return null;
  if (Debug) Util.checkClass(node, Node, LayoutNetwork, 'addNode:node');
  var lnode = this.findVertex(node);
  if (lnode === null) {
    lnode = this.createVertex();
    lnode.node = node;
    this.addVertex(lnode);
  }
  return lnode;
};

LayoutNetwork.prototype['deleteVertex'] =
/**
* Removes a {@link LayoutVertex} from the network.
* This function also deletes all edges to or from the vertex.
* @this {LayoutNetwork}
* @param {LayoutVertex} vertex
*/
LayoutNetwork.prototype.deleteVertex = function(vertex) {
  if (vertex === null) return;
  if (Debug) Util.checkClass(vertex, LayoutVertex, LayoutNetwork, 'deleteVertex:vertex');
  // Find the node in the network and remove.
  if (this._removeVertex(vertex)) {
    // Delete all links from predecessors of the node.
    var a = vertex.sourceEdgesList;
    for (var i = a.count - 1; i >= 0; i--) {
      var link = a.elt(i);
      this.deleteEdge(link);
    }

    // Delete all links to successors of the node.
    a = vertex.destinationEdgesList;
    for (var i = a.count - 1; i >= 0; i--) {
      var link = a.elt(i);
      this.deleteEdge(link);
    }
  }
};

/**
* @ignore
* @this {LayoutNetwork}
* @param {LayoutVertex} vertex
* @return {boolean}
*/
LayoutNetwork.prototype._removeVertex = function(vertex) {
  if (vertex === null) return false;

  var result = this.vertexes.remove(vertex);
  if (result) {
    var node = vertex.node;
    this.nodeToVertexMap.remove(node);
    vertex.network = null;
  }
  return result;
};

LayoutNetwork.prototype['deleteNode'] =
/**
* This convenience method deletes any {@link LayoutVertex}
* corresponding to a {@link Node}.
* @this {LayoutNetwork}
* @param {Node} node
*/
LayoutNetwork.prototype.deleteNode = function(node) {
  if (node === null) return;
  if (Debug) Util.checkClass(node, Node, LayoutNetwork, 'deleteNode:node');
  var lnode = this.findVertex(node);
  if (lnode !== null) {
    this.deleteVertex(lnode);
  }
};

LayoutNetwork.prototype['findVertex'] =
/**
* Returns the {@link LayoutVertex} that was constructed for the {@link Node}.
* @this {LayoutNetwork}
* @param {Node} node
* @return {LayoutVertex} a vertex in this network, or null if no such vertex exists.
*/
LayoutNetwork.prototype.findVertex = function(node) {
  if (node === null) return null;
  if (Debug) Util.checkClass(node, Node, LayoutNetwork, 'findVertex:node');
  var vertex = this.nodeToVertexMap.getValue(node);
  return vertex;
};

LayoutNetwork.prototype['addEdge'] =
/**
* Adds a {@link LayoutEdge} to the network.
* Although this method is provided for completeness,
* {@link #linkVertexes} provides a more efficient manner of linking
* vertexes already in the network.
* @this {LayoutNetwork}
* @param {LayoutEdge} edge
*/
LayoutNetwork.prototype.addEdge = function(edge) {
  if (edge === null) return;
  if (Debug) Util.checkClass(edge, LayoutEdge, LayoutNetwork, 'addEdge:edge');
  this.edges.add(edge);
  var link = edge.link;
  if (link !== null && this.findEdge(link) === null) {
    this.linkToEdgeMap.add(link, edge);
  }

  var toNode = edge.toVertex;
  if (toNode !== null)
    toNode.addSourceEdge(edge);

  var fromNode = edge.fromVertex;
  if (fromNode !== null)
    fromNode.addDestinationEdge(edge);

  edge.network = this;
};

LayoutNetwork.prototype['addLink'] =
/**
* This convenience method makes sure there is a {@link LayoutEdge}
* in this network corresponding to a {@link Link}.
* If {@link #findEdge} returns null, this method creates a new {@link LayoutEdge},
* makes sure the {@link Link#fromNode} and {@link Link#toNode} have
* corresponding {@link LayoutVertex}es in the network, and adds the edge itself
* to the network.
* @this {LayoutNetwork}
* @param {Link} link
* @return {LayoutEdge} an edge in this network.
*/
LayoutNetwork.prototype.addLink = function(link) {
  if (link === null) return null;
  if (Debug) Util.checkClass(link, Link, LayoutNetwork, 'addLink:link');
  var fromNode = link.fromNode;
  var toNode = link.toNode;
  var edge = this.findEdge(link);
  if (edge === null) {
    edge = this.createEdge();
    edge.link = link;

    if (fromNode !== null) {
      edge.fromVertex = this.addNode(fromNode);
    }

    if (toNode !== null) {
      edge.toVertex = this.addNode(toNode);
    }

    this.addEdge(edge);
  } else {
    if (fromNode !== null) {
      edge.fromVertex = this.addNode(fromNode);
    } else {
      edge.fromVertex = null;
    }

    if (toNode !== null) {
      edge.toVertex = this.addNode(toNode);
    } else {
      edge.toVertex = null;
    }
  }
  return edge;
};

LayoutNetwork.prototype['deleteEdge'] =
/**
* Removes a {@link LayoutEdge} from the network.
* @this {LayoutNetwork}
* @param {LayoutEdge} edge
*/
LayoutNetwork.prototype.deleteEdge = function(edge) {
  if (edge === null) return;
  if (Debug) Util.checkClass(edge, LayoutEdge, LayoutNetwork, 'deleteEdge:edge');

  // Remove the link from its to node's predecessor list.
  var toNode = edge.toVertex;
  if (toNode !== null)
    toNode.deleteSourceEdge(edge);

  // Remove the link from its from node's successor list.
  var fromNode = edge.fromVertex;
  if (fromNode !== null)
    fromNode.deleteDestinationEdge(edge);

  this._removeEdge(edge);
};

/**
* @ignore
* @this {LayoutNetwork}
* @param {LayoutEdge} edge
* @return {boolean}
*/
LayoutNetwork.prototype._removeEdge = function(edge) {
  if (edge === null) return false;

  // Find the link in the network and remove.
  var result = this.edges.remove(edge);
  if (result) {
    var link = edge.link;
    this.linkToEdgeMap.remove(link);
    edge.network = null;
  }
  return result;
};

LayoutNetwork.prototype['deleteLink'] =
/**
* This convenience method deletes from this network any {@link LayoutEdge}
* corresponding to a {@link Link}.
* @this {LayoutNetwork}
* @param {Link} link
*/
LayoutNetwork.prototype.deleteLink = function(link) {
  if (link === null) return;
  if (Debug) Util.checkClass(link, Link, LayoutNetwork, 'deleteLink:link');
  var llink = this.findEdge(link);
  if (llink !== null) {
    this.deleteEdge(llink);
  }
};


LayoutNetwork.prototype['findEdge'] =
/**
* Returns the {@link LayoutEdge} that was constructed for the {@link Link}.
* @this {LayoutNetwork}
* @param {Link} link
* @return {LayoutEdge} an edge in this network, or null if no such edge exists.
*/
LayoutNetwork.prototype.findEdge = function(link) {
  if (link === null) return null;
  if (Debug) Util.checkClass(link, Link, LayoutNetwork, 'findEdge:link');
  var edge = this.linkToEdgeMap.getValue(link);
  return edge;
};


LayoutNetwork.prototype['linkVertexes'] =
/**
* Links two vertexes already in the network and returns the created {@link LayoutEdge}.
* @this {LayoutNetwork}
* @param {LayoutVertex} fromVertex
* @param {LayoutVertex} toVertex
* @param {Link} link
* @return {LayoutEdge} an edge in this network, or null if both vertexes don't exist.
*/
LayoutNetwork.prototype.linkVertexes = function(fromVertex, toVertex, link) {
  if (fromVertex === null || toVertex === null) return null;
  if (Debug) {
    Util.checkClass(fromVertex, LayoutVertex, LayoutNetwork, 'linkVertexes:fromVertex');
    Util.checkClass(toVertex, LayoutVertex, LayoutNetwork, 'linkVertexes:toVertex');
    if (link !== null) Util.checkClass(link, Link, LayoutNetwork, 'linkVertexes:link');
  }
  // Verify that the from and to nodes are in the network.
  if (fromVertex.network === this && toVertex.network === this) {
    var pNetworkLink = this.createEdge();
    pNetworkLink.link = link;
    pNetworkLink.fromVertex = fromVertex;
    pNetworkLink.toVertex = toVertex;
    this.addEdge(pNetworkLink);
    return pNetworkLink;
  }
  return null;
};


LayoutNetwork.prototype['reverseEdge'] =
/**
* Reverses the direction of a {@link LayoutEdge} in the network.
* @this {LayoutNetwork}
* @param {LayoutEdge} edge
*/
LayoutNetwork.prototype.reverseEdge = function(edge) {
  if (edge === null) return;
  if (Debug) Util.checkClass(edge, LayoutEdge, LayoutNetwork, 'reverseEdge:edge');
  var fromNode = edge.fromVertex;
  var toNode = edge.toVertex;

  if (fromNode === null || toNode === null) return;

  fromNode.deleteDestinationEdge(edge);
  toNode.deleteSourceEdge(edge);

  edge.reverseEdge();

  fromNode.addSourceEdge(edge);
  toNode.addDestinationEdge(edge);
};


LayoutNetwork.prototype['deleteSelfEdges'] =
/**
* Deletes all {@link LayoutEdge}s whose "to vertex" and "from vertex" are the same vertex.
* @this {LayoutNetwork}
*/
LayoutNetwork.prototype.deleteSelfEdges = function() {
  var deleteList = Util.tempArray();
  var it = this.edges.iterator;
  while (it.next()) {
    var link = it.value;
    if (link.fromVertex === link.toVertex) {
      deleteList.push(link);
    }
  }
  var len = deleteList.length;
  for (var i = 0; i < len; i++) {
    this.deleteEdge(deleteList[i]);
  }
  Util.freeArray(deleteList);
};

LayoutNetwork.prototype['deleteArtificialVertexes'] =
/**
* Deletes all vertexes and edges that have no {@link Part} associated with them.
* @this {LayoutNetwork}
*/
LayoutNetwork.prototype.deleteArtificialVertexes = function() {
  var dummies = Util.tempArray();
  var it = this.vertexes.iterator;
  while (it.next()) {
    var v = it.value;
    if (v.node === null)
      dummies.push(v);
  }
  var len = dummies.length;
  for (var i = 0; i < len; i++) {
    this.deleteVertex(dummies[i]);
  }
  var dummies2 = Util.tempArray();
  it = this.edges.iterator;
  while (it.next()) {
    var e = it.value;
    if (e.link === null)
      dummies2.push(e);
  }
  var len2 = dummies2.length;
  for (var i = 0; i < len2; i++) {
    this.deleteEdge(dummies2[i]);
  }
  Util.freeArray(dummies);
  Util.freeArray(dummies2);
};

/**
* @ignore
* @this {LayoutNetwork}
*/
LayoutNetwork.prototype.deleteUselessEdges = function() {
  var deleteList = Util.tempArray();
  var it = this.edges.iterator;
  while (it.next()) {
    var link = it.value;
    if (link.fromVertex === null || link.toVertex === null) {
      deleteList.push(link);
    }
  }
  var len = deleteList.length;
  for (var i = 0; i < len; i++) {
    this.deleteEdge(deleteList[i]);
  }
  Util.freeArray(deleteList);
};

/**
* @ignore
* @this {LayoutNetwork}
* @param {LayoutVertex} v
* @return {boolean}
*/
LayoutNetwork.prototype.isSingleton = function(v) {
  if (v.sourceEdgesList.count > 0) return false;
  if (v.destinationEdgesList.count > 0) return false;
  return true;
};

LayoutNetwork.prototype['splitIntoSubNetworks'] =
/**
* Modify this network by splitting it up into separate subnetworks,
* each of which has all of its vertexes connected to each other, but not
* to any vertexes in any other subnetworks.
* <p/>
* This method will first delete from this network all artificial vertexes and
* all edges that do not connect two different vertexes.
* Afterwards, this original network may be empty or may contain all of the
* singleton vertexes, each of which had no edges connecting it to any other vertexes.
* @this {LayoutNetwork}
* @return {List} a collection of {@link LayoutNetworks},
* sorted in order of decreasing vertex count.
*/
LayoutNetwork.prototype.splitIntoSubNetworks = function() {
  this.deleteArtificialVertexes();
  this.deleteUselessEdges();
  this.deleteSelfEdges();
  var nets = new List(LayoutNetwork);
  var found = true;
  while (found) {
    found = false;
    var it = this.vertexes.iterator;
    while (it.next()) {
      var n = it.value;
      if (this.isSingleton(n)) continue;
      var net = this.layout.createNetwork();
      nets.add(net);
      this._traverseSubnet(net, n);
      found = true;  // start over again with all nodes
      break;
    }
  }
  nets.sort(function(a, b) {
    if (a === null || b === null || a === b) return 0;
    return b.vertexes.count - a.vertexes.count;
  });
  return nets;
};

/**
* @ignore
* @this {LayoutNetwork}
* @param {LayoutNetwork} net
* @param {LayoutVertex} n
*/
LayoutNetwork.prototype._traverseSubnet = function(net, n) {
  if (n === null) return;
  if (n.network === net) return;
  this._removeVertex(n);
  net.addVertex(n);
  var it = n.sourceEdges;
  while (it.next()) {
    var link = it.value;
    if (link.network === net) continue;
    this._removeEdge(link);
    net.addEdge(link);
    this._traverseSubnet(net, link.fromVertex);
  }
  it = n.destinationEdges;
  while (it.next()) {
    var link = it.value;
    if (link.network === net) continue;
    this._removeEdge(link);
    net.addEdge(link);
    this._traverseSubnet(net, link.toVertex);
  }
};


LayoutNetwork.prototype['getParts'] =  //??? keep for compatibility
LayoutNetwork.prototype['findAllParts'] =
/**
* Retrieve all of the {@link Node}s and {@link Link}s from the
* {@link LayoutVertex}es and {@link LayoutEdge}s that are in this network.
* @this {LayoutNetwork}
* @return {Set} A collection of {@link Part}s.
* @since 1.1
*/
LayoutNetwork.prototype.findAllParts = function() {
  var coll = new Set(Part);
  var it = this.vertexes.iterator;
  while (it.next()) {
    var v = it.value;
    coll.add(v.node);
  }
  it = this.edges.iterator;
  while (it.next()) {
    var e = it.value;
    coll.add(e.link);
  }
  return coll;
};


/**
 * This constructs a vertex that does not know about any {@link Node}.
 * @constructor
 * @category Layout
 * @class
 * A vertex represents a node in a {@link LayoutNetwork}.
 * It holds layout-specific data for the node.
 * <p/>
 * Modifying a {@link LayoutNetwork} or a {@link LayoutVertex} or a {@link LayoutEdge} does not
 * invalidate the {@link Layout} or raise any changed events.
 */
function LayoutVertex() {
  Util.uniqueHash(this);

  /**
  * Gets or sets the {@link LayoutNetwork} that owns this vertex.
  * The default value is null.
  * It is set automatically for you in {@link LayoutNetwork#addVertex}.
  * @name LayoutVertex#network
  * @function.
  * @return {LayoutNetwork}
  */
  /** @expose @type {LayoutNetwork} */
  this.network = null;

  // these are not exposed because the property setters need to displace the coordinate values
  /** @type {Rect} */
  this._bounds = new Rect(0, 0, 10, 10).freeze();
  /** @type {Point} */
  this._focus = new Point(5, 5).freeze();
  this.clear();
}

Util.publish('LayoutVertex', LayoutVertex);

/**
* @ignore
* Remove all references to other objects, besides the owner network.
* @this {LayoutVertex}
*/
LayoutVertex.prototype.clear = function() {
  // this is not exposed because the property setter needs to initialize the other properties
  /** @type {Node} */
  this._node = null;

  // internal state
  /** @ignore @type {List} */
  this.sourceEdgesList = new List(LayoutEdge);
  /** @ignore @type {List} */
  this.destinationEdgesList = new List(LayoutEdge);
};

/**
* @ignore
* @this {LayoutVertex}
* @return {string}
*/
LayoutVertex.prototype.toString = function() {
  return 'LayoutVertex#' + Util.hashId(this) + (this.node !== null ? '(' + this.node.toString() + ')' : '');
};


/**
* Gets or sets the {@link Node} associated with this vertex, if any.
* The value may be null if this vertex is a "dummy" vertex,
* not represented by a real {@link Node} in the {@link Diagram}.
* @name LayoutVertex#node
* @function.
* @return {Node}
*/
/** @type {Node} */
LayoutVertex.prototype.node;
Util.exportProperty(LayoutVertex, 'node', LayoutVertex.prototype.node);
Util.defineProperty(LayoutVertex, { node: 'node' },
  /** @this {LayoutVertex} */
  function() { return this._node; },
  /** @this {LayoutVertex} */
  function(val) {
    var old = this._node;
    if (old !== val) {
      if (Debug && val !== null) Util.checkClass(val, Node, LayoutVertex, 'node');
      this._node = val;
      // make sure the width and height are known
      val.ensureBounds();
      var ab = val.actualBounds;
      var x = ab.x;
      var y = ab.y;
      var w = ab.width;
      var h = ab.height;
      // use zero if the position is not known
      if (isNaN(x)) x = 0;
      if (isNaN(y)) y = 0;
      this._bounds._set(x, y, w, h);
      // focus should be middle of locationObject
      var locelt = val.locationObject;
      if (locelt !== val && !(val instanceof Group)) {
        var locab = locelt.actualBounds;
        this._focus._set(locab.x + locab.width / 2, locab.y + locab.height / 2);
      } else {  // but defaults to just the center of the node
        this._focus._set(w / 2, h / 2);
      }
    }
  }
);


/**
* Gets or sets the Bounds of this vertex, in document coordinates.
* Setting this property does not modify the position of any {@link Node},
* but it will modify the value of {@link #centerX} and {@link #centerY}.
* @name LayoutVertex#bounds
* @function.
* @return {Rect}
*/
/** @type {Rect} */
LayoutVertex.prototype.bounds;
Util.exportProperty(LayoutVertex, 'bounds', LayoutVertex.prototype.bounds);
Util.defineProperty(LayoutVertex, { bounds: 'bounds' },
  /** @this {LayoutVertex} */
  function() { return this._bounds; },
  /** @this {LayoutVertex} */
  function(val) {
    var old = this._bounds;
    if (!old.equals(val)) {
      if (Debug) Util.checkClass(val, Rect, LayoutVertex, 'bounds');
      this._bounds.assign(val);
    }
  }
);

/**
* Gets or sets the offset of the {@link #centerX} and {@link #centerY}
* from the {@link #bounds} position.
* Setting this property does not modify the position of any {@link Node},
* but it does affect the value of {@link #centerX} and {@link #centerY}.
* @name LayoutVertex#focus
* @function.
* @return {Point}
*/
/** @type {Point} */
LayoutVertex.prototype.focus;
Util.exportProperty(LayoutVertex, 'focus', LayoutVertex.prototype.focus);
Util.defineProperty(LayoutVertex, { focus: 'focus' },
  /** @this {LayoutVertex} */
  function() { return this._focus; },
  /** @this {LayoutVertex} */
  function(val) {
    var old = this._focus;
    if (!old.equals(val)) {
      if (Debug) Util.checkClass(val, Point, LayoutVertex, 'focus');
      this._focus.assign(val);
    }
  }
);

/**
* Gets or sets the center Point.x of this vertex, in document coordinates.
* This property depends on both {@link #bounds} and {@link #focus}.
* Setting this property does not modify the position of any {@link Node},
* but it will modify the value of {@link #bounds}.
* @name LayoutVertex#centerX
* @function.
* @return {number}
*/
/** @type {number} */
LayoutVertex.prototype.centerX;
Util.exportProperty(LayoutVertex, 'centerX', LayoutVertex.prototype.centerX);
Util.defineProperty(LayoutVertex, { centerX: 'centerX' },
  /** @this {LayoutVertex} */
  function() { return this._bounds.x + this._focus.x; },
  /** @this {LayoutVertex} */
  function(val) {
    var b = this._bounds;
    var old = b.x + this._focus.x;
    if (old !== val) {
      if (Debug) Util.checkRealNumber(val, LayoutVertex, 'centerX');
      b.thaw();
      b.x = val - this._focus.x;
      b.freeze();
    }
  }
);

/**
* Gets or sets the center Point.y of this vertex, in document coordinates.
* This property depends on both {@link #bounds} and {@link #focus}.
* Setting this property does not modify the position of any {@link Node},
* but it will modify the value of {@link #bounds}.
* @name LayoutVertex#centerY
* @function.
* @return {number}
*/
/** @type {number} */
LayoutVertex.prototype.centerY;
Util.exportProperty(LayoutVertex, 'centerY', LayoutVertex.prototype.centerY);
Util.defineProperty(LayoutVertex, { centerY: 'centerY' },
  /** @this {LayoutVertex} */
  function() { return this._bounds.y + this._focus.y; },
  /** @this {LayoutVertex} */
  function(val) {
    var b = this._bounds;
    var old = b.y + this._focus.y;
    if (old !== val) {
      if (Debug) Util.checkRealNumber(val, LayoutVertex, 'centerY');
      b.thaw();
      b.y = val - this._focus.y;
      b.freeze();
    }
  }
);

/**
* Gets or sets the relative X position of the "center" point, the focus.
* @name LayoutVertex#focusX
* @function.
* @return {number}
*/
/** @type {number} */
LayoutVertex.prototype.focusX;
Util.exportProperty(LayoutVertex, 'focusX', LayoutVertex.prototype.focusX);
Util.defineProperty(LayoutVertex, { focusX: 'focusX' },
  /** @this {LayoutVertex} */
  function() { return this._focus.x; },
  /** @this {LayoutVertex} */
  function(val) {
    var p = this._focus;
    var old = p.x;
    if (old !== val) {
      p.thaw();
      p.x = val;
      p.freeze();
    }
  }
);

/**
* Gets or sets the relative Y position of the "center" point, the focus.
* @name LayoutVertex#focusY
* @function.
* @return {number}
*/
/** @type {number} */
LayoutVertex.prototype.focusY;
Util.exportProperty(LayoutVertex, 'focusY', LayoutVertex.prototype.focusY);
Util.defineProperty(LayoutVertex, { focusY: 'focusY' },
  /** @this {LayoutVertex} */
  function() { return this._focus.y; },
  /** @this {LayoutVertex} */
  function(val) {
    var p = this._focus;
    var old = p.y;
    if (old !== val) {
      p.thaw();
      p.y = val;
      p.freeze();
    }
  }
);

/**
* Gets or sets the left point of this vertex.
* @name LayoutVertex#x
* @function.
* @return {number}
*/
/** @type {number} */
LayoutVertex.prototype.x;
Util.exportProperty(LayoutVertex, 'x', LayoutVertex.prototype.x);
Util.defineProperty(LayoutVertex, { x: 'x' },
  /** @this {LayoutVertex} */
  function() { return this._bounds.x; },
  /** @this {LayoutVertex} */
  function(val) {
    var b = this._bounds;
    var old = b.x;
    if (old !== val) {
      b.thaw();
      b.x = val;
      b.freeze();
    }
  }
);

/**
* Gets or sets the top point of this vertex.
* @name LayoutVertex#y
* @function.
* @return {number}
*/
/** @type {number} */
LayoutVertex.prototype.y;
Util.exportProperty(LayoutVertex, 'y', LayoutVertex.prototype.y);
Util.defineProperty(LayoutVertex, { y: 'y' },
  /** @this {LayoutVertex} */
  function() { return this._bounds.y; },
  /** @this {LayoutVertex} */
  function(val) {
    var b = this._bounds;
    var old = b.y;
    if (old !== val) {
      b.thaw();
      b.y = val;
      b.freeze();
    }
  }
);

/**
* Gets or sets the width of this vertex.
* This is always the horizontal distance reserved for the node.
* @name LayoutVertex#width
* @function.
* @return {number}
*/
/** @type {number} */
LayoutVertex.prototype.width;
Util.exportProperty(LayoutVertex, 'width', LayoutVertex.prototype.width);
Util.defineProperty(LayoutVertex, { width: 'width' },
  /** @this {LayoutVertex} */
  function() { return this._bounds.width; },
  /** @this {LayoutVertex} */
  function(val) {
    var b = this._bounds;
    var old = b.width;
    if (old !== val) {
      b.thaw();
      b.width = val;
      b.freeze();
    }
  }
);

/**
* Gets or sets the height of this vertex.
* This is always the vertical distance reserved for the node.
* @name LayoutVertex#height
* @function.
* @return {number}
*/
/** @type {number} */
LayoutVertex.prototype.height;
Util.exportProperty(LayoutVertex, 'height', LayoutVertex.prototype.height);
Util.defineProperty(LayoutVertex, { height: 'height' },
  /** @this {LayoutVertex} */
  function() { return this._bounds.height; },
  /** @this {LayoutVertex} */
  function(val) {
    var b = this._bounds;
    var old = b.height;
    if (old !== val) {
      b.thaw();
      b.height = val;
      b.freeze();
    }
  }
);


/**
* Moves the {@link Node} corresponding to this vertex
* so that its position is at the current {@link #bounds} point.
* <p/>
* To make the most common cases look right, the Node's {@link Part#locationObject}
* is centered.  Thus iconic nodes will have the center of the icon be positioned
* according to the center of this vertex, ignoring any labels.
* @expose
* @this {LayoutVertex}
*/
LayoutVertex.prototype.commit = function() {
  var node = this.node;
  if (node !== null) {
    var b = this.bounds;
    node.moveTo(b.x, b.y);  /*??? , true */
  }
};


LayoutVertex.prototype['addSourceEdge'] =
/**
* Adds a {@link LayoutEdge} to the list of predecessors
* (the edge will be coming into this vertex).
* Calling this method does not modify the {@link LayoutEdge#toVertex} of the LayoutEdge.
* @this {LayoutVertex}
* @param {LayoutEdge} edge
*/
LayoutVertex.prototype.addSourceEdge = function(edge) {
  if (edge === null) return;
  if (Debug) Util.checkClass(edge, LayoutEdge, LayoutVertex, 'addSourceEdge:edge');
  if (!this.sourceEdgesList.contains(edge)) {
    this.sourceEdgesList.add(edge);
  }
};

LayoutVertex.prototype['deleteSourceEdge'] =
/**
* Deletes a {@link LayoutEdge} from the list of predecessors
* (the edge was coming into this vertex).
* Calling this method does not modify the {@link LayoutEdge#toVertex} of the LayoutEdge.
* @this {LayoutVertex}
* @param {LayoutEdge} edge
*/
LayoutVertex.prototype.deleteSourceEdge = function(edge) {
  if (edge === null) return;
  if (Debug) Util.checkClass(edge, LayoutEdge, LayoutVertex, 'deleteSourceEdge:edge');
  this.sourceEdgesList.remove(edge);
};


LayoutVertex.prototype['addDestinationEdge'] =
/**
* Adds a {@link LayoutEdge} to the list of successors
* (the edge will be going out from this vertex).
* Calling this method does not modify the {@link LayoutEdge#fromVertex} of the LayoutEdge.
* @this {LayoutVertex}
* @param {LayoutEdge} edge
*/
LayoutVertex.prototype.addDestinationEdge = function(edge) {
  if (edge === null) return;
  if (Debug) Util.checkClass(edge, LayoutEdge, LayoutVertex, 'addDestinationEdge:edge');
  if (!this.destinationEdgesList.contains(edge)) {
    this.destinationEdgesList.add(edge);
  }
};

LayoutVertex.prototype['deleteDestinationEdge'] =
/**
* Deletes a {@link LayoutEdge} from the list of successors
* (the edge was going out from this vertex).
* Calling this method does not modify the {@link LayoutEdge#fromVertex} of the LayoutEdge.
* @this {LayoutVertex}
* @param {LayoutEdge} edge
*/
LayoutVertex.prototype.deleteDestinationEdge = function(edge) {
  if (edge === null) return;
  if (Debug) Util.checkClass(edge, LayoutEdge, LayoutVertex, 'deleteDestinationEdge:edge');
  this.destinationEdgesList.remove(edge);
};


/**
* Gets an iterator for all of the vertexes that are connected with edges coming into this vertex.
* @name LayoutVertex#sourceVertexes
* @function.
* @return {Iterator}
*/
/** @type {Iterator} */
LayoutVertex.prototype.sourceVertexes;
Util.defineReadOnlyProperty(LayoutVertex, { sourceVertexes: 'sourceVertexes' },
  /** @this {LayoutVertex} */
  function() {
    var a = new Set(LayoutVertex);
    var it = this.sourceEdges;
    while (it.next()) {
      var l = it.value;
      var n = l.fromVertex;
      if (n !== null && !a.contains(n)) {
        a.add(n);
      }
    }
    return a.iterator;
  }
);

/**
* Gets an iterator for all of the vertexes that are connected with edges going out of this vertex.
* @name LayoutVertex#destinationVertexes
* @function.
* @return {Iterator}
*/
/** @type {Iterator} */
LayoutVertex.prototype.destinationVertexes;
Util.defineReadOnlyProperty(LayoutVertex, { destinationVertexes: 'destinationVertexes' },
  /** @this {LayoutVertex} */
  function() {
    var a = new Set(LayoutVertex);
    var it = this.destinationEdges;
    while (it.next()) {
      var l = it.value;
      var n = l.toVertex;
      if (n !== null && !a.contains(n)) {
        a.add(n);
      }
    }
    return a.iterator;
  }
);

/**
* Gets an iterator for all of the vertexes that are connected in either direction with this vertex.
* @name LayoutVertex#vertexes
* @function.
* @return {Iterator}
*/
/** @type {Iterator} */
LayoutVertex.prototype.vertexes;
Util.defineReadOnlyProperty(LayoutVertex, { vertexes: 'vertexes' },
  /** @this {LayoutVertex} */
  function() {
    var a = new Set(LayoutVertex);
    var it = this.sourceEdges;
    while (it.next()) {
      var l = it.value;
      var n = l.fromVertex;
      if (n !== null && !a.contains(n)) {
        a.add(n);
      }
    }
    it = this.destinationEdges;
    while (it.next()) {
      var l = it.value;
      var n = l.toVertex;
      if (n !== null && !a.contains(n)) {
        a.add(n);
      }
    }
    return a.iterator;
  }
);

/**
* Gets an iterator for all of the edges that come into this vertex.
* @name LayoutVertex#sourceEdges
* @function.
* @return {Iterator}
*/
/** @type {Iterator} */
LayoutVertex.prototype.sourceEdges;
Util.defineReadOnlyProperty(LayoutVertex, { sourceEdges: 'sourceEdges' },
  /** @this {LayoutVertex} */
  function() { return this.sourceEdgesList.iterator; }
);

/**
* Gets an iterator for all of the edges that go out of this vertex.
* @name LayoutVertex#destinationEdges
* @function.
* @return {Iterator}
*/
/** @type {Iterator} */
LayoutVertex.prototype.destinationEdges;
Util.defineReadOnlyProperty(LayoutVertex, { destinationEdges: 'destinationEdges' },
  /** @this {LayoutVertex} */
  function() { return this.destinationEdgesList.iterator; }
);

/**
* Gets an iterator for all of the edges that are connected with this vertex in either direction.
* @name LayoutVertex#edges
* @function.
* @return {Iterator}
*/
/** @type {Iterator} */
LayoutVertex.prototype.edges;
Util.defineReadOnlyProperty(LayoutVertex, { edges: 'edges' },
  /** @this {LayoutVertex} */
  function() {
    var a = new List(LayoutEdge);
    var it = this.sourceEdges;
    while (it.next()) {
      var e = it.value;
      a.add(e);
    }
    it = this.destinationEdges;
    while (it.next()) {
      var e = it.value;
      a.add(e);
    }
    return a.iterator;
  }
);

/**
* Gets the total number of edges that are connected with this vertex in either direction.
* @name LayoutVertex#edgesCount
* @function.
* @return {number}
*/
/** @type {number} */
LayoutVertex.prototype.edgesCount;
Util.defineReadOnlyProperty(LayoutVertex, { edgesCount: 'edgesCount' },
  /** @this {LayoutVertex} */
  function() {
    return this.sourceEdgesList.count + this.destinationEdgesList.count;
  }
);

LayoutVertex['standardComparer'] =
/**
* This static method is used to compare the {@link Part#text} values of the {@link #node}s of
* the argument {@link LayoutVertex}es.
* This just does a simple case-sensitive string comparison.
* Alternatively you may wish to use {@link LayoutVertex.smartComparer} or write your own comparison function.
* @param {LayoutVertex} m
* @param {LayoutVertex} n
* @return {number} -1, 0, or 1, depending on whether the comparison between M and N is less than, equal, or greater than.
*/
LayoutVertex.standardComparer = function(m, n) {
  if (Debug) Util.checkClass(m, LayoutVertex, LayoutVertex, 'standardComparer:m');
  if (Debug) Util.checkClass(n, LayoutVertex, LayoutVertex, 'standardComparer:n');
  var a = m._node;
  var b = n._node;
  if (a) {
    if (b) {
      var at = a.text;
      var bt = b.text;
      if (at < bt) return -1;
      if (at > bt) return 1;
      return 0;
    } else {
      return 1;
    }
  } else {
    if (b !== null)
      return -1;
    else
      return 0;
  }
};

LayoutVertex['smartComparer'] =
/**
* This static method is used to compare the {@link Part#text} values of the {@link #node}s of
* the argument {@link LayoutVertex}es.
* If the text ends in a number, the values are compared as numbers rather than lexicographically.
* Naturally this comparison is significantly slower than {@link LayoutVertex.standardComparer}.
* @param {LayoutVertex} m
* @param {LayoutVertex} n
* @return {number} -1, 0, or 1, depending on whether the comparison between M and N is less than, equal, or greater than.
*/
LayoutVertex.smartComparer = function(m, n) {
  if (Debug) Util.checkClass(m, LayoutVertex, LayoutVertex, 'smartComparer:m');
  if (Debug) Util.checkClass(n, LayoutVertex, LayoutVertex, 'smartComparer:n');
  if (m !== null) {
    if (n !== null) {
      var a = m._node;
      var b = n._node;
      if (a !== null) {
        if (b !== null) {
          var aLower = a.text.toLocaleLowerCase();
          var bLower = b.text.toLocaleLowerCase();
          // split the string, separating numbers
          var aSplit = aLower.split(/([+\-]?[\.]?\d+(?:\.\d*)?(?:e[+\-]?\d+)?)/);
          var bSplit = bLower.split(/([+\-]?[\.]?\d+(?:\.\d*)?(?:e[+\-]?\d+)?)/);
          var i;
          for (i = 0; i < aSplit.length; i++) {
            if (bSplit[i] !== '' && bSplit[i] !== undefined) {
              var aCurrentNum = parseFloat(aSplit[i]);
              var bCurrentNum = parseFloat(bSplit[i]);
              if (!isNaN(aCurrentNum)) {
                if (!isNaN(bCurrentNum)) {
                  // both numbers
                  if (aCurrentNum - bCurrentNum !== 0) {
                    return aCurrentNum - bCurrentNum;
                  } else {
                    // same number, move to next element
                    continue;
                  }
                } else {
                  // aSplit[i] is a number, bSplit[i] is NaN
                  return -1;
                }
              } else {
                if (!isNaN(bCurrentNum)) {
                  // aSplit[i] is NaN, bSplit[i] is a number
                  return 1;
                } else {
                  //both strings
                  if (aSplit[i].localeCompare(bSplit[i]) !== 0) {
                    return aSplit[i].localeCompare(bSplit[i]);
                  } else {
                    // same string, move to next element
                    continue;
                  }
                }
              }
            } else {
              // bSplit[i] is either "" or undefined
              if (aSplit[i] === '') continue;
              else return 1;
            }
          }
          // i is now aSplit.length
          if (bSplit[i] !== '' && bSplit[i] !== undefined) return -1;
          else return 0;
        } else {
          return 1;
        }
      } else {
        if (b !== null)
          return -1;
        else
          return 0;
      }
    } else {
      return 1;
    }
  } else {
    if (n !== null)
      return -1;
    else
      return 0;
  }
};

/**
 * This constructs an edge that does not know about any {@link Link}.
 * @constructor
 * @category Layout
 * @class
 * An edge represents a link in a {@link LayoutNetwork}.
 * It holds layout-specific data for the link.
 * <p/>
 * Modifying a {@link LayoutNetwork} or a {@link LayoutVertex} or a {@link LayoutEdge} does not
 * invalidate the {@link Layout} or raise any changed events.
 */
function LayoutEdge() {
  Util.uniqueHash(this);

  /**
  * Gets or sets the {@link LayoutNetwork} that owns this edge.
  * The default value is null.
  * It is set automatically for you in {@link LayoutNetwork#addEdge}.
  * @name LayoutEdge#network
  * @function.
  * @return {LayoutNetwork}
  */
  /** @expose @type {LayoutNetwork} */
  this.network = null;
  this.clear();
}

Util.publish('LayoutEdge', LayoutEdge);

/**
* @ignore
* Remove all references to other objects, besides the owner network.
* @this {LayoutEdge}
*/
LayoutEdge.prototype.clear = function() {

  /**
  * Gets or sets the {@link Link} associated with this edge, if any.
  * The value may be null if this edge is a "dummy" edge,
  * not represented by a real {@link Link} in the {@link Diagram}.
  * @name LayoutEdge#link
  * @function.
  * @return {Link}
  */
  /** @expose @type {Link} */
  this.link = null;

  /**
  * Gets or sets the {@link LayoutVertex} that this edge comes from.
  * Setting this property does not change any {@link LayoutVertex#destinationEdges} collection.
  * @name LayoutEdge#fromVertex
  * @function.
  * @return {LayoutVertex}
  */
  /** @expose @type {LayoutVertex} */
  this.fromVertex = null;

  /**
  * Gets or sets the {@link LayoutVertex} that this edge goes to.
  * Setting this property does not change any {@link LayoutVertex#sourceEdges} collection.
  * @name LayoutEdge#toVertex
  * @function.
  * @return {LayoutVertex}
  */
  /** @expose @type {LayoutVertex} */
  this.toVertex = null;
};

/**
* @ignore
* @this {LayoutEdge}
* @return {string}
*/
LayoutEdge.prototype.toString = function() {
  return 'LayoutEdge#' + Util.hashId(this) + (this.link !== null ? '(' + this.link.toString() + ')' : '');
};

/**
* @ignore
* @this {LayoutEdge}
*/
LayoutEdge.prototype.reverseEdge = function() {
  var temp = this.fromVertex;
  this.fromVertex = this.toVertex;
  this.toVertex = temp;
};

/**
* Commits the route of this edge to the corresponding {@link Link}, if any.
* By default this does nothing.
* @expose
* @this {LayoutEdge}
*/
LayoutEdge.prototype.commit = function() {
};

LayoutEdge.prototype['getOtherVertex'] =
/**
* Returns the edge's vertex at the other of this edge from the given vertex.
* @this {LayoutEdge}
* @param {LayoutVertex} v
*/
LayoutEdge.prototype.getOtherVertex = function(v) {
  if (Debug) Util.checkClass(v, LayoutVertex, LayoutEdge, 'getOtherVertex:v');
  if (this.toVertex === v)
    return this.fromVertex;
  if (this.fromVertex === v)
    return this.toVertex;
  return null;
};

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
GridLayout
*/

/**
 * @constructor
 * @extends Layout
 * @category Layout
 * @class
 * This simple layout places all of the Parts in a grid-like arrangement, ordered, spaced apart,
 * and wrapping as needed.  It ignores any Links connecting the Nodes being laid out.
 * <p/>
 * By default this layout will sort all of the Parts alphabetically
 * (comparing {@link Part#text} values, respecting case)
 * and position them left-to-right, separated by {@link #spacing}<c>.width</c>,
 * until they do not fit in the current row.
 * At that time it starts a new row, separated from the previous row by {@link #spacing}<c>.height</c>.
 * There is a uniform cell size equal to the maximum Part width (plus spacing width)
 * and the maximum part height (plus spacing height).
 * At least one part is placed in each row, even if the part by itself is wider than the wrapping width.
 * <p/>
 * You can specify values for the {@link #cellSize} <c>width</c> and <c>height</c>.
 * If a part is wider than the cell size, it spans more than one cell in the row.
 * You can also specify a value for the {@link #wrappingWidth},
 * which will be used instead of the diagram's viewport width, to control when each row is considered "full".
 * The value of {@link Layout#isViewportSized} will be true when
 * the value of {@link #wrappingWidth} is <code>NaN</code>.
 * This causes the layout to be performed again automatically as the viewport changes size.
 * <p/>
 * You can also set {@link #wrappingColumn} to limit the number of items in each row.
 * Both the {@link #wrappingWidth} and the {@link #wrappingColumn} are respected when deciding when to wrap to the next row.
 * <p/>
 * This layout is sufficiently simple that it does not use a {@link LayoutNetwork}.
 */
function GridLayout() {
  if (arguments.length > 0) {
    Util.throwError('GridLayout constructor cannot take any arguments.');
  }
  Layout.call(this);
  this.isViewportSized = true;  // because default value for wrappingWidth is NaN
  /** @type {number} */
  this._wrappingWidth = NaN;
  /** @type {number} */
  this._wrappingColumn = NaN;
  /** @type {Size} */
  this._cellSize = new Size(NaN, NaN).freeze();
  /** @type {Size} */
  this._spacing = new Size(10, 10).freeze();
  /** @type {EnumValue} */
  this._alignment = GridLayout.Location;
  /** @type {EnumValue} */
  this._arrangement = GridLayout.LeftToRight;
  /** @type {EnumValue} */
  this._sorting = GridLayout.Ascending;
  /** @type {function(Part, Part):number} */
  this._comparer = GridLayout.standardComparer;
}

Util.publish('GridLayout', GridLayout);

Util.inherit(GridLayout, Layout);

/**
* @ignore
* Copies properties to a cloned Layout.
* @this {GridLayout}
* @param {Layout} copy
*/
GridLayout.prototype.cloneProtected = function(copy) {
  Layout.prototype.cloneProtected.call(this, copy);
  copy._wrappingWidth = this._wrappingWidth;
  copy._wrappingColumn = this._wrappingColumn;
  copy._cellSize.assign(this._cellSize);
  copy._spacing.assign(this._spacing);
  copy._alignment = this._alignment;
  copy._arrangement = this._arrangement;
  copy._sorting = this._sorting;
  copy._comparer = this._comparer;
};


/**
* Assign the positions of the parts, ignoring any links.
* @this {GridLayout}
* @param {Diagram|Group|Iterable} coll A {@link Diagram} or a {@link Group} or a collection of {@link Part}s.
*/
GridLayout.prototype.doLayout = function(coll) {
  if (!coll) Util.throwError('Layout.doLayout(collection) argument must not be null but a Diagram, a Group, or an Iterable of Parts');
  var diagram = this.diagram;
  if (diagram === null) Util.throwError('The diagram for this layout is not set.');

  this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin);

  // put parts in a set, getting rid of duplicates
  var allparts = new Set(Part);
  if (coll === this.diagram) {
    this.collectAllParts(allparts, coll.nodes, true, null, true, false, true);
    this.collectAllParts(allparts, coll.links, true, null, true, false, true);
    this.collectAllParts(allparts, coll.parts, true, null, true, false, true);
  } else if (coll === this.group) {
    this.collectAllParts(allparts, coll.memberParts, false, null, true, false, true);
  } else {
    allparts.addAll(coll.iterator);
  }

  // copy allparts so even if a part is removed from allparts, it will still remove its memberParts
  var partlist = allparts.copy();
  var pit = partlist.iterator;
  while (pit.next()) {
    var p = pit.value;
    // ignore links unless they are completely disconnected
    if (p instanceof Link) {
      if (p.fromNode !== null || p.toNode !== null) {
        allparts.remove(p);
        continue;
      }
    }
    p.ensureBounds();  // make sure all parts have been measured
    // now we remove any parts contained by a Group
    if (p instanceof Group) {
      var mems = p.memberParts;
      while (mems.next()) {
        allparts.remove(mems.value);
      }
    }
  }

  // order the parts, perhaps by sorting
  var partarray = allparts.toArray();
  if (partarray.length === 0) return;
  switch (this.sorting) {
    case GridLayout.Forward: break;
    case GridLayout.Reverse: partarray.reverse(); break;
    case GridLayout.Ascending: partarray.sort(this.comparer); break;
    case GridLayout.Descending: partarray.sort(this.comparer); partarray.reverse(); break;
  }

  var climit = this.wrappingColumn;
  if (isNaN(climit)) climit = 0;
  // calculate the wrapping width, which may depend on the panel's viewportBounds.width
  var xlimit = this.wrappingWidth;
  if (isNaN(xlimit)) {
    var viewb = this.diagram.viewportBounds;
    xlimit = Math.max(viewb.width - diagram.padding.left - diagram.padding.right, 0);
  } else {
    xlimit = Math.max(this.wrappingWidth, 0);
  }
  // must have some kind of limit
  if (climit <= 0 && xlimit <= 0) {
    climit = 1;
  }

  // get the minimum space between each part
  var spacex = this.spacing.width;
  if (!isFinite(spacex)) spacex = 0;
  var spacey = this.spacing.height;
  if (!isFinite(spacey)) spacey = 0;

  diagram.startTransaction('Layout');
  switch (this.alignment) {
    case GridLayout.Position:
      this.doPositionLayout(partarray, xlimit, climit, spacex, spacey);
      break;
    case GridLayout.Location:
      this.doLocationLayout(partarray, xlimit, climit, spacex, spacey);
      break;
  }
  diagram.commitTransaction('Layout');
  this.isValidLayout = true;
};

/**
* @ignore
* @this {GridLayout}
* @param {Array.<Part>} partarray
* @param {number} xlimit
* @param {number} climit
* @param {number} spacex
* @param {number} spacey
*/
GridLayout.prototype.doPositionLayout = function(partarray, xlimit, climit, spacex, spacey) {
  // calculate how wide each cell should be
  var cellW = Math.max(this.cellSize.width, 1);
  if (!isFinite(cellW)) {  // unknown -- calculate maximums
    cellW = 0;
    for (var i = 0; i < partarray.length; i++) {
      var p = partarray[i];
      var sz = p.measuredBounds;
      cellW = Math.max(cellW, sz.width);
    }
  }
  cellW += spacex;
  cellW = Math.max(cellW, 1);

  // calculate how tall each cell should be
  var cellH = Math.max(this.cellSize.height, 1);
  if (!isFinite(cellH)) {
    cellH = 0;
    for (var i = 0; i < partarray.length; i++) {
      var p = partarray[i];
      var sz = p.measuredBounds;
      cellH = Math.max(cellH, sz.height);
    }
  }
  cellH += spacey;
  cellH = Math.max(cellH, 1);

  // iterate through the parts, placing each one
  var arr = this.arrangement;
  var originx = this.arrangementOrigin.x;
  var originy = this.arrangementOrigin.y;
  var x = originx;
  var y = originy;
  var rowcount = 0;
  var rowheight = 0;
  for (var i = 0; i < partarray.length; i++) {
    var p = partarray[i];
    // figure out how many cells the part needs
    var sz = p.measuredBounds;
    var w = Math.ceil((sz.width + spacex) / cellW);
    var h = Math.ceil((sz.height + spacey) / cellH);
    var cszwidth = w * cellW;
    var cszheight = h * cellH;

    // maybe need to wrap to next row
    var needed;
    switch (arr) {
      case GridLayout.RightToLeft: needed = Math.abs(x - sz.width) + originx; break;
      default: needed = x + sz.width - originx; break;
    }
    // changed to account for location of origin
    if ((climit > 0 && rowcount > climit - 1) || (xlimit > 0 && rowcount > 0 && needed > xlimit)) {
      rowcount = 0;
      x = originx;
      y += rowheight;
      rowheight = 0;
    }

    rowheight = Math.max(rowheight, cszheight);

    // assign new part Position
    var coff;
    switch (arr) {
      case GridLayout.RightToLeft: coff = -sz.width; break;
      default: coff = 0; break;
    }
    p.moveTo(x + coff, y);

    // advance to next column
    switch (arr) {
      case GridLayout.RightToLeft: x -= cszwidth; break;
      default: x += cszwidth; break;
    }
    rowcount++;
  }
};

/**
* @ignore
* @this {GridLayout}
* @param {Array.<Part>} partarray
* @param {number} xlimit
* @param {number} climit
* @param {number} spacex
* @param {number} spacey
*/
GridLayout.prototype.doLocationLayout = function(partarray, xlimit, climit, spacex, spacey) {
  // calculate how wide each cell should be
  var cellW = Math.max(this.cellSize.width, 1);
  var cellL = 0;
  var cellR = 0;
  var cellT = 0;
  var temploc = Util.tempPoint();
  for (var i = 0; i < partarray.length; i++) {
    var p = partarray[i];
    var sz = p.measuredBounds;
    // when AlignsLocation, accumulate separate maximums for left of the Location, and for right
    var relloc = p.getRelativePoint(p.locationObject, p.locationSpot, temploc);
    cellL = Math.max(cellL, relloc.x);
    cellR = Math.max(cellR, sz.width - relloc.x);
    cellT = Math.max(cellT, relloc.y);
  }

  // account for space; which side depends on Arrangement
  var arr = this.arrangement;
  switch (arr) {
    case GridLayout.RightToLeft: cellL += spacex; break;
    default: cellR += spacex; break;
  }
  if (!isFinite(cellW)) {  // unknown -- calculate maximums
    cellW = Math.max(cellL + cellR, 1);
  } else {
    cellW = Math.max(cellW + spacex, 1);
  }

  // iterate through the parts, placing each part's Location at (X,Y)
  var originx = this.arrangementOrigin.x /* + cellL */;
  var originy = this.arrangementOrigin.y /* + cellT */;
  var x = originx;
  var y = originy;
  var rowcount = 0;
  var rowheight = 0;

  /* xlimit -= cellL; */  // remove space taken up at left edge beyond the location
  var xpos = 0;

  // calculate how tall each cell should be
  var cellH = Math.max(this.cellSize.height, 1);
  cellT = 0;
  var cellB = 0;

  var firstRow = true; // We only layout the first row by strict locations, then the others we use position
  var temploc2 = Util.tempPoint();

  for (var i = 0; i < partarray.length; i++) {
    var p = partarray[i];
    // figure out how many cells the part needs
    var sz = p.measuredBounds;
    var relloc = p.getRelativePoint(p.locationObject, p.locationSpot, temploc);
    // assign new part Position
    if (rowcount > 0) {
      switch (arr) {
        case GridLayout.RightToLeft: x = Math.floor((x - originx - (sz.width - relloc.x)) / cellW) * cellW + originx; break;
        default: x = Math.ceil((x - originx + relloc.x) / cellW) * cellW + originx; break;
      }
    } else {  // rowcount == 0
      switch (arr) {
        case GridLayout.RightToLeft: xpos = x + relloc.x + sz.width; break;
        default: xpos = x - relloc.x; break;
      }
    }
    // maybe need to wrap to next row
    var needed;
    // subtract the stuff sticking out beyond the end of the grid from the XLIMIT
    // changed fix problems with premature wrapping with RTL
    switch (arr) {
      case GridLayout.RightToLeft: needed = -(x + relloc.x) + originx + xpos; break;
      default: needed = x + sz.width - relloc.x - originx - xpos; break;
    }

    // check the column limit or the width limit or both
    if ((climit > 0 && rowcount > climit - 1) || (xlimit > 0 && rowcount > 0 && needed > xlimit)) {
      for (var j = 0; j < rowcount; j++) {
        if (i === rowcount) break; // first row is set by location
        var prevp = partarray[i - rowcount + j];
        var prevrelloc = prevp.getRelativePoint(prevp.locationObject, prevp.locationSpot, temploc2);
        prevp.moveTo(prevp.position.x, prevp.position.y + cellT - prevrelloc.y);
      }

      // Done with the row, calculate the height of the cell bottom:
      // assume all space on bottom
      cellB += spacey;

      if (firstRow)
        y += cellB;
      else
        y += cellB + cellT;

      // Reset vals for next row
      cellT = 0;
      cellB = 0;
      rowcount = 0;
      x = originx;
      firstRow = false;
    }

    // when AlignsLocation, accumulate separate maximums for above the Location, and for below
    cellT = Math.max(cellT, relloc.y);
    // consider the height of the part below the location point
    cellB = Math.max(cellB, sz.height - relloc.y);
    if (isFinite(cellH)) cellB = Math.max(cellB, Math.max(sz.height, cellH) - relloc.y);

    // the Position is just the Location minus the RelativeElementPoint
    if (firstRow)
      p.moveTo(x - relloc.x, y - relloc.y);
    else
      p.moveTo(x - relloc.x, y);

    // changed to account for space
    // advance to next column
    switch (arr) {
      case GridLayout.RightToLeft: x -= relloc.x + spacex; break;
      default: x += sz.width - relloc.x + spacex; break;
    }
    rowcount++;
  }
  // last row
  for (var j = 0; j < rowcount; j++) {
    if (i === rowcount) break; // first row is set by location
    var prevp = partarray[i - rowcount + j];
    var prevrelloc = prevp.getRelativePoint(prevp.locationObject, prevp.locationSpot, temploc);
    prevp.moveTo(prevp.position.x, prevp.position.y + cellT - prevrelloc.y);
  }
  Util.freePoint(temploc);
  Util.freePoint(temploc2);
};

/***************Properties***************/

/**
* Gets or sets the wrapping width.
* <p/>
* The default is NaN, meaning to use the width of the diagram's panel's viewport.
* Must be a value greater than 0.
* @name GridLayout#wrappingWidth
* @function.
* @return {number}
*/
/** @type {number} */
GridLayout.prototype.wrappingWidth;
Util.exportProperty(GridLayout, 'wrappingWidth', GridLayout.prototype.wrappingWidth);
Util.defineProperty(GridLayout, { wrappingWidth: 'wrappingWidth' },
  /** @this {GridLayout} */
	function() { return this._wrappingWidth; },
  /** @this {GridLayout} */
	function(val) {
	  if (this._wrappingWidth !== val && (val > 0 || isNaN(val))) {
	    this._wrappingWidth = val;
      this.isViewportSized = isNaN(val);
	    this.invalidateLayout();
	  }
	}
);

/**
* Gets or sets the maximum number of columns.
* <p/>
* The default is NaN, meaning not to limit the number of columns.
* 1 is a common value to produce a single column of parts.
* @name GridLayout#wrappingColumn
* @function.
* @return {number}
*/
/** @type {number} */
GridLayout.prototype.wrappingColumn;
Util.exportProperty(GridLayout, 'wrappingColumn', GridLayout.prototype.wrappingColumn);
Util.defineProperty(GridLayout, { wrappingColumn: 'wrappingColumn' },
  /** @this {GridLayout} */
  function() { return this._wrappingColumn; },
  /** @this {GridLayout} */
  function(val) {
	  if (this._wrappingColumn !== val && (val > 0 || isNaN(val))) {
	    this._wrappingColumn = val;
	    this.invalidateLayout();
	  }
  }
);

/**
* Gets or sets the minimum part size by which each part is positioned in the grid.
* <p/>
* The default value is NaN x NaN.
* The units are in model coordinates.
* <p/>
* When the cell size is smaller than a part, the part will occupy more than one cell.
* This allows parts to be positioned closer to each other, but then variations in part
* sizes may cause them not to be aligned in perfect rows or columns.
* @name GridLayout#cellSize
* @function.
* @return {Size}
*/
/** @type {Size} */
GridLayout.prototype.cellSize;
Util.exportProperty(GridLayout, 'cellSize', GridLayout.prototype.cellSize);
Util.defineProperty(GridLayout, { cellSize: 'cellSize' },
  /** @this {GridLayout} */
  function() { return this._cellSize; },
  /** @this {GridLayout} */
  function(val) {
    var old = this._cellSize;
    if (!old.equals(val)) {
      this._cellSize.assign(val);
      this.invalidateLayout();
    }
  }
);

/**
* Gets or sets the minimum horizontal and vertical space between parts.
* </p>
* The default value is 10 x 10.
* The units are in model coordinates.
* @name GridLayout#spacing
* @function.
* @return {Size}
*/
/** @type {Size} */
GridLayout.prototype.spacing;
Util.exportProperty(GridLayout, 'spacing', GridLayout.prototype.spacing);
Util.defineProperty(GridLayout, { spacing: 'spacing' },
  /** @this {GridLayout} */
  function() { return this._spacing; },
  /** @this {GridLayout} */
  function(val) {
    var old = this._spacing;
    if (!old.equals(val)) {
      this._spacing.assign(val);
      this.invalidateLayout();
    }
  }
);

/**
* Gets or sets whether the {@link Part#location} or the position should be used
* to arrange each part.
* </p>
* The default value is {@link GridLayout#Location} -- the {@link Part#location}s will
* be aligned in a grid.
* @name GridLayout#alignment
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
GridLayout.prototype.alignment;
Util.exportProperty(GridLayout, 'alignment', GridLayout.prototype.alignment);
Util.defineProperty(GridLayout, { alignment: 'alignment' },
	/** @this {GridLayout} */
	function() { return this._alignment; },
	/** @this {GridLayout} */
	function(val) {
		if (this._alignment !== val) {
			if (Debug) Util.checkClass(val, EnumValue, GridLayout, 'alignment');
      if (val === GridLayout.Location || val === GridLayout.Position) {
				this._alignment = val;
        this.invalidateLayout();
      }
    }
  }
);

/**
* Gets or sets how to arrange the parts.
* Must be {@link GridLayout#LeftToRight} or {@link GridLayout#RightToLeft}.
* </p>
* The default value is {@link GridLayout#LeftToRight}.
* @name GridLayout#arrangement
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
GridLayout.prototype.arrangement;
Util.exportProperty(GridLayout, 'arrangement', GridLayout.prototype.arrangement);
Util.defineProperty(GridLayout, { arrangement: 'arrangement' },
	/** @this {GridLayout} */
	function() { return this._arrangement; },
	/** @this {GridLayout} */
	function(val) {
		if (this._arrangement !== val) {
			if (Debug) Util.checkClass(val, EnumValue, GridLayout, 'arrangement');
      if (val === GridLayout.LeftToRight || val === GridLayout.RightToLeft) {
				this._arrangement = val;
        this.invalidateLayout();
      }
    }
  }
);

/**
* Gets or sets what order to place the parts.
* Must be {@link GridLayout#Forward}, {@link GridLayout#Reverse},
* {@link GridLayout#Ascending}, or {@link GridLayout#Descending}.
* <p/>
* The default value is {@link GridLayout#Ascending}.
* @name GridLayout#sorting
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
GridLayout.prototype.sorting;
Util.exportProperty(GridLayout, 'sorting', GridLayout.prototype.sorting);
Util.defineProperty(GridLayout, { sorting: 'sorting' },
	/** @this {GridLayout} */
	function() { return this._sorting; },
	/** @this {GridLayout} */
	function(val) {
		if (this._sorting !== val) {
			if (Debug) Util.checkClass(val, EnumValue, GridLayout, 'sorting');
      if (val === GridLayout.Forward || val === GridLayout.Reverse ||
			    val === GridLayout.Ascending || val === GridLayout.Descending) {
				this._sorting = val;
        this.invalidateLayout();
      }
    }
  }
);

/**
* Gets or sets the comparison function used to sort the parts.
* </p>
* The default value is a case-insensitive alphabetic comparison
* using the {@link Part#text} (attached) property of each part.
* @name GridLayout#comparer
* @function.
* @return {function(Part, Part):number}
*/
/** @type {function(Part, Part):number} */
GridLayout.prototype.comparer;
Util.exportProperty(GridLayout, 'comparer', GridLayout.prototype.comparer);
Util.defineProperty(GridLayout, { comparer: 'comparer' },
	/** @this {GridLayout} */
	function() { return this._comparer; },
	/** @this {GridLayout} */
	function(val) {
		if (this._comparer !== val) {
			if (Debug) Util.checkPrimitive(val, 'function', GridLayout, 'comparer');
			this._comparer = val;
			this.invalidateLayout();
		}
	}
);

GridLayout['standardComparer'] =
/**
* @ignore
* This static method is used to compare the {@link Part#text} values of the argument {@link Part}s.
* @param {Part} a
* @param {Part} b
* @return {number} -1, 0, or 1, depending on whether the comparison between A and B is less than, equal, or greater than.
*/
GridLayout.standardComparer = function(a, b) {
  if (Debug) Util.checkClass(a, Part, GridLayout, 'standardComparer:a');
  if (Debug) Util.checkClass(b, Part, GridLayout, 'standardComparer:b');
  var at = a.text;
  var bt = b.text;
  if (at < bt) return -1;
  if (at > bt) return 1;
  return 0;
};

GridLayout['smartComparer'] =
/**
* @ignore
* This static method is used to compare the {@link Part#text} values of the argument {@link Part}s.
* @param {Part} a
* @param {Part} b
* @return {number} -1, 0, or 1, depending on whether the comparison between A and B is less than, equal, or greater than.
*/
GridLayout.smartComparer = function(a, b) {
  if (Debug) Util.checkClass(a, Part, GridLayout, 'standardComparer:a');
  if (Debug) Util.checkClass(b, Part, GridLayout, 'standardComparer:b');
  if (a !== null) {
    if (b !== null) {
      var aLower = a.text.toLocaleLowerCase();
      var bLower = b.text.toLocaleLowerCase();
      // split the string, separating numbers
      var aSplit = aLower.split(/([+\-]?[\.]?\d+(?:\.\d*)?(?:e[+\-]?\d+)?)/);
      var bSplit = bLower.split(/([+\-]?[\.]?\d+(?:\.\d*)?(?:e[+\-]?\d+)?)/);
      var i;
      for (i = 0; i < aSplit.length; i++) {
        if (bSplit[i] !== '' && bSplit[i] !== undefined) {
          var aCurrentNum = parseFloat(aSplit[i]);
          var bCurrentNum = parseFloat(bSplit[i]);
          if (!isNaN(aCurrentNum)) {
            if (!isNaN(bCurrentNum)) {
              // both numbers
              if (aCurrentNum - bCurrentNum !== 0) {
                return aCurrentNum - bCurrentNum;
              } else {
                // same number, move to next element
                continue;
              }
            } else {
              // aSplit[i] is a number, bSplit[i] is NaN
              return -1;
            }
          } else {
            if (!isNaN(bCurrentNum)) {
              // aSplit[i] is NaN, bSplit[i] is a number
              return 1;
            } else {
              //both strings
              if (aSplit[i].localeCompare(bSplit[i]) !== 0) {
                return aSplit[i].localeCompare(bSplit[i]);
              } else {
                // same string, move to next element
                continue;
              }
            }
          }
        } else {
          // bSplit[i] is either "" or undefined
          if (aSplit[i] === '') continue;
          else return 1;
        }
      }
      // i is now aSplit.length
      if (bSplit[i] !== '' && bSplit[i] !== undefined) return -1;
      else return 0;
    } else {
      return 1;
    }
  } else {
    if (b !== null)
      return -1;
    else
      return 0;
  }
};

/***************Enums***************/

// These values specify whether to postion each part by its location or by its position.
/**
* Position the top-left corner of each part at a grid point;
* This value is used for {@link GridLayout#alignment}.
* @name GridLayout#Position
* @constant
* @static
* @return {EnumValue}
*/
GridLayout['Position'] = GridLayout.Position = Util.defineEnumValue(GridLayout, 'Position', 0);

/**
* Position the part's {@link Part#location} at a grid point;
* This value is used for {@link GridLayout#alignment}.
* @name GridLayout#Location
* @constant
* @static
* @return {EnumValue}
*/
GridLayout['Location'] = GridLayout.Location = Util.defineEnumValue(GridLayout, 'Location', 1);

// These values specify how to fill each row.
/**
* Fill each row from left to right;
* This value is used for {@link GridLayout#arrangement}.
* @name GridLayout#LeftToRight
* @constant
* @static
* @return {EnumValue}
*/
GridLayout['LeftToRight'] = GridLayout.LeftToRight = Util.defineEnumValue(GridLayout, 'LeftToRight', 2);

/**
* Fill each row from right to left;
* This value is used for {@link GridLayout#arrangement}.
* @name GridLayout#RightToLeft
* @constant
* @static
* @return {EnumValue}
*/
GridLayout['RightToLeft'] = GridLayout.RightToLeft = Util.defineEnumValue(GridLayout, 'RightToLeft', 3);

// These values specify whether to sort the children of a part,
// and in what order to position them.
/**
* Lay out each child in the order in which they were found;
* This value is used for {@link GridLayout#sorting}.
* @name GridLayout#Forward
* @constant
* @static
* @return {EnumValue}
*/
GridLayout['Forward'] = GridLayout.Forward = Util.defineEnumValue(GridLayout, 'Forward', 4);

/**
* Lay out each child in reverse order from which they were found;
* This value is used for {@link GridLayout#sorting}.
* @name GridLayout#Reverse
* @constant
* @static
* @return {EnumValue}
*/
GridLayout['Reverse'] = GridLayout.Reverse = Util.defineEnumValue(GridLayout, 'Reverse', 5);

/**
* Lay out each child according to the sort order given by {@link GridLayout#comparer};
* This value is used for {@link GridLayout#sorting}.
* @name GridLayout#Ascending
* @constant
* @static
* @return {EnumValue}
*/
GridLayout['Ascending'] = GridLayout.Ascending = Util.defineEnumValue(GridLayout, 'Ascending', 6);

/**
* Lay out each child in reverse sort order given by {@link GridLayout#comparer};
* This value is used for {@link GridLayout#sorting}.
* @name GridLayout#Descending
* @constant
* @static
* @return {EnumValue}
*/
GridLayout['Descending'] = GridLayout.Descending = Util.defineEnumValue(GridLayout, 'Descending', 7);

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
CircularLayout
CircularNetwork
CircularVertex
CircularEdge
*/

/***************CircularLayout***************/
/**
 * Constructs a {@link CircularLayout} with no {@link Layout#network}
 * and with no owning {@link Layout#diagram}.
 * @constructor
 * @extends Layout
 * @category Layout
 * @class
 * This layout positions nodes in a circular arrangement.
 * <p/>
 * This layout makes use of a {@link LayoutNetwork} of
 * {@link CircularVertex}es and {@link CircularEdge}s that normally
 * correspond to the {@link Node}s and {@link Link}s of the {@link Diagram}.
 */
function CircularLayout() {
  if (arguments.length > 0) {
    Util.throwError('CircularLayout constructor cannot take any arguments.');
  }
  Layout.call(this);

  // private variables
  /** @ignore @type {number} */
  this._eRadius = 0;
  /** @ignore @type {number} */
  this._eAspectRatio = 0;
  /** @ignore @type {number} */
  this._eStartAngle = 0;
  /** @ignore @type {number} */
  this._eSweepAngle = 360;
  /** @ignore @type {EnumValue} */
  this._eArrangement = CircularLayout.ConstantSpacing;
  /** @ignore @type {number} */
  this._eSpacing = 0;
  /** @ignore @type {EnumValue} */
  this._eNodeDiameterFormula = CircularLayout.ConstantSpacing;
  /** @ignore @type {number} */
  this._totalElementSizes = 0;  // the sum of the diameters of all the elements of the layout
  /** @ignore @type {number} */
  this._yRadius = 0;
  /** @ignore @type {number} */
  this._constDist = 0;  // for CircularLayout.ConstantDistance or ConstantAngle
  /** @ignore @type {VertexArrangement} */
  this._vertexArrangement = new VertexArrangement();
  /** @ignore @type {number} */
  this._packedIters = 0;
  /** @ignore @type {number} */
  this._correctLastAngle = 0;
  /** @ignore @type {number} */
  this._riemannnum = 600;

  // properties
  /** @type {number} */
  this._radius = NaN;
  /** @type {number} */
  this._aspectRatio = 1;
  /** @type {number} */
  this._startAngle = 0;
  /** @type {number} */
  this._sweepAngle = 360;
  /** @type {EnumValue} */
  this._arrangement = CircularLayout.ConstantSpacing;
  /** @type {EnumValue} */
  this._direction = CircularLayout.Clockwise;
  /** @type {EnumValue} */
  this._sorting = CircularLayout.Optimized;
  /** @type {function(CircularVertex, CircularVertex):number} */
  this._comparer = LayoutVertex.standardComparer;
  /** @type {number} */
  this._spacing = 6;
  /** @type {EnumValue} */
  this._nodeDiameterFormula = CircularLayout.Pythagorean;
}

Util.publish('CircularLayout', CircularLayout);

Util.inherit(CircularLayout, Layout);

/**
* @ignore
* Copies properties to a cloned Layout.
* @this {CircularLayout}
* @param {Layout} copy
*/
CircularLayout.prototype.cloneProtected = function(copy) {
  Layout.prototype.cloneProtected.call(this, copy);
  // these properties are computed:
  //this._eRadius
  //this._eAspectRatio
  //this._eStartAngle
  //this._eSweepAngle
  //this._eArrangement
  //this._eSpacing
  //this._totalElementSizes
  //this._yRadius
  //this._constDist
  //this._vertexArrangement
  //this._packedIters
  //this._correctLastAngle
  //this._riemannnum
  copy._radius = this._radius;
  copy._aspectRatio = this._aspectRatio;
  copy._startAngle = this._startAngle;
  copy._sweepAngle = this._sweepAngle;
  copy._arrangement = this._arrangement;
  copy._direction = this._direction;
  copy._sorting = this._sorting;
  copy._comparer = this._comparer;
  copy._spacing = this._spacing;
  copy._nodeDiameterFormula = this._nodeDiameterFormula;
};

/**
* Create a new {@link LayoutNetwork} of {@link CircularVertex}es and {@link CircularEdge}s.
* @this {CircularLayout}
* @return {LayoutNetwork} a new {@link LayoutNetwork}.
*/
CircularLayout.prototype.createNetwork = function() {
  var net = new CircularNetwork();
  net.setLayout(this);
  return net;
};


/**
* @ignore
* @this {CircularLayout}
* @param {List} vertices
* @param {List} evens
* @param {List} odds
* @return {Array.<List>}
*/
CircularLayout.prototype.setEffectiveValues = function(vertices, evens, odds) {
  vertices = this.sort(vertices);
  evens = new List(CircularVertex);
  odds = new List(CircularVertex);

  // get the private variables, and we will set them at the end
  var eArrangement = this._eArrangement;
  var eNodeDiameterFormula = this._eNodeDiameterFormula;
  var eRadius = this._eRadius;
  var eAspectRatio = this._eAspectRatio;
  var eStartAngle = this._eStartAngle;
  var eSweepAngle = this._eSweepAngle;
  var eSpacing = this._eSpacing;
  var totalElementSizes = this._totalElementSizes;
  var yRadius = this._yRadius;
  var constDist = this._constDist;

  // fetch local copies of property values; if invalid, use a valid value instead

  eArrangement = this.arrangement;
  eNodeDiameterFormula = this.nodeDiameterFormula;

  eRadius = this.radius;
  if (!isFinite(eRadius) || eRadius <= 0) {
    eRadius = NaN;
  }

  eAspectRatio = this.aspectRatio;
  if (!isFinite(eAspectRatio) || eAspectRatio <= 0) {
    eAspectRatio = 1;
  }

  eStartAngle = this.startAngle;
  if (!isFinite(eStartAngle)) {
    eStartAngle = 0;
  }

  eSweepAngle = this.sweepAngle;
  if (!isFinite(eSweepAngle) || eSweepAngle > 360 || eSweepAngle < 1) {
    eSweepAngle = 360;
  }

  eSpacing = this.spacing;
  if (!isFinite(eSpacing)) {
    eSpacing = NaN;
  }

  if (eArrangement === CircularLayout.Packed && eNodeDiameterFormula === CircularLayout.Circular) {
    // Packing circular nodes is equivalent to what CircularLayout.ConstantSpacing does
    eArrangement = CircularLayout.ConstantSpacing;
  } else if (eArrangement === CircularLayout.Packed && eNodeDiameterFormula !== CircularLayout.Circular) {
    eNodeDiameterFormula = CircularLayout.Circular;
    eArrangement = this.arrangement;
  }

  if ((this.direction === CircularLayout.BidirectionalLeft || this.direction === CircularLayout.BidirectionalRight)
	&& this.sorting !== CircularLayout.Optimized) {
    // bidirectional
    for (var i = 0;; i += 2) {
      if (i >= vertices.length)
        break;
      evens.add(vertices.elt(i));
      if (i + 1 >= vertices.length)
        break;
      odds.add(vertices.elt(i + 1));
    }
    if (this.direction === CircularLayout.BidirectionalLeft) {
      // reverse evens if Packed, append odds
      if (this.arrangement === CircularLayout.Packed)
        evens.reverse();
      vertices = new List(CircularVertex);
      vertices.addAll(evens);
      vertices.addAll(odds);
    } else {
      // reverse odds if Packed, append evens
      if (this.arrangement === CircularLayout.Packed)
        odds.reverse();
      vertices = new List(CircularVertex);
      vertices.addAll(odds);
      vertices.addAll(evens);
    }
  }

  var num = vertices.length;
  totalElementSizes = 0;
  var n = 0;
  for (var i = 0; i < vertices.length; i++) {
    var angle = eStartAngle + (eSweepAngle * n * (this.direction === CircularLayout.Clockwise ? 1 : -1)) / num;
    var add = vertices.elt(i).diameter;
    //var add = vertices.elt(i).computeDiameter(angle);
    if (isNaN(add)) add = vertices.elt(i).computeDiameter(angle);
    if (eSweepAngle < 360 && (i === 0 || i === vertices.length - 1)) {
      add /= 2;
    }
    totalElementSizes += add;
    n++;
  }

  if (isNaN(eRadius) || eArrangement === CircularLayout.Packed) {  // radius not set
    // spacing not set
    if (isNaN(eSpacing))
      eSpacing = 6;

    // set radius based on spacing
    if (eArrangement !== CircularLayout.ConstantSpacing && eArrangement !== CircularLayout.Packed) {
      var maxdist = -Infinity;
      for (var i = 0; i < num; i++) {
        var curr = vertices.elt(i);
        var next = vertices.elt(i === num - 1 ? 0 : i + 1);
        if (isNaN(curr.diameter)) curr.computeDiameter(0);
        if (isNaN(next.diameter)) next.computeDiameter(0);
        maxdist = Math.max(maxdist, (curr.diameter + next.diameter) / 2);
      }
      constDist = maxdist + eSpacing;
      if (eArrangement === CircularLayout.ConstantAngle) {
        var angle = 2 * Math.PI / num;
        var minrad = (maxdist + eSpacing) / angle;
        if (eAspectRatio > 1) {
          eRadius = minrad;
          yRadius = eRadius * eAspectRatio;
        } else {
          yRadius = minrad;
          eRadius = yRadius;
        }
      } else {
        eRadius = this.inverseEllipsePerim((constDist * (eSweepAngle >= 360 ? num : num - 1)), eAspectRatio, eStartAngle * Math.PI / 180, eSweepAngle * Math.PI / 180);
      }
    } else {
      // constant spacing
      eRadius = this.inverseEllipsePerim((totalElementSizes + (eSweepAngle >= 360 ? num : num - 1) * (eArrangement !== CircularLayout.Packed ? eSpacing : eSpacing * 1.6)), eAspectRatio, eStartAngle * Math.PI / 180, eSweepAngle * Math.PI / 180);
    }
    yRadius = eRadius * eAspectRatio;
  } else {
    // radius is a number
    yRadius = eRadius * eAspectRatio;
    var circ = this.ellipsePerim(eRadius, yRadius, eStartAngle * Math.PI / 180, eSweepAngle * Math.PI / 180);
    if (isNaN(eSpacing)) {
      // spacing is NaN
      if (eArrangement === CircularLayout.ConstantSpacing || eArrangement === CircularLayout.Packed) {
        eSpacing = (circ - totalElementSizes) / (eSweepAngle >= 360 ? num : num - 1);
      }
      // else eSpacing doesn't matter
    } else {  // spacing is set
      if (eArrangement === CircularLayout.ConstantSpacing || eArrangement === CircularLayout.Packed) {
        // spacing is set, const spacing
        var currentspacing = (circ - totalElementSizes) / (eSweepAngle >= 360 ? num : num - 1);

        if (currentspacing < eSpacing) {
          eRadius = this.inverseEllipsePerim((totalElementSizes + eSpacing * (eSweepAngle >= 360 ? num : num - 1)), eAspectRatio, eStartAngle * Math.PI / 180, eSweepAngle * Math.PI / 180);
          yRadius = eRadius * eAspectRatio;
        } else {
          eSpacing = currentspacing;
        }
      } else {
        // constant spacing (perhaps)
        var maxdist = -Infinity;
        for (var i = 0; i < num; i++) {
          var curr = vertices.elt(i);
          var next = vertices.elt(i === num - 1 ? 0 : i + 1);
          if (isNaN(curr.diameter)) curr.computeDiameter(0);
          if (isNaN(next.diameter)) next.computeDiameter(0);
          maxdist = Math.max(maxdist, (curr.diameter + next.diameter) / 2);
        }
        var minConstDist = maxdist + eSpacing;
        var minNeededRad = this.inverseEllipsePerim((minConstDist * (eSweepAngle >= 360 ? num : num - 1)), eAspectRatio, eStartAngle * Math.PI / 180, eSweepAngle * Math.PI / 180);
        if (minNeededRad > eRadius) {
          eRadius = minNeededRad;
          yRadius = eRadius * eAspectRatio;
          constDist = minConstDist;
        } else {
          constDist = circ / (eSweepAngle >= 360 ? num : num - 1); // may be unnecessary
        }
      }
    }
  }
  this._eArrangement = eArrangement;
  this._eNodeDiameterFormula = eNodeDiameterFormula;
  this._eRadius = eRadius;
  this._eAspectRatio = eAspectRatio;
  this._eStartAngle = eStartAngle;
  this._eSweepAngle = eSweepAngle;
  this._eSpacing = eSpacing;
  this._totalElementSizes = totalElementSizes;
  this._yRadius = yRadius;
  this._constDist = constDist;

  return [vertices, evens, odds];
};


/**
* Assign the positions of the vertexes in the network.
* @this {CircularLayout}
* @param {Diagram|Group|Iterable} coll A {@link Diagram} or a {@link Group} or a collection of {@link Part}s.
*/
CircularLayout.prototype.doLayout = function(coll) {
  if (!coll) Util.throwError('Layout.doLayout(collection) argument must not be null but a Diagram, a Group, or an Iterable of Parts');
  // create network
  if (this.network === null) {
    this.network = this.makeNetwork(coll);
  }

  // if there is only one node, put it at the origin
  var vertexes = this.network.vertexes;
  if (vertexes.count <= 1) {
    if (vertexes.count === 1) {
      var cv = vertexes.first();
      cv.centerX = 0;
      cv.centerY = 0;
    }
    this.updateParts();
    this.network = null;
    this.isValidLayout = true;
    return;
  }

  var vertices = new List(CircularVertex);
  vertices.addAll(vertexes.iterator);
  var evens = new List(CircularVertex);
  var odds = new List(CircularVertex);

  var resultsArr = this.setEffectiveValues(vertices, evens, odds);
  vertices = resultsArr[0];
  evens = resultsArr[1];
  odds = resultsArr[2];

  var eArrangement = this._eArrangement;
  var eNodeDiameterFormula = this._eNodeDiameterFormula;
  var eRadius = this._eRadius;
  var eAspectRatio = this._eAspectRatio;
  var eStartAngle = this._eStartAngle;
  var eSweepAngle = this._eSweepAngle;
  var eSpacing = this._eSpacing;
  var totalElementSizes = this._totalElementSizes;
  var yRadius = this._yRadius;
  var constDist = this._constDist;

  if ((this.direction === CircularLayout.BidirectionalLeft || this.direction === CircularLayout.BidirectionalRight) &&
			 eArrangement === CircularLayout.Packed) {
    // if Arrangement === Packed and Direction is bidirectional, this is achieved by using a rearrangement of the vertices, and shifting the StartAngle
    this.packedLayout(vertices, eSweepAngle, eStartAngle - eSweepAngle / 2, CircularLayout.Clockwise);
  } else if (this.direction === CircularLayout.BidirectionalLeft || this.direction === CircularLayout.BidirectionalRight) {
    var dsa = 0; // change in start angle
    // bidirectionals are achieved by laying out the even nodes in one direction, then laying out the odds in the opposite direction.
    // StartAngles must be slightly different.  The switch below computes the difference
    switch (eArrangement) {
      case CircularLayout.ConstantDistance:
        dsa = this.ellipseAngle(eRadius, yRadius, eStartAngle, constDist) * 180 / Math.PI;
        break;
      case CircularLayout.ConstantSpacing:
        {
          var evendia = 0;
          var odddia = 0;
          var firsteven = evens.first();
          if (firsteven !== null)
            evendia = firsteven.computeDiameter(Math.PI / 2);
          var firstodd = odds.first();
          if (firstodd !== null)
            odddia = firstodd.computeDiameter(Math.PI / 2);
          dsa = this.ellipseAngle(eRadius, yRadius, eStartAngle, eSpacing + (evendia + odddia) / 2) * 180 / Math.PI;
          break;
        }
      case CircularLayout.ConstantAngle:
        dsa = eSweepAngle / vertices.length;
        break;
    }
    // layout evens, then odds
    if (this.direction === CircularLayout.BidirectionalLeft) {
      switch (eArrangement) {
        case CircularLayout.ConstantDistance:
          this.distanceLayout(evens, eSweepAngle / 2, eStartAngle, CircularLayout.Counterclockwise);
          break;
        case CircularLayout.ConstantSpacing:
          this.spacingLayout(evens, eSweepAngle / 2, eStartAngle, CircularLayout.Counterclockwise);
          break;
        case CircularLayout.ConstantAngle:
          this.angleLayout(evens, eSweepAngle / 2, eStartAngle, CircularLayout.Counterclockwise);
          break;
      }
      switch (eArrangement) {
        case CircularLayout.ConstantDistance:
          this.distanceLayout(odds, eSweepAngle / 2, eStartAngle + dsa, CircularLayout.Clockwise);
          break;
        case CircularLayout.ConstantSpacing:
          this.spacingLayout(odds, eSweepAngle / 2, eStartAngle + dsa, CircularLayout.Clockwise);
          break;
        case CircularLayout.ConstantAngle:
          this.angleLayout(odds, eSweepAngle / 2, eStartAngle + dsa, CircularLayout.Clockwise);
          break;
      }
    } else {
      switch (eArrangement) {
        case CircularLayout.ConstantDistance:
          this.distanceLayout(odds, eSweepAngle / 2, eStartAngle, CircularLayout.Counterclockwise);
          break;
        case CircularLayout.ConstantSpacing:
          this.spacingLayout(odds, eSweepAngle / 2, eStartAngle, CircularLayout.Counterclockwise);
          break;
        case CircularLayout.ConstantAngle:
          this.angleLayout(odds, eSweepAngle / 2, eStartAngle, CircularLayout.Counterclockwise);
          break;
      }
      switch (eArrangement) {
        case CircularLayout.ConstantDistance:
          this.distanceLayout(evens, eSweepAngle / 2, eStartAngle + dsa, CircularLayout.Clockwise);
          break;
        case CircularLayout.ConstantSpacing:
          this.spacingLayout(evens, eSweepAngle / 2, eStartAngle + dsa, CircularLayout.Clockwise);
          break;
        case CircularLayout.ConstantAngle:
          this.angleLayout(evens, eSweepAngle / 2, eStartAngle + dsa, CircularLayout.Clockwise);
          break;
      }
    }
  } else {
    // if Direction isn't bidirectional, the nodes are laid out by calling one of these functions.
    switch (eArrangement) {
      case CircularLayout.ConstantDistance:
        this.distanceLayout(vertices, eSweepAngle, eStartAngle, this.direction);
        break;
      case CircularLayout.ConstantSpacing:
        this.spacingLayout(vertices, eSweepAngle, eStartAngle, this.direction);
        break;
      case CircularLayout.ConstantAngle:
        this.angleLayout(vertices, eSweepAngle, eStartAngle, this.direction);
        break;
      case CircularLayout.Packed:
        this.packedLayout(vertices, eSweepAngle, eStartAngle, this.direction);
        break;
    }
  }

  // Update the "physical" positions of the nodes and links.
  this.updateParts();
  this.network = null;
  this.isValidLayout = true;
};

/**
 * @ignore
 * Arranges the items so the angle between any item and
 * an adjacent item is the same.
 * @this {CircularLayout}
 * @param {List} vertices
 * @param {number} sweep
 * @param {number} start
 * @param {EnumValue} dir
 */
CircularLayout.prototype.angleLayout = function(vertices, sweep, start, dir) {
  var eSweepAngle = this._eSweepAngle;
  var eRadius = this._eRadius;
  var yRadius = this._yRadius;
  var theta0 = start * Math.PI / 180;
  var sweepingAngle = sweep * Math.PI / 180;
  //var e = eRadius > yRadius ? Math.sqrt(eRadius * eRadius - yRadius * yRadius) / eRadius : Math.Ssrt(yRadius * yRadius - eRadius * eRadius) / yRadius;
  var num = vertices.length;
  for (var i = 0; i < num; i++) {
    var theta = theta0 + (dir === CircularLayout.Clockwise ? (i * sweepingAngle) / (eSweepAngle >= 360 ? num : num - 1) : -(i * sweepingAngle) / num);
    var cv = vertices.elt(i);
    var w = eRadius * Math.tan(theta) / yRadius;
    var r = Math.sqrt((eRadius * eRadius + yRadius * yRadius * w * w) / (1 + w * w));
    cv.centerX = r * Math.cos(theta);
    cv.centerY = r * Math.sin(theta);
    cv.actualAngle = theta * 180 / Math.PI;
  }
};

/**
 * @ignore
 * Arranges the items so the spacing between any item and
 * an adjacent item is the same.
 * @this {CircularLayout}
 * @param {List} vertices
 * @param {number} sweep
 * @param {number} start
 * @param {EnumValue} dir
 */
CircularLayout.prototype.spacingLayout = function(vertices, sweep, start, dir) {
  var eRadius = this._eRadius;
  var yRadius = this._yRadius;
  var eSpacing = this._eSpacing;
  var theta = start * Math.PI / 180;
  var num = vertices.length;
  for (var i = 0; i < num; i++) {
    var curr = vertices.elt(i);
    var next = vertices.elt(i === num - 1 ? 0 : i + 1);
    var x = eRadius * Math.cos(theta);
    var y = yRadius * Math.sin(theta);
    curr.centerX = x;
    curr.centerY = y;
    curr.actualAngle = theta * 180 / Math.PI;
    if (isNaN(curr.diameter)) curr.computeDiameter(0);
    if (isNaN(next.diameter)) next.computeDiameter(0);
    var meandiam = (curr.diameter + next.diameter) / 2;
    var thetachange = this.ellipseAngle(eRadius, yRadius, dir === CircularLayout.Clockwise ? theta : -theta, meandiam + eSpacing);
    theta += dir === CircularLayout.Clockwise ? thetachange : -thetachange;
  }
};

/**
 * @ignore
 * Arranges the items so the distance between any item and
 * an adjacent item is the same.
 * @this {CircularLayout}
 * @param {List} vertices
 * @param {number} sweep
 * @param {number} start
 * @param {EnumValue} dir
 */
CircularLayout.prototype.distanceLayout = function(vertices, sweep, start, dir) {
  var eRadius = this._eRadius;
  var yRadius = this._yRadius;
  var constDist = this._constDist;
  var theta = start * Math.PI / 180;
  var num = vertices.length;
  for (var i = 0; i < num; i++) {
    var cv = vertices.elt(i);
    cv.centerX = eRadius * Math.cos(theta);
    cv.centerY = yRadius * Math.sin(theta);
    cv.actualAngle = theta * 180 / Math.PI;
    var thetachange = this.ellipseAngle(eRadius, yRadius, dir === CircularLayout.Clockwise ? theta : -theta, constDist);
    theta += dir === CircularLayout.Clockwise ? thetachange : -thetachange;
  }
};

/**
* @ignore
* Arranges the items so the spacing between any item and
* an adjacent item is the same, but takes into account the assumption
* that the nodes are rectangular.
* @this {CircularLayout}
* @param {List} vertices
* @param {number} sweep
* @param {number} start
* @param {EnumValue} dir
*/
CircularLayout.prototype.packedLayout = function(vertices, sweep, start, dir) {
  var correctLastAngle = this._correctLastAngle;
  var eSweepAngle = this._eSweepAngle;

  this._packedIters = 0;
  this._vertexArrangement = new VertexArrangement();

  if (sweep < 360) {
    correctLastAngle = start + (dir === CircularLayout.Clockwise ? eSweepAngle : -eSweepAngle);
    while (correctLastAngle < 0) { correctLastAngle += 360; }
    correctLastAngle %= 360;
    if (correctLastAngle > 180) { correctLastAngle -= 360; }
    correctLastAngle *= Math.PI / 180;
    this._correctLastAngle = correctLastAngle;
    this.packedLayoutSemi(vertices, sweep, start, dir);
  } else {
    this.packedLayoutFull(vertices, sweep, start, dir);
  }
  this._vertexArrangement.commit(vertices);
  return;
};

/**
* @ignore
* Assume a 360 degree sweep.
* @this {CircularLayout}
* @param {List} vertices
* @param {number} sweep
* @param {number} start
* @param {EnumValue} dir
*/
CircularLayout.prototype.packedLayoutFull = function(vertices, sweep, start, dir) {
  var eRadius = this._eRadius;
  var yRadius = this._yRadius;
  var eSpacing = this._eSpacing;
  var eAspectRatio = this._eAspectRatio;

  // do layout
  var x = eRadius * Math.cos(start * Math.PI / 180);
  var y = yRadius * Math.sin(start * Math.PI / 180);
  var verts = vertices.toArray();

  if (verts.length === 3) {
    verts[0].centerX = eRadius * Math.cos(0);
    verts[0].centerY = yRadius * Math.sin(0);
    verts[1].centerX = verts[0].centerX - verts[0].width / 2 - verts[1].width / 2 - eSpacing;
    verts[1].y = verts[0].y;
    verts[2].centerX = (verts[0].centerX + verts[1].centerX) / 2;
    verts[2].y = verts[0].y - verts[2].height - eSpacing;
    return;
  } else if (verts.length === 4) {
    verts[0].centerX = eRadius * Math.cos(0);
    verts[0].centerY = yRadius * Math.sin(0);
    verts[2].centerX = -verts[0].centerX;
    verts[2].centerY = verts[0].centerY;
    verts[1].centerX = 0;
    verts[1].y = Math.min(verts[0].y, verts[2].y) - verts[1].height - eSpacing;
    verts[3].centerX = 0;
    verts[3].y = Math.max(verts[0].y + verts[0].height + eSpacing, verts[2].y + verts[2].height + eSpacing);
    return;
  }

  for (var v = 0; v < verts.length; v++) {
    verts[v].centerX = x;
    verts[v].centerY = y;

    if (v >= verts.length - 1) break; // avoid index out of bounds
    var resultsArr = this.nexth(x, y, verts, v, dir);
    if (!resultsArr[0]) {
      resultsArr = this.nextv(x, y, verts, v, dir);
    }
    x = resultsArr[1];
    y = resultsArr[2];
    //Util.freeArray(resultsArr);
  }

  // check for gap, find gap sizes
  this._packedIters++;
  if (this._packedIters > 23) return;
  var locfx = verts[0].centerX;
  var locfy = verts[0].centerY;
  var loclx = verts[verts.length - 1].centerX;
  var locly = verts[verts.length - 1].centerY;
  var gapx = Math.abs(locfx - loclx) - ((verts[0].width + verts[verts.length - 1].width) / 2 + eSpacing);
  var gapy = Math.abs(locfy - locly) - ((verts[0].height + verts[verts.length - 1].height) / 2 + eSpacing);

  // compute gap
  var gap = 0;
  if (Math.abs(gapy) < 1) {
    var hgap = Math.abs(locfx - loclx);
    var max = (verts[0].width + verts[verts.length - 1].width) / 2;
    if (hgap < max) gap = 0;
    gapx = hgap - max;
  } else {
    // gapy not 0
    if (gapy > 0) {
      gap = gapy;
    } else {
      if (Math.abs(gapx) < 1) {
        gap = 0;
      } else {
        gap = gapx;
      }
    }
  }

  // check for excessive overlap
  var overlap = false;
  if (Math.abs(loclx) > Math.abs(locly)) {
    // use x
    overlap = (loclx > 0) !== (locfy > locly);
  } else {
    // use y
    overlap = (locly > 0) !== (locfx < loclx);
  }
  overlap = dir === CircularLayout.Clockwise ? overlap : !overlap;

  // if there's an excessive overlap, gap must be <0
  if (overlap) {
    gap = -Math.abs(gap);

    gap = Math.min(gap, -verts[verts.length - 1].width);
    gap = Math.min(gap, -verts[verts.length - 1].height);
  }

  // record this
  this._vertexArrangement.compare(gap, verts);

  // change radii accordingly
  if (Math.abs(gap) > 1) {
    if (this._packedIters < 8) {
      this._eRadius -= gap / (2 * Math.PI);
    } else {
      if (verts.length < 5 && gap > 10) {
        this._eRadius /= 2;
      } else {
        this._eRadius -= (gap > 0 ? 1.7 : -2.3);
      }
    }
    this._yRadius = this._eRadius * eAspectRatio;
    this.packedLayoutFull(vertices, sweep, start, dir);
  }
};

/**
* @ignore
* Assume less than 360 degree sweep.
* @this {CircularLayout}
* @param {List} vertices
* @param {number} sweep
* @param {number} start
* @param {EnumValue} dir
*/
CircularLayout.prototype.packedLayoutSemi = function(vertices, sweep, start, dir) {
  var eRadius = this._eRadius;
  var yRadius = this._yRadius;
  var eAspectRatio = this._eAspectRatio;

  // do layout
  var x = eRadius * Math.cos(start * Math.PI / 180);
  var y = yRadius * Math.sin(start * Math.PI / 180);
  var verts = vertices.toArray();
  for (var v = 0; v < verts.length; v++) {
    verts[v].centerX = x;
    verts[v].centerY = y;

    if (v >= verts.length - 1) break;  // avoid index out of bounds

    var resultsArr = this.nexth(x, y, verts, v, dir);
    if (!resultsArr[0]) {
      resultsArr = this.nextv(x, y, verts, v, dir);
    }
    x = resultsArr[1];
    y = resultsArr[2];
    //Util.freeArray(resultsArr);
  }

  // check for gap, find gap sizes
  this._packedIters++;
  if (this._packedIters > 23) return;

  // compute gap
  var lastangle = Math.atan2(y, x);
  var diff = dir === CircularLayout.Clockwise ? this._correctLastAngle - lastangle : lastangle - this._correctLastAngle;
  diff = Math.abs(diff) < Math.abs(diff - 2 * Math.PI) ? diff : diff - 2 * Math.PI;
  var gap = diff * (eRadius + yRadius) / 2;

  // record this
  this._vertexArrangement.compare2(gap, verts);

  // change radii accordingly
  if (Math.abs(gap) > 1) {
    if (this._packedIters < 8) {
      this._eRadius -= gap / (2 * Math.PI);
    } else {
      this._eRadius -= (gap > 0 ? 1.7 : -2.3);
    }
    this._yRadius = this._eRadius * eAspectRatio;
    this.packedLayoutSemi(vertices, sweep, start, dir);
  }
};

/**
* @ignore
* Finds the coords. of the next item in the PackedLayout if it's
* added horizontally.
* @this {CircularLayout}
* @param {number} x
* @param {number} y
* @param {Array.<CircularVertex>} verts
* @param {number} v
* @param {EnumValue} dir
* @return {Array}
*/
CircularLayout.prototype.nexth = function(x, y, verts, v, dir) {
	var eSpacing = this._eSpacing;
	var eRadius = this._eRadius;
	var yRadius = this._yRadius;

	var newx = 0;
	var newy = 0;
	var delta = (verts[v].width + verts[v + 1].width) / 2 + eSpacing;
	var inv = false;
	if ((y >= 0) !== (dir === CircularLayout.Clockwise)) {
		// x increases
		newx = x + delta;
		if (newx > eRadius) {
			// x decreases
			newx = x - delta;
			if (newx < -eRadius) {
			  var result = [];  //Util.tempArray(3);
        result[0] = false;
        result[1] = newx;
        result[2] = newy;
        return result;
			}
			inv = true;
		}
	} else {
		// x decreases
		newx = x - delta;
		if (newx < -eRadius) {
			newx = x + delta;
			if (newx > eRadius) {
			  var result = [];  //Util.tempArray(3);
			  result[0] = false;
			  result[1] = newx;
			  result[2] = newy;
			  return result;
			}
			inv = true;
		}
	}

	newy = Math.sqrt(1 - Math.min(1, newx * newx / (eRadius * eRadius))) * yRadius;
	if ((y < 0) !== inv) {
		newy = -newy;
	}
	if (Math.abs(y - newy) > (verts[v].height + verts[v + 1].height) / 2) {
	  var result = [];  //Util.tempArray(3);
	  result[0] = false;
	  result[1] = newx;
	  result[2] = newy;
	  return result;
	} else {
	  var result = [];  //Util.tempArray(3);
	  result[0] = true;
	  result[1] = newx;
	  result[2] = newy;
	  return result;
	}
};

/**
* @ignore
* Finds the coords. of the next item in the PackedLayout if it's
* added vertically.
* @this {CircularLayout}
* @param {number} x
* @param {number} y
* @param {Array.<CircularVertex>} verts
* @param {number} v
* @param {EnumValue} dir
* @return {Array}
*/
CircularLayout.prototype.nextv = function(x, y, verts, v, dir) {
	var eSpacing = this._eSpacing;
	var eRadius = this._eRadius;
	var yRadius = this._yRadius;

	var newx = 0;
	var newy = 0;
  var delta = (verts[v].height + verts[v + 1].height) / 2 + eSpacing;
	var inv = false; //true if it changes sides
	if ((x >= 0) !== (dir === CircularLayout.Clockwise)) {
		// y decreases
		newy = y - delta;
		if (newy < -yRadius) {
			// y increases
			newy = y + delta;
			if (newy > yRadius) {
			  var result = [];  //Util.tempArray(3);
			  result[0] = false;
			  result[1] = newx;
			  result[2] = newy;
			  return result;
			}
			inv = true;
		}
	} else {
		// y increases
		newy = y + delta;
		if (newy > yRadius) {
			// y decreases
			newy = y - delta;
			if (newy < -yRadius) {
			  var result = [];  //Util.tempArray(3);
			  result[0] = false;
			  result[1] = newx;
			  result[2] = newy;
			  return result;
			}
			inv = true;
		}
	}

	newx = Math.sqrt(1 - Math.min(1, newy * newy / (yRadius * yRadius))) * eRadius;
	if ((x < 0) !== inv) {
		newx = -newx;
	}
	if (Math.abs(x - newx) > (verts[v].width + verts[v + 1].width) / 2) {
	  var result = [];  //Util.tempArray(3);
	  result[0] = false;
	  result[1] = newx;
	  result[2] = newy;
	  return result;
	} else {
	  var result = [];  //Util.tempArray(3);
	  result[0] = true;
	  result[1] = newx;
	  result[2] = newy;
	  return result;
	}
};

/**
* @ignore
* @constructor
* @class
*/
function VertexArrangement() {
  /** @ignore @type {number} */
  this.gap = -Infinity;
  /** @ignore @type {Array.<number>} */
	this.xcoords = null;
	/** @ignore @type {Array.<number>} */
	this.ycoords = null;
}

/**
* @ignore
* Compares a new gap with the current one.  If it's better, it updates gap, xcoords, and ycoords.
* This is for a full sweep, where overshooting (gap less than 0) is worse than undershooting (gap > 0)
* because it will cause nodes to overlap.
* @this {VertexArrangement}
* @param {number} gap
* @param {Array.<CircularVertex>} verts
*/
VertexArrangement.prototype.compare = function(gap, verts) {
	if ((gap > 0 && this.gap < 0) || (Math.abs(gap) < Math.abs(this.gap) && !(gap < 0 && this.gap > 0))) {
		this.gap = gap;
		this.xcoords = [];
		this.ycoords = [];
		for (var i = 0; i < verts.length; i++) {
			this.xcoords[i] = verts[i].bounds.x;
			this.ycoords[i] = verts[i].bounds.y;
		}
	}
};

/**
* @ignore
* Compares a new gap with the current one.  If it's better, it updates gap, xcoords, and ycoords.
* This is for a partial sweep, where overshooting (gap less than 0) is no worse than undershooting (gap > 0).
* @this {VertexArrangement}
* @param {number} gap
* @param {Array.<CircularVertex>} verts
*/
VertexArrangement.prototype.compare2 = function(gap, verts) {
	if (Math.abs(gap) < Math.abs(this.gap)) {
		this.gap = gap;
		this.xcoords = [];
		this.ycoords = [];
		for (var i = 0; i < verts.length; i++) {
			this.xcoords[i] = verts[i].bounds.x;
			this.ycoords[i] = verts[i].bounds.y;
		}
	}
};

/**
* @ignore
* Set the vertices in verts to the correct positions.
* @this {VertexArrangement}
* @param {List} verts
*/
VertexArrangement.prototype.commit = function(verts) {
  if (this.xcoords === null || this.ycoords === null) return;
  for (var i = 0; i < this.xcoords.length; i++) {
    //verts.elt(i).position = new Point(this.xcoords[i], this.ycoords[i]);
    var v = verts.elt(i);
    v.x = this.xcoords[i];
    v.y = this.ycoords[i];
  }
};

/**
* Position each {@link Node} according to the Vertex position, and then position the {@link Link}s.
* <p/>
* You should not call this method -- it is a "protected virtual" method.
* @this {CircularLayout}
*/
CircularLayout.prototype.commitLayout = function() {
  this.commitNodes();
	if (this.isRouting) this.commitLinks();
};

/**
* Commit the position of all vertex nodes.
* @expose
* @this {CircularLayout}
*/
CircularLayout.prototype.commitNodes = function() {
  var center = this.actualCenter;
  var vit = this.network.vertexes.iterator;
  var v;
  while (vit.next()) {
    v = vit.value;
    v.x += center.x;
    v.y += center.y;
    v.commit();
  }
};

/**
* Commit the position and routing of all edge links.
* This is called by {@link #commitLayout}.
* This is only called if {@link Layout#isRouting} is true.
* @expose
* @this {CircularLayout}
*/
CircularLayout.prototype.commitLinks = function() {
  var eit = this.network.edges.iterator;
  while (eit.next()) {
    var e = eit.value;
    e.commit();
  }
};

/**
* @ignore
* Finds the perimeter of an ellipse with radii a and b.
* @this {CircularLayout}
* @param {number} a
* @param {number} b
* @param {number=} theta0
* @param {number=} sweep
* @return {number}
*/
CircularLayout.prototype.ellipsePerim = function(a, b, theta0, sweep) {
  var riemannnum = this._riemannnum;
	// circular case
	if (Math.abs(this._eAspectRatio - 1) < .001) {
	  if (theta0 !== undefined/*notpresent*/ && sweep !== undefined/*notpresent*/) return sweep * a;
		return 2 * Math.PI * a;
	}

	var e = a > b ? Math.sqrt(a * a - b * b) / a : Math.sqrt(b * b - a * a) / b; // eccentricity
	var integral = 0;
	var wid;
	if (theta0 !== undefined/*notpresent*/ && sweep !== undefined/*notpresent*/) {
		wid = sweep / (riemannnum + 1);
	} else {
		wid = Math.PI / (2 * (riemannnum + 1));
	}
	for (var i = 0; i <= riemannnum; i++) {
		var theta;
		if (theta0 !== undefined/*notpresent*/ && sweep !== undefined/*notpresent*/) {
			theta = theta0 + i * sweep / riemannnum;
		} else {
			theta = i * Math.PI / (2 * riemannnum);
		}
		var sin = Math.sin(theta);
		integral += Math.sqrt(1 - e * e * sin * sin) * wid;
	}
  if (theta0 !== undefined/*notpresent*/ && sweep !== undefined/*notpresent*/) return (a > b ? a : b) * integral;
	return 4 * (a > b ? a : b) * integral;
};

/**
* @ignore
* @this {CircularLayout}
*/
CircularLayout.prototype.inverseEllipsePerim = function(circ, asprat, theta0, sweep) {
  var perim1;
  if (theta0 !== undefined/*notpresent*/ && sweep !== undefined/*notpresent*/) {
		perim1 = this.ellipsePerim(1, asprat, theta0, sweep);
	} else {
		perim1 = this.ellipsePerim(1, asprat);
	}
  return circ / perim1;
};

/**
* @ignore
* Returns the angle of an elliptical arc of specified length.
* @this {CircularLayout}
* @param {number} a
* @param {number} b
* @param {number} theta0
* @param {number} length
* @return {number}
*/
CircularLayout.prototype.ellipseAngle = function(a, b, theta0, length) {
  if (Math.abs(this._eAspectRatio - 1) < .001) return length / a; // just added *****

  var e = a > b ? Math.sqrt(a * a - b * b) / a : Math.sqrt(b * b - a * a) / b; // eccentricity
  var integral = 0;
  var wid = (2 * Math.PI) / (this.network.vertexes.count * 700);
  if (a > b) { theta0 += Math.PI / 2; }
  for (var i = 0;; i++) {
    var theta = theta0 + i * wid;
    var sin = Math.sin(theta);
    integral += (a > b ? a : b) * Math.sqrt(1 - e * e * sin * sin) * wid;
    if (integral >= length) {
      return i * wid;
    }
  }
  return 0;
};

/**
* @ignore
* @this {CircularLayout}
* @param {List} vertices
* @return {List}
*/
CircularLayout.prototype.sort = function(vertices) {
  switch (this.sorting) {
    case CircularLayout.Forwards: break;
    case CircularLayout.Reverse: vertices.reverse(); break;
    case CircularLayout.Ascending: vertices.sort(this.comparer); break;
    case CircularLayout.Descending: vertices.sort(this.comparer); vertices.reverse(); break;
    case CircularLayout.Optimized: return this.optimize(this.connectivityArrange(vertices));
    default: Util.throwError('Invalid sorting type.');
  }
  return vertices;
};

/**
* @ignore
* Sort the nodes based on connectivity. The first node is the one with the highest connectivity, and
* each subsequent node is the one with the greatest number of links to nodes already in the list.
* This is used for cross reduction before optimize is called to make cross reduction more effective.
* @this {CircularLayout}
* @param {List} l
* @return {List}
*/
CircularLayout.prototype.connectivityArrange = function(l) {
  var conns = [];
  for (var i = 0; i < l.length; i++) {
    conns.push(0);
  }
  var res = new List(CircularVertex);
  for (var i = 0; i < l.length; i++) {
    var maxconn = -1;
    var maxind = -1;
    if (i === 0) {
      for (var j = 0; j < l.length; j++) {
        var vtx = l.elt(j);
        //var nconn = vtx.sourceEdges.count + vtx.destinationEdges.count;
        var nconn = vtx.edgesCount;
        if (nconn > maxconn) {
          maxconn = nconn;
          maxind = j;
        }
      }
    } else {
      for (var j = 0; j < l.length; j++) {
        var nconn = conns[j];
        if (nconn > maxconn) {
          maxconn = nconn;
          maxind = j;
        }
      }
    }
    res.add(l.elt(maxind));
    conns[maxind] = -1;

    var v = l.elt(maxind);
    var seit = v.sourceEdges;
    var deit = v.destinationEdges;
    var e;
    var f;
    var ind;
    while (seit.next()) {
      e = seit.value;
      f = e.fromVertex;
      ind = l.indexOf(f);
      if (ind < 0) continue;
      if (conns[ind] >= 0) conns[ind]++;
    }
    while (deit.next()) {
      e = deit.value;
      f = e.toVertex;
      ind = l.indexOf(f);
      if (ind < 0) continue;
      if (conns[ind] >= 0) conns[ind]++;
    }
  }
  return res;
};

/**
* @ignore
* Sorts the nodes to avoid crossing links.
* @this {CircularLayout}
* @param {List} v
* @return {List}
*/
CircularLayout.prototype.optimize = function(v) {
  var linkswith = [];
  for (var i = 0; i < v.length; i++) {
    var n = v.elt(i);
    linkswith[i] = [];
    var deit = n.destinationEdges;
    var seit = n.sourceEdges;
    var l;
    var ind;
    while (deit.next()) {
      l = deit.value;
      ind = v.indexOf(l.toVertex);
      if (ind !== i && linkswith[i].indexOf(ind) < 0) linkswith[i].push(ind);
    }
    while (seit.next()) {
      l = seit.value;
      ind = v.indexOf(l.fromVertex);
      if (ind !== i && linkswith[i].indexOf(ind) < 0) linkswith[i].push(ind);
    }
  }

  var indexes = [];
  for (var i = 0; i < linkswith.length; i++) {
    indexes[i] = 0;
  }
  var opt = [];
  var links1 = [];
  var links2 = [];
  var monoconnected = [];
  var disconnected = new List(CircularVertex);

  for (var i = 0, j = 0; i < linkswith.length; i++) {
    var conns = linkswith[i].length;
    if (conns === 1) {
      monoconnected.push(i);
      continue;
    }
    if (conns === 0) {
      disconnected.add(v.elt(i));
      continue;
    }

    if (j === 0) {
      opt.push(i);
      j++;
      continue;
    }

    var mincrosses = Infinity;
    var mindist = Infinity;
    var minpos = -1;
    var newposses = [];
    for (var k = 0; k < opt.length; k++) {
      if (linkswith[opt[k]].indexOf(opt[k === opt.length - 1 ? 0 : k + 1]) < 0) {
        newposses.push(k === opt.length - 1 ? 0 : k + 1);
      }
    }
    if (newposses.length === 0) {
      for (var k = 0; k < opt.length; k++) {
        newposses.push(k);
      }
    }
    for (var k = 0; k < newposses.length; k++) {
      var newpos = newposses[k];
      var crosses = this.crossings(linkswith[i], links1, links2, indexes, newpos, opt);

      var dist = 0;
      for (var l = 0; l < linkswith[i].length; l++) {
        var conn = linkswith[i][l];
        var ind = opt.indexOf(conn);
        if (ind >= 0) {
          var absdist = Math.abs(newpos - (ind >= newpos ? ind + 1 : ind));
          dist += absdist < opt.length + 1 - absdist ? absdist : opt.length + 1 - absdist;
        }
      }
      for (var l = 0; l < links1.length; l++) {
        var a = indexes[links1[l]];
        var b = indexes[links2[l]];  // a < b
        if (a >= newpos) a++;
        if (b >= newpos) b++;
        if (a > b) {
          var c = b;
          b = a;
          a = c;

        }
        if ((b - a < (opt.length + 2) / 2) === (a < newpos && newpos <= b)) {
          dist++;
        }
      }

      if (crosses < mincrosses || (crosses === mincrosses && dist < mindist)) {
        mincrosses = crosses;
        mindist = dist;
        minpos = newpos;
      }
    }
    opt.splice(minpos, 0, i);

    // update indexes
    for (var k = 0; k < opt.length; k++) {
      indexes[opt[k]] = k;
    }

    // update links
    for (var k = 0; k < linkswith[i].length; k++) {
      var link = linkswith[i][k];
      if (opt.indexOf(link) >= 0) {
        links1.push(i);
        links2.push(link);
      }
    }
    j++;
  }

  // add monoconnected
  var done = false;
  var cnt = opt.length;
  while (true) {
    done = true;
    for (var n = 0; n < monoconnected.length; n++) {
      var i = monoconnected[n];
      var tonode = linkswith[i][0];
      var ind = opt.indexOf(tonode);
      if (ind >= 0) {
        // insert either before or after
        var low = 0;  // links to node at lower index
        for (var j = 0; j < linkswith[tonode].length; j++) {
          var link = linkswith[tonode][j];
          var linkind = opt.indexOf(link);
          if (linkind < 0 || linkind === ind) continue;
          var d1 = linkind > ind ? linkind - ind : ind - linkind;
          var d2 = cnt - d1;
          low += ((linkind < ind) !== (d1 > d2)) ? 1 : -1;
        }
        opt.splice(low < 0 ? ind : ind + 1, 0, i);
        monoconnected.splice(n, 1);
        n--;
      } else {
        done = false;
      }
    }
    if (done) {
      break;
    } else {
      opt.push(monoconnected[0]);
      monoconnected.splice(0, 1);
    }
  }

  for (var i = 0; i < opt.length; i++) {
    var ind = opt[i];
    disconnected.add(v.elt(ind));
  }
  return disconnected;
};

/**
 * @ignore
 * Finds the number of link crossings added when a node is inserted at a specified index.
 * @this {CircularLayout}
 * @param {Array.<number>} newlinks
 * @param {Array.<number>} links1
 * @param {Array.<number>} links2
 * @param {Array.<number>} indexes
 * @param {number} node
 * @param {Array.<number>} opt
 * @return {number}
 */
CircularLayout.prototype.crossings = function(newlinks, links1, links2, indexes, node, opt) {
	var count = 0;
	for (var i = 0; i < links1.length; i++) {
		var l1 = links1[i];
		var l2 = links2[i];
		var l1pos = indexes[l1];
		var l2pos = indexes[l2];
		var c = 0;
		var d = 0;
		if (l1pos < l2pos) {
			c = l1pos;
			d = l2pos;
		} else {
			c = l2pos;
			d = l1pos;
		}
		// c < d

		if (c < node && node <= d) {
			// node between c and d
			for (var j = 0; j < newlinks.length; j++) {
				var link = newlinks[j];
				if (opt.indexOf(link) < 0) continue;
				if (!((c < indexes[link] && indexes[link] < d) || c === indexes[link] || d === indexes[link])) count++;
			}
		} else {
			// node not between c and d
			for (var j = 0; j < newlinks.length; j++) {
				var link = newlinks[j];
				if (opt.indexOf(link) < 0) continue;
				if (!(!(c < indexes[link] && indexes[link] < d) || c === indexes[link] || d === indexes[link])) count++;
			}
		}
	}
	return count;
};

/***************Properties***************/

/**
* Gets or sets the horizontal radius of the elliptical arrangement.
* <p/>
* The default value is NaN.
* NaN indicates that the {@link #spacing} will determine the size of the ring.
* If {@link #spacing} is also NaN, the effective spacing will be 6.
* If {@link #spacing} is a number, the effective radius will be > radius if and only if
* the spacing between elements would otherwise be less than spacing.
* The specified value for {@link #radius} will be ignored if {@link #arrangement} == {@link CircularLayout#Packed}.
* This property must always be positive or NaN.
* @name CircularLayout#radius
* @function.
* @return {number}
*/
/** @type {number} */
CircularLayout.prototype.radius;
Util.exportProperty(CircularLayout, 'radius', CircularLayout.prototype.radius);
Util.defineProperty(CircularLayout, { radius: 'radius' },
  /** @this {CircularLayout} */
	function() { return this._radius; },
  /** @this {CircularLayout} */
	function(val) {
	  if (this._radius !== val) {
	    if (val > 0 || isNaN(val)) {
	      this._radius = val;
	      this.invalidateLayout();
	    }
	  }
	}
);

/**
* Gets or sets the ratio of the arrangement's height to its width
* (1 for a circle, &gt;1 for a vertically elongated ellipse).
* <p/>
* This is 1 by default.
* The value must be a positive number.
* <p/>
* Modifying this value changes the height, but keeps the width and the {@link #radius} constant.
* @name CircularLayout#aspectRatio
* @function.
* @return {number}
*/
/** @type {number} */
CircularLayout.prototype.aspectRatio;
Util.exportProperty(CircularLayout, 'aspectRatio', CircularLayout.prototype.aspectRatio);
Util.defineProperty(CircularLayout, { aspectRatio: 'aspectRatio' },
	/** @this {CircularLayout} */
	function() { return this._aspectRatio; },
	/** @this {CircularLayout} */
	function(val) {
	  if (this._aspectRatio !== val) {
	    if (val > 0) {
	      this._aspectRatio = val;
	      this.invalidateLayout();
	    }
	  }
	}
);

/**
* Gets or sets the angle (in degrees, clockwise from the positive side of the X axis) of the first element.
* <p/>
* The default value is 0.
* @name CircularLayout#startAngle
* @function.
* @return {number}
*/
/** @type {number} */
CircularLayout.prototype.startAngle;
Util.exportProperty(CircularLayout, 'startAngle', CircularLayout.prototype.startAngle);
Util.defineProperty(CircularLayout, { startAngle: 'startAngle' },
	/** @this {CircularLayout} */
	function() { return this._startAngle; },
	/** @this {CircularLayout} */
	function(val) {
	  if (this._startAngle !== val) {
	    this._startAngle = val;
	    this.invalidateLayout();
	  }
	}
);

/**
* Gets or sets the absolute angle (in degrees) between the first and last node.
* <p/>
* The default value is 360.
* The value must be greater than zero and less than or equal to 360.
* If it is not in this range, it will be automatically set to 360.
* <p/>
* Whether the arrangement is clockwise or counterclockwise does not depend on the sign of this value.
* The direction can be controlled by setting {@link #direction}.
* If 360 is the specified value, the actual value will be less to keep the first and last
* elements from overlapping, and the spacing between the first and last nodes will be determined
* the same way as for all other adjacent nodes.
* @name CircularLayout#sweepAngle
* @function.
* @return {number}
*/
/** @type {number} */
CircularLayout.prototype.sweepAngle;
Util.exportProperty(CircularLayout, 'sweepAngle', CircularLayout.prototype.sweepAngle);
Util.defineProperty(CircularLayout, { sweepAngle: 'sweepAngle' },
	/** @this {CircularLayout} */
	function() { return this._sweepAngle; },
	/** @this {CircularLayout} */
	function(val) {
	  if (this._sweepAngle !== val) {
	    if (val > 0 && val <= 360) {
	      this._sweepAngle = val;
	    } else {
	      this._sweepAngle = 360;
	    }
	    this.invalidateLayout();
	  }
	}
);

/**
* Gets or sets how the nodes are spaced.
* If {@link #arrangement} == {@link CircularLayout#Packed},
* the specified {@link #radius} will be ignored.
* <p/>
* The default value is {@link CircularLayout#ConstantSpacing}.
* @name CircularLayout#arrangement
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
CircularLayout.prototype.arrangement;
Util.exportProperty(CircularLayout, 'arrangement', CircularLayout.prototype.arrangement);
Util.defineProperty(CircularLayout, { arrangement: 'arrangement' },
  /** @this {CircularLayout} */
  function() { return this._arrangement; },
  /** @this {CircularLayout} */
  function(val) {
    if (this._arrangement !== val) {
      if (Debug) Util.checkClass(val, EnumValue, CircularLayout, 'arrangement');
      if (val === CircularLayout.Packed || val === CircularLayout.ConstantSpacing ||
          val === CircularLayout.ConstantDistance || val === CircularLayout.ConstantAngle) {
        this._arrangement = val;
        this.invalidateLayout();
      }
    }
  }
);

/**
* Gets or sets whether the nodes are arranged clockwise or counterclockwise.
* <p/>
* The default value is {@link CircularLayout#Clockwise}.
* @name CircularLayout#direction
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
CircularLayout.prototype.direction;
Util.exportProperty(CircularLayout, 'direction', CircularLayout.prototype.direction);
Util.defineProperty(CircularLayout, { direction: 'direction' },
  /** @this {CircularLayout} */
  function() { return this._direction; },
  /** @this {CircularLayout} */
  function(val) {
    if (this._direction !== val) {
      if (Debug) Util.checkClass(val, EnumValue, CircularLayout, 'direction');
      if (val === CircularLayout.Clockwise || val === CircularLayout.Counterclockwise ||
          val === CircularLayout.BidirectionalLeft || val === CircularLayout.BidirectionalRight) {
        this._direction = val;
        this.invalidateLayout();
      }
    }
  }
);

/**
* Gets or sets if and how the nodes are sorted.
* <p/>
* {@link CircularLayout#Forwards} indicates that the nodes are arranged in the order the layout gets them.
* {@link CircularLayout#Reverse} indicates that the nodes are arranged in the reverse order that the layout gets them.
* {@link CircularLayout#Ascending} and {@link CircularLayout#Descending} indicate that the nodes
* will be sorted using the {@link #comparer}.
* {@link CircularLayout#Optimized} indicates that the nodes will be arranged to minimize link crossings.
* <p/>
* The default value is {@link CircularLayout#Optimized}.
* @name CircularLayout#sorting
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
CircularLayout.prototype.sorting;
Util.exportProperty(CircularLayout, 'sorting', CircularLayout.prototype.sorting);
Util.defineProperty(CircularLayout, { sorting: 'sorting' },
  /** @this {CircularLayout} */
	function() { return this._sorting; },
  /** @this {CircularLayout} */
	function(val) {
	  if (this._sorting !== val) {
	    if (Debug) Util.checkClass(val, EnumValue, CircularLayout, 'sorting');
	    if (val === CircularLayout.Forwards || val === CircularLayout.Reverse ||
			    val === CircularLayout.Ascending || CircularLayout.Descending ||
          val === CircularLayout.Optimized) {
	      this._sorting = val;
	      this.invalidateLayout();
	    }
	  }
	}
);

/**
* Gets or sets the comparer which sorts the data when {@link #sorting} is
* set to {@link CircularLayout#Ascending} or {@link CircularLayout#Descending}.
* <p/>
* The default function compares the {@link Part#text} values of the vertexes' {@link LayoutVertex#node}s.
* @name CircularLayout#comparer
* @function.
* @return {function(CircularVertex, CircularVertex):number}
*/
/** @type {function(*, *):number} */
CircularLayout.prototype.comparer;
Util.exportProperty(CircularLayout, 'comparer', CircularLayout.prototype.comparer);
Util.defineProperty(CircularLayout, { comparer: 'comparer' },
	/** @this {CircularLayout} */
	function() { return this._comparer; },
	/** @this {CircularLayout} */
	function(val) {
	  if (this._comparer !== val) {
	    if (Debug) Util.checkPrimitive(val, 'function', CircularLayout, 'comparer');
	    this._comparer = val;
	    this.invalidateLayout();
	  }
	}
);

/**
* Gets or sets the distance between nodes (if {@link #radius} is NaN)
* or the minimum distance between nodes (if {@link #radius} is a number).
* <p/>
* The default value is 6.
* The value may be NaN.
* <p/>
* If {@link #spacing} is NaN, there is no minimum spacing, allowing nodes to overlap,
* unless {@link #radius} is NaN,
* in which case the effective spacing will be 6 to determine an effective radius.
* If {@link #spacing} is a number but {@link #radius} isn't,
* the effective spacing will be spacing, and this will determine the effective radius.
* If both {@link #spacing} and {@link #radius} are numbers,
* the effective radius will be at least {@link #radius},
* but may be larger so that the minimum spacing between nodes is {@link #spacing}.
* @name CircularLayout#spacing
* @function.
* @return {number}
*/
/** @type {number} */
CircularLayout.prototype.spacing;
Util.exportProperty(CircularLayout, 'spacing', CircularLayout.prototype.spacing);
Util.defineProperty(CircularLayout, { spacing: 'spacing' },
	/** @this {CircularLayout} */
	function() { return this._spacing; },
	/** @this {CircularLayout} */
	function(val) {
	  if (this._spacing !== val) {
	    this._spacing = val;
	    this.invalidateLayout();
	  }
	}
);

/**
* Specifies how the diameter of nodes will be calculated.
* When a node is not circular, it is not clear what its diameter is.
* <p/>
* The default is {@link CircularLayout#Pythagorean}.
* @name CircularLayout#nodeDiameterFormula
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
CircularLayout.prototype.nodeDiameterFormula;
Util.exportProperty(CircularLayout, 'nodeDiameterFormula', CircularLayout.prototype.nodeDiameterFormula);
Util.defineProperty(CircularLayout, { nodeDiameterFormula: 'nodeDiameterFormula' },
	/** @this {CircularLayout} */
	function() { return this._nodeDiameterFormula; },
	/** @this {CircularLayout} */
	function(val) {
	  if (this._nodeDiameterFormula !== val) {
	    if (Debug) Util.checkClass(val, EnumValue, CircularLayout, 'nodeDiameterFormula');
	    if (val === CircularLayout.Pythagorean || val === CircularLayout.Circular) {
	      this._nodeDiameterFormula = val;
	      this.invalidateLayout();
	    }
	  }
	}
);

/**
* Gets the effective X radius that may have been calculated by the layout.
* @name CircularLayout#actualXRadius
* @function.
* @return {number}
*/
/** @type {number} */
CircularLayout.prototype.actualXRadius;
Util.defineReadOnlyProperty(CircularLayout, { actualXRadius: 'actualXRadius' },
  /** @this {CircularLayout} */
  function() { return this._eRadius; }
);

/**
* Gets the effective Y radius that may have been calculated by the layout.
* @name CircularLayout#actualYRadius
* @function.
* @return {number}
*/
/** @type {number} */
CircularLayout.prototype.actualYRadius;
Util.defineReadOnlyProperty(CircularLayout, { actualYRadius: 'actualYRadius' },
  /** @this {CircularLayout} */
  function() { return this._yRadius; }
);

/**
* Gets the effective spacing that may have been calculated by the layout.
* @name CircularLayout#actualSpacing
* @function.
* @return {number}
*/
/** @type {number} */
CircularLayout.prototype.actualSpacing;
Util.defineReadOnlyProperty(CircularLayout, { actualSpacing: 'actualSpacing' },
  /** @this {CircularLayout} */
  function() { return this._eSpacing; }
);

/**
* Returns the coordinates of the center of the laid-out ellipse.
* @name CircularLayout#actualCenter
* @function.
* @return {Point}
*/
/** @type {Point} */
CircularLayout.prototype.actualCenter;
Util.defineReadOnlyProperty(CircularLayout, { actualCenter: 'actualCenter' },
  /** @this {CircularLayout} */
  function() {
    if (isNaN(this.arrangementOrigin.x) || isNaN(this.arrangementOrigin.y)) {
      return new Point(0, 0);  // if no arrangementOrigin, center at origin
    }
    return new Point(this.arrangementOrigin.x + this.actualXRadius, this.arrangementOrigin.y + this.actualYRadius);
  }
);

/***************Enums***************/

  // These values specify how nodes should be spaced in the ring.
  /**
  * The spacing between the idealized boundaries of the nodes is constant;
  * This value is used for {@link CircularLayout#arrangement}.
  * @name CircularLayout#ConstantSpacing
  * @constant
  * @static
  * @return {EnumValue}
  */
  CircularLayout['ConstantSpacing'] = CircularLayout.ConstantSpacing = Util.defineEnumValue(CircularLayout, 'ConstantSpacing', 0);

  /**
  * The distance between the centers of the nodes is constant;
  * This value is used for {@link CircularLayout#arrangement}.
  * @name CircularLayout#ConstantDistance
  * @constant
  * @static
  * @return {EnumValue}
  */
  CircularLayout['ConstantDistance'] = CircularLayout.ConstantDistance = Util.defineEnumValue(CircularLayout, 'ConstantDistance', 1);

  /**
  * The angular distance between the nodes is constant;
  * This value is used for {@link CircularLayout#arrangement}.
  * @name CircularLayout#ConstantAngle
  * @constant
  * @static
  * @return {EnumValue}
  */
  CircularLayout['ConstantAngle'] = CircularLayout.ConstantAngle = Util.defineEnumValue(CircularLayout, 'ConstantAngle', 2);

  /**
  * The vertices are arranged as close together as possible considering the {@link CircularLayout#spacing},
  * assuming the nodes are rectangular;
  * This value is used for {@link CircularLayout#arrangement}.
  * @name CircularLayout#Packed
  * @constant
  * @static
  * @return {EnumValue}
  */
  CircularLayout['Packed'] = CircularLayout.Packed = Util.defineEnumValue(CircularLayout, 'Packed', 3);

  // These values represent the direction in which the nodes fill the ring.
  /**
  * Rings are filled clockwise;
  * This value is used for {@link CircularLayout#direction}.
  * @name CircularLayout#Clockwise
  * @constant
  * @static
  * @return {EnumValue}
  */
  CircularLayout['Clockwise'] = CircularLayout.Clockwise = Util.defineEnumValue(CircularLayout, 'Clockwise', 4);

  /**
  * Rings are filled counterclockwise;
  * This value is used for {@link CircularLayout#direction}.
  * @name CircularLayout#Counterclockwise
  * @constant
  * @static
  * @return {EnumValue}
  */
  CircularLayout['Counterclockwise'] = CircularLayout.Counterclockwise = Util.defineEnumValue(CircularLayout, 'Counterclockwise', 5);

  /**
  * The ring is filled by alternating sides; the second node is counterclockwise from the first node;
  * This value is used for {@link CircularLayout#direction}.
  * @name CircularLayout#BidirectionalLeft
  * @constant
  * @static
  * @return {EnumValue}
  */
  CircularLayout['BidirectionalLeft'] = CircularLayout.BidirectionalLeft = Util.defineEnumValue(CircularLayout, 'BidirectionalLeft', 6);

  /**
  * The ring is filled by alternating sides; the second node is clockwise from the first node;
  * This value is used for {@link CircularLayout#direction}.
  * @name CircularLayout#BidirectionalRight
  * @constant
  * @static
  * @return {EnumValue}
  */
  CircularLayout['BidirectionalRight'] = CircularLayout.BidirectionalRight = Util.defineEnumValue(CircularLayout, 'BidirectionalRight', 7);

  // These values specify how to sort the nodes.
  /**
  * Nodes are arranged in the order given;
  * This value is used for {@link CircularLayout#sorting}.
  * @name CircularLayout#Forwards
  * @constant
  * @static
  * @return {EnumValue}
  */
  CircularLayout['Forwards'] = CircularLayout.Forwards = Util.defineEnumValue(CircularLayout, 'Forwards', 8);

  /**
  * Nodes are arranged in the reverse of the order given;
  * This value is used for {@link CircularLayout#sorting}.
  * @name CircularLayout#Reverse
  * @constant
  * @static
  * @return {EnumValue}
  */
  CircularLayout['Reverse'] = CircularLayout.Reverse = Util.defineEnumValue(CircularLayout, 'Reverse', 9);

  /**
  * Nodes are sorted using the {@link #comparer}, in ascending order;
  * This value is used for {@link CircularLayout#sorting}.
  * @name CircularLayout#Ascending
  * @constant
  * @static
  * @return {EnumValue}
  */
  CircularLayout['Ascending'] = CircularLayout.Ascending = Util.defineEnumValue(CircularLayout, 'Ascending', 10);

  /**
  * Nodes are sorted using the {@link #comparer}, in reverse ascending (descending) order;
  * This value is used for {@link CircularLayout#sorting}.
  * @name CircularLayout#Descending
  * @constant
  * @static
  * @return {EnumValue}
  */
  CircularLayout['Descending'] = CircularLayout.Descending = Util.defineEnumValue(CircularLayout, 'Descending', 11);

  /**
  * Nodes are ordered to reduce link crossings;
  * This value is used for {@link CircularLayout#sorting}.
  * @name CircularLayout#Optimized
  * @constant
  * @static
  * @return {EnumValue}
  */
  CircularLayout['Optimized'] = CircularLayout.Optimized = Util.defineEnumValue(CircularLayout, 'Optimized', 12);

  // These values specify a method for finding the size of a node.
  /**
  * The effective diameter is sqrt(width^2+height^2);
  * The corners of square nodes will touch at 45 degrees when {@link CircularLayout#spacing} is 0;
  * This value is used for {@link CircularLayout#nodeDiameterFormula}.
  * @name CircularLayout#Pythagorean
  * @constant
  * @static
  * @return {EnumValue}
  */
  CircularLayout['Pythagorean'] = CircularLayout.Pythagorean = Util.defineEnumValue(CircularLayout, 'Pythagorean', 13);

  /**
  * The effective diameter is either the width or height of the node, whichever is larger;
  * This will cause circular nodes to touch when {@link CircularLayout#spacing} is 0;
  * This is ideal when the nodes are circular.
  * This value is used for {@link CircularLayout#nodeDiameterFormula}.
  * @name CircularLayout#Circular
  * @constant
  * @static
  * @return {EnumValue}
  */
  CircularLayout['Circular'] = CircularLayout.Circular = Util.defineEnumValue(CircularLayout, 'Circular', 14);

/***************CircularNetwork***************/

/**
* @ignore
* @constructor
* @extends LayoutNetwork
* @category Layout
* @class
* This class represents an abstract graph of {@link CircularVertex}es and {@link CircularEdge}s
* that can be constructed based on the {@link Node}s and {@link Link}s of a {@link Diagram}
* so that the {@link CircularLayout} can operate independently of the diagram until it
* is time to commit any node positioning or link routing.
*/
function CircularNetwork() {
  LayoutNetwork.call(this);
}

Util.publish('CircularNetwork', CircularNetwork);

Util.inherit(CircularNetwork, LayoutNetwork);

/**
* @ignore
* Allocate a new instance of {@link CircularVertex}.
* @this {CircularNetwork}
* @return {LayoutVertex}
*/
CircularNetwork.prototype.createVertex = function() {
  return new CircularVertex();
};

/**
* @ignore
* Allocate a new instance of {@link CircularEdge}.
* @this {CircularNetwork}
* @return {LayoutEdge}
*/
CircularNetwork.prototype.createEdge = function() {
  return new CircularEdge();
};


/**
 * @constructor
 * @extends LayoutVertex
 * @category Layout
 * @class
 * This holds {@link CircularLayout}-specific information about {@link Node}s.
 */
function CircularVertex() {
  LayoutVertex.call(this);

  // circular-specific properties:

  /**
  * Gets or sets the value used as the vertex's diameter.
  * <p/>
  * By default the value depends on the {@link CircularLayout#arrangement} property.
  * Any computed value is cached, to avoid unnecessary expensive computations.
  * @name CircularVertex#diameter
  * @function.
  * @return {number}
  */
  /** @expose @type {number}
  */
  this.diameter = NaN;

  /**
  * Gets or sets the value used as the vertex's angle.
  * @name CircularVertex#actualAngle
  * @function.
  * @return {number}
  */
  /** @expose @type {number}
  */
  this.actualAngle = NaN;
}

Util.publish('CircularVertex', CircularVertex);

Util.inherit(CircularVertex, LayoutVertex);

/**
* @ignore
* Finds the effective diameter of this CircularVertex, which may depend on the angle
* at which the ellipse is being filled.
* @this {CircularVertex}
* @param {number} angle
* @return {number}
*/
CircularVertex.prototype.computeDiameter = function(angle) {
  var network = this.network;
  if (network === null) return NaN;
  var layout = network.layout;
  if (layout === null) return NaN;
  if (layout.arrangement === CircularLayout.Packed) {
    if (layout.nodeDiameterFormula === CircularLayout.Circular) {
      this.diameter = Math.max(this.width, this.height);
      return this.diameter;
    } else {
      var sin = Math.abs(Math.sin(angle));
      var cos = Math.abs(Math.cos(angle));
      if (sin === 0) return this.width;
      if (cos === 0) return this.height;
      this.diameter = Math.min(this.height / sin, this.width / cos);
      return this.diameter;
    }
  } else {
    if (layout.nodeDiameterFormula === CircularLayout.Circular) {
      this.diameter = Math.max(this.width, this.height);
      return this.diameter;
    } else {
      this.diameter = Math.sqrt(this.width * this.width + this.height * this.height);
      return this.diameter;
    }
  }
};


/**
* @constructor
* @extends LayoutEdge
* @category Layout
* @class
* This holds {@link CircularLayout}-specific information about {@link Link}s.
*/
function CircularEdge() {
  LayoutEdge.call(this);
  // no circular-specific properties
}

Util.publish('CircularEdge', CircularEdge);

Util.inherit(CircularEdge, LayoutEdge);

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
ForceDirectedLayout
ForceDirectedNetwork
ForceDirectedVertex
ForceDirectedEdge
*/

/**
 * Constructs a {@link ForceDirectedLayout} with no {@link Layout#network}
 * and with no owning {@link Layout#diagram}.
 * @constructor
 * @extends Layout
 * @category Layout
 * @class
 * Force-directed layout treats the graph as if it were a system of physical
 * bodies with forces acting on them and between them.
 * The algorithm seeks a configuration of the bodies with locally minimal energy,
 * i.e. vertex positions such that the sum of the forces on each vertex is zero.
 * <p/>
 * This layout makes use of a {@link LayoutNetwork} of
 * {@link ForceDirectedVertex}es and {@link ForceDirectedEdge}s that normally
 * correspond to the {@link Node}s and {@link Link}s of the {@link Diagram}.
 */
function ForceDirectedLayout() {
  if (arguments.length > 0) {
    Util.throwError('ForceDirectedLayout constructor cannot take any arguments.');
  }
  Layout.call(this);
  /** @type {List} */
  this._vertexArray = null;
  /** @type {number} */
  this._iteration = 0;
  /** @type {Size} */
  this._arrangementSpacing = new Size(100, 100).freeze();
  /** @type {boolean} */
  this._arrangesToOrigin = false;
  /** @type {boolean} */
  this._setsPortSpots = true;
  /** @type {boolean} */
  this._comments = true;
  /** @type {number} */
  this._maxIterations = 100;
  /** @type {number} */
  this._epsilonDistance = 1;
  /** @type {number} */
  this._infinityDistance = 1000;
  /** @type {number} */
  this._defaultSpringStiffness = 0.05;
  /** @type {number} */
  this._defaultSpringLength = 50;
  /** @type {number} */
  this._defaultElectricalCharge = 150;
  /** @type {number} */
  this._defaultGravitationalMass = 0;
  /** @type {number} */
  this._defaultCommentSpringLength = 20;
  /** @type {number} */
  this._defaultCommentElectricalCharge = 25;
}

Util.publish('ForceDirectedLayout', ForceDirectedLayout);

Util.inherit(ForceDirectedLayout, Layout);

/**
* @ignore
* Copies properties to a cloned Layout.
* @this {ForceDirectedLayout}
* @param {Layout} copy
*/
ForceDirectedLayout.prototype.cloneProtected = function(copy) {
  Layout.prototype.cloneProtected.call(this, copy);
  // these are computed:
  //this._vertexArray
  //this._iteration
  copy._arrangementSpacing.assign(this._arrangementSpacing);
  copy._arrangesToOrigin = this._arrangesToOrigin;
  copy._setsPortSpots = this._setsPortSpots;
  copy._comments = this._comments;
  copy._maxIterations = this._maxIterations;
  copy._epsilonDistance = this._epsilonDistance;
  copy._infinityDistance = this._infinityDistance;
  copy._defaultSpringStiffness = this._defaultSpringStiffness;
  copy._defaultSpringLength = this._defaultSpringLength;
  copy._defaultElectricalCharge = this._defaultElectricalCharge;
  copy._defaultGravitationalMass = this._defaultGravitationalMass;
  copy._defaultCommentSpringLength = this._defaultCommentSpringLength;
  copy._defaultCommentElectricalCharge = this._defaultCommentElectricalCharge;
};

/**
* Create a new {@link LayoutNetwork} of {@link ForceDirectedVertex}es and {@link ForceDirectedEdge}s.
* @this {ForceDirectedLayout}
* @return {LayoutNetwork} a new {@link LayoutNetwork}.
*/
ForceDirectedLayout.prototype.createNetwork = function() {
  var net = new ForceDirectedNetwork();
  net.setLayout(this);
  return net;
};

/**
* Assign the positions of the vertexes in the network.
* @this {ForceDirectedLayout}
* @param {Diagram|Group|Iterable} coll A {@link Diagram} or a {@link Group} or a collection of {@link Part}s
*/
ForceDirectedLayout.prototype.doLayout = function(coll) {
  if (!coll) Util.throwError('Layout.doLayout(collection) argument must not be null but a Diagram, a Group, or an Iterable of Parts');
  if (this.network === null) {
    this.network = this.makeNetwork(coll);
  }

  var maxiter = this.maxIterations;
  if (this.network.vertexes.count > 0) {
    // Remove self-links from the input network.
    this.network.deleteSelfEdges();

    // Augment each node in the input network with
    //  ForceDirected auxilary data.
    var vit = this.network.vertexes.iterator;
    while (vit.next()) {
      var vertex = vit.value;
      // Record the charge of the node.
      vertex.charge = this.electricalCharge(vertex);
      // Record the mass of the node.
      vertex.mass = this.gravitationalMass(vertex);
    }

    // Augment each link in the input network with
    //  ForceDirected auxilary data.
    var eit = this.network.edges.iterator;
    while (eit.next()) {
      var edge = eit.value;
      // Record the stiffness of the link.
      edge.stiffness = this.springStiffness(edge);
      // Record the length of the link.
      edge.length = this.springLength(edge);
    }

    this._iteration = 0;
    if (this.needsClusterLayout()) {
      // split into subnetworks, plus the original network holding any singleton nodes
      var net = this.network;
      var subnets = net.splitIntoSubNetworks().iterator;
      // layout each subnetwork independently
      while (subnets.next()) {
        var subnet = subnets.value;
        this.network = subnet;
        this.initializeClustering();
        this.layoutClusters(0, maxiter);
      }
      this.network = net;
      // layout each subnetwork so that they don't overlap and are separated by InfinityDistance
      subnets.reset();
      this.arrangeConnectedGraphs(subnets, net);
      // merge back into original network
      subnets.reset();
      while (subnets.next()) {
        var subnet = subnets.value;
        var svit = subnet.vertexes.iterator;
        while (svit.next()) {
          var vertex = svit.value;
          net.addVertex(vertex);
        }
        var seit = subnet.edges.iterator;
        while (seit.next()) {
          var edge = seit.value;
          net.addEdge(edge);
        }
      }
    }
    // do normal force-directed calculations
    this.performIterations(maxiter);

    // Update the "physical" positions of the nodes and links.
    this.updateParts();
  }

  // restore in case of future re-use
  this._maxIterations = maxiter;
  this.network = null;
  this.isValidLayout = true;
};

/**
* @ignore
* Determines whether a clustering layout should be done before the regular force-directed layout.
* <p/>
* A clustering layout is useful when the graph is somewhat tree-like.
* @this {ForceDirectedLayout}
* @return {boolean}
*/
ForceDirectedLayout.prototype.needsClusterLayout = function() {
  if (this.network.vertexes.count < 3) return false;
  var count = 0;
  var i = 0;
  var vit = this.network.vertexes.iterator;
  vit.next();
  var r = vit.value._bounds;
  while (vit.next()) {
    var vertex = vit.value;
    var b = vertex._bounds;
    if (b.intersectsRect(r)) {
      count++;
      if (count > 1) return true;
    }
    if (i > 10) return false;  //???
    i++;
  }
  return false;
};

/**
* @ignore
* @this {ForceDirectedLayout}
* @param {LayoutNetwork} net
* @param {Rect} result
* @return {Rect}
*/
ForceDirectedLayout.prototype.computeBounds = function(net, result) {
  var first = true;
  var vit = net.vertexes.iterator;
  while (vit.next()) {
    var vertex = vit.value;
    if (first) {
      first = false;
      result.set(vertex._bounds);
    } else {
      result.unionRect(vertex._bounds);
    }
  }
  return result;
};

/**
* @ignore
* Determine how many additional force-directed layout iterations should occur for this clustered network.
* @this {ForceDirectedLayout}
* @param {number} level the recursion depth for clustered layout.
* @param {number} maxiter
* @return {number} a non-negative number that will be temporarily added to {@link #maxIterations}.
*/
ForceDirectedLayout.prototype.computeClusterLayoutIterations = function(level, maxiter) {
  if (Debug) {
    Util.checkRealNumber(level, ForceDirectedLayout, 'computeClusterLayoutIterations:level');
    Util.checkRealNumber(maxiter, ForceDirectedLayout, 'computeClusterLayoutIterations:maxiter');
  }
  return Math.max(Math.min(this.network.vertexes.count, maxiter*(level+1)/11.0), 10);  //??
};

/**
* @ignore
* @this {ForceDirectedLayout}
*/
ForceDirectedLayout.prototype.initializeClustering = function() {
  // assume self-links have already been removed
  var vit = this.network.vertexes.iterator;
  while (vit.next()) {
    var vertex = vit.value;
    var num = 0;
    var cit = vertex.vertexes;
    while (cit.next()) num++;
    vertex.numConnections = num;  // cache number of nodes connected to this node
    vertex.numInCluster = 1;
    vertex.clustereds = null;  // clear any internal state
    vertex.savedState = null;
  }
};

/**
* @ignore
* @this {ForceDirectedLayout}
* @param {number} level the recursion depth for clustered layout.
* @param {number} maxiter
*/
ForceDirectedLayout.prototype.layoutClusters = function(level, maxiter) {
  if (Debug) {
    Util.checkRealNumber(level, ForceDirectedLayout, 'layoutClusters:level');
    Util.checkRealNumber(maxiter, ForceDirectedLayout, 'layoutClusters:maxiter');
  }
  if (this.hasClusters(level)) {  // also sorts by # connections
    var oldInf = this._infinityDistance;
    this._infinityDistance *= (1.0 + 1.0 / (level + 1));  //??

    var oldnet = this.pushSubNetwork(level);
    var subiter = Math.max(0, this.computeClusterLayoutIterations(level, maxiter));
    this.maxIterations += subiter;
    this.layoutClusters(level + 1, maxiter);
    this.performIterations(subiter);
    this.popNetwork(oldnet, level);

    var varr = this._vertexArray;
    if (varr === null)
      varr = new List(ForceDirectedVertex);
    else
      varr.clear();
    varr.addAll(oldnet.vertexes);
    varr.sort(function(a, b) {
      if (a === null || b === null || a === b) return 0;
      return b.numConnections - a.numConnections;
    });
    var vit = varr.iterator;
    while (vit.next()) {
      var vertex = vit.value;
      this.surroundNode(vertex, level);
    }

    this._infinityDistance = oldInf;
  }
};

/**
* @ignore
* Determines if the a layer has clusters.
* A layer has clusters if it has more than one vertex with vertex.numConnections > 1.
* @this {ForceDirectedLayout}
* @param {number} level the recursion depth for clustered layout.
* @return {boolean}
*/
ForceDirectedLayout.prototype.hasClusters = function(level) {
  if (Debug) Util.checkRealNumber(level, ForceDirectedLayout, 'hasClusters:level');
  if (level > 10) return false;
  if (this.network.vertexes.count < 3) return false;  // redundant? since needsClusterLayout checks this
  if (this._vertexArray === null)
    this._vertexArray = new List(ForceDirectedVertex);
  else
    this._vertexArray.clear();
  this._vertexArray.addAll(this.network.vertexes);

  var varr = this._vertexArray;
  varr.sort(function(a, b) {
    if (a === null || b === null || a === b) return 0;
    return b.numConnections - a.numConnections;
  });
  var i = varr.count - 1;
  // the vertexes are now sorted in descending order by number of connections
  while (i >= 0 && varr._arr[i].numConnections <= 1) i--;
  var leaves = varr.count - i;  // leaves represents the number of vertexes for which numConnections > 1.
  return leaves > 1;
};

/**
* @ignore
* @this {ForceDirectedLayout}
* @param {number} level the recursion depth for clustered layout.
* @return {LayoutNetwork}
*/
ForceDirectedLayout.prototype.pushSubNetwork = function(level) {
  if (Debug) Util.checkRealNumber(level, ForceDirectedLayout, 'pushSubNetwork:level');
  var oldnet = this.network;
  var newnet = new ForceDirectedNetwork();
  // reparent multiply-connected nodes and their links
  // use this._vertexArray, the sorted List of the networks vertexes.
  var vit = this._vertexArray.iterator;
  while (vit.next()) {
    var vertex = vit.value;
    if (vertex.numConnections > 1) {
      newnet.addVertex(vertex);  // move to new network
      var info = {
        NumConnections: vertex.numConnections,
        Width: vertex.width,
        Height: vertex.height,
        FocusX: vertex._focus.x,
        FocusY: vertex._focus.y
      };  // save state
      if (vertex.savedState === null) vertex.savedState = new List();
      vertex.savedState.add(info);
      vertex.savedStateIndex = vertex.savedState.count - 1;
    } else {
      break;  // assume sorted (in hasClusters) by decreasing # connections
    }
  }
  var eit = oldnet.edges.iterator;
  while (eit.next()) {
    var edge = eit.value;
    if (edge.fromVertex.network === newnet && edge.toVertex.network === newnet) {
      newnet.addEdge(edge);  // move to new network
    } else if (edge.fromVertex.network === newnet) {
      var clus = edge.fromVertex.clustereds;
      if (clus === null) {
        clus = new List(ForceDirectedVertex);
        edge.fromVertex.clustereds = clus;
      }
      clus.add(edge.toVertex);  // add to other node's cluster
      edge.fromVertex.numConnections--;
      edge.fromVertex.numInCluster += edge.toVertex.numInCluster;
    } else if (edge.toVertex.network === newnet) {
      var clus = edge.toVertex.clustereds;
      if (clus === null) {
        clus = new List(ForceDirectedVertex);
        edge.toVertex.clustereds = clus;
      }
      clus.add(edge.fromVertex);  // add to other node's cluster
      edge.toVertex.numConnections--;
      edge.toVertex.numInCluster += edge.fromVertex.numInCluster;
    }
  }
  // relax the links connecting clustered nodes
  eit = newnet.edges.iterator;
  while (eit.next()) {
    var edge = eit.value;
    var num = edge.fromVertex.numInCluster + edge.toVertex.numInCluster;
    edge.length *= Math.max(1, Geo.sqrt(num / (4.0 * level + 1)));  //???
  }
  // pretend clustered nodes are larger
  vit = newnet.vertexes.iterator;
  while (vit.next()) {
    var vertex = vit.value;
    // update state
    var clus = vertex.clustereds;
    if (clus !== null && clus.count > 0) {
      var info = vertex.savedState._arr[vertex.savedState.count - 1];
      var cnt = info.NumConnections - vertex.numConnections;
      if (cnt <= 0) continue;
      var newarea = 0;
      var linklen = 0;
      for (var i = clus.count - cnt; i < clus.count; i++) {
        var v = clus._arr[i];
        // just check nodes connected directly to this node
        var edge = null;
        eit = v.edges.iterator;
        while (eit.next()) {
          var e = eit.value;
          if (e.getOtherVertex(v) === vertex) {
            edge = e;
            break;
          }
        }
        if (edge !== null) {
          //if (cnt > 4) edge.length *= Geo.sqrt(cnt/4.0);  //??
          linklen += edge.length;
          newarea += v.width*v.height;
        }
      }
      // update Bounds and Focus (maintaining Center)
      var ptx = vertex.centerX;
      var pty = vertex.centerY;
      var szw = vertex.width;
      var szh = vertex.height;
      var foc = vertex._focus;
      var area = szw * szh;
      if (area < 1) area = 1;
      var comp = Geo.sqrt((newarea + area + ((linklen * linklen * 4) / (cnt * cnt))) / area);  //??
      var fw = (comp - 1) * szw / 2;
      var fh = (comp - 1) * szh / 2;
      vertex.bounds = new Rect(ptx - foc.x - fw, pty - foc.y - fh, szw + fw * 2, szh + fh * 2);
      vertex.focus = new Point(foc.x + fw, foc.y + fh);
    }
  }
  this.network = newnet;
  return oldnet;
};

/**
* @ignore
* @this {ForceDirectedLayout}
* @param {LayoutNetwork} oldnet
* @param {number} level the recursion depth for clustered layout.
*/
ForceDirectedLayout.prototype.popNetwork = function(oldnet, level) {
  if (Debug) {
    Util.checkClass(oldnet, ForceDirectedNetwork, ForceDirectedLayout, 'popNetwork:oldnet');
    Util.checkRealNumber(level, ForceDirectedLayout, 'popNetwork:level');
  }
  var vit = this.network.vertexes.iterator;
  while (vit.next()) {
    var vertex = vit.value;
    vertex.network = oldnet;  // reparent node to old network; NOT: oldnet.addNode(node)
    // pop NumConnections & Bounds/Focus
    if (vertex.savedState !== null) {
      var idx = vertex.savedStateIndex;
      var info = vertex.savedState._arr[idx];
      vertex.numConnections = info.NumConnections;
      var w = info.Width;
      var h = info.Height;
      var focx = info.FocusX;
      var focy = info.FocusY;
      var ptx = vertex.centerX;
      var pty = vertex.centerY;
      // restore Size and Focus, adapting to new Center (if it had been moved)
      vertex.bounds = new Rect(ptx-focx, pty-focy, w, h);
      vertex.focus = new Point(focx, focy);
      vertex.savedStateIndex--;  // pop stack without losing StateInfos
    }
  }
  var eit = this.network.edges.iterator;
  while (eit.next()) {
    var edge = eit.value;
    edge.network = oldnet;  // reparent link to old network; NOT: oldnet.addLink(link);
    //?? restore edge.length
  }
  this.network = oldnet;
};

/**
* @ignore
* @this {ForceDirectedLayout}
* @param {LayoutVertex} vertex
* @param {number} level the recursion depth for clustered layout.
*/
ForceDirectedLayout.prototype.surroundNode = function(vertex, level) {
  if (Debug) {
    Util.checkClass(vertex, ForceDirectedVertex, ForceDirectedLayout, 'surroundNode:oldnet');
    Util.checkRealNumber(level, ForceDirectedLayout, 'surroundNode:level');
  }
  var clus = vertex.clustereds;
  if (clus === null || clus.count === 0) return;  // ignore non-clusters
  var centerX = vertex.centerX;
  var centerY = vertex.centerY;
  var width = vertex.width;
  var height = vertex.height;
  if (vertex.savedState !== null && vertex.savedState.count > 0) {
    var info = vertex.savedState._arr[0];
    width = info.Width;
    height = info.Height;
  }
  var radius = Geo.sqrt(width*width + height*height)/2;
  // where's it coming from? look at connected non-leaf nodes
  var external = false;
  var angle = 0;
  var count = 0;
  var externalcount = 0;
  var vit = vertex.vertexes.iterator;
  while (vit.next()) {
    var v = vit.value;
    if (v.numConnections <= 1) {
      count++;
    } else {
      external = true;
      externalcount++;
      angle += Math.atan2(vertex.centerY-v.centerY, vertex.centerX-v.centerX);
    }
  }
  if (count === 0) return;
  // average the angles to multi-connected node
  if (externalcount > 0) {
    angle /= externalcount;
  }
  // over what angle should they be laid out around the node
  var ang = 0;
  var offsetang = 0;
  if (external) {
    ang = Math.PI*2/(count+1);
  } else {
    ang = Math.PI*2/count;
  }
  if (count%2 === 0) offsetang = ang/2;
  // now position the leaf nodes around the node
  // reorder according to node size
  if (clus.count > 1) clus.sort(function(a, b) {
    if (a === null || b === null || a === b) return 0;
    return b.width*b.height - a.width*a.height;
  });
  var i = (count%2 === 0 ? 0 : 1);
  vit = clus.iterator;
  while (vit.next()) {
    var v = vit.value;
    if (v.numConnections > 1) continue;  // shouldn't happen?
    if (this.isFixed(v)) continue;
    // position satellite node according to distance given by link.length plus radii
    var edge = null;
    var eit = v.edges.iterator;
    while (eit.next()) {
      var e = eit.value;
      edge = e;
      break;
    }
    var w = v.width;
    var h = v.height;
    var r = Geo.sqrt(w*w + h*h)/2;
    var d = radius + edge.length + r;
    var a = angle + (ang*((i/2)>>1)+offsetang)*(i%2==0 ? 1 : -1);
    v.centerX = centerX + d * Math.cos(a);
    v.centerY = centerY + d * Math.sin(a);
    i++;
  }
};

/**
* @ignore
* @this {ForceDirectedLayout}
* @param {Iterable} subnets
* @param {LayoutNetwork} singletons
*/
ForceDirectedLayout.prototype.arrangeConnectedGraphs = function(subnets, singletons) {
  if (Debug) {
    Util.checkClass(singletons, ForceDirectedNetwork, ForceDirectedLayout, 'arrangeConnectedGraphs:singletons');
  }
  var spacing = this.arrangementSpacing;
  // how many subnetworks are there?
  var subnetcount = subnets.count;

  var first = true;
  var centerX = 0;  // first subnetwork's Center
  var centerY = 0;
  var fringe = Util.tempArray();
  for (var i = 0; i < subnetcount + singletons.vertexes.count + 2; i++) fringe[i] = null;
  var fringelen = 0;  // how many FRINGE points are valid
  subnets.reset();
  var bounds = Util.tempRect();
  while (subnets.next()) {
    var subnet = subnets.value;
    this.computeBounds(subnet, bounds);
    if (first) {
      first = false;
      centerX = bounds.x + bounds.width / 2;
      centerY = bounds.y + bounds.height / 2;
      fringe[0] = new Point(bounds.x + bounds.width + spacing.width, bounds.y);
      fringe[1] = new Point(bounds.x, bounds.y + bounds.height + spacing.height);
      fringelen = 2;
    } else {
      // place subnetwork somewhere closest to first subnetwork's center
      var idx = this.closestFringePoint(fringe, fringelen, centerX, centerY, bounds.width, bounds.height, spacing);
      var old = fringe[idx];
      var tr = new Point(old.x + bounds.width + spacing.width, old.y);
      var bl = new Point(old.x, old.y + bounds.height + spacing.height);
      // make room for additional fringe point
      if (idx + 1 < fringelen) fringe.splice(idx + 1, 0, null);
      fringe[idx] = tr;
      fringe[idx+1] = bl;
      fringelen++;
      // shift subnetwork to fit at OLD point
      var offx = old.x - bounds.x;
      var offy = old.y - bounds.y;
      var vit = subnet.vertexes.iterator;
      while (vit.next()) {
        var vertex = vit.value;
        vertex.centerX += offx;
        vertex.centerY += offy;
      }
    }
  }
  Util.freeRect(bounds);

  // place singletons
  var vit = singletons.vertexes.iterator;
  while (vit.next()) {
    var vertex = vit.value;
    var vb = vertex._bounds;
    if (fringelen < 2) {
      centerX = vb.x + vb.width / 2;
      centerY = vb.y + vb.height / 2;
      fringe[0] = new Point(vb.x + vb.width + spacing.width, vb.y);
      fringe[1] = new Point(vb.x, vb.y + vb.height + spacing.height);
      fringelen = 2;
      continue;
    }
    var idx = this.closestFringePoint(fringe, fringelen, centerX, centerY, vb.width, vb.height, spacing);
    var old = fringe[idx];
    var tr = new Point(old.x + vb.width + spacing.width, old.y);
    var bl = new Point(old.x, old.y + vb.height + spacing.height);
    // make room for additional fringe point
    if (idx + 1 < fringelen) fringe.splice(idx + 1, 0, null);
    fringe[idx] = tr;
    fringe[idx+1] = bl;
    fringelen++;
    vertex.centerX = old.x + vertex.width / 2;
    vertex.centerY = old.y + vertex.height / 2;
  }
  Util.freeArray(fringe);
};

/**
* @ignore
* @this {ForceDirectedLayout}
* @param {Array} fringe of Point
* @param {number} fringelen
* @param {number} centerx
* @param {number} centery
* @param {number} sizew
* @param {number} sizeh
* @param {Size} spacing
* @return {number}
*/
ForceDirectedLayout.prototype.closestFringePoint= function(fringe, fringelen, centerx, centery, sizew, sizeh, spacing) {
  var mindist = 9e19;
  var idx = -1;
  ANOTHER:
  for (var i = 0; i < fringelen; i++) {
    var p = fringe[i];
    var x = p.x-centerx;
    var y = p.y-centery;
    var sq = x*x+y*y;
    if (sq < mindist) {
      for (var j = i-1; j >= 0; j--) {
        if (fringe[j].y > p.y && fringe[j].x-p.x < sizew+spacing.width) continue ANOTHER;
      }
      for (var j = i+1; j < fringelen; j++) {
        if (fringe[j].x > p.x && fringe[j].y-p.y < sizeh+spacing.height) continue ANOTHER;
      }
      idx = i;
      mindist = sq;
    }
  }
  return idx;
};

/**
* @ignore
* Find associated objects to be positioned along with the {@link LayoutVertex#node}.
* <p/>
* This method is called for each vertex in the network, when {@link #comments} is true.
* The standard behavior is to look for {@link Node}s whose {@link Part#category}
* is "Comment" and that refer to the {@link LayoutVertex#node}.
* You may want to override this method in order to customize how any
* associated objects are found and how a new {@link ForceDirectedVertex}
* and {@link ForceDirectedEdge}
* are added to the network to represent the balloon comment.
* This method sets the new vertex's {@link ForceDirectedVertex#charge}
* to the value of {@link #defaultCommentElectricalCharge},
* and sets the new edge's {@link ForceDirectedEdge#length}
* to the value of {@link #defaultCommentSpringLength}.
* @this {ForceDirectedLayout}
* @param {LayoutVertex} v
*/
ForceDirectedLayout.prototype.addComments = function(v) {
  var node = v.node;
  if (node !== null) {
    var nit = node.findNodesConnected();
    while (nit.next()) {
      var comment = nit.value;
      if (comment.category !== 'Comment') continue;
      var cv = this.network.findVertex(comment);
      if (cv === null) {
        cv = this.network.addNode(comment);
        cv.charge = this._defaultCommentElectricalCharge;
        var edge = this.network.linkVertexes(v, cv, null);
        if (edge !== null) {
          edge.length = this._defaultCommentSpringLength;
        }
      }
    }
  }
};

/**
* @ignore
* Returns the distance between two vertexes.
* The default implementation considers the shortest distance between the two nodes.
* If the vertexes correspond to top-level parts, the width and height of the
* part is factored into the distance between the vertexes.
* If the vertexes do not correspond to parts, then the vertexes implicitly
* have a width and height of zero, and the distance is calculated.
* @this {ForceDirectedLayout}
* @param {LayoutVertex} vertexA
* @param {LayoutVertex} vertexB
* @return {number} the approximate distance between the two vertexes.
*/
ForceDirectedLayout.prototype.getNodeDistance = function(vertexA, vertexB) {
  if (Debug) {
    Util.checkClass(vertexA, ForceDirectedVertex, ForceDirectedLayout, 'getNodeDistance:vertexA');
    Util.checkClass(vertexB, ForceDirectedVertex, ForceDirectedLayout, 'getNodeDistance:vertexB');
  }
  var rA = vertexA._bounds;
  var rectAx = rA.x;
  var rectAy = rA.y;
  var rectAw = rA.width;
  var rectAh = rA.height;

  var rB = vertexB._bounds;
  var rectBx = rB.x;
  var rectBy = rB.y;
  var rectBw = rB.width;
  var rectBh = rB.height;

  if ((rectAx + rectAw) < rectBx) {
    if (rectAy > (rectBy + rectBh)) {
      var dx = rectAx + rectAw - rectBx;
      var dy = rectAy - rectBy - rectBh;
      return Geo.sqrt(dx*dx + dy*dy);
    }
    else if ((rectAy + rectAh) < rectBy) {
      var dx = rectAx + rectAw - rectBx;
      var dy = rectAy + rectAh - rectBy;
      return Geo.sqrt(dx*dx + dy*dy);
    }
    else {
      return rectBx - (rectAx + rectAw);
    }
  }
  else if (rectAx > (rectBx + rectBw)) {
    if (rectAy > (rectBy + rectBh)) {
      var dx = rectAx - rectBx - rectBw;
      var dy = rectAy - rectBy - rectBh;
      return Geo.sqrt(dx*dx + dy*dy);
    }
    else if ((rectAy + rectAh) < rectBy) {
      var dx = rectAx - rectBx - rectBw;
      var dy = rectAy + rectAh - rectBy;
      return Geo.sqrt(dx*dx + dy*dy);
    }
    else {
      return rectAx - (rectBx + rectBw);
    }
  }
  else {
    if (rectAy > (rectBy + rectBh)) {
      return rectAy - (rectBy + rectBh);
    }
    else if ((rectAy + rectAh) < rectBy) {
      return rectBy - (rectAy + rectAh);
    }
    else {
      // The two rectangles intersect.
      // Technically, could return 0.0, but that causes division
      //  by zero errors.  Instead, we return 0.1, which is smaller
      //  than any real distance between integer-coordinate points.
      //  Since the centers of the two rectangles are probably not
      //  the same, the forces between the nodes will point in some
      //  direction separating the nodes.
      return 0.1;
    }
  }
};

/**
* @ignore
* @this {ForceDirectedLayout}
* @param {number} num
*/
ForceDirectedLayout.prototype.performIterations = function(num) {
  if (Debug) Util.checkRealNumber(num, ForceDirectedLayout, 'performIterations:num');
  this._vertexArray = null;
  var end = this._iteration + num;
  while (this._iteration < end) {
    this._iteration++;
    // If no change occurred, solution found.
    if (!this.updatePositions()) break;
  }
  this._vertexArray = null;
};

/**
* @ignore
* Performs one iteration of the ForceDirected algorithm and updates the positions
* of the vertexes, but not the diagram's nodes.
* @this {ForceDirectedLayout}
* @return {boolean} returns true if additional iterations are needed to find a solution.
*/
ForceDirectedLayout.prototype.updatePositions = function() {
  if (this._vertexArray === null) {
    this._vertexArray = new List(ForceDirectedVertex);
    this._vertexArray.addAll(this.network.vertexes);
  }

  // Every node initially has no forces acting upon it.
  var vertexarray = this._vertexArray;
  if (vertexarray.count <= 0) return false;

  var firstnode = vertexarray._arr[0];
  firstnode.forceX = 0;
  firstnode.forceY = 0;
  var minx = firstnode.centerX;
  var maxx = minx;
  var miny = firstnode.centerY;
  var maxy = miny;
  for (var ni = 1; ni < vertexarray.count; ni++) {
    var vertex = vertexarray._arr[ni];
    vertex.forceX = 0;
    vertex.forceY = 0;
    var px = vertex.centerX;
    var py = vertex.centerY;
    minx = Math.min(minx, px);
    maxx = Math.max(maxx, px);
    miny = Math.min(miny, py);
    maxy = Math.max(maxy, py);
  }
  //  If there is a larger horizontal seperation than a vertical one,
  // sort the vertexes by horizontal position, else sort them by their
  // vertical positions.
  var sortedx = (maxx - minx > maxy - miny);
  if (sortedx) {
    vertexarray.sort(function(a, b) {
      if (a === null || b === null || a === b) return 0;
      return a.centerX - b.centerX;
    });
  } else {
    vertexarray.sort(function(a, b) {
      if (a === null || b === null || a === b) return 0;
      return a.centerY - b.centerY;
    });
  }

  var force = 0, forceX = 0, forceY = 0;
  // Calculate gravitational and electrical forces.
  for (var ni = 0; ni < vertexarray.count; ni++) {
    var vertexU = vertexarray._arr[ni];
    var NodeCenterUx = vertexU.centerX;
    var NodeCenterUy = vertexU.centerY;

    // Calculate the electrical forces in the X and Y directions.
    forceX = vertexU.charge * this.electricalFieldX(NodeCenterUx, NodeCenterUy);
    forceY = vertexU.charge * this.electricalFieldY(NodeCenterUx, NodeCenterUy);

    // Update the total forces acting upon the node.
    vertexU.forceX += forceX;
    vertexU.forceY += forceY;

    // Calculate the gravitational forces in the X and Y directions.
    forceX = vertexU.mass * this.gravitationalFieldX(NodeCenterUx, NodeCenterUy);
    forceY = vertexU.mass * this.gravitationalFieldY(NodeCenterUx, NodeCenterUy);

    // Update the total forces acting upon the node.
    vertexU.forceX += forceX;
    vertexU.forceY += forceY;

    // Scan through remaining nodes in the network.
    var infinity = this._infinityDistance;
    for (var posV = ni + 1; posV < vertexarray.count; posV++) {
      var vertexV = vertexarray._arr[posV];
      if (vertexV === vertexU) continue;
      var NodeCenterVx = vertexV.centerX;
      var NodeCenterVy = vertexV.centerY;

      if (Math.abs(NodeCenterUx - NodeCenterVx) > infinity) {
        if (sortedx) break;
        continue;
      }
      if (Math.abs(NodeCenterUy - NodeCenterVy) > infinity) {
        if (!sortedx) break;
        continue;
      }

      var dist = this.getNodeDistance(vertexU, vertexV);

      if (dist < 1) {
        // overlapping nodes
        if (NodeCenterUx > NodeCenterVx) {
          forceX = Math.abs(vertexV._bounds.right - vertexU._bounds.x);
          forceX = this.randNext(1 + forceX);
        } else if (NodeCenterUx < NodeCenterVx) {
          forceX = Math.abs(vertexV._bounds.x - vertexU._bounds.right);
          forceX = -this.randNext(1 + forceX);
        } else {
          var maxw = Math.max(vertexV.width, vertexU.width);
          forceX = this.randNext(1 + maxw) - maxw / 2;
        }
        if (NodeCenterUy > NodeCenterVy) {
          forceY = Math.abs(vertexV._bounds.bottom - vertexU._bounds.y);
          forceY = this.randNext(1 + forceY);
        } else if (NodeCenterUx < NodeCenterVx) {
          forceY = Math.abs(vertexV._bounds.y - vertexU._bounds.bottom);
          forceY = -this.randNext(1 + forceY);
        } else {
          var maxh = Math.max(vertexV.height, vertexU.height);
          forceY = this.randNext(1 + maxh) - maxh / 2;
        }
      } else {
        // Calculate the electrical force acting on the nodes.
        // There is no equivalent for gravitational force between vertexes because
        // among charged particles, the gravitational force is insignificant
        // when compared to the electrical force.
        force = -(vertexU.charge * vertexV.charge) / (dist * dist);

        // Calculate the electrical forces acting on the nodes in the X and Y directions.
        forceX = force * ((NodeCenterVx - NodeCenterUx) / dist);
        forceY = force * ((NodeCenterVy - NodeCenterUy) / dist);
      }

      // Update the total forces acting upon the nodes.
      vertexU.forceX += forceX;
      vertexU.forceY += forceY;
      vertexV.forceX -= forceX;
      vertexV.forceY -= forceY;
    }
  }

  // Calculate spring forces.
  var eit = this.network.edges.iterator;
  while (eit.next()) {
    var edge = eit.value;
    var vertexU = edge.fromVertex;
    var vertexV = edge.toVertex;
    var NodeCenterUx = vertexU.centerX;
    var NodeCenterUy = vertexU.centerY;
    var NodeCenterVx = vertexV.centerX;
    var NodeCenterVy = vertexV.centerY;

    var dist = this.getNodeDistance(vertexU, vertexV);

    if (dist < 1) {
      forceX = (NodeCenterUx > NodeCenterVx ? 1 : -1) * this.randNext(1 + Math.max(vertexV.width, vertexU.width));
      forceY = (NodeCenterUy > NodeCenterVy ? 1 : -1) * this.randNext(1 + Math.max(vertexV.height, vertexU.height));
    } else {
      // Calculate the spring force acting on the nodes.
      force = edge.stiffness * (dist - edge.length);

      // Calculate the spring forces acting on the nodes in the X and Y directions.
      forceX = force * ((NodeCenterVx - NodeCenterUx) / dist);
      forceY = force * ((NodeCenterVy - NodeCenterUy) / dist);
    }

    // Update the total forces acting upon the nodes.
    vertexU.forceX += forceX;
    vertexU.forceY += forceY;
    vertexV.forceX -= forceX;
    vertexV.forceY -= forceY;
  }

  var maxMove = 0;
  var moveLimit = Math.max(this._infinityDistance / 20, 50);

  // Update the positions of all nodes in the network.
  for (var i = 0; i < vertexarray.count; i++) {
    var vertex = vertexarray._arr[i];
    // Only move the node if it is not fixed.
    if (!this.isFixed(vertex)) {
      var centerx = vertex.centerX;
      var centery = vertex.centerY;

      // Calculate the distance to move the node based on the forces acting upon it.
      var dX = vertex.forceX;
      var dY = vertex.forceY;

      // Do not allow a node to move more than some number of units.
      if (dX < -moveLimit)
        dX = -moveLimit;
      else if (dX > moveLimit)
        dX = moveLimit;

      if (dY < -moveLimit)
        dY = -moveLimit;
      else if (dY > moveLimit)
        dY = moveLimit;

      // Set the center of the node.
      vertex.centerX += dX;
      vertex.centerY += dY;

      // Check to see if any node has moved significantly.
      maxMove = Math.max(maxMove, dX * dX + dY * dY);
    }
  }

  return (maxMove > this.epsilonDistance * this.epsilonDistance);
};

/**
* @ignore
* Returns a random integer value from 0 to max - 1.
* @this {ForceDirectedLayout}
* @param {number} max
* @return {number}
*/
ForceDirectedLayout.prototype.randNext = function(max) {
  return Math.floor(max * Math.random());
};

/**
* Position the {@link Node}s according to the {@link Vertex} positions.
* <p/>
* You should not call this method -- it is a "protected virtual" method.
* @this {ForceDirectedLayout}
*/
ForceDirectedLayout.prototype.commitLayout = function() {
  this.setPortSpotsAll();
  this.commitNodes();
  if (this.isRouting) this.commitLinks();
};

/**
* @ignore
* @this {ForceDirectedLayout}
*/
ForceDirectedLayout.prototype.setPortSpotsAll = function() {
  if (!this.setsPortSpots) return;
  var eit = this.network.edges.iterator;
  while (eit.next()) {
    var edge = eit.value;
    var link = edge.link;
    if (link !== null) {
      link.fromSpot = Spot.Default;
      link.toSpot = Spot.Default;
    }
  }
};

/**
* Commit the position of all vertex nodes.
* @expose
* @this {ForceDirectedLayout}
*/
ForceDirectedLayout.prototype.commitNodes = function() {
  var offsetx = 0;
  var offsety = 0;
  if (this.arrangesToOrigin) {
    var b = Util.tempRect();
    this.computeBounds(this.network, b);
    var orig = this.arrangementOrigin;
    offsetx = orig.x-b.x;
    offsety = orig.y-b.y;
    Util.freeRect(b);
  }
  var r = Util.tempRect();
  var vit = this.network.vertexes.iterator;
  while (vit.next()) {
    var vertex = vit.value;
    if (offsetx !== 0 || offsety !== 0) {
      r.assign(vertex._bounds);
      r.x += offsetx;
      r.y += offsety;
      vertex.bounds = r;
    }
    vertex.commit();
  }
  Util.freeRect(r);
};

/**
* Commit the position and routing of all edge links.
* This is called by {@link #commitLayout}.
* This is only called if {@link Layout#isRouting} is true.
* @expose
* @this {ForceDirectedLayout}
*/
ForceDirectedLayout.prototype.commitLinks = function() {
  var eit = this.network.edges.iterator;
  while (eit.next()) {
    var edge = eit.value;
    edge.commit();
  }
};

/*********************************************************************************************/
/*********************************************************************************************/

/**
* Returns the stiffness of the spring representing an edge.
* The two vertexes connected by the edge E are acted upon by a force of magnitude
* <code>springStiffness(E) * (getNodeDistance(E.fromVertex, E.toVertex) - springLength(E))</code>.
* @expose
* @this {ForceDirectedLayout}
* @param {ForceDirectedEdge} e
* @return {number}
* Returns the stiffness of the edge representing a link,
* the value of {@link ForceDirectedEdge#stiffness} if it's a number,
* or else the value of {@link #defaultSpringStiffness}.
*/
ForceDirectedLayout.prototype.springStiffness = function(e) {
  var s = e.stiffness;
  if (!isNaN(s)) return s;
  return this._defaultSpringStiffness;
};

/**
* Returns the length of the spring representing an edge.
* The two vertexes connected by the edge E are acted upon by a force of magnitude
* <code>springStiffness(E) * (getNodeDistance(E.fromVertex, E.toVertex) - springLength(E))</code>.
* @expose
* @this {ForceDirectedLayout}
* @param {ForceDirectedEdge} e
* @return {number}
* Returns the length of the edge representing a link,
* the value of {@link ForceDirectedEdge#length} if it's a number,
* or else the value of {@link #defaultSpringLength}.
*/
ForceDirectedLayout.prototype.springLength = function(e) {
  var s = e.length;
  if (!isNaN(s)) return s;
  return this._defaultSpringLength;
};

/*********************************************************************************************/
/*********************************************************************************************/

/**
* Returns the charge of the vertex,
* the value of {@link ForceDirectedVertex#charge} if it's a number,
* or else the value of {@link #defaultElectricalCharge}.
* @expose
* @this {ForceDirectedLayout}
* @param {ForceDirectedVertex} v
* @return {number}
*/
ForceDirectedLayout.prototype.electricalCharge = function(v) {
  var c = v.charge;
  if (!isNaN(c)) return c;
  return this._defaultElectricalCharge;
};

/**
* Returns the electrical field in the X direction acting on a vertex at the given point.
* <p/>
* Used to define an external electrical field at a point
* independent of the vertex charges.
* A vertex L is acted upon by a force in the X direction of magnitude
* <code>electricalFieldX(L.center.x, L.center.y) * electricalCharge(L)</code>.
* @expose
* @this {ForceDirectedLayout}
* @param {number} x
* @param {number} y
* @return {number} the default implementation returns zero.
*/
ForceDirectedLayout.prototype.electricalFieldX = function(x, y) {
  return 0;
};

/**
* Returns the electrical field in the Y direction acting on a vertex at the given point.
* <p/>
* Used to define an external electrical field at a point
* independent of the vertex charges.
* A vertex L is acted upon by a force in the Y direction of magnitude
* <code>electricalFieldY(L.center.x, L.center.y) * electricalCharge(L)</code>.
* @expose
* @this {ForceDirectedLayout}
* @param {number} x
* @param {number} y
* @return {number} the default implementation returns zero.
*/
ForceDirectedLayout.prototype.electricalFieldY = function(x, y) {
  return 0;
};

/*********************************************************************************************/
/*********************************************************************************************/

/**
* Returns the mass of the vertex,
* the value of {@link ForceDirectedVertex#mass} if it's a number,
* or else the value of {@link #defaultGravitationalMass}.
* @expose
* @this {ForceDirectedLayout}
* @param {ForceDirectedVertex} v
* @return {number}
*/
ForceDirectedLayout.prototype.gravitationalMass = function(v) {
  var m = v.mass;
  if (!isNaN(m)) return m;
  return this._defaultGravitationalMass;
};

/**
* This returns the gravitational field in the X direction acting on a vertex at the given point.
* <p/>
* Used to define an external gravitational field at a point
* independent of the vertex masses.
* A vertex L is acted upon by a force in the X direction of magnitude
* <code>gravitationalFieldX(L.center.x, L.center.y) * gravitationalMass(L)</code>.
* @expose
* @this {ForceDirectedLayout}
* @param {number} x
* @param {number} y
* @return {number} the default implementation returns zero.
*/
ForceDirectedLayout.prototype.gravitationalFieldX = function(x, y) {
  return 0;
};

/**
* This returns the gravitational field in the Y direction acting on a vertex at the given point.
* <p/>
* Used to define an external gravitational field at a point
* independent of the vertex masses.
* A vertex L is acted upon by a force in the Y direction of magnitude
* <code>gravitationalFieldY(L.center.x, L.center.y) * gravitationalMass(L)</code>.
* @expose
* @this {ForceDirectedLayout}
* @param {number} x
* @param {number} y
* @return {number} the default implementation returns zero.
*/
ForceDirectedLayout.prototype.gravitationalFieldY = function(x, y) {
  return 0;
};

/*********************************************************************************************/
/*********************************************************************************************/

/**
* This predicate returns true if the vertex should not be moved
* by the layout algorithm but still have an effect on nearby and connected vertexes.
* The default implementation returns {@link ForceDirectedVertex#isFixed}.
* @expose
* @this {ForceDirectedLayout}
* @param {ForceDirectedVertex} v
* @return {boolean} returns true if the node should not be moved by the layout algorithm.
*/
ForceDirectedLayout.prototype.isFixed = function(v) {
  return v.isFixed;
};

/*********************************************************************************************/
/*********************************************************************************************/


/**
* Gets the current iteration count, valid during a call to {@link #doLayout}.
* @name ForceDirectedLayout#currentIteration
* @function.
* @return {number}
*/
/** @type {number} */
ForceDirectedLayout.prototype.currentIteration;
Util.defineReadOnlyProperty(ForceDirectedLayout, {currentIteration : 'currentIteration'},
  /** @this {ForceDirectedLayout} */
  function() { return this._iteration; }
);


/**
* Gets or sets the space between which the layout
* will position the connected graphs that together compose the network.
* This defaults to Size(100, 100).
* These distances are used during a clustered layout;
* afterwards the normal force-directed layout
* will likely cause the size of any space between connected graphs to change,
* perhaps considerably.
* @name ForceDirectedLayout#arrangementSpacing
* @function.
* @return {Size}
*/
/** @type {Size} */
ForceDirectedLayout.prototype.arrangementSpacing;
Util.exportProperty(ForceDirectedLayout, 'arrangementSpacing', ForceDirectedLayout.prototype.arrangementSpacing);
Util.defineProperty(ForceDirectedLayout, {arrangementSpacing : 'arrangementSpacing'},
  /** @this {ForceDirectedLayout} */
  function() { return this._arrangementSpacing; },
  /** @this {ForceDirectedLayout} */
  function(val) {
    var old = this._arrangementSpacing;
    if (!old.equals(val)) {
      this._arrangementSpacing.assign(val);
      this.invalidateLayout();
    }
  }
);

/**
* Gets or sets whether {@link #commitNodes} should move all of the
* nodes so that the nodes all fit with the top-left corner at the
* {@link Layout#arrangementOrigin}.
* By default this is false -- the {@link Layout#arrangementOrigin} is ignored.
* When this is true, nodes are moved even though {@link #isFixed} was true.
* @name ForceDirectedLayout#arrangesToOrigin
* @function.
* @return {boolean}
*/
/** @type {boolean} */
ForceDirectedLayout.prototype.arrangesToOrigin;
Util.exportProperty(ForceDirectedLayout, 'arrangesToOrigin', ForceDirectedLayout.prototype.arrangesToOrigin);
Util.defineProperty(ForceDirectedLayout, {arrangesToOrigin : 'arrangesToOrigin'},
  /** @this {ForceDirectedLayout} */
  function() { return this._arrangesToOrigin; },
  /** @this {ForceDirectedLayout} */
  function(val) {
    var old = this._arrangesToOrigin;
    if (old !== val) {
      this._arrangesToOrigin = val;
      this.invalidateLayout();
    }
  }
);

/**
* Gets or sets whether the fromSpot and the toSpot of every {@link Link}
* should be set to {@link Spot#Default}.
* The default value is true.
* @name ForceDirectedLayout#setsPortSpots
* @function.
* @return {boolean}
*/
/** @type {boolean} */
ForceDirectedLayout.prototype.setsPortSpots;
Util.exportProperty(ForceDirectedLayout, 'setsPortSpots', ForceDirectedLayout.prototype.setsPortSpots);
Util.defineProperty(ForceDirectedLayout, {setsPortSpots : 'setsPortSpots'},
  /** @this {ForceDirectedLayout} */
  function() { return this._setsPortSpots; },
  /** @this {ForceDirectedLayout} */
  function(val) {
    var old = this._setsPortSpots;
    if (old !== val) {
      this._setsPortSpots = val;
      this.invalidateLayout();
    }
  }
);

/**
* Gets or sets whether this layout should find all {@link Node}s
* whose category is "Comment" and
* whose anchors are nodes represented in the network,
* and add {@link ForceDirectedVertex}es representing those balloon comments
* as nodes in the network.
* The default value is true.
* @name ForceDirectedLayout#comments
* @function.
* @return {boolean}
*/
/** @type {boolean} */
ForceDirectedLayout.prototype.comments;
Util.exportProperty(ForceDirectedLayout, 'comments', ForceDirectedLayout.prototype.comments);
Util.defineProperty(ForceDirectedLayout, {comments : 'comments'},
  /** @this {ForceDirectedLayout} */
  function() { return this._comments; },
  /** @this {ForceDirectedLayout} */
  function(val) {
    var old = this._comments;
    if (old !== val) {
      this._comments = val;
      this.invalidateLayout();
    }
  }
);

/**
* Gets or sets the maximum number of iterations to perform when doing the
* force-directed auto layout.
* The value must be non-negative.
* The default value is 100.
* @name ForceDirectedLayout#maxIterations
* @function.
* @return {number}
*/
/** @type {number} */
ForceDirectedLayout.prototype.maxIterations;
Util.exportProperty(ForceDirectedLayout, 'maxIterations', ForceDirectedLayout.prototype.maxIterations);
Util.defineProperty(ForceDirectedLayout, {maxIterations : 'maxIterations'},
  /** @this {ForceDirectedLayout} */
  function() { return this._maxIterations; },
  /** @this {ForceDirectedLayout} */
  function(val) {
    var old = this._maxIterations;
    if (old !== val && val >= 0) {
      this._maxIterations = val;
      this.invalidateLayout();
    }
  }
);

/**
* Gets or sets approximately how far a node must move in order for the iterations to continue.
* The default value is 1.
* The value must be larger than zero.
* @name ForceDirectedLayout#epsilonDistance
* @function.
* @return {number}
*/
/** @type {number} */
ForceDirectedLayout.prototype.epsilonDistance;
Util.exportProperty(ForceDirectedLayout, 'epsilonDistance', ForceDirectedLayout.prototype.epsilonDistance);
Util.defineProperty(ForceDirectedLayout, {epsilonDistance : 'epsilonDistance'},
  /** @this {ForceDirectedLayout} */
  function() { return this._epsilonDistance; },
  /** @this {ForceDirectedLayout} */
  function(val) {
    var old = this._epsilonDistance;
    if (old !== val && val > 0) {
      this._epsilonDistance = val;
      this.invalidateLayout();
    }
  }
);

/**
* Gets or sets a threshold for the distance beyond which the electrical charge forces may be ignored.
* The default value is 1000.
* The value must be larger than 1.
* @name ForceDirectedLayout#infinityDistance
* @function.
* @return {number}
*/
/** @type {number} */
ForceDirectedLayout.prototype.infinityDistance;
Util.exportProperty(ForceDirectedLayout, 'infinityDistance', ForceDirectedLayout.prototype.infinityDistance);
Util.defineProperty(ForceDirectedLayout, {infinityDistance : 'infinityDistance'},
  /** @this {ForceDirectedLayout} */
  function() { return this._infinityDistance; },
  /** @this {ForceDirectedLayout} */
  function(val) {
    var old = this._infinityDistance;
    if (old !== val && val > 1) {
      this._infinityDistance = val;
      this.invalidateLayout();
    }
  }
);

/**
* Gets or sets the default value computed by {@link #springStiffness}.
* The initial value is 0.05.
* @name ForceDirectedLayout#defaultSpringStiffness
* @function.
* @return {number}
*/
/** @type {number} */
ForceDirectedLayout.prototype.defaultSpringStiffness;
Util.exportProperty(ForceDirectedLayout, 'defaultSpringStiffness', ForceDirectedLayout.prototype.defaultSpringStiffness);
Util.defineProperty(ForceDirectedLayout, {defaultSpringStiffness : 'defaultSpringStiffness'},
  /** @this {ForceDirectedLayout} */
  function() { return this._defaultSpringStiffness; },
  /** @this {ForceDirectedLayout} */
  function(val) {
    var old = this._defaultSpringStiffness;
    if (old !== val) {
      this._defaultSpringStiffness = val;
      this.invalidateLayout();
    }
  }
);

/**
* Gets or sets the default value computed by {@link #springLength}.
* The initial value is 50.
* @name ForceDirectedLayout#defaultSpringLength
* @function.
* @return {number}
*/
/** @type {number} */
ForceDirectedLayout.prototype.defaultSpringLength;
Util.exportProperty(ForceDirectedLayout, 'defaultSpringLength', ForceDirectedLayout.prototype.defaultSpringLength);
Util.defineProperty(ForceDirectedLayout, {defaultSpringLength : 'defaultSpringLength'},
  /** @this {ForceDirectedLayout} */
  function() { return this._defaultSpringLength; },
  /** @this {ForceDirectedLayout} */
  function(val) {
    var old = this._defaultSpringLength;
    if (old !== val) {
      this._defaultSpringLength = val;
      this.invalidateLayout();
    }
  }
);

/**
* Gets or sets the default value computed by {@link #electricalCharge}.
* The initial value is 150.
* @name ForceDirectedLayout#defaultElectricalCharge
* @function.
* @return {number}
*/
/** @type {number} */
ForceDirectedLayout.prototype.defaultElectricalCharge;
Util.exportProperty(ForceDirectedLayout, 'defaultElectricalCharge', ForceDirectedLayout.prototype.defaultElectricalCharge);
Util.defineProperty(ForceDirectedLayout, {defaultElectricalCharge : 'defaultElectricalCharge'},
  /** @this {ForceDirectedLayout} */
  function() { return this._defaultElectricalCharge; },
  /** @this {ForceDirectedLayout} */
  function(val) {
    var old = this._defaultElectricalCharge;
    if (old !== val) {
      this._defaultElectricalCharge = val;
      this.invalidateLayout();
    }
  }
);

/**
* Gets or sets the default value computed by {@link #gravitationalMass}.
* The initial value is zero.
* @name ForceDirectedLayout#defaultGravitationalMass
* @function.
* @return {number}
*/
/** @type {number} */
ForceDirectedLayout.prototype.defaultGravitationalMass;
Util.exportProperty(ForceDirectedLayout, 'defaultGravitationalMass', ForceDirectedLayout.prototype.defaultGravitationalMass);
Util.defineProperty(ForceDirectedLayout, {defaultGravitationalMass : 'defaultGravitationalMass'},
  /** @this {ForceDirectedLayout} */
  function() { return this._defaultGravitationalMass; },
  /** @this {ForceDirectedLayout} */
  function(val) {
    var old = this._defaultGravitationalMass;
    if (old !== val) {
      this._defaultGravitationalMass = val;
      this.invalidateLayout();
    }
  }
);

/**
* Gets or sets the default value computed by {@link #springLength}.
* The initial value is 20.
* @name ForceDirectedLayout#defaultCommentSpringLength
* @function.
* @return {number}
*/
/** @type {number} */
ForceDirectedLayout.prototype.defaultCommentSpringLength;
Util.exportProperty(ForceDirectedLayout, 'defaultCommentSpringLength', ForceDirectedLayout.prototype.defaultCommentSpringLength);
Util.defineProperty(ForceDirectedLayout, {defaultCommentSpringLength : 'defaultCommentSpringLength'},
  /** @this {ForceDirectedLayout} */
  function() { return this._defaultCommentSpringLength; },
  /** @this {ForceDirectedLayout} */
  function(val) {
    var old = this._defaultCommentSpringLength;
    if (old !== val) {
      this._defaultCommentSpringLength = val;
      this.invalidateLayout();
    }
  }
);

/**
* Gets or sets the default value computed by {@link #electricalCharge}.
* The initial value is 25.
* @name ForceDirectedLayout#defaultCommentElectricalCharge
* @function.
* @return {number}
*/
/** @type {number} */
ForceDirectedLayout.prototype.defaultCommentElectricalCharge;
Util.exportProperty(ForceDirectedLayout, 'defaultCommentElectricalCharge', ForceDirectedLayout.prototype.defaultCommentElectricalCharge);
Util.defineProperty(ForceDirectedLayout, {defaultCommentElectricalCharge : 'defaultCommentElectricalCharge'},
  /** @this {ForceDirectedLayout} */
  function() { return this._defaultCommentElectricalCharge; },
  /** @this {ForceDirectedLayout} */
  function(val) {
    var old = this._defaultCommentElectricalCharge;
    if (old !== val) {
      this._defaultCommentElectricalCharge = val;
      this.invalidateLayout();
    }
  }
);


/**
 * @ignore
 * @constructor
 * @extends LayoutNetwork
 * @category Layout
 * @class
 */
function ForceDirectedNetwork() {
  LayoutNetwork.call(this);
}

Util.publish('ForceDirectedNetwork', ForceDirectedNetwork);

Util.inherit(ForceDirectedNetwork, LayoutNetwork);

/**
* @ignore
* Allocate a new instance of {@link ForceDirectedVertex}.
* @this {ForceDirectedNetwork}
* @return {LayoutVertex}
*/
ForceDirectedNetwork.prototype.createVertex = function() {
  return new ForceDirectedVertex();
};

/**
* @ignore
* Allocate a new instance of {@link ForceDirectedEdge}.
* @this {ForceDirectedNetwork}
* @return {LayoutEdge}
*/
ForceDirectedNetwork.prototype.createEdge = function() {
  return new ForceDirectedEdge();
};


/**
 * @constructor
 * @extends LayoutVertex
 * @category Layout
 * @class
 * This holds {@link ForceDirectedLayout}-specific information about {@link Node}s.
 */
function ForceDirectedVertex() {
  LayoutVertex.call(this);

  // force-specific properties:

  /**
  * Gets or sets whether the vertex may be moved by any forces.
  * The default value is false.
  * @name ForceDirectedVertex#isFixed
  * @function.
  * @return {boolean}
  */
  /** @expose @type {boolean} */
  this.isFixed = false;

  /**
  * Gets or sets the electrical charge for this vertex.
  * The default value is NaN.
  * @name ForceDirectedVertex#charge
  * @function.
  * @return {number}
  */
  /** @expose @type {number} */
  this.charge = NaN;

  /**
  * Gets or sets the gravitational mass for this vertex.
  * The default value is NaN.
  * @name ForceDirectedVertex#mass
  * @function.
  * @return {number}
  */
  /** @expose @type {number} */
  this.mass = NaN;

  /**
  * Gets or sets the cumulative force on the vertex in the X direction.
  * The default value is zero.
  * @name ForceDirectedVertex#forceX
  * @function.
  * @return {number}
  */
  /** @expose @type {number} */
  this.forceX = 0;

  /**
  * Gets or sets the cumulative force on the vertex in the Y direction.
  * The default value is zero.
  * @name ForceDirectedVertex#forceY
  * @function.
  * @return {number}
  */
  /** @expose @type {number} */
  this.forceY = 0;

  // internal state
  /** @ignore @type {number} */
  this.numConnections = 0;
  /** @ignore @type {number} */
  this.numInCluster = 0;
  /** @ignore @type {List} */
  this.clustereds = null;
  /** @ignore @type {List} */
  this.savedState = null;
  /** @ignore @type {number} */
  this.savedStateIndex = 0;
}

Util.publish('ForceDirectedVertex', ForceDirectedVertex);

Util.inherit(ForceDirectedVertex, LayoutVertex);


/**
 * @constructor
 * @extends LayoutEdge
 * @category Layout
 * @class
 * This holds {@link ForceDirectedLayout}-specific information about {@link Link}s.
 */
function ForceDirectedEdge() {
  LayoutEdge.call(this);

  // force-specific properties:

  /**
  * Gets or sets this edge's stiffness or resistance to compression or stretching.
  * The default value is NaN.
  * @name ForceDirectedEdge#stiffness
  * @function.
  * @return {number}
  */
  /** @expose @type {number} */
  this.stiffness = NaN;

  /**
  * Gets or sets the length of this edge.
  * The default value is NaN.
  * @name ForceDirectedEdge#length
  * @function.
  * @return {number}
  */
  /** @expose @type {number} */
  this.length = NaN;
}

Util.publish('ForceDirectedEdge', ForceDirectedEdge);

Util.inherit(ForceDirectedEdge, LayoutEdge);

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
LayeredDigraphLayout
LayeredDigraphNetwork
LayeredDigraphVertex
LayeredDigraphEdge
*/

/**
 * Constructs a {@link LayeredDigraphLayout} with no {@link Layout#network}
 * and with no owning {@link Layout#diagram}.
 * @constructor
 * @extends Layout
 * @category Layout
 * @class
 * This arranges nodes into layers.
 * The method uses a hierarchical approach
 * for creating drawings of digraphs with nodes arranged in layers.
 * The layout algorithm consists of four-major steps: Cycle Removal,
 * Layer Assignment, Crossing Reduction, and Straightening and Packing.
 * <p/>
 * If the diagram is structured in a tree-like fashion,
 * it may be better to use {@link TreeLayout},
 * which has more options specific to trees.
 * {@link TreeLayout} is much faster than LayeredDigraphLayout,
 * and can handle a limited number of links that would prevent the
 * graph structure from being a true tree (i.e. some nodes having multiple parents).
 * <p/>
 * This layout makes use of a {@link LayoutNetwork} of
 * {@link LayeredDigraphVertex}es and {@link LayeredDigraphEdge}s that normally
 * correspond to the {@link Node}s and {@link Link}s of the {@link Diagram}.
 */
function LayeredDigraphLayout() {
  if (arguments.length > 0) {
    Util.throwError('LayeredDigraphLayout constructor cannot take any arguments.');
  }
  Layout.call(this);
  /** @type {number} */
  this._layerSpacing = 25.0;
  /** @type {number} */
  this._columnSpacing = 25.0;
  /** @type {number} */
  this._direction = 0.0;
  /** @type {EnumValue} */
  this._cycleRemoveOption = LayeredDigraphLayout.CycleDepthFirst;
  /** @type {EnumValue} */
  this._layeringOption = LayeredDigraphLayout.LayerOptimalLinkLength;
  /** @type {EnumValue} */
  this._initializeOption = LayeredDigraphLayout.InitDepthFirstOut;
  /** @type {number} */
  this._iterations = 4;
  /** @type {EnumValue} */
  this._aggressiveOption = LayeredDigraphLayout.AggressiveLess;
  /** @type {number} */  //should be bitwise combinable enum.
  this._packOption = LayeredDigraphLayout.PackAll;
  /** @type {boolean} */
  this._setsPortSpots = true;
  /** @type {number} */
  this._linkSpacing = 4;

  /** @type {number} */
  this._maxLayer = -1;
  /** @type {number} */
  this._maxIndex = -1;
  /** @type {number} */
  this._maxColumn = -1;
  /** @type {number} */
  this._minIndexLayer = 0;
  /** @type {number} */
  this._maxIndexLayer = 0;
  /** @type {Array.<number>} */
  this._indices = null;
  /** @type {Array.<number>} */
  this._layerSpaceLeft = null;
  /** @type {Array.<number>} */
  this._layerSpaceRight = null;
  /** @type {Array.<number>} */
  this._layerPositions = null;
  /** @type {Array.<number>} */
  this._layerSpaces = null;
  /** @type {number} */
  this._myDepthFirstSearchCycleRemovalTime = 0;
  /** @type {Array.<number>} */
  this._mySavedLayout = null;
  /** @type {Array.<number>} */
  this._myCrossings = null;
  /** @type {number} */
  this._myComponent = 0;
  /** @type {Array.<List>} */
  this._myLayers = null;
  /** @type {Array.<Array.<LayeredDigraphVertex>>} */
  this._myCachedNodeArrayLists = [];
  this._myCachedNodeArrayLists.length = 100;
}

Util.publish('LayeredDigraphLayout', LayeredDigraphLayout);

Util.inherit(LayeredDigraphLayout, Layout);

/**
* @ignore
* Copies properties to a cloned Layout.
* @this {LayeredDigraphLayout}
* @param {Layout} copy
*/
LayeredDigraphLayout.prototype.cloneProtected = function(copy) {
  Layout.prototype.cloneProtected.call(this, copy);
  copy._layerSpacing = this._layerSpacing;
  copy._columnSpacing = this._columnSpacing;
  copy._direction = this._direction;
  copy._cycleRemoveOption = this._cycleRemoveOption;
  copy._layeringOption = this._layeringOption;
  copy._initializeOption = this._initializeOption;
  copy._iterations = this._iterations;
  copy._aggressiveOption = this._aggressiveOption;
  copy._packOption = this._packOption;
  copy._setsPortSpots = this._setsPortSpots;
  copy._linkSpacing = this._linkSpacing;
  // these are computed and thus do not need to be copied:
  //this._maxLayer
  //this._maxIndex
  //this._maxColumn
  //this._minIndexLayer
  //this._maxIndexLayer
  //this._indices
  //this._layerSpaceLeft
  //this._layerSpaceRight
  //this._layerPositions
  //this._layerSpaces
  //this._myDepthFirstSearchCycleRemovalTime
  //this._mySavedLayout
  //this._myCrossings
  //this._myComponent
  //this._myLayers
  //this._myCachedNodeArrayLists
  //this._myCachedNodeArrayLists.length
};

/**
* Create a new {@link LayoutNetwork} of {@link LayeredDigraphVertex}es and {@link LayeredDigraphEdge}s.
* @this {LayeredDigraphLayout}
* @return {LayoutNetwork} a new {@link LayoutNetwork}.
*/
LayeredDigraphLayout.prototype.createNetwork = function() {
  var net = new LayeredDigraphNetwork();
  net.setLayout(this);
  return net;
};

/**
* Assign the positions of the vertexes in the network.
* @this {LayeredDigraphLayout}
* @param {Diagram|Group|Iterable} coll A {@link Diagram} or a {@link Group} or a collection of {@link Part}s.
*/
LayeredDigraphLayout.prototype.doLayout = function(coll) {
  if (!coll) Util.throwError('Layout.doLayout(collection) argument must not be null but a Diagram, a Group, or an Iterable of Parts');
  if (this.network === null) {
    this.network = this.makeNetwork(coll);
  }

  this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin);

  this._clearCaches();
  if (this.network.vertexes.count > 0) {
    //Remove self-links from the input network.
    this.network.deleteSelfEdges();

    //Removes cycles from the input network by reversing some number of links.
    this.removeCycles();

    // Assigns every node in the input network to a layer.
    // The layering satisfies the following:
    //  if L is a link from node U to node V,
    //  then U.layer > V.layer;
    //  further, U.layer - V.layer >= LinkMinLength(L).
    // In addition, the nodes will satisfy
    //  for all nodes U, U.layer >= 0, with equality in at least one case,
    //  for all nodes U, U.layer <= maxLayer, with equality in at least one case.
    this._assignLayersInternal();

    // Converts the input network into a proper digraph; i.e., artificial nodes and links
    //  are introduced into the network such that every link is between nodes in adjacent
    //  layers.  This has the effect of breaking up long links into a sequence of artificial
    //  nodes.
    this.makeProper();

    // Assigns every node in the input network an index number,
    //  such that nodes in the same layer will be labeled with
    //  consecutive indices in left to right order.
    // All consecutive layout operations will preserve or update
    //  the indices.
    this._initializeIndicesInternal();

    // Assigns every node in the input network a column number,
    //  such that nodes in the same layer will be labeled with
    //  increasing indices in left to right order.
    // In addition, a node U is assigned to a column such that
    //  2 * minColumnSpace(U) + 1 columns are "allocated" to node U,
    //  and no two nodes have overlapping "allocations" of columns.
    // All consecutive layout operations will preserve or update
    //  the columns.
    this.initializeColumns();

    // Reorders nodes within layers to reduce the total number of link
    //  crossings in the network.
    this.reduceCrossings();

    // Adjusts the columns of nodes in the network to produce a layout which reduces
    //  the number of bends and is tightly packed.
    this.straightenAndPack();

    // Update the "physical" positions of the nodes and links.
    this.updateParts();
  }
  this.network = null;
  this.isValidLayout = true;
};

/**********************************************************************************/
/**
* @ignore
* The function LinkMinLength returns the minimum length of the
* link represented by the LayeredDigraphEdge link.
* The default implementation gives multi-links a minimum length of 2,
* and all other links a minimum length of 1.
* This function can be overridden to provide "fine-tuning" of the layout.
* @this {LayeredDigraphLayout}
* @param {LayeredDigraphEdge} edge
* @return {number} Returns the minimum length of the link represented by link.
*/
LayeredDigraphLayout.prototype.linkMinLength = function(edge) {
  var fromVertex = edge.fromVertex;
  var toVertex = edge.toVertex;

  var links = 0;
  var succEdgeIter = fromVertex.destinationEdges;
  while (succEdgeIter.next()) {
    var succVertex = succEdgeIter.value.toVertex;
    if (succVertex === toVertex) {
      links++;
    }
  }
  if (links > 1) {
    return 2;
  }
  return 1;
};

/**
* @ignore
* The function LinkLengthWeight returns the weight of the link
* represented by the LayeredDigraphEdge link.  This weight is used by
* OptimalLinkLengthLayering to minimize weighted link lengths.
* The default implementation gives all links a length weight of 1.
* This function can be overridden to provide "fine-tuning" of the layout.
* @this {LayeredDigraphLayout}
* @param {LayeredDigraphEdge} edge
* @return {number} Returns the weight of the link represented by link.
*/
LayeredDigraphLayout.prototype.linkLengthWeight = function(edge) {
  return 1;
};

/**
* @ignore
* The function linkStraightenWeight returns the weight of the link
* represented by the LayeredDigraphEdge link.  This weight is used by
* the straightening methods to give priority straightening to those links
* with higher weights.
* The default implementation gives links between two "real" nodes a weight of 1,
* links between a "real" node and an "artificial" node a weight of 4,
* and links between two "artificial" nodes a weight of 8.
* This function can be overridden to provide "fine-tuning" of the layout.
* @this {LayeredDigraphLayout}
* @param {LayeredDigraphEdge} edge
* @return {number} Returns the weight of the link represented by link.
*/
LayeredDigraphLayout.prototype.linkStraightenWeight = function(edge) {
  var fromNode = edge.fromVertex._node;
  var toNode = edge.toVertex._node;


  if ((fromNode === null) && (toNode === null))
    return 8;

  if ((fromNode === null) || (toNode === null))
    return 4;

  return 1;
};

/**
* @ignore
* This function returns the minimum space reserved for this node from the center point
* for the "depth" of the layer that it is in. <p/>
* The default implementation returns 0 for nodes that do not
* correspond to top-level Go objects.  For nodes that do correspond
* to top-level Go objects, the layer space is determined by the
* width or height of the object depending on the {@link #direction}.
* By default this adds 10 to the space, to account for port end segment lengths.
* @this {LayeredDigraphLayout}
* @param {LayeredDigraphVertex} v
* @param {boolean} topleft whether to return the distance from the vertex's position
* to its center, or from the center
* to the bottom or right side of its bounds.
* @return {number} Returns the minimum space reserved above and below this node, in document coordinates.
*/
LayeredDigraphLayout.prototype.nodeMinLayerSpace = function(v, topleft) {
  if (v._node === null) return 0;
  // Don't use copy() function for performance reasons
  if (this._direction === 90 || this._direction === 270) {
    if (topleft)
      return v._focus.y + 10;
    else
      return v._bounds.height - v._focus.y + 10;
  } else {
    if (topleft)
      return v._focus.x + 10;
    else
      return v._bounds.width - v._focus.x + 10;
  }
};

/**
* @ignore
* The function nodeMinColumnSpace returns the minimum space
* reserved to either side of this node.
* The default implementation returns 0 for nodes that do not
* correspond to top-level Go objects.  For nodes that do correspond
* to top-level Go objects, the column space is determined by the
* width and height of the object divided by the {@link #columnSpcacing}.
* Note: all sub-classes that override this method should ensure that
* nodes that do not correspond to top-level Go objects have a minimum
* column space of 0.
* This function can be overridden to provide "fine-tuning" of the layout.
* @this {LayeredDigraphLayout}
* @param {LayeredDigraphVertex} v
* @param {boolean} topleft whether to return the distance from the vertex's position
* to its center, or from the center
* to the bottom or right side of its bounds.
* @return {number} Returns the minimum space reserved to either side of the center of this node, in units of {@link #columnSpacing}.
*/
LayeredDigraphLayout.prototype.nodeMinColumnSpace = function(v, topleft) {
  if (v._node === null) return 0;
  if (topleft) var s = v.nodeMinColumnSpaceTopLeft;
  else var s = v.nodeMinColumnSpaceBottomRight;
  if (s !== undefined) return s;
  // Don't use copy() function for performance reasons
  var direction = this._direction;
  if (direction === 90 || direction === 270) {
    if (topleft)
      return v.nodeMinColumnSpaceTopLeft = ((v._focus.x / this._columnSpacing) + 1) | 0;
    else
      return v.nodeMinColumnSpaceBottomRight = (((v._bounds.width - v._focus.x) / this._columnSpacing) + 1) | 0;
  } else {
    if (topleft)
      return v.nodeMinColumnSpaceTopLeft = ((v._focus.y / this._columnSpacing) + 1) | 0;
    else
      return v.nodeMinColumnSpaceBottomRight = (((v._bounds.height - v._focus.y) / this._columnSpacing) + 1) | 0;
  }
};

/**
* @ignore
* The function SaveLayout stores the layer, column, and index of all
* nodes in an array of integers. <p/>
* See also {@link #restoreLayout}
* @this {LayeredDigraphLayout}
* @return {Array.<number>} Returns an integer array representation of the current layout.
*/
LayeredDigraphLayout.prototype.saveLayout = function() {
  if (this._mySavedLayout === null)
    this._mySavedLayout = [];
  var i = 0;

  var vertIter = this.network.vertexes.iterator;
  var vertex;
  while (vertIter.next()) {
    vertex = vertIter.value;
    //??? is saving/restoring the vertex.layer unnecessary?
    this._mySavedLayout[i] = vertex.layer;
    i++;
    this._mySavedLayout[i] = vertex.column;
    i++;
    this._mySavedLayout[i] = vertex.index;
    i++;
  }
  return this._mySavedLayout;
};

/**
* @ignore
* The function restoreLayout restores the layer, column, and index of all
* nodes from an array of integers. <p/>
* See also {@link #saveLayout}
* @this {LayeredDigraphLayout}
* @param {Array.<number>} layout
*/
LayeredDigraphLayout.prototype.restoreLayout = function(layout) {
  var i = 0;
  var vertIter = this.network.vertexes.iterator;
  var vertex;
  while (vertIter.next()) {
    vertex = vertIter.value;
    //??? is saving/restoring the vertex.layer unnecessary?
    vertex.layer = layout[i];
    i++;
    vertex.column = layout[i];
    i++;
    vertex.index = layout[i];
    i++;
  }
};

/********************************************************************************************/
//Crossings

/**
* @ignore
* Computes the crossing matrix between the unfixedLayer and its adjacent layers.
* The direction argument indicates which adjacent layers should be taken into
* consideration when computing the crossing matrix:
* direction === 0  --  use unfixedLayer - 1 and unfixedLayer + 1
* direction > 0  --  use unfixedLayer - 1 (sweeping away from layer 0)
* direction < 0  --  use unfixedLayer + 1 (sweeping towards layer 0)
* The resulting integer array can be used as follows:
* if index1 and index2 are the indices corresponding to two nodes on the
* unfixedLayer and crossmat is the crossing matrix, then
* crossmat[index1 * indices[unfixedLayer] + index2]
* is the number of crossing that occur if the node corresponding to index1 is
* placed to the left of the node corresponding to index2.  If index1 === index2,
* then crossmat[index1 * indices[unfixedLayer] + index2] is the number of crossings
* between links to and from the node corresponding to index1.
* @this {LayeredDigraphLayout}
* @param {number} unfixedLayer
* @param {number} direction
* @return {Array.<number>} Returns the total number of crossings in the network.
*/
LayeredDigraphLayout.prototype.crossingMatrix = function(unfixedLayer, direction) {
  if (Debug) {
    Util.checkRealNumber(unfixedLayer, LayeredDigraphLayout, 'crossingMatrix:unfixedLayer');
    Util.checkRealNumber(direction, LayeredDigraphLayout, 'crossingMatrix:direction');
  }
  // Fill unfixedLayerNodes with nodes in the unfixedLayer, ordered by index.
  var unfixedLayerNodes = this._getCachedNodeArrayList(unfixedLayer);
  var num = this._indices[unfixedLayer];

  if (!this._myCrossings)
    this._myCrossings = [];
  var crossmat = this._myCrossings;
  var crossings;
  // Process all pairs of nodes in the unfixed layer.
  for (var A = 0; A < num; A++) {
    // First, compute the crossings between links to and from unfixedLayerNodes[A].

    // Initially, no crossings discovered.
    crossings = 0;
    // count unrelated nodes separating a node from the node it is supposed to be Near
    var vertex = unfixedLayerNodes[A];
    var near = vertex.near;
    var B, v, i;
    if (near !== null && near.layer === vertex.layer) {
      B = near.index;
      if (B > A) {
        for (i = A + 1; i < B; i++) {
          v = unfixedLayerNodes[i];
          if (v.near !== near || v.artificialType !== near.artificialType) crossings++;
        }
      } else {
        for (i = A - 1; i > B; i--) {
          v = unfixedLayerNodes[i];
          if (v.near !== near || v.artificialType !== near.artificialType) crossings++;
        }
      }
    }
    var links;
    var posA, edgeA, indexA, portToPosA, portFromPosA, linksA;
    var posB, edgeB, indexB, portToPosB, portFromPosB, linksB;

    // Compute crossings in positive direction.
    if (direction >= 0) {
      // The first link.
      links = unfixedLayerNodes[A].sourceEdgesList;
      for (posA = 0; posA < links.count; posA++) {
        edgeA = links._arr[posA];
        if (edgeA.valid && (edgeA.fromVertex.layer !== unfixedLayer)) {
          // Record the index of the node the link originates from.
          indexA = edgeA.fromVertex.index;

          // Record the portToPos and portFromPos for the link.
          portToPosA = edgeA.portToPos;
          portFromPosA = edgeA.portFromPos;

          // The second link.
          for (posB = posA + 1; posB < links.count; posB++) {
            edgeB = links._arr[posB];
            if (edgeB.valid && (edgeB.fromVertex.layer !== unfixedLayer)) {
              // Record the index of the node the link originates from.
              indexB = edgeB.fromVertex.index;

              // Record the portToPos and portFromPos for the link.
              portToPosB = edgeB.portToPos;
              portFromPosB = edgeB.portFromPos;

              // If the to position of the first link is
              //  to the left of the to position of the second link
              //  and the from position of the first link is
              //  to the right of the from position of the second link,
              //  then a crossing occurs.
              if ((portToPosA < portToPosB) &&
				      ((indexA > indexB) || ((indexA === indexB) && (portFromPosA > portFromPosB)))) {
                crossings++;
              }
              // If the to position of the second link is
              //  to the left of the to position of the first link
              //  and the from position of the second link is
              //  to the right of the from position of the first link,
              //  then a crossing occurs.
              if ((portToPosB < portToPosA) &&
			      	((indexB > indexA) || ((indexB === indexA) && (portFromPosB > portFromPosA)))) {
                crossings++;
              }
            }
          }
        }
      }
    }

    if (direction <= 0) {
      // The first link.
      links = unfixedLayerNodes[A].destinationEdgesList;
      for (posA = 0; posA < links.count; posA++) {
        edgeA = links._arr[posA];
        if (edgeA.valid && (edgeA.toVertex.layer !== unfixedLayer)) {
          // Record the index of the node the link goes to.
          indexA = edgeA.toVertex.index;

          // Record the portToPos and portFromPos for the link.
          portToPosA = edgeA.portToPos;
          portFromPosA = edgeA.portFromPos;

          // The second link.
          for (posB = posA + 1; posB < links.count; posB++) {
            edgeB = links._arr[posB];
            if (edgeB.valid && (edgeB.toVertex.layer !== unfixedLayer)) {
              // Record the index of the node the link goes to.
              indexB = edgeB.toVertex.index;

              // Record the portToPos and portFromPos for the link.
              portToPosB = edgeB.portToPos;
              portFromPosB = edgeB.portFromPos;

              // If the from position of the first link is
              //  to the left of the from position of the second link
              //  and the to position of the first link is
              //  to the right of the to position of the second link,
              //  then a crossing occurs.
              if ((portFromPosA < portFromPosB) &&
				      ((indexA > indexB) || ((indexA === indexB) && (portToPosA > portToPosB)))) {
                crossings++;
              }
              // If the from position of the second link is
              //  to the left of the from position of the first link
              //  and the to position of the second link is
              //  to the right of the to position of the first link,
              //  then a crossing occurs.
              if ((portFromPosB < portFromPosA) &&
				      ((indexB > indexA) || ((indexB === indexA) && (portToPosB > portToPosA)))) {
                crossings++;
              }
            }
          }
        }
      }
    }

    // Set the crossings of unfixedLayerNodes[A] with itself.
    crossmat[A * num + A] = crossings;

    // Now, compute the crossings between links to and from unfixedLayerNodes[A]
    //  and unfixedLayerNodes[B] for B > A.
    for (B = A + 1; B < num; B++) {
      // Initially, no crossings discovered.
      // The variable crossingAB records the number of crossings if
      //  unfixedLayerNodes[A] (the A node) is placed to the left
      //  of unfixedLayerNodes[B] (the B node).
      // The variable crossingBA records the number of crossings if
      //  unfixedLayerNodes[A] (the A node) is placed to the right
      //  of unfixedLayerNodes[B] (the B node).
      var crossingAB = 0, crossingBA = 0;

      // Compute crossings in positive direction.
      if (direction >= 0) {
        linksA = unfixedLayerNodes[A].sourceEdgesList;
        linksB = unfixedLayerNodes[B].sourceEdgesList;

        // The first link.
        for (posA = 0; posA < linksA.count; posA++) {
          edgeA = linksA._arr[posA];
          if (edgeA.valid && (edgeA.fromVertex.layer !== unfixedLayer)) {
            // Record the index of the node the link originates from.
            indexA = edgeA.fromVertex.index;

            // Record the portToPos and portFromPos for the link.
            portToPosA = edgeA.portToPos;
            portFromPosA = edgeA.portFromPos;

            // The second link.
            for (posB = 0; posB < linksB.count; posB++) {
              edgeB = linksB._arr[posB];
              if (edgeB.valid && (edgeB.fromVertex.layer !== unfixedLayer)) {
                // Record the index of the node the link originates from.
                indexB = edgeB.fromVertex.index;

                // Record the portToPos and portFromPos for the link.
                portToPosB = edgeB.portToPos;
                portFromPosB = edgeB.portFromPos;

                // If the from position of the first link is
                //  to the right of the from position of the second link,
                //  then a crossing occurs if the first node is to the right
                //  of the second node.
                if ((indexA < indexB) || ((indexA === indexB) && (portFromPosA < portFromPosB))) {
                  crossingBA++;
                }
                // If the from position of the second link is
                //  to the right of the from position of the first link,
                //  then a crossing occurs if the first node is to the left
                //  of the second node.
                if ((indexB < indexA) || ((indexB === indexA) && (portFromPosB < portFromPosA))) {
                  crossingAB++;
                }
              }
            }
          }
        }
      }

      // Compute crossings in negative direction.
      if (direction <= 0) {
        linksA = unfixedLayerNodes[A].destinationEdgesList;
        linksB = unfixedLayerNodes[B].destinationEdgesList;

        // The first link.
        for (posA = 0; posA < linksA.count; posA++) {
          edgeA = linksA._arr[posA];
          if (edgeA.valid && (edgeA.toVertex.layer !== unfixedLayer)) {
            // Record the index of the node the link goes to.
            indexA = edgeA.toVertex.index;

            // Record the portToPos and portFromPos for the link.
            portToPosA = edgeA.portToPos;
            portFromPosA = edgeA.portFromPos;

            // The second link.
            for (posB = 0; posB < linksB.count; posB++) {
              edgeB = linksB._arr[posB];
              if (edgeB.valid && (edgeB.toVertex.layer !== unfixedLayer)) {
                // Record the index of the node the link goes to.
                indexB = edgeB.toVertex.index;

                // Record the portToPos and portFromPos for the link.
                portToPosB = edgeB.portToPos;
                portFromPosB = edgeB.portFromPos;

                // If the to position of the first link is
                //  to the right of the to position of the second link,
                //  then a crossing occurs if the first node is to the right
                if ((indexA < indexB) || ((indexA === indexB) && (portToPosA < portToPosB))) {
                  crossingBA++;
                }
                // If the to position of the second link is
                //  to the right of the to position of the first link,
                //  then a crossing occurs if the first node is to the left
                //  of the second node.
                if ((indexB < indexA) || ((indexB === indexA) && (portToPosB < portToPosA))) {
                  crossingAB++;
                }
              }
            }
          }
        }
      }

      // Set the crossings of unfixedLayerNode[A] with unfixedLayerNode[B].
      crossmat[A * num + B] = crossingAB;
      crossmat[B * num + A] = crossingBA;
    }
  }
  this._freeCachedNodeArrayList(unfixedLayer, unfixedLayerNodes);
  return crossmat;
};

/**
* @ignore
* Returns the total number of crossings in the network.
* Internal method used by {@link #reduceCrossings}.
* @expose
* @this {LayeredDigraphLayout}
* @return {number} Returns the total number of crossings in the network.
*/
LayeredDigraphLayout.prototype.countCrossings = function() {
  var layer;
  var crossings = 0;
  var crossmat;
  var num;
  // Sweep from layer 0 to layer maxLayer.
  for (layer = 0; layer <= this._maxLayer; layer++) {
    crossmat = this.crossingMatrix(layer, 1);
    // Since index i <= index j,
    //  summing the entries in the crossing matrix
    //  yields the total number of crossings in the layer.
    num = this._indices[layer];
    for (var i = 0; i < num; i++) {
      for (var j = i; j < num; j++) {
        crossings += crossmat[i * num + j];
      }
    }
  }
  return crossings;
};

/********************************************************************************************/
//Bends

/**
* @ignore
* Computes the bends between the unfixedLayer and its adjacent layers.
* The "bend" between a node U and a node V connected by a link L is calcluated by
* abs((U.column + L.portFromColOffset) - (V.column + L.portToColOffset))
* The "weighted bend" between a node U and a node V connected by link L is calculated by
* abs((U.column + L.portFromColOffset) - (V.column + L.portToColOffset)) * linkStraightenWeight(L)
* The linkStraightenWeight attempts to give higher priority to links between
* "artificial" nodes; i.e., long links in the final layout will be straighter.
* The direction argument indicates which adjacent layers should be taken into
* consideration when computing the crossing matrix:
* direction === 0  --  use unfixedLayer - 1 and unfixedLayer + 1
* direction > 0  --  use unfixedLayer - 1 (sweeping away from layer 0)
* direction < 0  --  use unfixedLayer + 1 (sweeping towards layer 0)
* @this {LayeredDigraphLayout}
* @param {number} unfixedLayer
* @param {number} direction
* @param {boolean} weighted
* @return {number} Returns the bends between the unfixedLayer and its adjacent layers.
*/
LayeredDigraphLayout.prototype.bends = function(unfixedLayer, direction, weighted) {
  // Fill unfixedLayerNodes with nodes in the unfixedLayer, ordered by index.
  var unfixedLayerNodes = this._getCachedNodeArrayList(unfixedLayer);
  var num = this._indices[unfixedLayer];

  // The total bends.
  var bends = 0;

  var index;
  for (index = 0; index < num; index++) {
    // Calculate the predecessor link list, based on direction.
    if (direction <= 0) {
      var LinksP = unfixedLayerNodes[index].sourceEdgesList;
    }
    // Calculate the successor link list, based on direction.
    if (direction >= 0) {
      var LinksS = unfixedLayerNodes[index].destinationEdgesList;
    }

    var edge, fromColumn, toColumn;
    if (typeof LinksP !== 'undefined') {
      // Contribution to bends from predecessors not on same layer.
      for (var posP = 0; posP < LinksP.count; posP++) {
        edge = LinksP._arr[posP];
        if (edge.valid && (edge.fromVertex.layer !== unfixedLayer)) {
          fromColumn = edge.fromVertex.column + edge.portFromColOffset;
          toColumn = edge.toVertex.column + edge.portToColOffset;
          if (weighted) {
            bends += Math.abs(fromColumn - toColumn) * this.linkStraightenWeight(edge);
          } else {
            bends += Math.abs(fromColumn - toColumn);
          }
        }
      }
    }

    if (typeof LinksS !== 'undefined') {
      // Contribution to bends from successors not on same layer.
      for (var posS = 0; posS < LinksS.count; posS++) {
        edge = LinksS._arr[posS];
        if (edge.valid && (edge.toVertex.layer !== unfixedLayer)) {
          fromColumn = edge.fromVertex.column + edge.portFromColOffset;
          toColumn = edge.toVertex.column + edge.portToColOffset;
          if (weighted) {
            bends += (Math.abs(fromColumn - toColumn) + 1) * this.linkStraightenWeight(edge);
          } else {
            bends += Math.abs(fromColumn - toColumn);
          }
        }
      }
    }

  }
  this._freeCachedNodeArrayList(unfixedLayer, unfixedLayerNodes);
  return bends;
};

/**
* @ignore
* Returns the total number of bends in the network.
* The "bend" between a node U and a node V connected by a link L is calcluated by
* abs((U.column + L.portFromColOffset) - (V.column + L.portToColOffset))
* The "weighted bend" between a node U// and a node V connected by link L is calculated by
* abs((U.column + L.portFromColOffset) - (V.column + L.portToColOffset)) * linkStraightenWeight(L)
* The linkStraightenWeight attempts to give higher priority to links between
* "artificial" nodes; i.e., long links in the final layout will be straighter.
* @this {LayeredDigraphLayout}
* @param {boolean} weighted
* @return {number} Returns the total number of bends in the network.
*/
LayeredDigraphLayout.prototype.countBends = function(weighted) {
  var bends = 0;
  for (var layer = 0; layer <= this._maxLayer; layer++) {
    bends += this.bends(layer, 1, weighted);
  }
  return bends;
};

/********************************************************************************************/
//Normalize

/**
* @ignore
* Adjusts the columns of all nodes such that the leftmost column will be
* column 0 and maxColumn is updated appropriately.
* @this {LayeredDigraphLayout}
*/
LayeredDigraphLayout.prototype.normalize = function() {
  var minColumn = Infinity;
  this._maxColumn = -1;
  var vertIter = this.network.vertexes.iterator;
  var vertex;
  while (vertIter.next()) {
    vertex = vertIter.value;
    minColumn = Math.min(minColumn, vertex.column - this.nodeMinColumnSpace(vertex, true));
    this._maxColumn = Math.max(this._maxColumn, vertex.column + this.nodeMinColumnSpace(vertex, false));
  }

  vertIter.reset();
  while (vertIter.next()) {
    vertIter.value.column -= minColumn;
  }

  this._maxColumn -= minColumn;
};

/********************************************************************************************/
//Barycenters and Medians

/**
* @ignore
* Computes the array of barycenters (average) columns for the nodes in the
* unfixedLayer based on the columns of predecessors (direction < 0),
* successors (direction > 0), or both predecessors and successors (direction === 0)
* Elements without a defined barycenter will have an entry of -1.
* @this {LayeredDigraphLayout}
* @param {number} unfixedLayer
* @param {number} direction
* @return {Array.<number>} Returns the array of barycenters (average) columns for the nodes in
* the unfixedLayer.
*/
LayeredDigraphLayout.prototype.barycenters = function(unfixedLayer, direction) {
  if (Debug) {
    Util.checkRealNumber(unfixedLayer, LayeredDigraphLayout, 'barycenters:unfixedLayer');
    Util.checkRealNumber(direction, LayeredDigraphLayout, 'barycenters:direction');
  }
  // Fill unfixedLayerNodes with nodes in the unfixedLayer, ordered by index.
  var unfixedLayerNodes = this._getCachedNodeArrayList(unfixedLayer);
  var num = this._indices[unfixedLayer];

  var barycentersArr = [];

  var index;
  for (index = 0; index < num; index++) {
    var vertex = unfixedLayerNodes[index];

    // Calculate the predecessor link list, based on direction.
    var linksP = null;
    if (direction <= 0) {
      linksP = vertex.sourceEdgesList;
    }
    // Calculate the successor link list, based on direction.
    var linksS = null;
    if (direction >= 0) {
      linksS = vertex.destinationEdgesList;
    }

    // Compute the barycenter.
    // The variable total counts the total column position.
    // The variable N counts the number of predecessors or successors,
    // and any node in the same layer that this node is near.
    var total = 0;
    var N = 0;

    // regardless of direction, use the column of the node that should be Near to this node
    var near = vertex.near;
    if (near !== null && near.layer === vertex.layer) {
      total += near.column - 1;  //??? -1
      N++;
    }
    var edge;
    if (linksP !== null) {
      // Contribution to barycenter from predecessors not on same layer.
      for (var posP = 0; posP < linksP.count; posP++) {
        edge = linksP._arr[posP];
        var fromVertex = edge.fromVertex;
        if (edge.valid && !edge.rev && (fromVertex.layer !== unfixedLayer)) {
          total += fromVertex.column + edge.portFromColOffset;
          N++;
        }
      }
    }

    if (linksS !== null) {
      // Contribution to barycenter from successors not on same layer.
      for (var posS = 0; posS < linksS.count; posS++) {
        edge = linksS._arr[posS];
        var toVertex = edge.toVertex;
        if (edge.valid && !edge.rev && (toVertex.layer !== unfixedLayer)) {
          total += toVertex.column + edge.portToColOffset;
          N++;
        }
      }
    }

    // Calculate the barycenter.
    if (N === 0) {
      barycentersArr[index] = -1;
    } else {
      barycentersArr[index] = total / N;
    }
  }
  this._freeCachedNodeArrayList(unfixedLayer, unfixedLayerNodes);
  return barycentersArr;
};

/**
* @ignore
* Computes the array of median columns for the nodes in the
* unfixedLayer based on the columns of predecessors (direction < 0),
* successors (direction > 0), or both predecessors and successors (direction === 0).
* Elements without a defined median will have an entry of -1.
* @this {LayeredDigraphLayout}
* @param {number} unfixedLayer
* @param {number} direction
* @return {Array.<number>} Returns the array of median columns for the nodes in
* the unfixedLayer.
*/
LayeredDigraphLayout.prototype.medians = function(unfixedLayer, direction) {
  if (Debug) {
    Util.checkRealNumber(unfixedLayer, LayeredDigraphLayout, 'medians:unfixedLayer');
    Util.checkRealNumber(direction, LayeredDigraphLayout, 'medians:direction');
  }
  // Fill unfixedLayerNodes with nodes in the unfixedLayer, ordered by index.
  var unfixedLayerNodes = this._getCachedNodeArrayList(unfixedLayer);
  var num = this._indices[unfixedLayer];

  var mediansArr = [];

  for (var index = 0; index < num; index++) {
    var vertex = unfixedLayerNodes[index];

    // Calculate the predecessor link list, based on direction.
    var linksP = null;
    if (direction <= 0) {
      linksP = vertex.sourceEdgesList;
    }

    // Calculate the successor link list, based on direction.
    var linksS = null;
    if (direction >= 0) {
      linksS = vertex.destinationEdgesList;
    }

    // Compute the median.
    // The variable N counts the number of predecessors or successors not on same layer,
    // and any node in the same layer that this node is near.
    var N = 0;

    // Allocate an array of integers to hold the columns of the predecessors
    //  and successors.
    var myColumnsPS = [];

    var near = vertex.near;
    if (near !== null && near.layer === vertex.layer) {
      myColumnsPS[N] = near.column - 1; //??? -1
      N++;
    }

    // Count the total number of predecessors and successors not on same layer.
    // And fill in the myColumnsPS array with the columns of the predecessors and successors not on same layer.
    var edge;
    if (linksP !== null) {
      for (var posP = 0; posP < linksP.count; posP++) {
        edge = linksP._arr[posP];
        var fromVertex = edge.fromVertex;
        if (edge.valid && !edge.rev && (fromVertex.layer !== unfixedLayer)) {
          myColumnsPS[N] = fromVertex.column + edge.portFromColOffset;
          N++;
        }
      }
    }

    if (linksS !== null) {
      for (var posS = 0; posS < linksS.count; posS++) {
        edge = linksS._arr[posS];
        var toVertex = edge.toVertex;
        if (edge.valid && !edge.rev && (toVertex.layer !== unfixedLayer)) {
          myColumnsPS[N] = toVertex.column + edge.portToColOffset;
          N++;
        }
      }
    }

    if (N === 0) {
      mediansArr[index] = -1;
    } else {
      // sort the array of columns
      myColumnsPS.sort(function(a, b) { return a - b; });

      // Calculate the position of the median.
      var M = N >> 1;
      // If there is a distinct median, use it.
      if (N & 1) {
        mediansArr[index] = myColumnsPS[M];
        // If there are two medians, take their average.
      } else {
        mediansArr[index] = (myColumnsPS[M - 1] + myColumnsPS[M]) >> 1;
      }
    }
  }
  this._freeCachedNodeArrayList(unfixedLayer, unfixedLayerNodes);
  return mediansArr;
};

/********************************************************************************************/
//Component methods

/**
* @ignore
* Uses a depth first search algorithm to set the component of all nodes in a component.
* Tight** functions only set the component and recurse on nodes which are "tight",
* in the sense that the nodes are separated by a link which corresponds to the
* minimum link length of the link between the two nodes.
* **Unset functions only set the component and recurse on nodes whose component is currently
* set to the unset value.
* The forward and backward bools indicate the direction to use for a
* directed depth first search from node.
* @this {LayeredDigraphLayout}
* @param {LayeredDigraphVertex} v
* @param {number} component
* @param {number} unset
* @param {boolean} forward
* @param {boolean} backward
*/
LayeredDigraphLayout.prototype.tightComponentUnset = function(v, component, unset, forward, backward) {
  if (v.component === unset) {
    v.component = component;
    var length, minLength;
    if (forward) {
      var succEdgeIter = v.destinationEdges;
      while (succEdgeIter.next()) {
        var succVertex = succEdgeIter.value.toVertex;
        length = v.layer - succVertex.layer;
        minLength = this.linkMinLength(succEdgeIter.value);
        if (length === minLength) {
          this.tightComponentUnset(succVertex, component, unset, forward, backward);
        }
      }
    }

    if (backward) {
      var predEdgeIter = v.sourceEdges;
      while (predEdgeIter.next()) {
        var predVertex = predEdgeIter.value.fromVertex;
        length = predVertex.layer - v.layer;
        minLength = this.linkMinLength(predEdgeIter.value);
        if (length === minLength) {
          this.tightComponentUnset(predVertex, component, unset, forward, backward);
        }
      }
    }
  }
};

/**
* @ignore
* Uses a depth first search algorithm to set the component of all nodes in a component.
* Unset functions only set the component and recurse on nodes whose component is currently
* set to the unset value.
* The forward and backward bools indicate the direction to use for a
* directed depth first search from node.
* @this {LayeredDigraphLayout}
* @param {LayeredDigraphVertex} v
* @param {number} component
* @param {number} unset
* @param {boolean} forward
* @param {boolean} backward
*/
LayeredDigraphLayout.prototype.componentUnset = function(v, component, unset, forward, backward) {
  if (v.component === unset) {
    v.component = component;
    if (forward) {
      var succEdgeIter = v.destinationEdges;
      var succVertex;
      while (succEdgeIter.next()) {
        succVertex = succEdgeIter.value.toVertex;
        this.componentUnset(succVertex, component, unset, forward, backward);
      }
    }

    if (backward) {
      var predEdgeIter = v.sourceEdges;
      var predVertex;
      while (predEdgeIter.next()) {
        predVertex = predEdgeIter.value.fromVertex;
        this.componentUnset(predVertex, component, unset, forward, backward);
      }
    }
  }
};

/********************************************************************************************/

/**
* @ignore
* Removes cycles from the input network by reversing some number of links.
* By default, this just calls {@link #greedyCycleRemoval} or {@link #depthFirstCycleRemoval},
* as appropriate, give the value of {@link #cycleRemoveOption}.
* @this {LayeredDigraphLayout}
*/
LayeredDigraphLayout.prototype.removeCycles = function() {
  var iter = this.network.edges.iterator;
  while (iter.next()) {
    var edge = iter.value;
    edge.rev = false;
  }
  switch (this._cycleRemoveOption) {
    default:
    case LayeredDigraphLayout.CycleGreedy:
      this.greedyCycleRemoval();
      break;
    case LayeredDigraphLayout.CycleDepthFirst:
      this.depthFirstSearchCycleRemoval();
      break;
  }
};

/********************************************************************************************/
// Greedy Cycle Removal

/**
* @ignore
* Removes cycles from the input network using a Greedy-Cycle-Removal algorithm.
* The idea is to induce an order on all nodes
* in the network (U1, U2, U3, ..., Uk) such that for the majority of links L = (Ui, Uj)
* it is true that i < j.  All links L = (Ui, Uj) such that i > j are reversed.
* @this {LayeredDigraphLayout}
*/
LayeredDigraphLayout.prototype.greedyCycleRemoval = function() {
  // The array nodes will represent the ordering of the nodes.
  var l = 0;
  var r = this.network.vertexes.count - 1;
  var nodes = [];
  nodes.length = r + 1;

  // Every node is initially valid -- i.e., available to be added to the ordering.
  var vertIter = this.network.vertexes.iterator;
  while (vertIter.next()) {
    vertIter.value.valid = true;
  }

  // While some node is still valid...
  while (this.greedyCycleRemovalFindNode(this.network) !== null) {
    var vertex;
    // Add all sink nodes to the ordering at the rightmost available position
    //  and invalidate the node.
    vertex = this.greedyCycleRemovalFindSink(this.network);
    while (vertex !== null) {
      nodes[r] = vertex;
      r--;
      vertex.valid = false;
      vertex = this.greedyCycleRemovalFindSink(this.network);
    }
    // Add all source nodes to the ordering at the leftmost available position,
    //  and invalidate them.
    vertex = this.greedyCycleRemovalFindSource(this.network);
    while (vertex !== null) {
      nodes[l] = vertex;
      l++;
      vertex.valid = false;
      vertex = this.greedyCycleRemovalFindSource(this.network);
    }
    // Add a node which maximizes outdeg - indeg at the leftmost available position,
    //  and invalidate the node.
    // This is the greedy step, which locally maximizes the number of "good" links
    //  for a given number of "bad" links.
    vertex = this.greedyCycleRemovalFindNodeMaxDegDiff(this.network);
    if (vertex !== null) {
      nodes[l] = vertex;
      l++;
      vertex.valid = false;
    }
  }

  // Set the index of each node to the appropriate order position.
  var nodeIndex;
  for (nodeIndex = 0; nodeIndex < this.network.vertexes.count; nodeIndex++) {
    nodes[nodeIndex].index = nodeIndex;
  }

  // Reverse the necessary links.
  var edgeIter = this.network.edges.iterator;
  while (edgeIter.next()) {
    var edge = edgeIter.value;
    var fromIndex = edge.fromVertex.index;
    var toIndex = edge.toVertex.index;
    if (fromIndex > toIndex) {
      this.network.reverseEdge(edge);
      edge.rev = true;
    }
  }
};

/**
* @ignore
* Finds a valid node in the network.
* Returns null if no valid node exists.
* Used by {@link #greedyCycleRemoval}.
* @this {LayeredDigraphLayout}
* @param {LayoutNetwork} network
* @return {LayeredDigraphVertex} Returns a valid node in the network or null if no valid nodes exist.
*/
LayeredDigraphLayout.prototype.greedyCycleRemovalFindNode = function(network) {
  var iter = network.vertexes.iterator;
  while (iter.next()) {
    var vertex = iter.value;
    if (vertex.valid) {
      return vertex;
    }
  }
  return null;
};

/**
* @ignore
* Finds a sink node in the network.  A node is considered a sink node if it is
* valid and all of its successors are invalid.  A valid node with no successors
* is vacuously a sink.
* Returns null if no valid sink node exists.
* Used by {@link #greedyCycleRemoval}.
* @this {LayeredDigraphLayout}
* @param {LayoutNetwork} network
* @return {LayeredDigraphVertex} Returns a sink node in the network, or null if no valid sink node exists.
*/
LayeredDigraphLayout.prototype.greedyCycleRemovalFindSink = function(network) {
  var vertIter = network.vertexes.iterator;
  while (vertIter.next()) {
    var vertex = vertIter.value;
    if (vertex.valid) {
      var sink = true;
      var edgeIter = vertex.destinationEdges;
      while (edgeIter.next()) {
        if (edgeIter.value.toVertex.valid) {
          sink = false;
          break;
        }
      }
      if (sink) return vertex;
    }
  }
  return null;
};

/**
* @ignore
* Finds a source node in the network.  A node is considered a source node if it is
* valid and all of its predecessors are invalid.  A valid node with no predecessors
* is vacuously a source.
* Returns null if no valid source node exists.
* Used by {@link #greedyCycleRemoval}.
* @this {LayeredDigraphLayout}
* @param {LayoutNetwork} network
* @return {LayeredDigraphVertex} Returns a source node in the network, or null if no valid source node exists.
*/
LayeredDigraphLayout.prototype.greedyCycleRemovalFindSource = function(network) {
  var vertIter = network.vertexes.iterator;
  while (vertIter.next()) {
    var vertex = vertIter.value;
    if (vertex.valid) {
      var source = true;
      var edgeIter = vertex.sourceEdges;
      while (edgeIter.next()) {
        if (edgeIter.value.fromVertex.valid) {
          source = false;
          break;
        }
      }
      if (source) return vertex;
    }
  }
  return null;
};

/**
* @ignore
* Finds a valid node in the network that maximizes outdeg - indeg.
* The degree difference is computed using valid successors and predecessors.
* Returns null if no valid node exists.
* Used by {@link #greedyCycleRemoval}.
* @this {LayeredDigraphLayout}
* @param {LayoutNetwork} network
* @return {LayeredDigraphVertex} Returns a valid node in the network that maximized outdeg-indeg or null
* if no valid node exists.
*/
LayeredDigraphLayout.prototype.greedyCycleRemovalFindNodeMaxDegDiff = function(network) {
  var vertexMax = null;
  var max = 0;
  var vertIter = this.network.vertexes.iterator;
  while (vertIter.next()) {
    var vertex = vertIter.value;
    if (vertex.valid) {
      var outdeg = 0;
      var succEdgeIter = vertex.destinationEdges;
      while (succEdgeIter.next()) {
        if (succEdgeIter.value.toVertex.valid) {
          outdeg++;
        }
      }
      var indeg = 0;
      var predEdgeIter = vertex.sourceEdges;
      while (predEdgeIter.next()) {
        if (predEdgeIter.value.fromVertex.valid) {
          indeg++;
        }
      }
      if ((vertexMax === null) || (max < (outdeg - indeg))) {
        vertexMax = vertex;
        max = outdeg - indeg;
      }
    }
  }
  return vertexMax;
};

/********************************************************************************************/
// DepthFirst Cycle Removal

/**
* @ignore
* Removes cycles from the input network using a depth first search.
* A link not in the depth first forest is reversed if the from-node was discovered
* and finished by the depth first search after the to-node was discovered but before
* the to-node was finished.
* @this {LayeredDigraphLayout}
*/
LayeredDigraphLayout.prototype.depthFirstSearchCycleRemoval = function() {
  // Every node is initially undiscovered and unfinished.
  var vertIter = this.network.vertexes.iterator;
  while (vertIter.next()) {
    vertIter.value.discover = -1;
    vertIter.value.finish = -1;
  }
  //Every link is initially not in the depth first forest.
  var edgeIter = this.network.edges.iterator;
  while (edgeIter.next()) {
    edgeIter.value.forest = false;
  }

  this._myDepthFirstSearchCycleRemovalTime = 0;

  vertIter.reset();
  while (vertIter.next()) {
    if (vertIter.value.sourceEdges.count === 0) {
      this.depthFirstSearchCycleRemovalVisit(vertIter.value);
    }
  }

  vertIter.reset();
  while (vertIter.next()) {
    if (vertIter.value.discover === -1) {
      this.depthFirstSearchCycleRemovalVisit(vertIter.value);
    }
  }

  // Scan through all non-forest links and reverse the appropriate links.
  edgeIter.reset();
  while (edgeIter.next()) {
    var edge = edgeIter.value;
    if (!(edge.forest)) {
      var fromVertex = edge.fromVertex;
      var fDiscover = fromVertex.discover;
      var fFinish = fromVertex.finish;

      var toVertex = edge.toVertex;
      var tDiscover = toVertex.discover;
      var tFinish = toVertex.finish;

      if ((tDiscover < fDiscover) && (fFinish < tFinish)) {
        this.network.reverseEdge(edge);
        edge.rev = true;
      }
    }
  }
};

/**
* @ignore
* Performs the recursive step of the depth first search on node.
* Updates the discover and finish time of node.
* Updates the forest flag of followed links.
* @this {LayeredDigraphLayout}
* @param {LayoutVertex} v
*/
LayeredDigraphLayout.prototype.depthFirstSearchCycleRemovalVisit = function(v) {
  v.discover = this._myDepthFirstSearchCycleRemovalTime;
  this._myDepthFirstSearchCycleRemovalTime++;
  var edgeIter = v.destinationEdges;
  while (edgeIter.next()) {
    var edge = edgeIter.value;
    var vertexS = edge.toVertex;
    if (vertexS.discover === -1) {
      edge.forest = true;
      this.depthFirstSearchCycleRemovalVisit(vertexS);
    }
  }
  v.finish = this._myDepthFirstSearchCycleRemovalTime;
  this._myDepthFirstSearchCycleRemovalTime++;
};

/********************************************************************************************/
// Layer Assignment

/**
* @ignore
* @this {LayeredDigraphLayout}
*/
LayeredDigraphLayout.prototype._assignLayersInternal = function() {
  // Every node is initially unlayered.
  var vertIter = this.network.vertexes.iterator;
  var vertex;
  while (vertIter.next()) {
    vertex = vertIter.value;
    vertex.layer = -1;
  }
  this._maxLayer = -1;
  this.assignLayers();
  //Determine the actual maximum
  vertIter.reset();
  while (vertIter.next()) {
    this._maxLayer = Math.max(this._maxLayer, vertIter.value.layer);
  }
};

/**
* Assigns every vertex in the input network to a layer.
* The layer is a non-negative integer describing which row of vertexes each vertex belongs in.
* (Do not confuse this concept of "layer" with {@link Layer}s that control the z-ordering of Parts.)
* The layering satisfies the following relationship:
* if L is a link from node U to node V, then U.layer > V.layer.
* This method can be overridden to customize how nodes are assigned layers.
* By default, this does the appropriate assignments given the value of {@link #layeringOption}.
* @expose
* @this {LayeredDigraphLayout}
* @since 1.1
*/
LayeredDigraphLayout.prototype.assignLayers = function() {
  switch (this._layeringOption) {
    case LayeredDigraphLayout.LayerLongestPathSink:
      this.longestPathSinkLayering();
      break;
    case LayeredDigraphLayout.LayerLongestPathSource:
      this.longestPathSourceLayering();
      break;
    default:
    case LayeredDigraphLayout.LayerOptimalLinkLength:
      this.optimalLinkLengthLayering();
      break;
  }
};

/********************************************************************************************/
// Longest Path Sink Layering

/**
* @ignore
* Assigns every node in the input network to a layer.
* In addition to the requirements described in {@link #assignLayers},
* LongestPathSinkLayering ensures that every sink appears in layer 0
* and every node is as close to a sink as possible.
* @this {LayeredDigraphLayout}
*/
LayeredDigraphLayout.prototype.longestPathSinkLayering = function() {
  var vertIter = this.network.vertexes.iterator;
  while (vertIter.next()) {
    var layer = this.longestPathSinkLayeringLength(vertIter.value);
    this._maxLayer = Math.max(layer, this._maxLayer);
  }
};

/**
* @ignore
* Computes the length of the longest path from node to a sink node and sets the
* layer of node to that length.
* Returns the length of the longest path from node to a sink node.
* @this {LayeredDigraphLayout}
* @param {LayoutVertex} v
* @return {number} Returns the length of the longest path from node to a sink node.
*/
LayeredDigraphLayout.prototype.longestPathSinkLayeringLength = function(v) {
  var length = 0;
  if (v.layer === -1) {
    var edgeIter = v.destinationEdges;
    while (edgeIter.next()) {
      var edge = edgeIter.value;
      var minLength = this.linkMinLength(edge);
      length = Math.max(length, this.longestPathSinkLayeringLength(edge.toVertex) + minLength);
    }
    v.layer = length;
  } else {
    length = v.layer;
  }

  return length;
};

/********************************************************************************************/
// Longest Path Source Layering

/**
* @ignore
* Assigns every node in the input network to a layer.
* In addition to the requirements described in {@link #assignLayers},
* LongestPathSourceLayering ensures that every source appears in layer maxlayer
* and every node is as close to a source as possible.
* @this {LayeredDigraphLayout}
*/
LayeredDigraphLayout.prototype.longestPathSourceLayering = function() {
  var layer;
  var vertIter = this.network.vertexes.iterator;
  while (vertIter.next()) {
    layer = this.longestPathSourceLayeringLength(vertIter.value);
    this._maxLayer = Math.max(layer, this._maxLayer);
  }

  // Restore the correct orientation of the network,
  //  since LongestPathSourceLayeringLength assigns layers "backwards".
  vertIter.reset();
  var vertex;
  while (vertIter.next()) {
    vertex = vertIter.value;
    vertex.layer = this._maxLayer - vertex.layer;
  }
};

/**
* @ignore
* Computes the length of the longest path from node to a source node and sets the
* layer of node to that length.
* Returns the length of the longest path from node to a source node.
* @this {LayeredDigraphLayout}
* @param {LayeredDigraphVertex} v
* @return {number} Returns the length of the longest path from node to a source node.
*/
LayeredDigraphLayout.prototype.longestPathSourceLayeringLength = function(v) {
  var length = 0;
  if (v.layer === -1) {
    var minLength;
    var edge;
    var edgeIter = v.sourceEdges;
    while (edgeIter.next()) {
      edge = edgeIter.value;
      minLength = this.linkMinLength(edge);
      length = Math.max(length, this.longestPathSourceLayeringLength(edge.fromVertex) + minLength);
    }
    v.layer = length;
  } else {
    length = v.layer;
  }

  return length;
};

/********************************************************************************************/
// Optimal Link Length Layering

/**
* @ignore
* Assigns every node in the input network to a layer.
* In addition to the requirements described in AssignLayers(),
* OptimalLinkLengthLayering ensures that nodes are set in layers
* to minimize the total weighted link length.
* Hence, OptimalLinkLengthLayering minimizes the sum
* (U.layer - V.layer) * LinkLengthWeight(L)
* over all links L = (U,V).
* @this {LayeredDigraphLayout}
*/
LayeredDigraphLayout.prototype.optimalLinkLengthLayering = function() {
  // Begin by performing a LongestPathSinkLayering.
  // This ensures that all sinks are in layer 0 and evert node
  //  is as close to a sink as possible.
  this.longestPathSinkLayering();

  // Every node is initially invalid -- i.e., it hasn't been reached by
  //  the depth first search.
  // This is mainly an optimization -- depth first searching through a
  //  portion of the network that is already valid will not change
  //  the layering, but it will spend the time calculating that nothing needs
  //  to be done.  By only examining invalid nodes, the running time improves.
  var vertIter = this.network.vertexes.iterator;
  while (vertIter.next()) {
    vertIter.value.valid = false;
  }

  // Perform a depth first search from the sources of the network.
  // At the conclusion of this depth first search, all nodes have been
  //  moved into their appropriate layers relative to their decendents.
  vertIter.reset();
  while (vertIter.next()) {
    if (vertIter.value.sourceEdges.count === 0) {
      this.optimalLinkLengthLayeringDepthFirstSearch(vertIter.value);
    }
  }

  // However, the entire network may have been shifted.
  // Find the minimum layer.
  var minLayer = Infinity;
  vertIter.reset();
  while (vertIter.next()) {
    minLayer = Math.min(minLayer, vertIter.value.layer);
  }
  // And move evey node so that the minimum layer is now layer 0.
  // Also recompute the maxLayer, since nodes may have been pushed.
  this._maxLayer = -1;
  vertIter.reset();
  while (vertIter.next()) {
    vertIter.value.layer -= minLayer;
    this._maxLayer = Math.max(this._maxLayer, vertIter.value.layer);
  }
};

/**
* @ignore
* Performs the depth first search of the network.
* After traversing all descendents, the node is "pull"-ed into
* the appropriate layer.
* @this {LayeredDigraphLayout}
* @param {LayeredDigraphVertex} v
*/
LayeredDigraphLayout.prototype.optimalLinkLengthLayeringDepthFirstSearch = function(v) {
  if (!(v.valid)) {
    v.valid = true;
    var destEdgeIter = v.destinationEdges;
    while (destEdgeIter.next()) {
      this.optimalLinkLengthLayeringDepthFirstSearch(destEdgeIter.value.toVertex);
    }
    this.optimalLinkLengthLayeringPull(v);
    this.optimalLinkLengthLayeringPush(v);
  }
};

/**
* @ignore
* Attempts to move node and its tight component to a higher layer.
* @this {LayeredDigraphLayout}
* @param {LayeredDigraphVertex} v
*/
LayeredDigraphLayout.prototype.optimalLinkLengthLayeringPull = function(v) {
  // Every node is initially unset -- i.e., it hasn't been assigned to
  //  a component.
  var vertIter = this.network.vertexes.iterator;
  while (vertIter.next()) {
    vertIter.value.component = -1;
  }

  // Constants for parent and child components.
  /** @ignore @constant */
  var parentComponent = 0;
  /** @ignore @constant */
  var childComponent = 1;

  // Form the tight forward component of node's non-tight parents.
  // The idea is to exclude from node's component all those nodes which
  //  are already tight with respect to the parents of node, since
  //  node will move towards it's non-tight parents.
  var predEdgeIter = v.sourceEdgesList._arr;
  var l = predEdgeIter.length;
  for (var i = 0; i < l; i++) {
    var predEdge = predEdgeIter[i];
    var minLength = this.linkMinLength(predEdge);
    var length = predEdge.fromVertex.layer - predEdge.toVertex.layer;
    if (length > minLength) {
      this.tightComponentUnset(predEdge.fromVertex, parentComponent, -1, true, false);
    }
  }

  // Form the tight component of node which excludes nodes in the
  //  parent component.
  // The tight component of node is the set of nodes which
  //  are decendents or ancestors of node and have a path of "tight"
  //  links from or to node.
  // A link L from node U to node V is tight if
  //  U.layer - V.layer === LinkMinLength(L)
  // Hence, if node can be shifted to a higher layer, all of these
  //  nodes must also be shifted.
  this.tightComponentUnset(v, childComponent, -1, true, true);

  // If node is in it's parent component, then it cannot be pulled
  //  (it would violate some LinkMinLength),
  //  or it has been cast out of the childComponent and a pull
  //  would not reduce the weighted sum of the links in the network.
  while (v.component !== parentComponent) {
    // Compute the difference in the weights of links into the childComponent and
    //  links out of the childCcomponent.
    var totalDiff = 0;
    // Keep track of the maximum amount by which the component can be shifted.
    var shift = Infinity;
    // Also compute the node in the childComponent which satisfies the following:
    //  the node has no children in the childComponent
    //  the node minimizes the weighted difference of links into the node
    //  and links out of the node (i.e., the node is "best" in the
    //  sense that it will most increase the totalDiff next time through
    //  the loop.
    var minDiff = 0;
    var minDiffVertex = null;

    // Step through all nodes in the network.
    var childCompVertexIter = this.network.vertexes.iterator;
    while (childCompVertexIter.next()) {
      var childCompVertex = childCompVertexIter.value;
      if (childCompVertex.component === childComponent) {
        // Compute the weighted difference of links into the node
        //  and links out of the node.
        // Also record if the node has no children in the childComponent.
        var diff = 0;
        var children = false;

        // Links into the node.
        var childCompPredEdgeIter = childCompVertex.sourceEdgesList._arr;
        l = childCompPredEdgeIter.length;
        for (var i = 0; i < l; i++) {
          var predEdge = childCompPredEdgeIter[i];
          var predVertex = predEdge.fromVertex;
          // Update the node difference.
          diff += this.linkLengthWeight(predEdge);
          if (predVertex.component !== childComponent) {
            // Update the total difference.
            totalDiff += this.linkLengthWeight(predEdge);
            // Update shift if the link has the limiting length.
            var childCompLength = predVertex.layer - childCompVertex.layer;
            var childCompMinLength = this.linkMinLength(predEdge);
            shift = Math.min(shift, childCompLength - childCompMinLength);
          }
        }

        // Links out of the node.
        var childCompSuccEdgeIter = childCompVertex.destinationEdgesList._arr;
        l = childCompSuccEdgeIter.length;
        for (var i = 0; i < l; i++) {
          var succEdge = childCompSuccEdgeIter[i];
          var succVertex = succEdge.toVertex;
          // Update the node difference.
          diff -= this.linkLengthWeight(succEdge);
          if (succVertex.component !== childComponent) {
            // Update the total difference.
            totalDiff -= this.linkLengthWeight(succEdge);
          } else {
            // Update the children.
            children = true;
          }
        }

        // Update the minimum node difference.
        if (((minDiffVertex === null) || (diff < minDiff)) && (!children)) {
          minDiffVertex = childCompVertex;
          minDiff = diff;
        }
      }
    }

    // If the sum of the weights of links into the component is greater than
    //  the sum of the weights out of the component, then shifting the
    //  component to a higher level will decrease the weighted sum of the
    //  links in the network.
    // If not, cast out the MinDiffNode (which will have the greatest effect
    //  in increasing the totalDiff next time through) and recompute.
    if (totalDiff > 0) {
      vertIter.reset();
      while (vertIter.next()) {
        var vertex = vertIter.value;
        if (vertex.component === childComponent) {
          vertex.layer += shift;
          // Since the node was shifted, invalidate it so that additional shifts can be made.
          // pNode.valid = false;
        }
      }
      // Break the while loop.
      v.component = parentComponent;
    } else {
      minDiffVertex.component = parentComponent;
    }
  }
};

/**
* @ignore
* Attempts to move node and its tight component to a lower layer.
* @this {LayeredDigraphLayout}
* @param {LayeredDigraphVertex} v
*/
LayeredDigraphLayout.prototype.optimalLinkLengthLayeringPush = function(v) {
  // Every node is initially unset -- i.e., it hasn't been assigned to
  //  a component.
  var vertIter = this.network.vertexes.iterator;
  while (vertIter.next()) {
    vertIter.value.component = -1;
  }

  // Constants for parent and child components.
  /** @ignore @constant */
  var parentComponent = 0;
  /** @ignore @constant */
  var childComponent = 1;

  // Form the tight forward component of node.
  // The tight forward component of node is the set of nodes which
  //  are decendents of node and have a path of "tight"
  //  links from or to node.
  // A link L from node U to node V is tight if
  //  U.layer - V.layer === LinkMinLength(L)
  // Hence, if node can be shifted to a lower layer, all of these
  //  nodes must also be shifted.
  this.tightComponentUnset(v, childComponent, -1, true, false);

  // If node is in it's parent component, then it has been cast out of the
  //  childComponent and a push would not reduce the weighted sum of the
  //  links in the network.
  while (v.component !== parentComponent) {
    // Compute the difference in the weights of links into the childComponent and
    //  links out of the childCcomponent.
    var totalDiff = 0;
    // Keep track of the maximum amount by which the component can be shifted.
    var shift = Infinity;
    // Also compute the node in the childComponent which satisfies the following:
    //  the node has no parents in the childComponent
    //  the node maximizes the weighted difference of links into the node
    //   and links out of the node (i.e., the node is "best" in the
    //   sense that it will most decrease the totalDiff next time through
    //   the loop.
    var maxDiff = 0;
    var maxDiffVertex = null;
    // Step through all nodes in the network.
    var childCompVertexIter = this.network.vertexes.iterator;
    while (childCompVertexIter.next()) {
      var childCompVertex = childCompVertexIter.value;
      if (childCompVertex.component === childComponent) {
        // Compute the weighted difference of links into the node
        //  and links out of the node.
        // Also record if the node has no children in the childComponent.
        var diff = 0;
        var parents = false;

        // Links into the node.
        var predEdgeIter = childCompVertex.sourceEdgesList._arr;
        var l = predEdgeIter.length;
        for (var i = 0; i < l; i++) {
          var predEdge = predEdgeIter[i];
          var predVertex = predEdge.fromVertex;
          // Update the node difference.
          diff += this.linkLengthWeight(predEdgeIter.value);
          if (predVertex.component !== childComponent) {
            // Update the total difference.
            totalDiff += this.linkLengthWeight(predEdgeIter.value);
          } else {
            // Update the parents.
            parents = true;
          }
        }
        // Links out of the node.
        var succEdgeIter = childCompVertex.destinationEdgesList._arr;
        l = succEdgeIter.length;
        for (var i = 0; i < l; i++) {
          var succEdge = succEdgeIter[i];
          var succVertex = succEdge.toVertex;
          // Update the node difference.
          diff -= this.linkLengthWeight(succEdge);
          if (succVertex.component !== childComponent) {
            // Update the total difference.
            totalDiff -= this.linkLengthWeight(succEdge);
            // Update shift if the link has the limiting length.
            var childCompLength = childCompVertex.layer - succVertex.layer;
            var childCompMinLength = this.linkMinLength(succEdge);
            shift = Math.min(shift, childCompLength - childCompMinLength);
          }
        }

        // Update the maximum difference node.
        if (((maxDiffVertex === null) || (diff > maxDiff)) && (!parents)) {
          maxDiffVertex = childCompVertex;
          maxDiff = diff;
        }
      }
    }

    // If the sum of the weights of links into the component is greater than
    //  the sum of the weights out of the component, then shifting the
    //  component to a higher level will decrease the weighted sum of the
    //  links in the network.
    // If not, cast out the pMinDiffNode (which will have the greatest effect
    //  in increasing the totalDiff next time through) and recompute.
    if (totalDiff < 0) {
      vertIter.reset();
      while (vertIter.next()) {
        var vertex = vertIter.value;
        if (vertex.component === childComponent) {
          vertex.layer -= shift;
          // Since the node was shifted, invalidate it so that additional shifts can be made.
          //node.valid = false;
        }
      }
      // Break the while loop.
      v.component = parentComponent;
    } else {
      maxDiffVertex.component = parentComponent;
    }
  }
};

/********************************************************************************************/
//Make Proper methods

/**
* @ignore
* Converts the input network into a proper digraph; i.e., artificial nodes and links
* are introduced into the network such that every link is between nodes in adjacent
* layers.  This has the effect of breaking up long links into a sequence of artificial
* nodes.
* This method must not change the layer of any existing node, nor add or remove any layers.
* @this {LayeredDigraphLayout}
*/
LayeredDigraphLayout.prototype.makeProper = function() {
  // Initially, all links are invalid.
  // As links are examined, they are either validated or a sequence of
  //  valid links is added to represent long list.
  var edgeIter = this.network.edges.iterator;
  var edge;
  var edgeArray = [];
  while (edgeIter.next()) {
    edge = edgeIter.value;
    edge.valid = false;
    // The array is being constructed this way rather than using List.toArray since
    // the list is already being iterated through.
    edgeArray.push(edge);
  }

  // Since we are adding links to the network as we examine links,
  //  only calculate ports on invalid links.  This will be the first
  //  set of links, which correspond to "real" links in the network.
  for (var i = 0; i < edgeArray.length; i++) {
    edge = edgeArray[i];
    if (edge.valid) continue;
    if ((edge.fromVertex._node === null || edge.toVertex._node === null) && edge.fromVertex.layer === edge.toVertex.layer)
      continue;
    // Set the portFromColOffset and portToColOffset and portFromPos and portToPos.
    // This allows the crossing matrix to correctly calculate the crossings
    //  for nodes with multiple ports and assists in straightening.
    var portFromColOffset, portToColOffset;
    var portFromPos, portToPos;
    portFromColOffset = portToColOffset = portFromPos = portToPos = 0;
    var vertexFrom = edge.fromVertex;
    var vertexTo = edge.toVertex;
    if (edge.link !== null) {
      var reallink = edge.link;
      if (reallink === null) continue;
      var realFromNode = vertexFrom._node;
      var realToNode = vertexTo._node;
      if (realFromNode === null || realToNode === null) continue;
      var fromNode = reallink.fromNode;
      var toNode = reallink.toNode;
      var fromPort = reallink.fromPort;
      var toPort = reallink.toPort;
      if (edge.rev) {
        var dummy = fromNode;
        var dummyelt = fromPort;
        fromNode = toNode;
        fromPort = toPort;
        toNode = dummy;
        toPort = dummyelt;
      }
      var nodeFromPt = vertexFrom._focus;
      var nodeToPt = edge.toVertex._focus;
      var fromR = (edge.rev) ? vertexTo._bounds : vertexFrom._bounds;
      var portFromPt = Util.tempPoint();
      if (isNaN(fromR.x)) {
        portFromPt.assign(nodeFromPt);
      } else {
        fromNode.getRelativePoint(fromPort, Spot.Center, portFromPt);
      }
      if (realFromNode !== fromNode && !isNaN(fromR.x) && fromNode.isVisible()) {
        var realFromR = vertexFrom._bounds;
        if (!isNaN(realFromR.x)) {
          portFromPt.x += fromR.x - realFromR.x;
          portFromPt.y += fromR.y - realFromR.y;
        }
      }
      var toR = (edge.rev) ? vertexFrom._bounds : vertexTo._bounds;
      var portToPt = Util.tempPoint();
      if (isNaN(toR.x)) {
        portToPt.assign(nodeToPt);
      } else {
        toNode.getRelativePoint(toPort, Spot.Center, portToPt);
      }
      if (realToNode !== toNode && !isNaN(toR.x) && toNode.isVisible()) {
        var realToR = vertexTo._bounds;
        if (!isNaN(realToR.x)) {
          portToPt.x += toR.x - realToR.x;
          portToPt.y += toR.y - realToR.y;
        }
      }
      if (this._direction === 90 || this._direction === 270) {
        portFromColOffset = Math.round((portFromPt.x - nodeFromPt.x) / this._columnSpacing);
        portFromPos = portFromPt.x;
        portToColOffset = Math.round((portToPt.x - nodeToPt.x) / this._columnSpacing);
        portToPos = portToPt.x;
      } else {
        portFromColOffset = Math.round((portFromPt.y - nodeFromPt.y) / this._columnSpacing);
        portFromPos = portFromPt.y;
        portToColOffset = Math.round((portToPt.y - nodeToPt.y) / this._columnSpacing);
        portToPos = portToPt.y;
      }
      Util.freePoint(portFromPt);
      Util.freePoint(portToPt);

      edge.portFromColOffset = portFromColOffset;
      edge.portFromPos = portFromPos;
      edge.portToColOffset = portToColOffset;
      edge.portToPos = portToPos;
    } else {
      edge.portFromColOffset = 0;
      edge.portFromPos = 0;
      edge.portToColOffset = 0;
      edge.portToPos = 0;
    }

    var layerFrom = vertexFrom.layer;
    var layerTo = vertexTo.layer;
    var aroundNodes = this._goesAround(edge);
    var aroundfromnode = (aroundNodes === 1 || aroundNodes === 3) ? true : false;
    var aroundtonode = (aroundNodes === 2 || aroundNodes === 3) ? true : false;
    // Pointers to the "artifical" nodes and links added.
    var edgeA;
    var vertexA;
    // add an artifical node in the to-node's layer when a reversed link is coming back around
    if (aroundtonode) {
      //// Add an artificial node at the appropriate layer.
      vertexA = this.network.createVertex();
      vertexA._node = null;
      vertexA.artificialType = 1;
      vertexA.layer = layerFrom;
      vertexA.near = vertexFrom;
      this.network.addVertex(vertexA);
      // Link up the artifical node to its parent.
      edgeA = this.network.linkVertexes(vertexFrom, vertexA, edge.link);
      // not between adjacent layers
      edgeA.valid = false;
      // Inherit the reversed status of the "real" link.
      edgeA.rev = edge.rev;
      edgeA.portFromColOffset = portFromColOffset;
      edgeA.portToColOffset = 0;
      edgeA.portFromPos = portFromPos;
      edgeA.portToPos = 0;
      vertexFrom = vertexA;
    }
    var loopback = 1;
    if (aroundfromnode) loopback--;
    if (layerFrom - layerTo > loopback && layerFrom > 0) {
      // Invalidate the "real" link.  The remainder of the layout algorithm will
      //  only work on "valid" links, which will be links between adjacent layers.
      edge.valid = false;
      // Add the first artificial node at the appropriate layer.
      vertexA = this.network.createVertex();
      vertexA._node = null;
      vertexA.artificialType = 2;
      vertexA.layer = layerFrom - 1;
      this.network.addVertex(vertexA);
      // Link up the artifical node to its parent.
      edgeA = this.network.linkVertexes(vertexFrom, vertexA, edge.link);
      // Validate the new link, since it is between adjacent layers.
      edgeA.valid = true;
      // Inherit the reversed status of the "real" link.
      edgeA.rev = edge.rev;
      // The portFromColOffset is inherited from the "real" link,
      //  but portToColOffset is to an artifical node, so is 0.
      edgeA.portFromColOffset = (aroundtonode ? 0 : portFromColOffset);
      edgeA.portToColOffset = 0;
      edgeA.portFromPos = (aroundtonode ? 0 : portFromPos);
      edgeA.portToPos = 0;
      // Make the new artifical node the from node and loop.
      vertexFrom = vertexA;
      layerFrom--;
      // Add the intermediate artifical nodes.
      while (layerFrom - layerTo > loopback && layerFrom > 0) {
        // Add an artificial node at the appropriate layer.
        vertexA = this.network.createVertex();
        vertexA._node = null;
        vertexA.artificialType = 3;
        vertexA.layer = layerFrom - 1;
        this.network.addVertex(vertexA);
        // Link up the artifical node to its parent.
        edgeA = this.network.linkVertexes(vertexFrom, vertexA, edge.link);
        // Validate the new link, since it is between adjacent layers.
        edgeA.valid = true;
        // Inherit the reversed status of the "real" link.
        edgeA.rev = edge.rev;
        // The portFromColOffset and portToColOffset are to artificial nodes,
        //  so are 0.
        edgeA.portFromColOffset = 0;
        edgeA.portToColOffset = 0;
        edgeA.portFromPos = 0;
        edgeA.portToPos = 0;
        // Make the new artifical node the from node and loop.
        vertexFrom = vertexA;
        layerFrom--;
      }

      // Link up the last artifical node to the "real" to node.
      edgeA = this.network.linkVertexes(vertexA, vertexTo, edge.link);
      // Validate the new link, since it may be between adjacent layers.
      edgeA.valid = !aroundfromnode;
      if (aroundfromnode) vertexA.near = vertexTo;
      // Inherit the reversed status of the "real" link.
      edgeA.rev = edge.rev;
      // The portToColOffset is inherited from the "real" link,
      //  but portFromColOffset is to an artifical node, so is 0.
      edgeA.portFromColOffset = 0;
      edgeA.portToColOffset = portToColOffset;
      edgeA.portFromPos = 0;
      edgeA.portToPos = portToPos;
    } else {
      // The "real" link is between adjacent layers, so validate it.
      edge.valid = true;
    }
  }
};

/**
* @ignore
* @this {LayeredDigraphLayout}
* @param {LayeredDigraphEdge} edge
* @return {number}
* aroundfromnode and aroundtonode are outs.
*/
LayeredDigraphLayout.prototype._goesAround = function(edge) {
  var around = 0;
  var pLink = edge.link;
  if (pLink !== null) {
    var gofromport = pLink.fromPort;
    var gotoport = pLink.toPort;
    if (gofromport !== null && gotoport !== null) {
      var gofromnode = pLink.fromNode;
      var gotonode = pLink.toNode;
      if (gofromnode !== null && gotonode !== null) {
        var fromspot = gofromport.fromSpot;
        var tospot = gotoport.toSpot;
        // ignore Link.fromSpot and .toSpot if this.setsPortSpots
        if (!this.setsPortSpots) {
          if (!pLink.fromSpot.isDefault()) fromspot = pLink.fromSpot;
          if (!pLink.toSpot.isDefault()) tospot = pLink.toSpot;
        }
        if (fromspot.isDefault() || fromspot === Spot.None) fromspot = this._getDefaultSpot(true);
        if (tospot.isDefault() || tospot === Spot.None) tospot = this._getDefaultSpot(false);
        var ortho = pLink.isOrthogonal;
        var frompt = pLink.getLinkPoint(gofromnode, gofromport, fromspot, true, ortho, gotonode, gotoport, Util.tempPoint());
        // account for node rotation
        var fromdir = pLink.getLinkDirection(gofromnode, gofromport, frompt, fromspot, true, ortho, gotonode, gotoport);
        Util.freePoint(frompt);
        // need to go around the "from" node?
        if (fromdir === this._oppositeSpotDir(edge, true)) {
          around += 1;
        } else if (this.setsPortSpots && gofromnode !== null && gofromnode.ports.count === 1) {
          if (edge.rev)
            around += 1;
        }
        var topt = pLink.getLinkPoint(gotonode, gotoport, tospot, false, ortho, gofromnode, gofromport, Util.tempPoint());
        // account for node rotation
        var todir = pLink.getLinkDirection(gotonode, gotoport, topt, tospot, false, ortho, gofromnode, gofromport);
        Util.freePoint(topt);
        // need to go around the "to" node?
        if (todir === this._oppositeSpotDir(edge, false)) {
          around += 2;
        } else if (this.setsPortSpots && gotonode !== null && gotonode.ports.count === 1) {
          if (edge.rev)
            around += 2;
        }
      }
    }
  }
  return around;
};

/**
* @ignore
* @this {LayeredDigraphLayout}
* @param {LayeredDigraphEdge} edge
* @param {boolean} from
* @return {number}
*/
LayeredDigraphLayout.prototype._oppositeSpotDir = function(edge, from) {
  if (this._direction === 90) {
    if (from && !edge.rev || !from && edge.rev)
      return 270;
    else
      return 90;
  } else if (this._direction === 180) {
    if (from && !edge.rev || !from && edge.rev)
      return 0;
    else
      return 180;
  } else if (this._direction === 270) {
    if (from && !edge.rev || !from && edge.rev)
      return 90;
    else
      return 270;
  } else {
    if (from && !edge.rev || !from && edge.rev)
      return 180;
    else
      return 0;
  }
};

/********************************************************************************************/
//Initialize Indices methods

/**
* @ignore
* @this {LayeredDigraphLayout}
*/
LayeredDigraphLayout.prototype._initializeIndicesInternal = function() {
  var indices = this._indices = [];
  var i;
  for (i = 0; i <= this._maxLayer; i++) {
    indices[i] = 0;
  }
  // Every node is initially unset -- i.e., it hasn't been assigned an index.
  var vertIter = this.network.vertexes.iterator;
  while (vertIter.next()) {
    vertIter.value.index = -1;
  }

  this.initializeIndices();

  this._maxIndex = -1;
  this._minIndexLayer = 0;
  this._maxIndexLayer = 0;
  for (i = 0; i <= this._maxLayer; i++) {
    if (indices[i] > indices[this._maxIndexLayer]) {
      this._maxIndex = indices[i] - 1;
      this._maxIndexLayer = i;
    }
    if (indices[i] < indices[this._minIndexLayer]) {
      this._minIndexLayer = i;
    }
  }

  //organize all nodes by layer, for faster access.
  this._myLayers = [];
  for (i = 0; i < indices.length; i++) {
    this._myLayers[i] = [];
  }
  vertIter.reset();
  var layer, vertex;
  while (vertIter.next()) {
    vertex = vertIter.value;
    layer = vertex.layer;
    var v = this._myLayers[layer];
    v[vertex.index] = vertex;
  }
};

/**
* @ignore
* Assigns every node in the input network an index number,
* such that nodes in the same layer will be labeled with
* consecutive indices in left to right order.
* All consecutive layout operations will preserve or update
* the indices.
* In addition, the indices array is initialized such that
* indices[layer] indicates the number of nodes in the layer.
* Finally, the variables minIndexLayer and maxIndexLayer record
* the layers that correspond to the minimum and maximum nodes
* in a layer.
* @expose
* @this {LayeredDigraphLayout}
* By default this will just call {@link #naiveInitializeIndices},
* {@link #depthfirstOutInitializeIndices}, or
* {@link #depthfirstInInitializeIndices}, as appropriate
* given the value of {@link #initializeOption}.
* This method must not change the layer of any existing node, nor add or remove any layers.
*/
LayeredDigraphLayout.prototype.initializeIndices = function() {
  switch (this._initializeOption) {
    default:
    case LayeredDigraphLayout.InitNaive:
      this.naiveInitializeIndices();
      break;
    case LayeredDigraphLayout.InitDepthFirstOut:
      this.depthFirstOutInitializeIndices();
      break;
    case LayeredDigraphLayout.InitDepthFirstIn:
      this.depthFirstInInitializeIndices();
      break;
  }
};

/********************************************************************************************/
// InitNaive index initialization

/**
* @ignore
* Assigns every node in the input network an index number,
* such that nodes in the same layer will be labeled with
* consecutive indices in left to right order.
* Uses a naive implementation that assigns indices to nodes as they
* are encountered in a sweep of the network.  Because of the way
* networks are stored, this has the effect of initially placing all
* "artificial" nodes to the right of all "real" nodes.
* @this {LayeredDigraphLayout}
*/
LayeredDigraphLayout.prototype.naiveInitializeIndices = function() {
  var layer;
  var vertIter = this.network.vertexes.iterator;
  while (vertIter.next()) {
    var vertex = vertIter.value;
    layer = vertex.layer;
    vertex.index = this._indices[layer];
    this._indices[layer]++;
  }
};

/********************************************************************************************/
//InitDepthFirstOut index initialization

/**
* @ignore
* Assigns every node in the input network an index number,
* such that nodes in the same layer will be labeled with
* consecutive indices in left to right order.
* Uses a depth first "outward" (i.e., following links from "from-node" to "to-node")
* traversal of the network, assigning indices to nodes as they are discovered.
* @this {LayeredDigraphLayout}
*/
LayeredDigraphLayout.prototype.depthFirstOutInitializeIndices = function() {
  var layer;
  // Begin at maxLayer and sweep towards 0.
  // This ensures that the sources are discovered in the correct order.
  var vertIter = this.network.vertexes.iterator;
  for (layer = this._maxLayer; layer >= 0; layer--) {
    while (vertIter.next()) {
      if ((vertIter.value.layer === layer) && (vertIter.value.index === -1)) {
        this.depthFirstOutInitializeIndicesVisit(vertIter.value);
      }
    }
    vertIter.reset();
  }
};

/**
* @ignore
* Assigns node the appropriate index and updates the indices array.
* Implements the recursive portion of a depth first search.
* @this {LayeredDigraphLayout}
* @param {LayeredDigraphVertex} v
*/
LayeredDigraphLayout.prototype.depthFirstOutInitializeIndicesVisit = function(v) {
  var layer = v.layer;
  v.index = this._indices[layer];
  this._indices[layer]++;

  // Copy the destinationLinksList into succLinksArray and sort on portFromPos.
  // This ensures that multi-port nodes initialize children in the correct order.
  var succLinksArray = v.destinationEdgesList.toArray();

  var exchange = true;
  var indexS;
  while (exchange) {
    exchange = false;
    for (indexS = 0; indexS < (succLinksArray.length - 1); indexS++) {
      var edgeL = succLinksArray[indexS];
      var edgeR = succLinksArray[indexS + 1];
      if (edgeL.portFromColOffset > edgeR.portFromColOffset) {
        exchange = true;
        succLinksArray[indexS] = edgeR;
        succLinksArray[indexS + 1] = edgeL;
      }
    }
  }

  var vertexS, edge;
  for (indexS = 0; indexS < succLinksArray.length; indexS++) {
    edge = succLinksArray[indexS];
    if (edge.valid) {
      vertexS = edge.toVertex;
      if (vertexS.index === -1) {
        this.depthFirstOutInitializeIndicesVisit(vertexS);
      }
    }
  }
};

/********************************************************************************************/
//InitDepthFirstIn index initialization

/**
* @ignore
* Assigns every node in the input network an index number,
* such that nodes in the same layer will be labeled with
* consecutive indices in left to right order.
* Uses a depth first "inward" (i.e., following links from "to-node" to "from-node")
* traversal of the network, assigning indices to nodes as they are discovered.
* @this {LayeredDigraphLayout}
*/
LayeredDigraphLayout.prototype.depthFirstInInitializeIndices = function() {
  var layer;
  // Begin at 0 and sweep towards maxLayer.
  // This ensures that the sinks are discovered in the correct order.
  var vertIter = this.network.vertexes.iterator;
  for (layer = 0; layer <= this._maxLayer; layer++) {
    while (vertIter.next()) {
      if ((vertIter.value.layer === layer) && (vertIter.value.index === -1)) {
        this.depthFirstInInitializeIndicesVisit(vertIter.value);
      }
    }
    vertIter.reset();
  }
};

/**
* @ignore
* Assigns node the appropriate index and updates the indices array.
* Implements the recursive portion of a depth first search.
* @this {LayeredDigraphLayout}
* @param {LayeredDigraphVertex} v
*/
LayeredDigraphLayout.prototype.depthFirstInInitializeIndicesVisit = function(v) {
  var layer = v.layer;
  v.index = this._indices[layer];
  this._indices[layer]++;

  // Copy the sourceLinksList into predLinksArray and sort on portToPos.
  // This ensures that multi-port nodes initialize children in the correct order.
  var predLinksArray = v.sourceEdgesList.toArray();

  var exchange = true;
  var indexP;
  while (exchange) {
    exchange = false;
    for (indexP = 0; indexP < (predLinksArray.length - 1); indexP++) {
      var edgeL = predLinksArray[indexP];
      var edgeR = predLinksArray[indexP + 1];
      if (edgeL.portToColOffset > edgeR.portToColOffset) {
        exchange = true;
        predLinksArray[indexP] = edgeR;
        predLinksArray[indexP + 1] = edgeL;
      }
    }
  }

  var vertexP, edge;
  for (indexP = 0; indexP < predLinksArray.length; indexP++) {
    edge = predLinksArray[indexP];
    if (edge.valid) {
      vertexP = edge.fromVertex;
      if (vertexP.index === -1) {
        this.depthFirstInInitializeIndicesVisit(vertexP);
      }
    }
  }
};

/********************************************************************************************/
// Initialize columns methods

/**
* @ignore
* Assigns every node in the input network a column number,
* such that nodes in the same layer will be labeled with
* increasing indices in left to right order.
* <p\>
* In addition, a node U is assigned to a column such that
* 2 * MinColumnSpace(U) + 1 columns are "allocated" to node U,
* and no two nodes have overlapping "allocations" of columns.
* All consecutive layout operations will preserve or update
* the columns.
* This method can be overridden to customize the layout algorithm.
* This method must not change the layer of any existing node, nor add or remove any layers.
* @this {LayeredDigraphLayout}
*/
LayeredDigraphLayout.prototype.initializeColumns = function() {
  this._maxColumn = -1;
  for (var layer = 0; layer <= this._maxLayer; layer++) {
    // Fill unfixedLayerNodes with nodes in the layer, ordered by index.
    var unfixedLayerNodes = this._getCachedNodeArrayList(layer);

    // Assign columns to the unfixedLayerNodes such that "allocated"
    //  columns do not overlap.
    var column = 0;
    var layerIndex = this._indices[layer];
    for (var index = 0; index < layerIndex; index++) {
      var vertex = unfixedLayerNodes[index];
      column += this.nodeMinColumnSpace(vertex, true);
      vertex.column = column;
      column += 1;
      column += this.nodeMinColumnSpace(vertex, false);
    }

    this._maxColumn = Math.max(this._maxColumn, column - 1);
    this._freeCachedNodeArrayList(layer, unfixedLayerNodes);
  }
};

/********************************************************************************************/
//Reduce Crossings methods

/**
* @ignore
* Reorders nodes within layers to reduce the total number of link
* crossings in the network.
* There are many, many possible implementations of this function.
* Basically, some iteration of MedianBarycenterCrossingReduction
* and AdjacentExchangeCrossingReductionBendStraighten
* sweeping back and forth over the layers is needed.
* The default implementation has performed favorably on a large number
* of networks, but other options are available.
* @expose
* @this {LayeredDigraphLayout}
*/
LayeredDigraphLayout.prototype.reduceCrossings = function() {
  // Record the current number of crossings and the current layout.
  // These variables will be updated with the "best" crossings and
  //  layouts produced.
  var bestcrossings = this.countCrossings();
  var bestlayout = this.saveLayout();

  var count, layer, crossings;

  // The first sequence of sweeps.
  for (count = 0; count < this._iterations; count++) {
    // Sweep from layer 0 to layer maxLayer,
    //  performing directed medianBarycenter and adjacentExchange
    //  crossing reductions on each layer.
    for (layer = 0; layer <= this._maxLayer; layer++) {
      this.medianBarycenterCrossingReduction(layer, 1);
      this.adjacentExchangeCrossingReductionBendStraighten(layer, 1, false, 1);
    }
    // Update the bestcrossings and bestlayout if an improvement was made.
    crossings = this.countCrossings();
    if (crossings < bestcrossings) {
      bestcrossings = crossings;
      bestlayout = this.saveLayout();
    }
    // Sweep from layer maxLayer to layer 0,
    //  performing directed medianBarycenter and adjacentExchange
    //  crossing reductions on each layer.
    for (layer = this._maxLayer; layer >= 0; layer--) {
      this.medianBarycenterCrossingReduction(layer, -1);
      this.adjacentExchangeCrossingReductionBendStraighten(layer, -1, false, -1);
    }
    // Update the bestcrossings and bestlayout if an improvement was made.
    crossings = this.countCrossings();
    if (crossings < bestcrossings) {
      bestcrossings = crossings;
      bestlayout = this.saveLayout();
    }
  }
  // Restore the bestlayout for subsequent operations.
  this.restoreLayout(bestlayout);

  // The second sequence of sweeps.
  for (count = 0; count < this._iterations; count++) {
    // Sweep from layer 0 to layer maxLayer,
    //  performing undirected medianBarycenter and adjacentExchange
    //  crossing reductions on each layer.
    for (layer = 0; layer <= this._maxLayer; layer++) {
      this.medianBarycenterCrossingReduction(layer, 0);
      this.adjacentExchangeCrossingReductionBendStraighten(layer, 0, false, 0);
    }
    // Update the bestcrossings and bestlayout if an improvement was made.
    crossings = this.countCrossings();
    if (crossings < bestcrossings) {
      bestcrossings = crossings;
      bestlayout = this.saveLayout();
    }
    // Sweep from layer maxLayer to layer 0,
    //  performing undirected medianBarycenter and adjacentExchange
    //  crossing reductions on each layer.
    for (layer = this._maxLayer; layer >= 0; layer--) {
      this.medianBarycenterCrossingReduction(layer, 0);
      this.adjacentExchangeCrossingReductionBendStraighten(layer, 0, false, 0);
    }
    // Update the bestcrossings and bestlayout if an improvement was made.
    crossings = this.countCrossings();
    if (crossings < bestcrossings) {
      bestcrossings = crossings;
      bestlayout = this.saveLayout();
    }
  }
  // Restore the bestlayout for subsequent operations.
  this.restoreLayout(bestlayout);

  // A final sequence of operations.
  // The idea is that sometimes the bestlayout was found early in
  //  the iterations, and not every operation got a chance to permute it.
  // This final sequence takes the bestlayout and uses all the operations
  //  to move it towards a local minimum number of crossings.
  // If the aggressiveOption is set, then every sub-interval of layers
  //  is examined to reduce the crossings in the whole graph.  The idea
  //  is that some "twisted links" just need to be permuted in the right
  //  direction for the right number of layers.  By considering all of the
  //  sub-intervals, we run accross each one.  Of course, with N layers,
  //  that's N(N+1)/2 sub-intervals to consider, and we keep considering
  //  these sub-intervals until no crossings can be reduced.  Hence, we
  //  leave it as a option.
  // If the aggressiveOption is not set, then only the full interval of layers
  //  is examined.
  var change;
  var topLayer;
  var botLayer;
  var lastcrossings;
  var recent;
  switch (this._aggressiveOption) {
    case LayeredDigraphLayout.AggressiveNone: break;
    case LayeredDigraphLayout.AggressiveMore:
      lastcrossings = bestcrossings + 1;
      while ((recent = this.countCrossings()) < lastcrossings) {
        lastcrossings = recent;
        for (topLayer = this._maxLayer; topLayer >= 0; topLayer--) {
          for (botLayer = 0; botLayer <= topLayer; botLayer++) {
            change = true;
            while (change) {
              change = false;
              for (layer = topLayer; layer >= botLayer; layer--) {
                change = this.adjacentExchangeCrossingReductionBendStraighten(layer, -1, false, -1) || change;
              }
            }
            crossings = this.countCrossings();
            if (crossings >= bestcrossings) {
              this.restoreLayout(bestlayout);
            } else {
              bestcrossings = crossings;
              bestlayout = this.saveLayout();
            }

            change = true;
            while (change) {
              change = false;
              for (layer = topLayer; layer >= botLayer; layer--) {
                change = this.adjacentExchangeCrossingReductionBendStraighten(layer, 1, false, 1) || change;
              }
            }
            crossings = this.countCrossings();
            if (crossings >= bestcrossings) {
              this.restoreLayout(bestlayout);
            } else {
              bestcrossings = crossings;
              bestlayout = this.saveLayout();
            }

            change = true;
            while (change) {
              change = false;
              for (layer = botLayer; layer <= topLayer; layer++) {
                change = this.adjacentExchangeCrossingReductionBendStraighten(layer, 1, false, 1) || change;
              }
            }
            if (crossings >= bestcrossings) {
              this.restoreLayout(bestlayout);
            } else {
              bestcrossings = crossings;
              bestlayout = this.saveLayout();
            }

            change = true;
            while (change) {
              change = false;
              for (layer = botLayer; layer <= topLayer; layer++) {
                change = this.adjacentExchangeCrossingReductionBendStraighten(layer, -1, false, -1) || change;
              }
            }
            if (crossings >= bestcrossings) {
              this.restoreLayout(bestlayout);
            } else {
              bestcrossings = crossings;
              bestlayout = this.saveLayout();
            }

            change = true;
            while (change) {
              change = false;
              for (layer = topLayer; layer >= botLayer; layer--) {
                change = this.adjacentExchangeCrossingReductionBendStraighten(layer, 0, false, 0) || change;
              }
            }
            if (crossings >= bestcrossings) {
              this.restoreLayout(bestlayout);
            } else {
              bestcrossings = crossings;
              bestlayout = this.saveLayout();
            }

            change = true;
            while (change) {
              change = false;
              for (layer = botLayer; layer <= topLayer; layer++) {
                change = this.adjacentExchangeCrossingReductionBendStraighten(layer, 0, false, 0) || change;
              }
            }
            if (crossings >= bestcrossings) {
              this.restoreLayout(bestlayout);
            } else {
              bestcrossings = crossings;
              bestlayout = this.saveLayout();
            }
          }
        }
      }
      break;
    default:
    case LayeredDigraphLayout.AggressiveLess:
      topLayer = this._maxLayer;
      botLayer = 0;
      lastcrossings = bestcrossings + 1;
      while ((recent = this.countCrossings()) < lastcrossings) {
        lastcrossings = recent;
        change = true;
        while (change) {
          change = false;
          for (layer = topLayer; layer >= botLayer; layer--) {
            change = this.adjacentExchangeCrossingReductionBendStraighten(layer, -1, false, -1) || change;
          }
        }
        crossings = this.countCrossings();
        if (crossings >= bestcrossings) {
          this.restoreLayout(bestlayout);
        } else {
          bestcrossings = crossings;
          bestlayout = this.saveLayout();
        }
        change = true;
        while (change) {
          change = false;
          for (layer = topLayer; layer >= botLayer; layer--) {
            change = this.adjacentExchangeCrossingReductionBendStraighten(layer, 1, false, 1) || change;
          }
        }
        crossings = this.countCrossings();
        if (crossings >= bestcrossings) {
          this.restoreLayout(bestlayout);
        } else {
          bestcrossings = crossings;
          bestlayout = this.saveLayout();
        }

        change = true;
        while (change) {
          change = false;
          for (layer = botLayer; layer <= topLayer; layer++) {
            change = this.adjacentExchangeCrossingReductionBendStraighten(layer, 1, false, 1) || change;
          }
        }
        if (crossings >= bestcrossings) {
          this.restoreLayout(bestlayout);
        } else {
          bestcrossings = crossings;
          bestlayout = this.saveLayout();
        }
        change = true;
        while (change) {
          change = false;
          for (layer = botLayer; layer <= topLayer; layer++) {
            change = this.adjacentExchangeCrossingReductionBendStraighten(layer, -1, false, -1) || change;
          }
        }
        if (crossings >= bestcrossings) {
          this.restoreLayout(bestlayout);
        } else {
          bestcrossings = crossings;
          bestlayout = this.saveLayout();
        }
        change = true;
        while (change) {
          change = false;
          for (layer = topLayer; layer >= botLayer; layer--) {
            change = this.adjacentExchangeCrossingReductionBendStraighten(layer, 0, false, 0) || change;
          }
        }
        if (crossings >= bestcrossings) {
          this.restoreLayout(bestlayout);
        } else {
          bestcrossings = crossings;
          bestlayout = this.saveLayout();
        }
        change = true;
        while (change) {
          change = false;
          for (layer = botLayer; layer <= topLayer; layer++) {
            change = this.adjacentExchangeCrossingReductionBendStraighten(layer, 0, false, 0) || change;
          }
        }
        if (crossings >= bestcrossings) {
          this.restoreLayout(bestlayout);
        } else {
          bestcrossings = crossings;
          bestlayout = this.saveLayout();
        }
      }
      break;
  }
  // Restore the bestlayout.
  this.restoreLayout(bestlayout);
};

/**
* @ignore
* Reorders nodes within the unfixedLayer to reduce the number of link crossings between
* the unfixedLayer and its adjacent layers.  The direction argument indicates which of the
* adjacent layers should be taken into consideration when reducing the number of crossings.
* direction === 0  --  use unfixedLayer - 1 and unfixedLayer + 1
* direction > 0  --  use unfixedLayer - 1 (sweeping away from layer 0)
* direction < 0  --  use unfixedLayer + 1 (sweeping towards layer 0)
* The idea is to calculate the median and barycenter for each node in the unfixedLayer,
* and to sort the nodes in the unfixedLayer by their median and barycenter values.
* Returns true if some change was made to the layer.
* @this {LayeredDigraphLayout}
* @param {number} unfixedLayer
* @param {number} direction
* @return {boolean} Returns true if some change was made to the layer and false otherwise.
*/
LayeredDigraphLayout.prototype.medianBarycenterCrossingReduction = function(unfixedLayer, direction) {
  if (Debug) {
    Util.checkRealNumber(unfixedLayer, LayeredDigraphLayout, 'medianBarycenterCrossingReduction:unfixedLayer');
    Util.checkRealNumber(direction, LayeredDigraphLayout, 'medianBarycenterCrossingReduction:direction');
  }
  var index;
  var layerChange = false;

  // Fill unfixedLayerNodes with nodes in the unfixedLayer, ordered by index.
  var unfixedLayerNodes = this._getCachedNodeArrayList(unfixedLayer);
  var num = this._indices[unfixedLayer];

  // Initialize the medians and barycenters.
  var medians = this.medians(unfixedLayer, direction);
  var barycenters = this.barycenters(unfixedLayer, direction);

  // A median or barycenter value of -1 indicates that the node does not
  //  have a defined median or barycenter (i.e., the node has no neighbors
  //  in the appropriate adjacent layer).  In that case, use the current column
  //  value as the median or barycenter.
  for (index = 0; index < num; index++) {
    if (barycenters[index] === -1) {
      barycenters[index] = unfixedLayerNodes[index].column;
    }
    if (medians[index] === -1) {
      medians[index] = unfixedLayerNodes[index].column;
    }
  }

  // Sort nodes on medians and barycenters.
  // Nodes are permuted within the unfixedLayerNodes.
  var change = true;
  var vertex;
  while (change) {
    change = false;
    for (index = 0; index < (num - 1); index++) {
      if ((medians[index + 1] < medians[index]) ||
		((medians[index + 1] === medians[index]) && (barycenters[index + 1] < barycenters[index]))) {
        layerChange = true;
        change = true;
        var medianTemp = medians[index];
        medians[index] = medians[index + 1];
        medians[index + 1] = medianTemp;
        var barycenterTemp = barycenters[index];
        barycenters[index] = barycenters[index + 1];
        barycenters[index + 1] = barycenterTemp;
        vertex = unfixedLayerNodes[index];
        unfixedLayerNodes[index] = unfixedLayerNodes[index + 1];
        unfixedLayerNodes[index + 1] = vertex;
      }
    }
  }

  // Update the index for each node in the unfixedLayer.
  // Update the column for each node in the unfixedLayer.
  var column = 0;
  for (index = 0; index < num; index++) {
    vertex = unfixedLayerNodes[index];
    vertex.index = index;
    column += this.nodeMinColumnSpace(vertex, true);
    vertex.column = column;
    column += 1;
    column += this.nodeMinColumnSpace(vertex, false);
  }

  // Return status of the unfixedLayer.
  this._freeCachedNodeArrayList(unfixedLayer, unfixedLayerNodes);
  return layerChange;
};

/**
* @ignore
* Adjusts the columns of nodes within the unfixedLayer to simultaneously reduce the
* number of link crossings and the number of "bends" between the unfixedLayer and its
* adjacent layers.
* The directionCR argument indicates which of the adjacent layers should be taken
* into consideration when reducing the number of link crossings.
* direction === 0  --  use unfixedLayer - 1 and unfixedLayer + 1
* direction > 0  --  use unfixedLayer - 1 (sweeping away from layer 0)
* direction < 0  --  use unfixedLayer + 1 (sweeping towards layer 0)
* The directionBS argument indicates which of the adjacent layers should be taken
* into consideration when reducing the number of bends.
* direction === 0  --  use unfixedLayer - 1 and unfixedLayer + 1
* direction > 0  --  use unfixedLayer - 1 (sweeping away from layer 0)
* direction < 0  --  use unfixedLayer + 1 (sweeping towards layer 0)
* The "weighted bend" between a node U and a node V connected by link L is calculated by
* abs((U.column + L.portFromColOffset) - (V.column + L.portToColOffset)) * LinkStraightenWeight(L)
* The LinkStraightenWeight attempts to give higher priority to links between
* "artificial" nodes; i.e., long links in the final layout will be straighter.
* The idea is to use a bubble-sort technique to exchange adjacent nodes whenever
* doing so reduces the number of link crossings or the number of bends.
* This function is used in both crossing reduction and bend straightening.
* Returns true if some change was made to the layer.
* @this {LayeredDigraphLayout}
* @param {number} unfixedLayer The layer to be reordered.
* @param {number} directionCR Indicates which adjacent layers should be taken into consideration when calculating the crossing matrix.
* @param {boolean} straighten Indicates whether or not to reorder to nodes to straighten links.
* @param {number} directionBS Indicates which adjacent layers should be taken into consideration when calculating the bends of a link.
* @return {boolean} Returns true if some change was made to the layer and false otherwise.
*/
LayeredDigraphLayout.prototype.adjacentExchangeCrossingReductionBendStraighten = function(unfixedLayer, directionCR, straighten, directionBS) {
  // Fill unfixedLayerNodes with nodes in the unfixedLayer, ordered by index.
  var unfixedLayerNodes = this._getCachedNodeArrayList(unfixedLayer);
  var num = this._indices[unfixedLayer];

  // Initialize the crossing matrix such that
  //  if index1 and index2 are the indices corresponding to two nodes on the
  //  unfixedLayer and crossmat is the crossing matrix, then
  //   crossmat[index1 * indices[unfixedLayer] + index2]
  //  is the number of crossing that occur if the node corresponding to index1 is
  //  placed to the left of the node corresponding to index2.
  var crossmat = this.crossingMatrix(unfixedLayer, directionCR);
  var index;
  // Initialize the barycenters from the negative direction.
  var barycentersNeg;
  // If no straightening or direction > 0,
  //  then set barycenters from the negative direction to -1.
  if ((!straighten) || (directionBS > 0)) {
    barycentersNeg = [];
    for (index = 0; index < num; index++) {
      barycentersNeg[index] = -1;
    }
  } else {
    barycentersNeg = this.barycenters(unfixedLayer, -1);
  }
  // Initialize the barycenters from the positive direction.
  var barycentersPos;
  // If no straightening or direction < 0,
  //  then set barycenters from the positive direction to -1.
  if ((!straighten) || (directionBS < 0)) {
    barycentersPos = [];
    for (index = 0; index < num; index++) {
      barycentersPos[index] = -1;
    }
  } else {
    barycentersPos = this.barycenters(unfixedLayer, 1);
  }

  var layerChange = false;
  var exchange = true;
  while (exchange) {
    exchange = false;
    for (index = 0; index < num - 1; index++) {
      var crossingLR = crossmat[unfixedLayerNodes[index].index * num + unfixedLayerNodes[index + 1].index];
      var crossingRL = crossmat[unfixedLayerNodes[index + 1].index * num + unfixedLayerNodes[index].index];
      // Calculate the crossing numbers of nodes on the same layer.
      var layerCrossingLR = 0;
      var layerCrossingRL = 0;

      // Column of the node to the left.
      var columnL = unfixedLayerNodes[index].column;
      // Column of the node to the right.
      var columnR = unfixedLayerNodes[index + 1].column;
      var indexSpaceLeft = this.nodeMinColumnSpace(unfixedLayerNodes[index], true);
      var indexSpaceRight = this.nodeMinColumnSpace(unfixedLayerNodes[index], false);
      var indexPlusOneSpaceLeft = this.nodeMinColumnSpace(unfixedLayerNodes[index + 1], true);
      var indexPlusOneSpaceRight = this.nodeMinColumnSpace(unfixedLayerNodes[index + 1], false);
      // Column of the node to the left after an exchange (takes into account nodeMinColumSpace of the two nodes).
      var columnLX = columnL - indexSpaceLeft + indexPlusOneSpaceLeft;
      // Column of the node to the right after an exchange (takes into account nodeMinColumSpace of the two nodes).
      var columnRX = columnR - indexSpaceRight + indexPlusOneSpaceRight;
      // Calculate the bend numbers if the left node (L) and the right node (R) are
      //  order L-R  or R-L.
      var bendLR = 0;
      var bendRL = 0;
      var edge, weight, portFromColOffset, portToColOffset, fromCol, toCol;
      var fromVertex, indexFrom, toVertex, indexTo;
      // Calculate the predecessor link list of the left node, based on direction
      var sourceEdgeIter = unfixedLayerNodes[index].sourceEdges.iterator;
      if (straighten && (directionBS <= 0)) {
        while (sourceEdgeIter.next()) {
          edge = sourceEdgeIter.value;
          if (edge.valid && (edge.fromVertex.layer !== unfixedLayer)) {
            // Update the bends.
            weight = this.linkStraightenWeight(edge);
            portFromColOffset = edge.portFromColOffset;
            portToColOffset = edge.portToColOffset;
            fromCol = edge.fromVertex.column;
            bendLR += (Math.abs((columnL + portToColOffset) - (fromCol + portFromColOffset)) + 1) * weight;
            bendRL += (Math.abs((columnRX + portToColOffset) - (fromCol + portFromColOffset)) + 1) * weight;
          }
        }
      }

      // Compute "crossings" of nodes on same layer.
      sourceEdgeIter.reset();
      while (sourceEdgeIter.next()) {
        edge = sourceEdgeIter.value;
        if (edge.valid && (edge.fromVertex.layer === unfixedLayer)) {
          fromVertex = edge.fromVertex;
          indexFrom = 0;
          while (unfixedLayerNodes[indexFrom] !== fromVertex) indexFrom++;
          // Depending on where the from node falls,
          //  we increase the appropriate crossing value.
          // The different values indicate how "strongly" that particular
          //  ordering is desired.
          if (indexFrom < index) {
            layerCrossingLR += 2 * (index - indexFrom);
            layerCrossingRL += 2 * ((index + 1) - indexFrom);
          }
          if (indexFrom === index + 1) {
            layerCrossingLR += 1;
          }
          if (indexFrom > index + 1) {
            layerCrossingLR += 4 * (indexFrom - index);
            layerCrossingRL += 4 * (indexFrom - (index + 1));
          }
        }
      }

      // Calculate the successor link list of the left node, based on direction
      var destinationEdgeIter = unfixedLayerNodes[index].destinationEdges.iterator;
      if (straighten && (directionBS >= 0)) {
        while (destinationEdgeIter) {
          edge = destinationEdgeIter.value;
          if (edge.valid && (edge.toVertex.layer !== unfixedLayer)) {
            // Update the bends.
            weight = this.linkStraightenWeight(edge);
            portFromColOffset = edge.portFromColOffset;
            portToColOffset = edge.portToColOffset;
            toCol = edge.toVertex.column;
            bendLR += (Math.abs((columnL + portFromColOffset) - (toCol + portToColOffset)) + 1) * weight;
            bendRL += (Math.abs((columnRX + portFromColOffset) - (toCol + portToColOffset)) + 1) * weight;
          }
        }
      }

      // Compute "crossings" of nodes on same layer.
      destinationEdgeIter.reset();
      while (destinationEdgeIter.next()) {
        edge = destinationEdgeIter.value;
        if (edge.valid && (edge.toVertex.layer === unfixedLayer)) {
          toVertex = edge.toVertex;
          indexTo = 0;
          while (unfixedLayerNodes[indexTo] !== toVertex) indexTo++;
          // Depending on where the to node falls,
          //  we increase the appropriate crossing value.
          // The different values indicate how "strongly" that particular
          //  ordering is desired.
          if (indexTo === index + 1) {
            layerCrossingRL += 1;
          }
        }
      }

      // Calculate the predecessor link list of the right node, based on direction
      var rightSourceEdgeIter = unfixedLayerNodes[index + 1].sourceEdges.iterator;
      if (straighten && (directionBS <= 0)) {
        while (rightSourceEdgeIter.next()) {
          edge = rightSourceEdgeIter.value;
          if (edge.valid && (edge.fromVertex.layer !== unfixedLayer)) {
            // Update the bends.
            weight = this.linkStraightenWeight(edge);
            portFromColOffset = edge.portFromColOffset;
            portToColOffset = edge.portToColOffset;
            fromCol = edge.fromVertex.column;
            bendLR += (Math.abs((columnR + portToColOffset) - (fromCol + portFromColOffset)) + 1) * weight;
            bendRL += (Math.abs((columnLX + portToColOffset) - (fromCol + portFromColOffset)) + 1) * weight;
          }
        }
      }

      // Compute "crossings" of nodes on same layer.
      rightSourceEdgeIter.reset();
      while (rightSourceEdgeIter.next()) {
        edge = rightSourceEdgeIter.value;
        if (edge.valid && (edge.fromVertex.layer === unfixedLayer)) {
          fromVertex = edge.fromVertex;
          indexFrom = 0;
          while (unfixedLayerNodes[indexFrom] !== fromVertex) indexFrom++;
          // Depending on where the from node falls,
          //  we increase the appropriate crossing value.
          // The different values indicate how "strongly" that particular
          //  ordering is desired.
          if (indexFrom < index) {
            layerCrossingLR += 2 * ((index + 1) - indexFrom);
            layerCrossingRL += 2 * (index - indexFrom);
          }
          if (indexFrom === index) {
            layerCrossingRL += 1;
          }
          if (indexFrom > index + 1) {
            layerCrossingLR += 4 * (indexFrom - (index + 1));
            layerCrossingRL += 4 * (indexFrom - index);
          }
        }
      }

      // Calculate the successor link list of the right node, based on direction
      var rightDestinationEdgeIter = unfixedLayerNodes[index + 1].destinationEdges.iterator;
      if (straighten && (directionBS >= 0)) {
        while (rightDestinationEdgeIter.next()) {
          edge = rightDestinationEdgeIter.value;
          if (edge.valid && (edge.toVertex.layer !== unfixedLayer)) {
            // Update the bends.
            weight = this.linkStraightenWeight(edge);
            portFromColOffset = edge.portFromColOffset;
            portToColOffset = edge.portToColOffset;
            toCol = edge.toVertex.column;
            bendLR += (Math.abs((columnR + portFromColOffset) - (toCol + portToColOffset)) + 1) * weight;
            bendRL += (Math.abs((columnLX + portFromColOffset) - (toCol + portToColOffset)) + 1) * weight;
          }
        }
      }

      // Compute "crossings" of nodes on same layer.
      rightDestinationEdgeIter.reset();
      while (rightDestinationEdgeIter.next()) {
        edge = rightDestinationEdgeIter.value;
        if (edge.valid && (edge.toVertex.layer === unfixedLayer)) {
          toVertex = edge.toVertex;
          indexTo = 0;
          while (unfixedLayerNodes[indexTo] !== toVertex) indexTo++;
          // Depending on where the to node falls,
          //  we increase the appropriate crossing value.
          // The different values indicate how "strongly" that particular
          //  ordering is desired.
          if (indexTo === index) {
            layerCrossingLR += 1;
          }
        }
      }

      // Calculate the bend numbers for the left and right nodes,
      //  based on their barycenter values.
      // The idea is that if neither a shift to the left or the right reduces
      //  the actual number of bends, moving towards the barycenter will
      //  improve the centering and balance of the layout.
      var BbendLR = 0;
      var BbendRL = 0;
      var barycenterNegL = barycentersNeg[unfixedLayerNodes[index].index];
      var barycenterPosL = barycentersPos[unfixedLayerNodes[index].index];
      var barycenterNegR = barycentersNeg[unfixedLayerNodes[index + 1].index];
      var barycenterPosR = barycentersPos[unfixedLayerNodes[index + 1].index];

      // A barycenter of -1 indicates that the barycenter does not exist
      //  for that direction; hence no bends exist.
      if (barycenterNegL !== -1) {
        BbendLR += Math.abs(barycenterNegL - columnL);
        BbendRL += Math.abs(barycenterNegL - columnRX);
      }
      // A barycenter of -1 indicates that the barycenter does not exist
      //  for that direction; hence no bends exist.
      if (barycenterPosL !== -1) {
        BbendLR += Math.abs(barycenterPosL - columnL);
        BbendRL += Math.abs(barycenterPosL - columnRX);
      }
      // A barycenter of -1 indicates that the barycenter does not exist
      //  for that direction; hence no bends exist.
      if (barycenterNegR !== -1) {
        BbendLR += Math.abs(barycenterNegR - columnR);
        BbendRL += Math.abs(barycenterNegR - columnLX);
      }
      // A barycenter of -1 indicates that the barycenter does not exist
      //  for that direction; hence no bends exist.
      if (barycenterPosR !== -1) {
        BbendLR += Math.abs(barycenterPosR - columnR);
        BbendRL += Math.abs(barycenterPosR - columnLX);
      }
      // Peform an exchange if it improves the number of link crossings
      //  or the number of bends.
      if ((layerCrossingRL < layerCrossingLR - 0.5) ||
		((layerCrossingRL === layerCrossingLR) && (crossingRL < crossingLR - 0.5)) ||
		((layerCrossingRL === layerCrossingLR) && (crossingRL === crossingLR) && (bendRL < bendLR - 0.5)) ||
		((layerCrossingRL === layerCrossingLR) && (crossingRL === crossingLR) && (bendRL === bendLR) && (BbendRL < BbendLR - 0.5))) {
        layerChange = true;
        exchange = true;
        unfixedLayerNodes[index].column = columnRX;
        unfixedLayerNodes[index + 1].column = columnLX;
        var vertex = unfixedLayerNodes[index];
        unfixedLayerNodes[index] = unfixedLayerNodes[index + 1];
        unfixedLayerNodes[index + 1] = vertex;
      }
    }
  }
  // Update the index for each node in the unfixedLayer.
  for (index = 0; index < num; index++) {
    unfixedLayerNodes[index].index = index;
  }
  // Return status of the unfixedLayer.
  this._freeCachedNodeArrayList(unfixedLayer, unfixedLayerNodes);
  return layerChange;
};

/********************************************************************************************/
//StraightenAndPack
/**
* @ignore
* Adjusts the columns of nodes in the network to produce a layout which reduces
* the number of bends and is tightly packed.
* @expose
* @this {LayeredDigraphLayout}
*/
LayeredDigraphLayout.prototype.straightenAndPack = function() {
  var layer;
  var change;

  var expand = ((this._packOption & LayeredDigraphLayout.PackExpand) !== 0);
  var forceexpand = (this._packOption === LayeredDigraphLayout.PackAll);
  if (this.network.edges.count > 1000 && !forceexpand) expand = false;
  if (expand) {
    // In order to give the straightening methods more "room",
    //  widen the spaces between each node.
    // First, compute the maximum column used by each layer.
    // This will be used to center the nodes in each layer.
    // The idea is that centered nodes are more likely to align
    //  with their parents and children.
    var columns = [];
    var index;
    for (index = 0; index <= this._maxLayer; index++) {
      columns[index] = 0;
    }
    var vertIter = this.network.vertexes.iterator;
    var vertex;
    var column;
    while (vertIter.next()) {
      vertex = vertIter.value;
      layer = vertex.layer;
      column = vertex.column;
      var minColumnSpace = this.nodeMinColumnSpace(vertex, false);
      columns[layer] = Math.max(columns[layer], column + minColumnSpace);
    }

    // Next, modify the column of each node so that it is spaced and centered.
    var MULT = 8;
    vertIter.reset();
    while (vertIter.next()) {
      vertex = vertIter.value;
      layer = vertex.layer;
      column = vertex.column;
      vertex.column = ((((this._maxColumn - columns[layer]) * MULT) >> 1) + column * MULT);
    }
    this._maxColumn *= MULT;
  }

  if ((this._packOption & LayeredDigraphLayout.PackStraighten) !== 0) {
    // Use the bendStraighten method, sweeping away from the maxIndexLayer,
    //  iterating until no changes occur.
    // The idea is that the layer with the most nodes will have the greatest
    //  influence on the remainder of the nodes.
    change = true;
    while (change) {
      change = false;
      for (layer = this._maxIndexLayer + 1; layer <= this._maxLayer; layer++) {
        change = this.bendStraighten(layer, 1) || change;
      }
      for (layer = this._maxIndexLayer - 1; layer >= 0; layer--) {
        change = this.bendStraighten(layer, -1) || change;
      }
      change = this.bendStraighten(this._maxIndexLayer, 0) || change;
    }
  }

  if ((this._packOption & LayeredDigraphLayout.PackMedian) !== 0) {
    // Use the medianStraighten method, sweeping away from the maxIndexLayer.
    // The idea is that the layer with the most nodes will have the greatest
    //  influence on the remainder of the nodes.
    for (layer = this._maxIndexLayer + 1; layer <= this._maxLayer; layer++) {
      this.medianStraighten(layer, 1);
    }
    for (layer = this._maxIndexLayer - 1; layer >= 0; layer--) {
      this.medianStraighten(layer, -1);
    }
    this.medianStraighten(this._maxIndexLayer, 0);
  }

  // Iterate compactification and straightening until bends are not reduced.
  // Since componentPack and bendStraighten both are guaranteed not to
  //  increase the number of "bends", this loop will terminate,
  //  usually only after two or three iterations.

  if (expand) {
    // Use the componentPack method to tightly pack the nodes.
    this.componentPack(-1);
    this.componentPack(1);
  }

  if ((this._packOption & LayeredDigraphLayout.PackStraighten) !== 0) {
    // Use the bendStraighten method, sweeping away from the maxIndexLayer,
    //  iterating until no changes occur.
    // The idea is that the layer with the most nodes will have the greatest
    //  influence on the remainder of the nodes.
    change = true;
    while (change) {
      change = false;
      change = this.bendStraighten(this._maxIndexLayer, 0) || change;
      for (layer = this._maxIndexLayer + 1; layer <= this._maxLayer; layer++) {
        change = this.bendStraighten(layer, 0) || change;
      }
      for (layer = this._maxIndexLayer - 1; layer >= 0; layer--) {
        change = this.bendStraighten(layer, 0) || change;
      }
    }
  }
};

/********************************************************************************************/
//Straighten methods

/**
* @ignore
* Adjusts the columns of nodes within the unfixedLayer to reduce the number of "bends"
* between the unfixedLayer and its adjacent layers.  The direction argument indicates
* which of the adjacent layers should be taken into consideration when reducing the number
* of bends.
* The "weighted bend" between a node U and a node V connected by link L is calculated by
* abs((U.column + L.portFromColOffset) - (V.column + L.portToColOffset)) * LinkStraightenWeight(L)
* The LinkStraightenWeight attempts to give higher priority to links between
* "artificial" nodes; i.e., long links in the final layout will be straighter.
* The idea is to iterate the shiftBendStraighten and adjacentExchangeBendStraighten
* methods until no improvements are made.
* @this {LayeredDigraphLayout}
* @param {number} unfixedLayer
* @param {number} direction
* @return {boolean} Returns true if an improvement was made.
*/
LayeredDigraphLayout.prototype.bendStraighten = function(unfixedLayer, direction) {
  if (Debug) {
    Util.checkRealNumber(unfixedLayer, LayeredDigraphLayout, 'bendStraighten:unfixedLayer');
    Util.checkRealNumber(direction, LayeredDigraphLayout, 'bendStraighten:direction');
  }
  var layerChange = false;
  while (this.shiftBendStraighten(unfixedLayer, direction)) {
    layerChange = true;
  }
  return layerChange;
};

/**
* @ignore
* Adjusts the columns of nodes within the unfixedLayer to reduce the number of "bends"
* between the unfixedLayer and its adjacent layers.  The direction argument indicates
* which of the adjacent layers should be taken into consideration when reducing the number
* of bends.
* The "weighted bend" between a node U and a node V connected by link L is calculated by
* abs((U.column + L.portFromColOffset) - (V.column + L.portToColOffset)) * linkStraightenWeight(L)
* The linkStraightenWeight attempts to give higher priority to links between
* "artificial" nodes; i.e., long links in the final layout will be straighter.
* The idea is shift nodes to the left and to the right to reduce the bends
* ensuring that no two nodes have overlapping "allocations" of columns.
* Return true if some change was made to the layer.
* @this {LayeredDigraphLayout}
* @param {number} unfixedLayer
* @param {number} direction
* @return {boolean} Returns true if some change was made to the layer and false otherwise.
*/
LayeredDigraphLayout.prototype.shiftBendStraighten = function(unfixedLayer, direction) {
  if (Debug) {
    Util.checkRealNumber(unfixedLayer, LayeredDigraphLayout, 'shiftbendStraighten:unfixedLayer');
    Util.checkRealNumber(direction, LayeredDigraphLayout, 'shiftbendStraighten:direction');
  }
  var index;
  // Fill unfixedLayerNodes with nodes in the unfixedLayer, ordered by index.
  var unfixedLayerNodes = this._getCachedNodeArrayList(unfixedLayer);
  var num = this._indices[unfixedLayer];

  // Initialize the barycenters from the negative direction.
  var barycentersNeg = this.barycenters(unfixedLayer, -1);
  // If direction > 0, the set barycenters from the negative direction to -1.
  if (direction > 0) {
    for (index = 0; index < num; index++) {
      barycentersNeg[index] = -1;
    }
  }
  // Initialize the barycenters from the positive direction.
  var barycentersPos = this.barycenters(unfixedLayer, 1);
  // If direction < 0, the set barycenters from the positive direction to -1.
  if (direction < 0) {
    for (index = 0; index < num; index++) {
      barycentersPos[index] = -1;
    }
  }

  var layerChange = false;
  var shift = true;
  while (shift) {
    shift = false;
    for (index = 0; index < num; index++) {
      // Current column of unfixedLayerNodes[index].
      var columnC = unfixedLayerNodes[index].column;
      // Minimum column space for unfixedLayerNodes[index].
      var minColumnSpaceLeft = this.nodeMinColumnSpace(unfixedLayerNodes[index], true);
      var minColumnSpaceRight = this.nodeMinColumnSpace(unfixedLayerNodes[index], false);

      // Calculate the column of a shift to the left.
      // If there are no nodes to the left, or there is enough space between
      //  unfixedLayerNodes[index] and unfixedLayerNodes[index-1],
      //  then columnL = columnC - 1.
      // Otherwise, columnL = columnC and no shift will be taken
      //  (since the current bends will equal the bends after a shift into columnL).
      var columnL;
      if ((index - 1 < 0) ||
        ((columnC - unfixedLayerNodes[index - 1].column - 1) > (minColumnSpaceLeft + this.nodeMinColumnSpace(unfixedLayerNodes[index - 1], false)))) {
        columnL = columnC - 1;
      } else {
        columnL = columnC;
      }

      // Calculate the column of a shift to the right.
      // If there are no nodes to the right, or there is enough space between
      //  unfixedLayerNodes[index] and unfixedLayerNodes[index+1],
      //  then columnR = columnC + 1.
      // Otherwise, columnR = columnC and no shift will be taken
      //  (since the current bends will equal the bends after a shift into columnR).
      var columnR;
      if ((index + 1 >= num) ||
		    ((unfixedLayerNodes[index + 1].column - columnC - 1) > (minColumnSpaceRight + this.nodeMinColumnSpace(unfixedLayerNodes[index + 1], true)))) {
        columnR = columnC + 1;
      } else {
        columnR = columnC;
      }

      // Calculate the bend numbers for the current column, left column, and right column.
      var bendC = 0;
      var bendL = 0;
      var bendR = 0;

      var edge, weight, portFromColOffset, portToColOffset;

      // Calculate the predecessor link list, based on direction.
      if (direction <= 0) {
        var sourceEdgeIter = unfixedLayerNodes[index].sourceEdges.iterator;
        while (sourceEdgeIter.next()) {
          edge = sourceEdgeIter.value;
          if (edge.valid && (edge.fromVertex.layer !== unfixedLayer)) {
            // Update the bends.
            weight = this.linkStraightenWeight(edge);
            portFromColOffset = edge.portFromColOffset;
            portToColOffset = edge.portToColOffset;
            var fromCol = edge.fromVertex.column;
            bendC += (Math.abs((columnC + portToColOffset) - (fromCol + portFromColOffset)) + 1) * weight;
            bendL += (Math.abs((columnL + portToColOffset) - (fromCol + portFromColOffset)) + 1) * weight;
            bendR += (Math.abs((columnR + portToColOffset) - (fromCol + portFromColOffset)) + 1) * weight;
          }
        }
      }

      // Calculate the successor link list, based on direction.
      if (direction >= 0) {
        var destinationEdgeIter = unfixedLayerNodes[index].destinationEdges.iterator;
        while (destinationEdgeIter.next()) {
          edge = destinationEdgeIter.value;
          if (edge.valid && (edge.toVertex.layer !== unfixedLayer)) {
            // Update the bends.
            weight = this.linkStraightenWeight(edge);
            portFromColOffset = edge.portFromColOffset;
            portToColOffset = edge.portToColOffset;
            var toCol = edge.toVertex.column;
            bendC += (Math.abs((columnC + portFromColOffset) - (toCol + portToColOffset)) + 1) * weight;
            bendL += (Math.abs((columnL + portFromColOffset) - (toCol + portToColOffset)) + 1) * weight;
            bendR += (Math.abs((columnR + portFromColOffset) - (toCol + portToColOffset)) + 1) * weight;
          }
        }
      }

      // Calculate the bend numbers for the current column, left column,
      //  and right column, based on the barycenter values.
      // The idea is that if neither a shift to the left or the right reduces
      //  the actual number of bends, moving towards the barycenter will
      //  improve the centering and balance of the layout.
      var BbendC = 0;
      var BbendL = 0;
      var BbendR = 0;
      var barycenterNegC = barycentersNeg[unfixedLayerNodes[index].index];
      var barycenterPosC = barycentersPos[unfixedLayerNodes[index].index];
      // A barycenter of -1 indicates that the barycenter does not exist
      //  for that direction; hence no bends exist.
      if (barycenterNegC !== -1) {
        BbendC += Math.abs(barycenterNegC - columnC);
        BbendL += Math.abs(barycenterNegC - columnL);
        BbendR += Math.abs(barycenterNegC - columnR);
      }
      // A barycenter of -1 indicates that the barycenter does not exist
      //  for that direction; hence no bends exist.
      if (barycenterPosC !== -1) {
        BbendC += Math.abs(barycenterPosC - columnC);
        BbendL += Math.abs(barycenterPosC - columnL);
        BbendR += Math.abs(barycenterPosC - columnR);
      }
      // Peform a shift if it improves the bends.
      if ((bendL < bendC) || ((bendL === bendC) && (BbendL < BbendC))) {
        layerChange = true;
        shift = true;
        unfixedLayerNodes[index].column = columnL;
      }
      // Peform a shift if it improves the bends.
      if ((bendR < bendC) || ((bendR === bendC) && (BbendR < BbendC))) {
        layerChange = true;
        shift = true;
        unfixedLayerNodes[index].column = columnR;
      }
    }
  }
  this._freeCachedNodeArrayList(unfixedLayer, unfixedLayerNodes);
  // Some nodes may have been moved to the left of column 0 or to the right
  //  of column maxColumn, so normalize the nodes; i.e., the leftmost column will
  //  be column 0 and maxColumn will be updated appropriately.
  this.normalize();

  // Return status of the unfixedLayer.
  return layerChange;
};

/**
* @ignore
* Adjusts the columns of nodes within the unfixedLayer in order to move nodes towards
* their median columns.  The direction argument indicates which of the adjacent layers
* should be taken into consideration when computing the median column.
* The idea is shift nodes to the left and to the right to move nodes towards their
* median columns, ensuring that no two nodes have overlapping "allocations" of columns.
* Returns true if some change was made to the layer.
* @this {LayeredDigraphLayout}
* @param {number} unfixedLayer
* @param {number} direction
* @return {boolean} Returns true if some change was made to the layer and false otherwise.
*/
LayeredDigraphLayout.prototype.medianStraighten = function(unfixedLayer, direction) {
  if (Debug) {
    Util.checkRealNumber(unfixedLayer, LayeredDigraphLayout, 'medianStraighten:unfixedLayer');
    Util.checkRealNumber(direction, LayeredDigraphLayout, 'medianStraighten:direction');
  }
  var index;
  // Fill unfixedLayerNodes with nodes in the unfixedLayer, ordered by index
  var unfixedLayerNodes = this._getCachedNodeArrayList(unfixedLayer);
  var num = this._indices[unfixedLayer];

  // Calculate the median value of each node and convert to integer.
  var dmedians = this.medians(unfixedLayer, direction);
  var medians = [];
  for (index = 0; index < num; index++) {
    medians[index] = dmedians[index];
  }
  var layerChange = false;
  var change = true;
  while (change) {
    change = false;
    for (index = 0; index < num; index++) {
      // The current column of unfixedLayerNodes[index].
      var column = unfixedLayerNodes[index].column;
      var minColumnSpaceLeft = this.nodeMinColumnSpace(unfixedLayerNodes[index], true);
      var minColumnSpaceRight = this.nodeMinColumnSpace(unfixedLayerNodes[index], false);
      // The new column of unfixedLayerNodes[index].
      var ncolumn = 0;
      var rcolumn, lcolumn, nrcolumn, nlcolumn;
      // A median value of -1 indicates that the node does not
      //  have a defined median (i.e., the node has no neighbors
      //  in the appropriate adjacent layer).
      // In that case, treat these nodes specially, since they can be
      //  shifted "out of the way" of nodes that have a defined median.
      if (medians[index] === -1) {
        // If index === 0 and index === num - 1,
        //  then there is only one node on the layer
        //  and the node does not move.
        if ((index === 0) && (index === num - 1)) {
          ncolumn = column;
          // If index === 0,
          //  then check if the node is "adjacent" (in the sense of nodeMinColumnSpace values)
          //  to its rightmost neighbor.  If so, move the node to the left.
          // The idea is that the rightmost neighbor may be "moving left",
          //  so move the node out of the way.
        }
        else if (index === 0) {
          rcolumn = unfixedLayerNodes[index + 1].column;
          if (rcolumn - column === (minColumnSpaceRight + this.nodeMinColumnSpace(unfixedLayerNodes[index + 1], true))) {
            ncolumn = column - 1;
          } else {
            ncolumn = column;
          }

          // If index === num - 1,
          //  then check if the node is "adjacent" (in the sense of nodeMinColumnSpace values)
          //  to its leftmost neighbor.  If so, move the node to the right.
          // The idea is that the leftmost neighbor may be "moving right",
          //  so move the node out of the way.
        }
        else if (index === num - 1) {
          lcolumn = unfixedLayerNodes[index - 1].column;
          if (column - lcolumn === (minColumnSpaceLeft + this.nodeMinColumnSpace(unfixedLayerNodes[index - 1], false))) {
            ncolumn = column + 1;
          } else {
            ncolumn = column;
          }

          // Otherwise, position the node between its left and right neighbors.
        } else {
          lcolumn = unfixedLayerNodes[index - 1].column;
          nlcolumn = lcolumn + this.nodeMinColumnSpace(unfixedLayerNodes[index - 1], false) + minColumnSpaceLeft + 1;
          rcolumn = unfixedLayerNodes[index + 1].column;
          nrcolumn = rcolumn - this.nodeMinColumnSpace(unfixedLayerNodes[index + 1], true) - minColumnSpaceRight - 1;
          ncolumn = ((nlcolumn + nrcolumn) / 2) | 0;
        }

        // Otherwise, the node has a defined median.
      } else {
        // If index === 0 and index === num - 1,
        //  then there is only one node on the layer
        //  and the node can be moved to its median position.
        if ((index === 0) && (index === num - 1)) {
          ncolumn = medians[index];
          // If index === 0,
          //  then move the node to the position closest to its median that does
          //  not overlap with its rightmost neighbor.
        }
        else if (index === 0) {
          rcolumn = unfixedLayerNodes[index + 1].column;
          nrcolumn = rcolumn - this.nodeMinColumnSpace(unfixedLayerNodes[index + 1], true) - minColumnSpaceRight - 1;
          ncolumn = Math.min(medians[index], nrcolumn);
          // If index === num - 1,
          //  then move the node to the position closest to its median that does
          //  not overlap with its leftmost neighbor.
        }
        else if (index === num - 1) {
          lcolumn = unfixedLayerNodes[index - 1].column;
          nlcolumn = lcolumn + this.nodeMinColumnSpace(unfixedLayerNodes[index - 1], false) + minColumnSpaceLeft + 1;
          ncolumn = Math.max(medians[index], nlcolumn);
          // Otherwise, move the node to the position closest to its median that does
          //  not overlap with either its left or right neighbors.
        } else {
          lcolumn = unfixedLayerNodes[index - 1].column;
          nlcolumn = lcolumn + this.nodeMinColumnSpace(unfixedLayerNodes[index - 1], false) + minColumnSpaceLeft + 1;
          rcolumn = unfixedLayerNodes[index + 1].column;
          nrcolumn = rcolumn - this.nodeMinColumnSpace(unfixedLayerNodes[index + 1], true) - minColumnSpaceRight - 1;
          if ((nlcolumn < medians[index]) && (medians[index] < nrcolumn)) {
            ncolumn = medians[index];
          }
          else if (nlcolumn >= medians[index]) {
            ncolumn = nlcolumn;
          }
          else if (nrcolumn <= medians[index]) {
            ncolumn = nrcolumn;
          }
        }
      }

      // If the node changed position, make the appropriate updates.
      if (ncolumn !== column) {
        layerChange = true;
        change = true;
        unfixedLayerNodes[index].column = ncolumn;
      }
    }
  }
  this._freeCachedNodeArrayList(unfixedLayer, unfixedLayerNodes);
  // Some nodes may have been moved to the left of column 0 or to the right
  //  of column maxColumn, so normalize the nodes; i.e., the leftmost column will
  //  be column 0 and maxColumn will be updated appropriately.
  this.normalize();
  // Return status of the unfixedLayer.
  return layerChange;
};

/********************************************************************************************/
//Pack methods

/**
* @ignore
* Adjusts the columns of nodes in the network to produce a layout which is tightly packed.
* The idea is that columns which are "un-allocated" through all layers can be eliminated
* and the nodes can be shifted into that space.
* @this {LayeredDigraphLayout}
*/
LayeredDigraphLayout.prototype.pack = function() {
  // Sweep the network from column 0 to column maxColumn, eliminating empty columns.
  for (var column = 0; column <= this._maxColumn; column++) {
    while (this.packAux(column, 1)) { }
  }
  // Some columns may have been eliminated, so normalize the nodes;
  //  i.e., the leftmost column will be column 0 and maxColumn will
  //  be updated appropriately.
  this.normalize();
};

/**
* @ignore
* Attempts to remove the argument column by shifting columns into from the argument direction.
* direction > 0 -- columns > argument column are shifted
* direction < 0 -- columns < argument column are shifted
* Returns true if the argument column was removed.
* @this {LayeredDigraphLayout}
* @param {number} column
* @param {number} direction
* @return {boolean} Returns true if the argument column was removed and false otherwise.
*/
LayeredDigraphLayout.prototype.packAux = function(column, direction) {
  if (Debug) {
    Util.checkRealNumber(column, LayeredDigraphLayout, 'packAux:column');
    Util.checkRealNumber(direction, LayeredDigraphLayout, 'packAux:direction');
  }
  // Scan all nodes in the network.
  // A shift is possible if no node has been "allocated" the argument column.
  var doshift = true;
  var vertIter = this.network.vertexes.iterator;
  var vertex;
  while (vertIter.next()) {
    vertex = vertIter.value;
    var minColumnSpaceLeft = this.nodeMinColumnSpace(vertex, true);
    var minColumnSpaceRight = this.nodeMinColumnSpace(vertex, false);
    if ((vertex.column - minColumnSpaceLeft <= column) && (vertex.column + minColumnSpaceRight >= column)) {
      doshift = false;
      break;
    }
  }

  // If no node has been "allocated" the argument column,
  //  shift nodes into the eliminated column from the appropriate direction.
  var change = false;
  if (doshift) {
    if (direction > 0) {
      vertIter.reset();
      while (vertIter.next()) {
        vertex = vertIter.value;
        if (vertex.column > column) {
          vertex.column -= 1;
          change = true;
        }
      }
    }
    if (direction < 0) {
      vertIter.reset();
      while (vertIter.next()) {
        if (vertex.column < column) {
          vertex.column += 1;
          change = true;
        }
      }
    }
  }

  // Return status of the column.
  return change;
};

/**
* @ignore
* Adjusts the columns of nodes in the network to produce a layout which is tightly packed.
* The idea is that two adjacent columns can be "merged" if each layer has at most one of
* the two columns "allocated" to a node.
* @this {LayeredDigraphLayout}
*/
LayeredDigraphLayout.prototype.tightPack = function() {
  // Begin by using the pack method.
  // This (faster) method eliminates some columns and reduces the number of columns
  //  that need to be examined.
  this.pack();
  // Sweep the network from column 0 to column maxColumn, merging columns.
  for (var column = 0; column < this._maxColumn; column++) {
    while (this.tightPackAux(column, 1)) { }
  }
  // Some columns may have been eliminated, so normalize the nodes;
  //  i.e., the leftmost column will be column 0 and maxColumn will
  //  be updated appropriately.
  this.normalize();
};

/**
* @ignore
* Attempts to augment the argument column by merging columns into from the argument direction.
* direction > 0 -- columns > the argument column are shifted
* direction < 0 -- columns < the argument column are shifted
* Returns true if the argument column was changed.
* @this {LayeredDigraphLayout}
* @param {number} column
* @param {number} direction
* @return {boolean} Returns true if the argument column was changed and false otherwise.
*/
LayeredDigraphLayout.prototype.tightPackAux = function(column, direction) {
  if (Debug) {
    Util.checkRealNumber(column, LayeredDigraphLayout, 'tightPackAux:column');
    Util.checkRealNumber(direction, LayeredDigraphLayout, 'tightPackAux:direction');
  }
  // Set the next column to the appropriate value based on direction.
  var nextcolumn = column;
  if (direction > 0)
    nextcolumn = column + 1;
  if (direction < 0)
    nextcolumn = column - 1;

  // The curCol and nextCol arrays indicate which layers in the current column and
  //  the next column have been "allocated" to nodes.
  // Initially, both the curCol and nextCol are empty.
  var index;
  var curCol = [];
  var nextCol = [];
  for (index = 0; index <= this._maxLayer; index++) {
    curCol[index] = false;
    nextCol[index] = false;
  }

  // Scan all nodes in the network.
  // If a node has been "allocated" either the current column or the next column,
  //  update the appropriate entry in curCol and nextCol.
  var vertIter = this.network.vertexes.iterator;
  var vertex;
  while (vertIter.next()) {
    vertex = vertIter.value;
    var leftColumn = vertex.column - this.nodeMinColumnSpace(vertex, true);
    var rightColumn = vertex.column + this.nodeMinColumnSpace(vertex, false);
    if ((leftColumn <= column) && (rightColumn >= column)) {
      curCol[vertex.layer] = true;
    }
    if ((leftColumn <= nextcolumn) && (rightColumn >= nextcolumn)) {
      nextCol[vertex.layer] = true;
    }
  }

  // A shift is possible if each layer has at most one column "allocated" between
  //  the current column and the next column. A logical NAND verifies that the columns
  //  can be merged at a particular layer.
  var doshift = true;
  var change = false;
  for (index = 0; index <= this._maxLayer; index++) {
    doshift = doshift && (!(curCol[index] && nextCol[index]));
  }

  // If each layer has at most one column "allocated" between
  //  the current column and the next column shift nodes into the merged
  //  column from the appropriate direction.
  if (doshift) {
    if (direction > 0) {
      vertIter.reset();
      while (vertIter.next()) {
        vertex = vertIter.value;
        if (vertex.column > column) {
          vertex.column -= 1;
          change = true;
        }
      }
    }
    if (direction < 0) {
      vertIter.reset();
      while (vertIter.next()) {
        vertex = vertIter.value;
        if (vertex.column < column) {
          vertex.column += 1;
          change = true;
        }
      }
    }
  }

  // Return status of the column.
  return change;
};

/**
* @ignore
* Adjusts the columns of nodes in the network to produce a layout which is tightly packed.
* The idea is that the network can be fragmented from a given column in the following way:
* all nodes "behind" the column are placed into a single component, and the remainder of
* the network is divided into connected components.  Each of these new components can be
* examined, and those that can be merged with the given column do so.
* @this {LayeredDigraphLayout}
* @param {number} direction
*/
LayeredDigraphLayout.prototype.componentPack = function(direction) {
   if (Debug) Util.checkRealNumber(direction, LayeredDigraphLayout, 'componentPack:direction');
  // Begin by using the tightPack method.
  // This (faster) method eliminates some columns and reduces the number of columns
  //  that need to be examined.
  this.tightPack();

  var column;
  var bestlayout, bestbends, lastbends, bends;
  if (direction > 0) {
    // Sweep the network from column 0 to column maxColumn, merging components.
    for (column = 0; column <= this._maxColumn; column++) {
      // Continue merging components into column
      //  while it reduces the number of "bends".
      bestlayout = this.saveLayout();
      bestbends = this.countBends(true);
      lastbends = bestbends + 1;
      while (bestbends < lastbends) {
        lastbends = bestbends;
        this.componentPackAux(column, 1);
        bends = this.countBends(true);
        if (bends > bestbends) {
          this.restoreLayout(bestlayout);
        } else if (bends < bestbends) {
          bestbends = bends;
          bestlayout = this.saveLayout();
        }
      }
    }
  }
  if (direction < 0) {
    // Sweep the network from column maxColumn to column 0, merging components.
    for (column = this._maxColumn; column >= 0; column--) {
      // Continue merging components into column
      //  while it reduces the number of "bends".
      bestlayout = this.saveLayout();
      bestbends = this.countBends(true);
      lastbends = bestbends + 1;
      while (bestbends < lastbends) {
        lastbends = bestbends;
        this.componentPackAux(column, -1);
        bends = this.countBends(true);
        if (bends > bestbends) {
          this.restoreLayout(bestlayout);
        } else if (bends < bestbends) {
          bestbends = bends;
          bestlayout = this.saveLayout();
        }
      }
    }
  }

  // Some columns may have been eliminated, so normalize the nodes;
  //  i.e., the leftmost column will be column 0 and maxColumn will
  //  be updated appropriately.
  this.normalize();
};

/**
* @ignore
* Attempts to augment the argument column by merging components into from the argument direction.
* direction > 0 -- columns > the argument column are shifted
* direction < 0 -- columns < the argument column are shifted
* Returns true if the argument column was changed.
* @this {LayeredDigraphLayout}
* @param {number} column
* @param {number} direction
* @return {boolean} Returns true if the argument column was changed and false otherwise.
*/
LayeredDigraphLayout.prototype.componentPackAux = function(column, direction) {
  // Every node is initially unset -- i.e., it hasn't been assigned to
  //  a component.

  // Add nodes "behind" the argument column to component 0.
  this._myComponent = 0;
  var vertIter = this.network.vertexes.iterator;
  var vertex;
  while (vertIter.next()) {
    vertIter.value.component = -1;
  }
  if (direction > 0) {
    vertIter.reset();
    while (vertIter.next()) {
      vertex = vertIter.value;
      if (vertex.column - this.nodeMinColumnSpace(vertex, true) <= column) {
        vertex.component = this._myComponent;
      }
    }
  }
  if (direction < 0) {
    vertIter.reset();
    while (vertIter.next()) {
      vertex = vertIter.value;
      if (vertex.column + this.nodeMinColumnSpace(vertex, false) >= column) {
        vertex.component = this._myComponent;
      }
    }
  }

  // The remaining nodes are placed into successive "compact" components.
  this._myComponent++;
  vertIter.reset();
  while (vertIter.next()) {
    vertex = vertIter.value;
    if (vertex.component === -1) {
      this.componentUnset(vertex, this._myComponent, -1, true, true);
      this._myComponent++;
    }
  }

  // Create the interference matrix.
  // If interference[component1 * component + component2] is true,
  //  then component1 must be shifted in order for component2 to be shifted.
  // This allows components that must be moved together to be detected.
  var index;
  var interference = [];
  for (index = 0; index < this._myComponent * this._myComponent; index++) {
    interference[index] = false;
  }

  // Fill in the interference matrix.
  // Begin by filling in a matrix representing the current distribution
  //  of components among layers and columns.
  var components = [];
  for (index = 0; index < (this._maxLayer + 1) * (this._maxColumn + 1); index++) {
    components[index] = -1;
  }

  // Scan all nodes in the network.
  // If a node has been "allocated" to some columns,
  //  update the appropriate entries in components.
  vertIter.reset();
  while (vertIter.next()) {
    vertex = vertIter.value;
    var layer = vertex.layer;
    var startCol = Math.max(0, vertex.column - this.nodeMinColumnSpace(vertex, true));
    var endCol = Math.min(this._maxColumn, vertex.column + this.nodeMinColumnSpace(vertex, false));
    for (var col = startCol; col <= endCol; col++) {
      components[layer * (this._maxColumn + 1) + col] = vertex.component;
    }
  }

  // A component interferes with another component if two different components
  //  in the current column and the "next" column are allocated to the same layer.
  // The "next" column is dependent on the direction.
  for (var layerIndex = 0; layerIndex <= this._maxLayer; layerIndex++) {
    // In the positive direction, the "next" column is col + 1.
    if (direction > 0) {
      for (col = 0; col < this._maxColumn; col++) {
        if ((components[layerIndex * (this._maxColumn + 1) + col] !== -1) &&
		    (components[layerIndex * (this._maxColumn + 1) + col + 1] !== -1) &&
		    (components[layerIndex * (this._maxColumn + 1) + col] !== components[layerIndex * (this._maxColumn + 1) + col + 1])) {
          interference[components[layerIndex * (this._maxColumn + 1) + col] * this._myComponent + components[layerIndex * (this._maxColumn + 1) + col + 1]] = true;
        }
      }
    }
    // In the negative direction, the "next" column is col - 1.
    if (direction < 0) {
      for (col = this._maxColumn; col > 0; col--) {
        if ((components[layerIndex * (this._maxColumn + 1) + col] !== -1) &&
		    (components[layerIndex * (this._maxColumn + 1) + col - 1] !== -1) &&
		    (components[layerIndex * (this._maxColumn + 1) + col] !== components[layerIndex * (this._maxColumn + 1) + col - 1])) {
          interference[components[layerIndex * (this._maxColumn + 1) + col] * this._myComponent + components[layerIndex * (this._maxColumn + 1) + col - 1]] = true;
        }
      }
    }
  }

  // Determine which components can be shifted.
  // Initially, all components can be shifted.
  // Using the interference matrix, dependencies are detected and marked.
  // In particular, component 0 can not be shifted,
  //  and it dictates which other components cannot be shifted.
  var doshift = [];
  for (index = 0; index < this._myComponent; index++) {
    doshift[index] = true;
  }
  // Use a queue to keep track of which components cannot be shifted.
  var Queue = new List('number');
  // Initially, only component 0 cannot be shifted.
  Queue.add(0);
  var head;
  while (Queue.count !== 0) {
    // Dequeue.
    head = (Queue._arr[Queue.count - 1]);
    Queue.removeAt(Queue.count - 1);
    // If this is the first time encountering this component,
    //  mark it as unshiftable and queue the components it interferes with.
    if (doshift[head]) {
      doshift[head] = false;
      for (index = 0; index < this._myComponent; index++) {
        if (interference[head * this._myComponent + index]) {
          Queue.insertAt(0, index);
        }
      }
    }
  }


  // Components which can be shifted are moved in the appropriate direction.
  var change = false;
  if (direction > 0) {
    vertIter.reset();
    while (vertIter.next()) {
      vertex = vertIter.value;
      if (doshift[vertex.component]) {
        vertex.column -= 1;
        change = true;
      }
    }
  }
  if (direction < 0) {
    vertIter.reset();
    while (vertIter.next()) {
      vertex = vertIter.value;
      if (doshift[vertex.component]) {
        vertex.column += 1;
        change = true;
      }
    }
  }

  // Return status of the column.
  return change;
};

/********************************************************************************************/
// Layout Nodes and Links

/**
* Updates the physical location of "real" nodes and links to reflect
* the layout.
* <p/>
* You should not call this method -- it is a "protected virtual" method.
* <p/>
* One reason to override this method would be to take advantage of
* added functionality of sub-classes of Link, for example, a sub-class
* that tracked bend points and allowed them to be repositioned
* by the application.
* Calls the {@link #commitNodes} and {@link #commitLinks} methods.
* @this {LayeredDigraphLayout}
*/
LayeredDigraphLayout.prototype.commitLayout = function() {
  this._setPortSpotsAll();
  this.commitNodes();
  if (this.isRouting) this.commitLinks();
};

/**
* @ignore
* @this {LayeredDigraphLayout}
*/
LayeredDigraphLayout.prototype._setPortSpotsAll = function() {
  if (!this.setsPortSpots) return;
  var fromspot = this._getDefaultSpot(true);
  var tospot = this._getDefaultSpot(false);
  var edgeIter = this.network.edges.iterator;
  var link;
  while (edgeIter.next()) {
    link = edgeIter.value.link;
    if (link !== null) {
      link.fromSpot = fromspot;
      link.toSpot = tospot;
    }
  }
};

/**
* @ignore
* @this {LayeredDigraphLayout}
* @param {boolean} from
* @return {Spot}
*/
LayeredDigraphLayout.prototype._getDefaultSpot = function(from) {
  if (this._direction === 270) {
    return (from ? Spot.MiddleTop : Spot.MiddleBottom);
  } else if (this._direction === 90) {
    return (from ? Spot.MiddleBottom : Spot.MiddleTop);
  } else if (this._direction === 180) {
    return (from ? Spot.MiddleLeft : Spot.MiddleRight);
  } else {
    return (from ? Spot.MiddleRight : Spot.MiddleLeft);
  }
};

/**
* Lays out the nodes.  Called by {@link #commitLayout}
* <p/>
* See also {@link #commitLinks}.
* @expose
* @this {LayeredDigraphLayout}
*/
LayeredDigraphLayout.prototype.commitNodes = function() {
  // The layerSpace array records the maximum layer spacing needed
  //  by a node in each layer, in document units.

  this._layerSpaceLeft = [];
  this._layerSpaceRight = [];
  this._layerPositions = [];
  this._layerSpaces = [];

  for (var i = 0; i <= this._maxLayer; i++) {
    this._layerSpaceLeft[i] = 0;
    this._layerSpaceRight[i] = 0;
    this._layerPositions[i] = 0;
    this._layerSpaces[i] = 0;
  }

  // Scan all nodes in the network, updating the layerSpace array.
  var vertIter = this.network.vertexes.iterator;
  var vertex, layer;
  while (vertIter.next()) {
    vertex = vertIter.value;
    layer = vertex.layer;
    this._layerSpaceLeft[layer] = Math.max(this._layerSpaceLeft[layer], this.nodeMinLayerSpace(vertex, true));
    this._layerSpaceRight[layer] = Math.max(this._layerSpaceRight[layer], this.nodeMinLayerSpace(vertex, false));
  }

  // The layerPositions array records the position in document units for each layer.
  // Each layer receives layerSpace[layer] space "above" and "below" it,
  // to accomodate the largest node in the layer, plus LayerSpacing between layers
  var layerPosition = 0;
  var space = this._layerSpacing;
  for (var layerInd = 0; layerInd <= this._maxLayer; layerInd++) {
    var s = space;
    // don't reserve LayerSpacing around layers consisting entirely of artificial nodes
    if (this._layerSpaceLeft[layerInd] + this._layerSpaceRight[layerInd] <= 0) s = 0;
    if (layerInd > 0) layerPosition += s / 2;  // avoid a margin: don't add half a LayerSpacing for first layer
    if (this._direction === 90 || this._direction === 0) {
      layerPosition += this._layerSpaceRight[layerInd];
      this._layerPositions[layerInd] = layerPosition;  // middle of layer
      layerPosition += this._layerSpaceLeft[layerInd];
    } else {
      layerPosition += this._layerSpaceLeft[layerInd];
      this._layerPositions[layerInd] = layerPosition;  // middle of layer
      layerPosition += this._layerSpaceRight[layerInd];
    }
    if (layerInd < this._maxLayer) layerPosition += s / 2;  // space between layers, except when beyond last layer
    this._layerSpaces[layerInd] = layerPosition;  // middle of space between layers
  }
  // layerPosition now remembers total depth

  var orig = this.arrangementOrigin;

  // convert layerPositions and layerSpaces arrays to use actual document coordinates, not just document units
  for (layerInd = 0; layerInd <= this._maxLayer; layerInd++) {
    if (this._direction === 270) {
      this._layerPositions[layerInd] = orig.y + this._layerPositions[layerInd];
      this._layerSpaces[layerInd] = orig.y + this._layerSpaces[layerInd];
    } else if (this._direction === 90) {
      this._layerPositions[layerInd] = orig.y + layerPosition - this._layerPositions[layerInd];
      this._layerSpaces[layerInd] = orig.y + layerPosition - this._layerSpaces[layerInd];
    } else if (this._direction === 180) {
      this._layerPositions[layerInd] = orig.x + this._layerPositions[layerInd];
      this._layerSpaces[layerInd] = orig.x + this._layerSpaces[layerInd];
    } else {
      this._layerPositions[layerInd] = orig.x + layerPosition - this._layerPositions[layerInd];
      this._layerSpaces[layerInd] = orig.x + layerPosition - this._layerSpaces[layerInd];
    }
  }

  // Scan all nodes in the network (both "real" and "artificial"),
  //  and set their locations.
  vertIter.reset();
  while (vertIter.next()) {
    vertex = vertIter.value;
    layer = vertex.layer;
    var column = vertex.column | 0;
    // Place the center of the node depending on the direction of the layout.
    var x, y;
    if (this._direction === 270 || this._direction === 90) {
      x = orig.x + this._columnSpacing * column;
      y = this._layerPositions[layer];
    } else {
      x = this._layerPositions[layer];
      y = orig.y + this._columnSpacing * column;
    }
    // Set the center position, update the position in the network,
    //  and commit the position to the physical location of the node.
    vertex.centerX = x;
    vertex.centerY = y;

    vertex.commit();
  }
};

/**
* Routes the links.
* This is called by {@link #commitLayout}.
* This is only called if {@link Layout#isRouting} is true.
* See also {@link #commitNodes}.
* @expose
* @this {LayeredDigraphLayout}
*/
LayeredDigraphLayout.prototype.commitLinks = function() {
  // first, clear out all the existing link points
  var edgeIter = this.network.edges.iterator;
  var edge, pLink;
  while (edgeIter.next()) {
    pLink = edgeIter.value.link;
    if (typeof pLink !== 'undefined' && pLink !== null) {
      pLink.startRoute();
      pLink.clearPoints();
      pLink.commitRoute();
    }
  }
  // second, call Link.updateRoute on each link, just once per Link
  // NB: multiple LayeredDigraphEdges can refer to the same Link
  edgeIter.reset();
  while (edgeIter.next()) {
    pLink = edgeIter.value.link;
    if (typeof pLink !== 'undefined' && pLink !== null) pLink.updateRoute();
  }
  // Scan all links in the network (both "real" and "artificial"),
  //  and set their locations.
  edgeIter.reset();
  while (edgeIter.next()) {
    edge = edgeIter.value;
    pLink = edge.link;
    if (!pLink) continue;
    pLink.startRoute();

    // The "real" physical link and "real" physical ports.
    var golink = pLink;
    var gofromnode = golink.fromNode;
    var gotonode = golink.toNode;
    var gofromport = golink.fromPort;
    var gotoport = golink.toPort;

    // A valid link requires no bends, unless maybe if it's Bezier, to avoid crossing other nodes in the same layers
    if (edge.valid) {
      // it's a "real" link connecting two "real" nodes, not needing any intermediate points
      if (pLink.curve === Link.Bezier && pLink.pointsCount === 4) {
        if (edge.rev) {
          var tempN = gofromnode;
          gofromnode = gotonode;
          gotonode = tempN;
          var temp = gofromport;
          gofromport = gotoport;
          gotoport = temp;
        }
        // when same column, assume straight
        if (edge.fromVertex.column === edge.toVertex.column) {
          var p0 = pLink.getLinkPoint(gofromnode, gofromport, pLink.computeSpot(true), true, false, gotonode, gotoport);
          var p3 = pLink.getLinkPoint(gotonode, gotoport, pLink.computeSpot(false), false, false, gofromnode, gofromport);
          pLink.clearPoints();
          pLink.addPointAt(p0.x, p0.y);
          pLink.addPointAt((2 * p0.x + p3.x) / 3, (2 * p0.y + p3.y) / 3);
          pLink.addPointAt((p0.x + 2 * p3.x) / 3, (p0.y + 2 * p3.y) / 3);
          pLink.addPointAt(p3.x, p3.y);
        } else {
          // Not needed when the ports have spots -- check each port separately
          var fromSpotNone = false, toSpotNone = false;
          if (gofromport !== null && pLink.computeSpot(true) === Spot.None) fromSpotNone = true;
          if (gotoport !== null && pLink.computeSpot(false) === Spot.None) toSpotNone = true;
          if (fromSpotNone || toSpotNone) {
            var p0x = pLink.getPoint(0).x;
            var p0y = pLink.getPoint(0).y;
            var c1x = pLink.getPoint(1).x;
            var c1y = pLink.getPoint(1).y;
            var c2x = pLink.getPoint(2).x;
            var c2y = pLink.getPoint(2).y;
            var p3x = pLink.getPoint(3).x;
            var p3y = pLink.getPoint(3).y;
            if (fromSpotNone) {
              if (this._direction === 90 || this._direction === 270) {
                c1x = p0x;
                c1y = (p0y + p3y) / 2;
              } else {
                c1x = (p0x + p3x) / 2;
                c1y = p0y;
              }
              pLink.setPointAt(1, c1x, c1y);
              var endpt = pLink.getLinkPoint(gofromnode, gofromport, pLink.computeSpot(true), true, false, gotonode, gotoport);
              pLink.setPointAt(0, endpt.x, endpt.y);
            }
            if (toSpotNone) {
              if (this._direction === 90 || this._direction === 270) {
                c2x = p3x;
                c2y = (p0y + p3y) / 2;
              } else {
                c2x = (p0x + p3x) / 2;
                c2y = p3y;
              }
              pLink.setPointAt(2, c2x, c2y);
              var endpt = pLink.getLinkPoint(gotonode, gotoport, pLink.computeSpot(false), false, false, gofromnode, gofromport);
              pLink.setPointAt(3, endpt.x, endpt.y);
            }
          }
        }
      }
      pLink.commitRoute();
      continue;
    }

    // skip links connecting nodes within the same layer, including dummy links
    // inserted to support loopbacks
    if (edge.fromVertex.layer === edge.toVertex.layer) {
      pLink.commitRoute();
      continue;
    }

    // now dealing with a !valid link -- find and route all dummy links
    // corresponding to this link that connect artificial nodes with the
    // real from and to nodes.
    var bezier = false;
    var ortho = false;
    var numpts, pts;
    var si = pLink.firstPickIndex + 1;  // insertion index for intermediate stroke points
    if (pLink.isOrthogonal) {
      ortho = true;
      // keep first and last two points
      numpts = pLink.pointsCount;
      if (numpts > 4) {
        pLink.points.removeRange(2, numpts - 3);
      }
    } else if (pLink.curve === Link.Bezier) {
      bezier = true;
      // keep first and last two points
      numpts = pLink.pointsCount;
      if (numpts > 4) {
        pLink.points.removeRange(2, numpts - 3);
      }
      si = 2;  // insert triplets of bezier points after first control point
    } else {
      // keep the first and last points only
      numpts = pLink.pointsCount;
      var nofromspot = (pLink.computeSpot(true) === Spot.None);
      var notospot = (pLink.computeSpot(false) === Spot.None);
      if (numpts > 2 && nofromspot && notospot) {
        pLink.points.removeRange(1, numpts - 2);
      } else if (numpts > 3 && nofromspot && !notospot) {
        pLink.points.removeRange(1, numpts - 3);
      } else if (numpts > 3 && !nofromspot && notospot) {
        pLink.points.removeRange(2, numpts - 2);
      } else if (numpts > 4 && !nofromspot && !notospot) {
        pLink.points.removeRange(2, numpts - 3);
      }
    }

    // get the from and to nodes.
    var vertexFrom = edge.fromVertex;
    var vertexTo = edge.toVertex;
    var vertexA, prevVertexA;

    // An invalid link requires bends.
    // Add bend points at the positions of the "artificial" nodes.
    // Be smarter about Bezier style and about Orthogonal links.
    if (!edge.rev) {  // i.e. normal direction
      // Walk the sequence of "artificial" nodes to set the bend points of the links.
      while (vertexFrom !== null && vertexFrom !== vertexTo) {
        // Find the "artificial" node that corresponds to the next bend in the link.
        vertexA = null;
        prevVertexA = null;
        // All links between "artificial" nodes have their to and from vertexes set to the
        // those of the link they are replacing.  Hence,
        // it suffices to find the successor link of the current node
        // which is the "real" physical link.
        var destinationEdgeIter = vertexFrom.destinationEdges.iterator;
        var edgeA;
        while (destinationEdgeIter.next()) {
          edgeA = destinationEdgeIter.value;
          if (edgeA.link === edge.link) {
            vertexA = edgeA.toVertex;
            prevVertexA = edgeA.fromVertex;
            if (prevVertexA._node !== null) prevVertexA = null;
            if (vertexA._node === null) break;
          }
        }
        var prevx, prevy, nextx, nexty, mid, depthL, depthR;
        if (vertexA !== vertexTo) {  // not yet end of iteration?
          prevx = pLink.getPoint(si - 1).x;
          prevy = pLink.getPoint(si - 1).y;
          nextx = vertexA.centerX;
          nexty = vertexA.centerY;
          if (ortho) {
            if (this._direction === 180 || this._direction === 0) {
              var py = (prevVertexA !== null ? prevVertexA.centerY : prevy);
              if (py !== nexty) {
                mid = this._layerSpaces[vertexA.layer];
                if (si === 2) {
                  if (this._direction === 0)
                    mid = Math.max(mid, prevx);
                  else
                    mid = Math.min(mid, prevx);
                }
                pLink.insertPointAt(si++, mid, prevy);
                pLink.insertPointAt(si++, mid, nexty);
              }
            } else {
              var px = (prevVertexA !== null ? prevVertexA.centerX : prevx);
              if (px !== nextx) {
                mid = this._layerSpaces[vertexA.layer];
                if (si === 2) {
                  if (this._direction === 90)
                    mid = Math.max(mid, prevy);
                  else
                    mid = Math.min(mid, prevy);
                }
                pLink.insertPointAt(si++, prevx, mid);
                pLink.insertPointAt(si++, nextx, mid);
              }
            }
          } else {  // when style is line or bezier
            depthL = Math.max(10, this._layerSpaceLeft[vertexA.layer]);
            depthR = Math.max(10, this._layerSpaceRight[vertexA.layer]);
            if (this._direction === 180) {
              pLink.insertPointAt(si++, nextx + depthR, nexty);
              if (bezier) pLink.insertPointAt(si++, nextx, nexty);
              pLink.insertPointAt(si++, nextx - depthL, nexty);
            } else if (this._direction === 90) {
              pLink.insertPointAt(si++, nextx, nexty - depthL);
              if (bezier) pLink.insertPointAt(si++, nextx, nexty);
              pLink.insertPointAt(si++, nextx, nexty + depthR);
            } else if (this._direction === 270) {
              pLink.insertPointAt(si++, nextx, nexty + depthR);
              if (bezier) pLink.insertPointAt(si++, nextx, nexty);
              pLink.insertPointAt(si++, nextx, nexty - depthL);
            } else {
              pLink.insertPointAt(si++, nextx - depthL, nexty);
              if (bezier) pLink.insertPointAt(si++, nextx, nexty);
              pLink.insertPointAt(si++, nextx + depthR, nexty);
            }
          }
        }
        // Update the from node and iterate.
        vertexFrom = vertexA;
      }
      if (ortho) {  // do the last zig-zag
        prevx = pLink.getPoint(si - 1).x;
        prevy = pLink.getPoint(si - 1).y;
        nextx = pLink.getPoint(si).x;
        nexty = pLink.getPoint(si).y;
        if (this._direction === 180 || this._direction === 0) {
          if (prevy !== nexty) {
            if (this._direction === 0)
              mid = Math.min(Math.max((nextx + prevx) / 2, this._layerSpaces[vertexTo.layer]), nextx);
            else
              mid = Math.max(Math.min((nextx + prevx) / 2, this._layerSpaces[vertexTo.layer]), nextx);
            pLink.insertPointAt(si++, mid, prevy);
            pLink.insertPointAt(si++, mid, nexty);
          }
        } else {
          if (prevx !== nextx) {
            //Diagram.Debug(((nexty+prevy)/2).toString() + "  " + this._layerSpaces[vertexTo.layer].toString());
            if (this._direction === 90)
              mid = Math.min(Math.max((nexty + prevy) / 2, this._layerSpaces[vertexTo.layer]), nexty);
            else
              mid = Math.max(Math.min((nexty + prevy) / 2, this._layerSpaces[vertexTo.layer]), nexty);
            pLink.insertPointAt(si++, prevx, mid);
            pLink.insertPointAt(si++, nextx, mid);
          }
        }
      }
    } else {  // reversed
      // Walk the sequence of "artificial" nodes to set the bend points of the links.
      var f;
      while (vertexTo !== null && vertexFrom !== vertexTo) {
        // Find the "artificial" node that corresponds to the next bend in the link.
        vertexA = null;
        prevVertexA = null;
        // All links between "artificial" nodes have their GoObject
        //  set to the GoObject of the link they are replacing.  Hence,
        //  it suffices to find the predecessor link of the current node
        //  which has a GoObject equal to the "real" physical link.
        var sourceEdgeIter = vertexTo.sourceEdges.iterator;
        while (sourceEdgeIter.next()) {
          edgeA = sourceEdgeIter.value;
          if (edgeA.link === edge.link) {
            vertexA = edgeA.fromVertex;
            prevVertexA = edgeA.toVertex;
            if (vertexA._node === null) break;
          }
        }
        if (vertexA !== vertexFrom) {  // not yet end of iteration?
          prevx = pLink.getPoint(si - 1).x;
          prevy = pLink.getPoint(si - 1).y;
          nextx = vertexA.centerX;
          nexty = vertexA.centerY;
          if (ortho) {
            if (this._direction === 180 || this._direction === 0) {
              if (si === 2) {  // from real node to first artificial node
                pLink.insertPointAt(si++, prevx, prevy);
                pLink.insertPointAt(si++, prevx, nexty);
              } else {
                var py = (prevVertexA !== null ? prevVertexA.centerY : prevy);
                if (py !== nexty) {
                  mid = this._layerSpaces[vertexA.layer - 1];
                  pLink.insertPointAt(si++, mid, prevy);
                  pLink.insertPointAt(si++, mid, nexty);
                }
              }
            } else {
              if (si === 2) {  // from real node to first artificial node
                pLink.insertPointAt(si++, prevx, prevy);
                pLink.insertPointAt(si++, nextx, prevy);
              } else {
                var px = (prevVertexA !== null ? prevVertexA.centerX : prevx);
                if (px !== nextx) {
                  mid = this._layerSpaces[vertexA.layer - 1];
                  pLink.insertPointAt(si++, prevx, mid);
                  pLink.insertPointAt(si++, nextx, mid);
                }
              }
            }
          } else if (si === 2) {
            if (bezier) {  // when style is bezier, for first segment
              depthL = Math.max(10, this._layerSpaceLeft[vertexTo.layer]);
              depthR = Math.max(10, this._layerSpaceRight[vertexTo.layer]);
              if (this._direction === 180) {
                f = vertexTo._bounds.x;
                pLink.insertPointAt(si++, f - depthL, nexty);
                pLink.insertPointAt(si++, f, nexty);
                pLink.insertPointAt(si++, f + depthR, nexty);
              } else if (this._direction === 90) {
                f = vertexTo._bounds.y + vertexTo._bounds.height;
                pLink.insertPointAt(si++, nextx, f + depthR);
                pLink.insertPointAt(si++, nextx, f);
                pLink.insertPointAt(si++, nextx, f - depthL);
              } else if (this._direction === 270) {
                f = vertexTo._bounds.y;
                pLink.insertPointAt(si++, nextx, f - depthL);
                pLink.insertPointAt(si++, nextx, f);
                pLink.insertPointAt(si++, nextx, f + depthR);
              } else {
                f = vertexTo._bounds.x + vertexTo._bounds.width;
                pLink.insertPointAt(si++, f + depthR, nexty);
                pLink.insertPointAt(si++, f, nexty);
                pLink.insertPointAt(si++, f - depthL, nexty);
              }
            } else {  // for first segment, regular lines
              pLink.insertPointAt(si++, prevx, prevy);
              if (this._direction === 180 || this._direction === 0) {
                //?? make "orthogonal", even though not needed
                pLink.insertPointAt(si++, prevx, nexty);
                pLink.insertPointAt(si++, nextx, nexty);
              } else {
                //?? make "orthogonal", even though not needed
                pLink.insertPointAt(si++, nextx, prevy);
                pLink.insertPointAt(si++, nextx, nexty);
              }
            }
          } else {  // when style is line or bezier, for intermediate segments
            depthL = Math.max(10, this._layerSpaceLeft[vertexA.layer]);
            depthR = Math.max(10, this._layerSpaceRight[vertexA.layer]);
            if (this._direction === 180) {
              if (bezier) pLink.insertPointAt(si++, nextx - depthL, nexty);
              pLink.insertPointAt(si++, nextx, nexty);
              if (bezier) pLink.insertPointAt(si++, nextx + depthR, nexty);
            } else if (this._direction === 90) {
              if (bezier) pLink.insertPointAt(si++, nextx, nexty + depthR);
              pLink.insertPointAt(si++, nextx, nexty);
              if (bezier) pLink.insertPointAt(si++, nextx, nexty - depthL);
            } else if (this._direction === 270) {
              if (bezier) pLink.insertPointAt(si++, nextx, nexty - depthL);
              pLink.insertPointAt(si++, nextx, nexty);
              if (bezier) pLink.insertPointAt(si++, nextx, nexty + depthR);
            } else {
              if (bezier) pLink.insertPointAt(si++, nextx + depthR, nexty);
              pLink.insertPointAt(si++, nextx, nexty);
              if (bezier) pLink.insertPointAt(si++, nextx - depthL, nexty);
            }
          }
        }
        // Update the to node and iterate.
        vertexTo = vertexA;
      }  // now coming from pNodeFrom
      if (gotoport === null || pLink.computeSpot(false) !== Spot.None) {
        prevx = pLink.getPoint(si - 1).x;
        prevy = pLink.getPoint(si - 1).y;
        nextx = pLink.getPoint(si).x;
        nexty = pLink.getPoint(si).y;
        // make adjustments for reverse links coming "around" the node back into it
        if (ortho) {  // when style is ortho for last segment
          var depth2 = this._layerSpaceRight[vertexFrom.layer];
          var s;
          if (this._direction === 180 || this._direction === 0) {
            s = prevy;

            // delete these two InsertPoints if there is an artificial node in the to-node's layer for reverse links
            if (s >= vertexFrom._bounds.y && s <= vertexFrom._bounds.bottom) {
              f = vertexFrom.centerX + depth2;
              if (s < (vertexFrom._bounds.y + vertexFrom._bounds.height / 2))
                s = vertexFrom._bounds.y - this._columnSpacing / 2;
              else
                s = vertexFrom._bounds.bottom + this._columnSpacing / 2;
              pLink.insertPointAt(si++, f, prevy);
              pLink.insertPointAt(si++, f, s);
            }

            pLink.insertPointAt(si++, nextx, s);
            pLink.insertPointAt(si++, nextx, nexty);
          } else {
            s = prevx;

            // delete these two InsertPoints if there is an artificial node in the to-node's layer for reverse links
            if (s >= vertexFrom._bounds.x && s <= vertexFrom._bounds.right) {
              f = vertexFrom.centerY + depth2;
              if (s < (vertexFrom._bounds.x + vertexFrom._bounds.width / 2))
                s = vertexFrom._bounds.x - this._columnSpacing / 2;
              else
                s = vertexFrom._bounds.right + this._columnSpacing / 2;
              pLink.insertPointAt(si++, prevx, f);
              pLink.insertPointAt(si++, s, f);
            }

            pLink.insertPointAt(si++, s, nexty);
            pLink.insertPointAt(si++, nextx, nexty);
          }
        } else if (bezier) {  // when style is bezier for last segment
          depthL = Math.max(10, this._layerSpaceLeft[vertexFrom.layer]);
          depthR = Math.max(10, this._layerSpaceRight[vertexFrom.layer]);
          if (this._direction === 180) {
            f = vertexFrom._bounds.x + vertexFrom._bounds.width;
            pLink.setPointAt(si - 2, f, prevy);
            pLink.setPointAt(si - 1, f + depthR, prevy);
          } else if (this._direction === 90) {
            f = vertexFrom._bounds.y;
            pLink.setPointAt(si - 2, prevx, f);
            pLink.setPointAt(si - 1, prevx, f - depthL);
          } else if (this._direction === 270) {
            f = vertexFrom._bounds.y + vertexFrom._bounds.height;
            pLink.setPointAt(si - 2, prevx, f);
            pLink.setPointAt(si - 1, prevx, f + depthR);
          } else {
            f = vertexFrom._bounds.x;
            pLink.setPointAt(si - 2, f, prevy);
            pLink.setPointAt(si - 1, f - depthL, prevy);
          }
        } else {  // when style is line for last segment
          //?? make "orthogonal", even though not needed
          if (this._direction === 180 || this._direction === 0)
            pLink.insertPointAt(si++, nextx, prevy);
          else
            pLink.insertPointAt(si++, prevx, nexty);
          pLink.insertPointAt(si++, nextx, nexty);
        }
      }
    }

    // adjust end points for Bezier links, to look better at the node
    if (golink !== null && bezier) {
      if (gofromport !== null) {
        if (pLink.computeSpot(true).isNoSpot()) {
          var end = pLink.getPoint(0);
          var ctrl = pLink.getPoint(2);
          if (!end.equals(ctrl)) pLink.setPointAt(1, (end.x + ctrl.x) / 2, (end.y + ctrl.y) / 2);
        }
        var endpt = pLink.getLinkPoint(gofromnode, gofromport, Spot.None, true, false, gotonode, gotoport);
        pLink.setPointAt(0, endpt.x, endpt.y);
      }
      if (gotoport !== null) {
        if (pLink.computeSpot(false).isNoSpot()) {
          var end = pLink.getPoint(pLink.pointsCount - 1);
          var ctrl = pLink.getPoint(pLink.pointsCount - 3);
          if (!end.equals(ctrl)) pLink.setPointAt(pLink.pointsCount - 2, (end.x + ctrl.x) / 2, (end.y + ctrl.y) / 2);
        }
        var endpt = pLink.getLinkPoint(gotonode, gotoport, Spot.None, false, false, gofromnode, gofromport);
        pLink.setPointAt(pLink.pointsCount - 1, endpt.x, endpt.y);
      }
    }
    pLink.commitRoute();
    edge.commit();
  }

  this.avoidOrthogonalOverlaps();
};

/**
* @ignore
* Try to avoid overlapping segments of Orthogonal links.
* <p/> This is called as part of {@link #commitLinks}.
* @this {LayeredDigraphLayout}
*/
LayeredDigraphLayout.prototype.avoidOrthogonalOverlaps = function() {
  var orthos = new List(Link);
  var edgeIter = this.network.edges.iterator;
  var pLink;
  while (edgeIter.next()) {
    pLink = edgeIter.value.link;
    if (pLink !== null && pLink.isOrthogonal && !orthos.contains(pLink)) {
      orthos.add(pLink);
    }
  }
  if (orthos.count > 0) {
    if (this._direction === 90 || this._direction === 270) {
      this.adjustOverlapsH(orthos);
    } else {
      this.adjustOverlapsV(orthos);
    }
  }
};

/**
* @ignore
* @constructor
* @class
*/
function SegInfo() {
  /** @ignore @type {number} */
  this.layer = 0;
  /** @ignore @type {number} */
  this.first = 0;
  /** @ignore @type {number} */
  this.last = 0;
  /** @ignore @type {number} */
  this.columnMin = 0;
  /** @ignore @type {number} */
  this.columnMax = 0;
  /** @ignore @type {number} */
  this.index = 0;
  /** @ignore @type {Link} */
  this.link = null;
  /** @ignore @type {number} */
  this.turns = 0;
}

Util.defineDataProperties(SegInfo, {
  layer: true,
  first: true,
  last: true,
  columnMin: true,
  columnMax: true,
  index: true,
  link: true,
  turns: true
});

/**
* @ignore
* @param {*} a
* @param {*} b
* @return {number} The result of the comparison.
*/
LayeredDigraphLayout.prototype.segInfoComparerDefault = function(a, b) {
  if (!(a instanceof SegInfo) || !(b instanceof SegInfo) || (a === b))
    return 0;
  if (a.layer < b.layer) return -1;
  if (a.layer > b.layer) return 1;
  if (a.columnMin < b.columnMin) return -1;
  if (a.columnMin > b.columnMin) return 1;
  if (a.columnMax < b.columnMax) return -1;
  if (a.columnMax > b.columnMax) return 1;
  return 0;
};

/**
* @ignore
* @param {*} a
* @param {*} b
* @return {number} The result of the comparison.
*/
LayeredDigraphLayout.prototype.segInfoComparer2DefaultFirst = function(a, b) {
  if (!(a instanceof SegInfo) || !(b instanceof SegInfo) || (a === b))
    return 0;
  if (a.first < b.first) return -1;
  if (a.first > b.first) return 1;
  if (a.turns < b.turns) return 1;
  if (a.turns > b.turns) return -1;
  //if ((a.columnMax-a.columnMin) < (b.columnMax-b.columnMin)) return -1;
  //if ((a.columnMax-a.columnMin) > (b.columnMax-b.columnMin)) return 1;
  if (a.columnMin < b.columnMin) return -1;
  if (a.columnMin > b.columnMin) return 1;
  if (a.columnMax < b.columnMax) return -1;
  if (a.columnMax > b.columnMax) return 1;
  return 0;
};

/**
* @ignore
* @param {*} a
* @param {*} b
* @return {number} The result of the comparison.
*/
LayeredDigraphLayout.prototype.segInfoComparer2DefaultLast = function(a, b) {
  if (!(a instanceof SegInfo) || !(b instanceof SegInfo) || (a === b))
    return 0;
  if (a.last < b.last) return -1;
  if (a.last > b.last) return 1;
  if (a.turns < b.turns) return 1;
  if (a.turns > b.turns) return -1;
  //if ((a.columnMax-a.columnMin) < (b.columnMax-b.columnMin)) return -1;
  //if ((a.columnMax-a.columnMin) > (b.columnMax-b.columnMin)) return 1;
  if (a.columnMin < b.columnMin) return -1;
  if (a.columnMin > b.columnMin) return 1;
  if (a.columnMax < b.columnMax) return -1;
  if (a.columnMax > b.columnMax) return 1;
  return 0;
};

/**
* @ignore
* @param {number} a
* @param {number} b
* @return {boolean}
*/
LayeredDigraphLayout.prototype.isApprox = function(a, b) {
  if (Debug) {
    Util.checkRealNumber(a, LayeredDigraphLayout, 'isApprox:a');
    Util.checkRealNumber(b, LayeredDigraphLayout, 'isApprox:b');
  }
  var d = a - b;
  return (d > -1.0 && d < 1.0);
};

/**
* @ignore
* @this {LayeredDigraphLayout}
* @param {List} routables
* @return {number}
*/
LayeredDigraphLayout.prototype.adjustOverlapsH = function(routables) {
  var layersize = 2;  // smaller than for document
  var overlaps = 0;
  var arr = new List(SegInfo);
  var linkIter = routables.iterator;
  var l, p, q;
  while (linkIter.next()) {
    l = linkIter.value;

    if (l !== null && l.isOrthogonal) {
      for (var i = 2; i < l.pointsCount - 3; i++) {
        p = l.getPoint(i);
        q = l.getPoint(i + 1);
        if (this.isApprox(p.y, q.y) && !this.isApprox(p.x, q.x)) {  // assuming Vertical orientation for whole layout
          var info = new SegInfo();
          info.layer = Math.floor(p.y / layersize);
          var p0 = l.getPoint(0);
          var pn = l.getPoint(l.pointsCount - 1);
          info.first = p0.x * p0.x + p0.y;
          info.last = pn.x * pn.x + pn.y;
          info.columnMin = Math.min(p.x, q.x);
          info.columnMax = Math.max(p.x, q.x);
          info.index = i;
          info.link = l;
          if (i + 2 < l.pointsCount) {
            var b = l.getPoint(i - 1);
            var a = l.getPoint(i + 2);
            var t = 0;
            if (b.y < p.y) {
              if (a.y < p.y) t = 3;  // down & up
              else if (p.x < q.x) t = 2;  // crosses segment upward, and jags right
              else t = 1;  // crosses, and jags left
            } else if (b.y > p.y) {
              if (a.y > p.y) t = 0;  // up & down
              else if (q.x < p.x) t = 2;  // crosses segment downward, and jags left
              else t = 1;  // crosses, and jags right
            }
            info.turns = t;
          }
          arr.add(info);
        }
      }
    }
  }
  if (arr.count > 1) {
    arr.sort(this.segInfoComparerDefault);
    var firstlayer = 0;
    while (firstlayer < arr.count) {
      // find all link segments at a layer
      var curlayer = (arr._arr[firstlayer]).layer;
      var nextlayer = firstlayer + 1;
      while (nextlayer < arr.count && (arr._arr[nextlayer]).layer === curlayer) nextlayer++;
      if (nextlayer - firstlayer > 1) {
        // now all SegInfos from firstlayer to nextlayer-1 have layer === curlayer
        var firstgroup = firstlayer;
        while (firstgroup < nextlayer) {
          // find groups of overlapping link segments
          var curmax = (arr._arr[firstgroup]).columnMax;
          var nextgroup = firstlayer + 1;
          while (nextgroup < nextlayer && (arr._arr[nextgroup]).columnMin < curmax) {
            curmax = Math.max(curmax, (arr._arr[nextgroup]).columnMax);
            nextgroup++;
          }
          var groupcount = nextgroup - firstgroup;
          if (groupcount > 1) {
            // now all SegInfos from firstgroup to nextgroup-1 have some overlap with some other
            // link segment in the same group
            //for (i = firstgroup; i < nextgroup; i++) {
            //  var found = false;
            //  for (var j = firstgroup; j < nextgroup; j++) {
            //    if (j === i) continue;
            //    var a = arr._arr[i];
            //    var b = arr._arr[j];
            //    if (a.columnMax >= b.columnMin || b.columnMax >= a.columnMin) {
            //      found = true;
            //      break;
            //    }
            //  }
            //}

            // sort all of the overlapping links by their Last position and Turns number
            arr.sortRange(this.segInfoComparer2DefaultLast, firstgroup, firstgroup + groupcount);
            // count how many overlapping links connect to the same port (actually, same port column)
            var samelastportcount = 1;
            var prevportpos = (arr._arr[firstgroup]).last;
            var si;
            for (i = firstgroup; i < nextgroup; i++) {
              si = arr._arr[i];
              if (si.last !== prevportpos) {
                samelastportcount++;
                prevportpos = si.last;
              }
            }
            // sort all of the overlapping links by their First position and Turns number
            arr.sortRange(this.segInfoComparer2DefaultFirst, firstgroup, firstgroup + groupcount);
            // count how many overlapping links connect to the same port (actually, same port column)
            var samefirstportcount = 1;
            prevportpos = (arr._arr[firstgroup]).first;
            for (i = firstgroup; i < nextgroup; i++) {
              si = arr._arr[i];
              if (si.first !== prevportpos) {
                samefirstportcount++;
                prevportpos = si.first;
              }
            }
            var useFirst;
            var sameportcount;
            if (samelastportcount < samefirstportcount) {
              useFirst = false;
              sameportcount = samelastportcount;
              prevportpos = (arr._arr[firstgroup]).last;
              // resort by Last position
              arr.sortRange(this.segInfoComparer2DefaultLast, firstgroup, firstgroup + groupcount);
            } else {
              useFirst = true;
              sameportcount = samefirstportcount;
              prevportpos = (arr._arr[firstgroup]).first;
              // already sorted by First position
            }

            // now spread out overlapping links
            //??? need to do bin packing
            var lay = 0;
            for (i = firstgroup; i < nextgroup; i++) {
              si = arr._arr[i];
              if ((useFirst ? si.first : si.last) !== prevportpos) {
                lay++;
                prevportpos = (useFirst ? si.first : si.last);
              }
              l = si.link;
              p = l.getPoint(si.index);
              q = l.getPoint(si.index + 1);
              var dy = this.linkSpacing * (lay - (sameportcount - 1) / 2.0);  //??? 4
              if (l.routing !== Link.AvoidsNodes || this.isUnoccupied2(p.x, p.y + dy, q.x, q.y + dy)) {
                overlaps++;
                l.startRoute();
                l.setPointAt(si.index, p.x, p.y + dy);
                l.setPointAt(si.index + 1, q.x, q.y + dy);
                l.commitRoute();
              }
            }
          }
          firstgroup = nextgroup;
        }
      }
      firstlayer = nextlayer;
    }
  }
  return overlaps;
};

/**
* @ignore
* @this {LayeredDigraphLayout}
* @param {List} routables
* @return {number}
*/
LayeredDigraphLayout.prototype.adjustOverlapsV = function(routables) {
  var layersize = 2;  // smaller than for document
  var overlaps = 0;
  var arr = new List(SegInfo);
  var linkIter = routables.iterator;
  var l, p, q;
  while (linkIter.next()) {
    l = linkIter.value;
    if (l !== null && l.isOrthogonal) {
      for (var i = 2; i < l.pointsCount - 3; i++) {
        p = l.getPoint(i);
        q = l.getPoint(i + 1);
        if (this.isApprox(p.x, q.x) && !this.isApprox(p.y, q.y)) {  // assuming Vertical orientation for whole layout
          var info = new SegInfo();
          info.layer = Math.floor(p.x / layersize);
          var p0 = l.getPoint(0);
          var pn = l.getPoint(l.pointsCount - 1);
          info.first = p0.x + p0.y * p0.y;
          info.last = pn.x + pn.y * pn.y;
          info.columnMin = Math.min(p.y, q.y);
          info.columnMax = Math.max(p.y, q.y);
          info.index = i;
          info.link = l;
          if (i + 2 < l.pointsCount) {
            var b = l.getPoint(i - 1);
            var a = l.getPoint(i + 2);
            var t = 0;
            if (b.x < p.x) {
              if (a.x < p.x) t = 3;  // down & up
              else if (p.y < q.y) t = 2;  // crosses segment upward, and jags right
              else t = 1;  // crosses, and jags left
            } else if (b.x > p.x) {
              if (a.x > p.x) t = 0;  // up & down
              else if (q.y < p.y) t = 2;  // crosses segment downward, and jags left
              else t = 1;  // crosses, and jags right
            }
            info.turns = t;
          }
          arr.add(info);
        }
      }
    }
  }
  if (arr.count > 1) {
    arr.sort(this.segInfoComparerDefault);
    var firstlayer = 0;
    while (firstlayer < arr.count) {
      // find all link segments at a layer
      var curlayer = (arr._arr[firstlayer]).layer;
      var nextlayer = firstlayer + 1;
      while (nextlayer < arr.count && (arr._arr[nextlayer]).layer === curlayer) nextlayer++;
      if (nextlayer - firstlayer > 1) {
        // now all SegInfos from firstlayer to nextlayer-1 have layer === curlayer
        var firstgroup = firstlayer;
        while (firstgroup < nextlayer) {
          // find groups of overlapping link segments
          var curmax = (arr._arr[firstgroup]).columnMax;
          var nextgroup = firstlayer + 1;
          while (nextgroup < nextlayer && (arr._arr[nextgroup]).columnMin < curmax) {
            curmax = Math.max(curmax, (arr._arr[nextgroup]).columnMax);
            nextgroup++;
          }
          var groupcount = nextgroup - firstgroup;
          if (groupcount > 1) {
            // now all SegInfos from firstgroup to nextgroup-1 have some overlap with some other
            // link segment in the same group
            //for (i = firstgroup; i < nextgroup; i++) {
            //  var found = false;
            //  for (var j = firstgroup; j < nextgroup; j++) {
            //    if (j === i) continue;
            //    var a = arr._arr[i];
            //    var b = arr._arr[j];
            //    if (a.columnMax >= b.columnMin || b.columnMax >= a.columnMin) {
            //      found = true;
            //      break;
            //    }
            //  }
            //}

            // sort all of the overlapping links by their Last position and Turns number
            arr.sortRange(this.segInfoComparer2DefaultLast, firstgroup, firstgroup + groupcount);
            // count how many overlapping links connect to the same port (actually, same port column)
            var samelastportcount = 1;
            var prevportpos = (arr._arr[firstgroup]).last;
            var si;
            for (i = firstgroup; i < nextgroup; i++) {
              si = arr._arr[i];
              if (si.last !== prevportpos) {
                samelastportcount++;
                prevportpos = si.last;
              }
            }
            // sort all of the overlapping links by their First position and Turns number
            arr.sortRange(this.segInfoComparer2DefaultFirst, firstgroup, firstgroup + groupcount);
            // count how many overlapping links connect to the same port (actually, same port column)
            var samefirstportcount = 1;
            prevportpos = (arr._arr[firstgroup]).first;
            for (i = firstgroup; i < nextgroup; i++) {
              si = arr._arr[i];
              if (si.first !== prevportpos) {
                samefirstportcount++;
                prevportpos = si.first;
              }
            }
            var useFirst;
            var sameportcount;
            if (samelastportcount < samefirstportcount) {
              useFirst = false;
              sameportcount = samelastportcount;
              prevportpos = (arr._arr[firstgroup]).last;
              // resort by Last position
              arr.sortRange(this.segInfoComparer2DefaultLast, firstgroup, firstgroup + groupcount);
            } else {
              useFirst = true;
              sameportcount = samefirstportcount;
              prevportpos = (arr._arr[firstgroup]).first;
              // already sorted by First position
            }

            // now spread out overlapping links
            //??? need to do bin packing
            var lay = 0;
            for (i = firstgroup; i < nextgroup; i++) {
              si = arr._arr[i];
              if ((useFirst ? si.first : si.last) !== prevportpos) {
                lay++;
                prevportpos = (useFirst ? si.first : si.last);
              }
              l = si.link;
              p = l.getPoint(si.index);
              q = l.getPoint(si.index + 1);
              var dx = this.linkSpacing * (lay - (sameportcount - 1) / 2.0);  //??? 4
              if (l.routing !== Link.AvoidsNodes || this.isUnoccupied2(p.x + dx, p.y, q.x + dx, q.y)) {
                overlaps++;
                l.startRoute();
                l.setPointAt(si.index, p.x + dx, p.y);
                l.setPointAt(si.index + 1, q.x + dx, q.y);
                l.commitRoute();
              }
            }
          }
          firstgroup = nextgroup;
        }
      }
      firstlayer = nextlayer;
    }
  }
  return overlaps;
};

/**
* @ignore
* @this {LayeredDigraphLayout}
* @param {number} px
* @param {number} py
* @param {number} qx
* @param {number} qy
* @return {boolean}
*/
LayeredDigraphLayout.prototype.isUnoccupied2 = function(px, py, qx, qy) {  //TODO implement when functionality is available
  if (Debug) {
    Util.checkRealNumber(px, LayeredDigraphLayout, 'isUnoccupied2:px');
    Util.checkRealNumber(py, LayeredDigraphLayout, 'isUnoccupied2:py');
    Util.checkRealNumber(qx, LayeredDigraphLayout, 'isUnoccupied2:qx');
    Util.checkRealNumber(qy, LayeredDigraphLayout, 'isUnoccupied2:qy');
  }
  return true;
  //  if (this.diagram === null) return true;
  //  var panel = this.diagram.panel;
  //  if (panel === null) return true;
  //  var minx = Math.min(px, qx);
  //  var miny = Math.min(py, qy);
  //  var maxx = Math.max(px, qx);
  //  var maxy = Math.max(py, qy);
  //  return panel.isUnoccupied(new Rect(minx, miny, maxx-minx, maxy-miny), null);

};

/**
* @ignore
* Resets several of the private variables in LayeredDigraphLayout.
* @this {LayeredDigraphLayout}
*/
LayeredDigraphLayout.prototype._clearCaches = function() {
  this._maxIndex = -1;
  this._minIndexLayer = 0;
  this._maxIndexLayer = 0;
  this._mySavedLayout = null;
  this._myCrossings = null;
  this._myLayers = null;
  var i;
  for (i = 0; i < this._myCachedNodeArrayLists.length; i++)
    this._myCachedNodeArrayLists[i] = null;
};

/**
* @ignore
* Gets the cached node array list.
* Tries to reuse some of the temporary node arrays.
* @this {LayeredDigraphLayout}
* @param {number} unfixedLayer the layer from which nodes are drawn to fill {@link #unfixedLayerNodes}.
* @return {Array.<LayeredDigraphVertex>} the cached node array list.
*/
LayeredDigraphLayout.prototype._getCachedNodeArrayList = function(unfixedLayer) {
  var unfixedLayerNodes;
  var num = this._indices[unfixedLayer];

  if (num >= this._myCachedNodeArrayLists.length) {
    var temp = [];
    var i;
    for (i = 0; i < this._myCachedNodeArrayLists.length; i++) {
      temp[i] = this._myCachedNodeArrayLists[i];
    }
    this._myCachedNodeArrayLists = temp;
  }
  if (typeof this._myCachedNodeArrayLists[num] === 'undefined' || this._myCachedNodeArrayLists[num] === null) {
    unfixedLayerNodes = [];
  } else {
    unfixedLayerNodes = this._myCachedNodeArrayLists[num];
    this._myCachedNodeArrayLists[num] = null;
  }

  var layer = this._myLayers[unfixedLayer];
  var vertex;
  for (i = 0; i < layer.length; i++) {
    vertex = layer[i];
    if (vertex instanceof LayeredDigraphVertex) {
      unfixedLayerNodes[vertex.index] = vertex;
    }
  }
  return unfixedLayerNodes;
};

/**
* @ignore
* @this {LayeredDigraphLayout}
* @param {number} unfixedLayer
* @param {Array.<LayeredDigraphVertex>} nodes
*/
LayeredDigraphLayout.prototype._freeCachedNodeArrayList = function(unfixedLayer, nodes) {
  this._myCachedNodeArrayLists[this._indices[unfixedLayer]] = nodes;
};

/***************************************************************/
//Property Definitions

/**
* Gets or sets the size of each layer.
* This value must be positive and it defaults to 25.
* @name LayeredDigraphLayout#layerSpacing
* @function.
* @return {number}
*/
/** @type {number} */
LayeredDigraphLayout.prototype.layerSpacing;
Util.exportProperty(LayeredDigraphLayout, 'layerSpacing', LayeredDigraphLayout.prototype.layerSpacing);
Util.defineProperty(LayeredDigraphLayout, { layerSpacing: 'layerSpacing' },
  /** @this {LayeredDigraphLayout} */
  function() { return this._layerSpacing; },
  /** @this {LayeredDigraphLayout} */
  function(val) {
    if (this._layerSpacing !== val && typeof val === 'number' && val >= 0) {
      this._layerSpacing = val;
      this.invalidateLayout();
    }
  }
);

/**
* Gets or sets the size of each column.
* This value must be positive and it defaults to 25.
* @name LayeredDigraphLayout#columnSpacing
* @function.
* @return {number}
*/
/** @type {number} */
LayeredDigraphLayout.prototype.columnSpacing;
Util.exportProperty(LayeredDigraphLayout, 'columnSpacing', LayeredDigraphLayout.prototype.columnSpacing);
Util.defineProperty(LayeredDigraphLayout, { columnSpacing: 'columnSpacing' },
  /** @this {LayeredDigraphLayout} */
  function() { return this._columnSpacing; },
  /** @this {LayeredDigraphLayout} */
  function(val) {
    if (this._columnSpacing !== val && typeof val === 'number' && val >= 0) {
      this._columnSpacing = val;
      this.invalidateLayout();
    }
  }
);

/**
* Gets or sets the direction the graph grows towards.
* 0 is towards the right, 90 is downwards, 180 is towards the left, and 270 is upwards.
* The default value is 0.
* @name LayeredDigraphLayout#direction
* @function.
* @return {number}
*/
/** @type {number} */
LayeredDigraphLayout.prototype.direction;
Util.exportProperty(LayeredDigraphLayout, 'direction', LayeredDigraphLayout.prototype.direction);
Util.defineProperty(LayeredDigraphLayout, { direction: 'direction' },
  /** @this {LayeredDigraphLayout} */
  function() { return this._direction; },
  /** @this {LayeredDigraphLayout} */
  function(val) {
    if (this._direction !== val && typeof val === 'number') {
      this._direction = val;
      this.invalidateLayout();
    }
  }
);

/**
* Gets or set which cycle removal option is used.
* The default value is {@link LayeredDigraphLayout#CycleDepthFirst}.
* @name LayeredDigraphLayout#cycleRemoveOption
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
LayeredDigraphLayout.prototype.cycleRemoveOption;
Util.exportProperty(LayeredDigraphLayout, 'cycleRemoveOption', LayeredDigraphLayout.prototype.cycleRemoveOption);
Util.defineProperty(LayeredDigraphLayout, { cycleRemoveOption: 'cycleRemoveOption' },
  /** @this {LayeredDigraphLayout} */
  function() { return this._cycleRemoveOption; },
  /** @this {LayeredDigraphLayout} */
  function(val) {
    if (this._cycleRemoveOption !== val) {
      if (Debug) Util.checkClass(val, EnumValue, LayeredDigraphNetwork, 'cycleRemoveOption');
      if (val === LayeredDigraphLayout.CycleGreedy || val === LayeredDigraphLayout.CycleDepthFirst) {
        this._cycleRemoveOption = val;
        this.invalidateLayout();
      }
    }
  }
);

/**
* Gets or sets which layering option is being used.
* The default value is {@link LayeredDigraphLayout#LayerOptimalLinkLength}.
* @name LayeredDigraphLayout#layeringOption
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
LayeredDigraphLayout.prototype.layeringOption;
Util.exportProperty(LayeredDigraphLayout, 'layeringOption', LayeredDigraphLayout.prototype.layeringOption);
Util.defineProperty(LayeredDigraphLayout, { layeringOption: 'layeringOption' },
  /** @this {LayeredDigraphLayout} */
  function() { return this._layeringOption; },
  /** @this {LayeredDigraphLayout} */
  function(val) {
    if (this._layeringOption !== val) {
      if (Debug) Util.checkClass(val, EnumValue, LayeredDigraphNetwork, 'layeringOption');
      if (val === LayeredDigraphLayout.LayerOptimalLinkLength || val === LayeredDigraphLayout.LayerLongestPathSink || val === LayeredDigraphLayout.LayerLongestPathSource) {
        this._layeringOption = val;
        this.invalidateLayout();
      }
    }
  }
);

/**
* Gets or sets which indices initialization option is being used.
* The default value is {@link LayeredDigraphLayout#InitDepthFirstOut}.
* @name LayeredDigraphLayout#initializeOption
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
LayeredDigraphLayout.prototype.initializeOption;
Util.exportProperty(LayeredDigraphLayout, 'initializeOption', LayeredDigraphLayout.prototype.initializeOption);
Util.defineProperty(LayeredDigraphLayout, { initializeOption: 'initializeOption' },
  /** @this {LayeredDigraphLayout} */
  function() { return this._initializeOption; },
  /** @this {LayeredDigraphLayout} */
  function(val) {
    if (this._initializeOption !== val) {
      if (Debug) Util.checkClass(val, EnumValue, LayeredDigraphNetwork, 'initializeOption');
      if (val === LayeredDigraphLayout.InitDepthFirstOut || val === LayeredDigraphLayout.InitDepthFirstIn || val === LayeredDigraphLayout.InitNaive) {
        this._initializeOption = val;
        this.invalidateLayout();
      }
    }
  }
);

/**
* Gets or sets the number of iterations to be done.
* The value must be non-negative.  The default value is 4.
* @name LayeredDigraphLayout#iterations
* @function.
* @return {number}
*/
/** @type {number} */
LayeredDigraphLayout.prototype.iterations;
Util.exportProperty(LayeredDigraphLayout, 'iterations', LayeredDigraphLayout.prototype.iterations);
Util.defineProperty(LayeredDigraphLayout, { iterations: 'iterations' },
  /** @this {LayeredDigraphLayout} */
  function() { return this._iterations; },
  /** @this {LayeredDigraphLayout} */
  function(val) {
    if (Debug) Util.checkRealNumber(val, LayeredDigraphNetwork, 'iterations');
    if (this._iterations !== val && typeof val === 'number' && val >= 0) {
      this._iterations = val;
      this.invalidateLayout();
    }
  }
);

/**
* Gets or sets which aggressive option is being used to look for link crossings.
* The default value is {@link LayeredDigraphLayout#AggressiveLess}.
* @name LayeredDigraphLayout#aggressiveOption
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
LayeredDigraphLayout.prototype.aggressiveOption;
Util.exportProperty(LayeredDigraphLayout, 'aggressiveOption', LayeredDigraphLayout.prototype.aggressiveOption);
Util.defineProperty(LayeredDigraphLayout, { aggressiveOption: 'aggressiveOption' },
  /** @this {LayeredDigraphLayout} */
  function() { return this._aggressiveOption; },
  /** @this {LayeredDigraphLayout} */
  function(val) {
    if (this._aggressiveOption !== val) {
      if (Debug) Util.checkClass(val, EnumValue, LayeredDigraphNetwork, 'cycleRemoveOption');
      if (val === LayeredDigraphLayout.AggressiveNone || val === LayeredDigraphLayout.AggressiveLess || val === LayeredDigraphLayout.AggressiveMore) {
        this._aggressiveOption = val;
        this.invalidateLayout();
      }
    }
  }
);

/**
* Gets or sets the options used by the straighten and pack function,
* The default value is {@link LayeredDigraphLayout#PackAll}.
* @name LayeredDigraphLayout#packOption
* @function.
* @return {number}
*/
/** @type {number} */
LayeredDigraphLayout.prototype.packOption;
Util.exportProperty(LayeredDigraphLayout, 'packOption', LayeredDigraphLayout.prototype.packOption);
Util.defineProperty(LayeredDigraphLayout, { packOption: 'packOption' },
  /** @this {LayeredDigraphLayout} */
  function() { return this._packOption; },
  /** @this {LayeredDigraphLayout} */
  function(val) {
    if (this._packOption !== val && (typeof val === 'number') && (val >= 0) && (val < 8)) {
      this._packOption = val;
      this.invalidateLayout();
    }
  }
);

/**
* Gets or sets whether the FromSpot and ToSpot of each link should be set
* to values appropriate for the given value of {@link LayeredDigraphLayout#direction}.
* The default value is true.
* @name LayeredDigraphLayout#setsPortSpots
* @function.
* @return {boolean}
*/
/** @type {boolean} */
LayeredDigraphLayout.prototype.setsPortSpots;
Util.exportProperty(LayeredDigraphLayout, 'setsPortSpots', LayeredDigraphLayout.prototype.setsPortSpots);
Util.defineProperty(LayeredDigraphLayout, { setsPortSpots: 'setsPortSpots' },
  /** @this {LayeredDigraphLayout} */
  function() { return this._setsPortSpots; },
  /** @this {LayeredDigraphLayout} */
  function(val) {
    if ((this._setsPortSpots !== val) && (typeof val === 'boolean')) {
      this._setsPortSpots = val;
      this.invalidateLayout();
    }
  }
);

/**
* @ignore
* Gets or sets the distance between link segments for unrelated links that would otherwise be overlapping.
* The default value is 4.
* <p/>
* If there are a lot of possibly overlapping links and the {@link #layerSpacing} is not large enough,
* some links may cross over nodes.
* You will either need to increase the layerSpacing or decrease this linkSpacing property.
* @name LayeredDigraphLayout#linkSpacing
* @function.
* @return {number}
*/
/** @type {number} */
LayeredDigraphLayout.prototype.linkSpacing;
Util.exportProperty(LayeredDigraphLayout, 'linkSpacing', LayeredDigraphLayout.prototype.linkSpacing);
Util.defineProperty(LayeredDigraphLayout, { linkSpacing: 'linkSpacing' },
  /** @this {LayeredDigraphLayout} */
  function() { return this._linkSpacing; },
  /** @this {LayeredDigraphLayout} */
  function(val) {
    if (this._linkSpacing !== val) {
      this._linkSpacing = val;
      this.invalidateLayout();
    }
  }
);

/**
* Gets the largest layer value.
* @name LayeredDigraphLayout#maxLayer
* @function.
* @return {number}
*/
/** @type {number} */
LayeredDigraphLayout.prototype.maxLayer;
Util.defineReadOnlyProperty(LayeredDigraphLayout, { maxLayer: 'maxLayer' },
  /** @this {LayeredDigraphLayout} */
  function() { return this._maxLayer; }
);

/**
* Gets the largest index value.
* @name LayeredDigraphLayout#maxIndex
* @function.
* @return {number}
*/
/** @type {number} */
LayeredDigraphLayout.prototype.maxIndex;
Util.defineReadOnlyProperty(LayeredDigraphLayout, { maxIndex: 'maxIndex' },
  /** @this {LayeredDigraphLayout} */
  function() { return this._maxIndex; }
);

/**
* Gets the largest column value.
* @name LayeredDigraphLayout#maxColumn
* @function.
* @return {number}
*/
/** @type {number} */
LayeredDigraphLayout.prototype.maxColumn;
Util.defineReadOnlyProperty(LayeredDigraphLayout, { maxColumn: 'maxColumn' },
  /** @this {LayeredDigraphLayout} */
  function() { return this._maxColumn; }
);

/**
* Gets the smallest index layer.
* @name LayeredDigraphLayout#minIndexLayer
* @function.
* @return {number}
*/
/** @type {number} */
LayeredDigraphLayout.prototype.minIndexLayer;
Util.defineReadOnlyProperty(LayeredDigraphLayout, { minIndexLayer: 'minIndexLayer' },
  /** @this {LayeredDigraphLayout} */
  function() { return this._minIndexLayer; }
);

/**
* Gets the larges index layer.
* @name LayeredDigraphLayout#maxIndexLayer
* @function.
* @return {number}
*/
/** @type {number} */
LayeredDigraphLayout.prototype.maxIndexLayer;
Util.defineReadOnlyProperty(LayeredDigraphLayout, { maxIndexLayer: 'maxIndexLayer' },
  /** @this {LayeredDigraphLayout} */
  function() { return this._maxIndexLayer; }
);

/*****************************************************************************************/
//Enums

/**
* Remove cycles using depth first cycle removal;
* a valid value of {@link LayeredDigraphLayout#cycleRemoveOption}.
* @name LayeredDigraphLayout#CycleDepthFirst
* @constant
* @static
* @return {EnumValue}
*/
LayeredDigraphLayout['CycleDepthFirst'] = LayeredDigraphLayout.CycleDepthFirst = Util.defineEnumValue(LayeredDigraphLayout, 'CycleDepthFirst', 0);

/**
* Remove cycles using greedy cycle removal;
* a valid value of {@link LayeredDigraphLayout#cycleRemoveOption}.
* @name LayeredDigraphLayout#CycleGreedy
* @constant
* @static
* @return {EnumValue}
*/
LayeredDigraphLayout['CycleGreedy'] = LayeredDigraphLayout.CycleGreedy = Util.defineEnumValue(LayeredDigraphLayout, 'CycleGreedy', 1);

/**
* Assign layers using optimal link length layering;
* A valid value for {@link LayeredDigraphLayout#layeringOption}.
* @name LayeredDigraphLayout#LayerOptimalLinkLength
* @constant
* @static
* @return {EnumValue}
*/
LayeredDigraphLayout['LayerOptimalLinkLength'] = LayeredDigraphLayout.LayerOptimalLinkLength = Util.defineEnumValue(LayeredDigraphLayout, 'LayerOptimalLinkLength', 0);

/**
* Assign layers using longest path sink layering;
* a valid value for {@link LayeredDigraphLayout#layeringOption}.
* @name LayeredDigraphLayout#LayerLongestPathSink
* @constant
* @static
* @return {EnumValue}
*/
LayeredDigraphLayout['LayerLongestPathSink'] = LayeredDigraphLayout.LayerLongestPathSink = Util.defineEnumValue(LayeredDigraphLayout, 'LayerLongestPathSink', 1);

/**
* Assign layers using longest path source layering;
* a valid value for {@link LayeredDigraphLayout#layeringOption}.
* @name LayeredDigraphLayout#LayerLongestPathSource
* @constant
* @static
* @return {EnumValue}
*/
LayeredDigraphLayout['LayerLongestPathSource'] = LayeredDigraphLayout.LayerLongestPathSource = Util.defineEnumValue(LayeredDigraphLayout, 'LayerLongestPathSource', 2);

/**
* Initialize using depth first out initialization;
* a valid value for {@link LayeredDigraphLayout#initializeOption}.
* @name LayeredDigraphLayout#InitDepthFirstOut
* @constant
* @static
* @return {EnumValue}
*/
LayeredDigraphLayout['InitDepthFirstOut'] = LayeredDigraphLayout.InitDepthFirstOut = Util.defineEnumValue(LayeredDigraphLayout, 'InitDepthFirstOut', 0);

/**
* Initialize using depth first in initialization;
* a valid value for {@link LayeredDigraphLayout#initializeOption}.
* @name LayeredDigraphLayout#InitDepthFirstIn
* @constant
* @static
* @return {EnumValue}
*/
LayeredDigraphLayout['InitDepthFirstIn'] = LayeredDigraphLayout.InitDepthFirstIn = Util.defineEnumValue(LayeredDigraphLayout, 'InitDepthFirstIn', 1);

/**
* Initialize using naive initialization;
* a valid value for {@link LayeredDigraphLayout#initializeOption}.
* @name LayeredDigraphLayout#InitNaive
* @constant
* @static
* @return {EnumValue}
*/
LayeredDigraphLayout['InitNaive'] = LayeredDigraphLayout.InitNaive = Util.defineEnumValue(LayeredDigraphLayout, 'InitNaive', 2);

/**
* The fastest, but poorest, crossing reduction algorithm;
* a valid value for {@link LayeredDigraphLayout#aggressiveOption}.
* @name LayeredDigraphLayout#AggressiveNone
* @constant
* @static
* @return {EnumValue}
*/
LayeredDigraphLayout['AggressiveNone'] = LayeredDigraphLayout.AggressiveNone = Util.defineEnumValue(LayeredDigraphLayout, 'AggressiveNone', 0);

/**
* The faster, less aggressive, crossing reduction algorithm;
* a valid value for {@link LayeredDigraphLayout#aggressiveOption}.
* @name LayeredDigraphLayout#AggressiveLess
* @constant
* @static
* @return {EnumValue}
*/
LayeredDigraphLayout['AggressiveLess'] = LayeredDigraphLayout.AggressiveLess = Util.defineEnumValue(LayeredDigraphLayout, 'AggressiveLess', 1);

/**
* The slower, more aggressive, crossing reduction algorithm,
* a valid value for {@link LayeredDigraphLayout#aggressiveOption}.
* @name LayeredDigraphLayout#AggressiveMore
* @constant
* @static
* @return {EnumValue}
*/
LayeredDigraphLayout['AggressiveMore'] = LayeredDigraphLayout.AggressiveMore = Util.defineEnumValue(LayeredDigraphLayout, 'AggressiveMore', 2);

/**
* Does minimal work in packing the nodes;
* a valid value for {@link LayeredDigraphLayout#packOption}.
* @name LayeredDigraphLayout#PackNone
* @constant
* @static
* @return {number}
*/
LayeredDigraphLayout['PackNone'] = LayeredDigraphLayout.PackNone = 0;

/**
* This option gives more chances for the packing algorithm to improve the network,
* but is very expensive in time for large networks;
* a valid value for {@link LayeredDigraphLayout#packOption}.
* @name LayeredDigraphLayout#PackExpand
* @constant
* @static
* @return {number}
*/
LayeredDigraphLayout['PackExpand'] = LayeredDigraphLayout.PackExpand = 1;

/**
* This option tries to have the packing algorithm straighten many of the
* links that cross layers,
* a valid value for {@link LayeredDigraphLayout#packOption}.
* @name LayeredDigraphLayout#PackStraighten
* @constant
* @static
* @return {number}
*/
LayeredDigraphLayout['PackStraighten'] = LayeredDigraphLayout.PackStraighten = 2;

/**
* This option tries to have the packing algorithm center groups of nodes
* based on their relationships with nodes in other layers,
* a valid value for {@link LayeredDigraphLayout#packOption}.
* @name LayeredDigraphLayout#PackMedian
* @constant
* @static
* @return {number}
*/
LayeredDigraphLayout['PackMedian'] = LayeredDigraphLayout.PackMedian = 4;

/**
* Enable all options for the {@link LayeredDigraphLayout#packOption} property;
* See also {@link LayeredDigraphLayout#PackExpand}, {@link LayeredDigraphLayout#PackStraighten},
* and {@link LayeredDigraphLayout#PackMedian}.
* @name LayeredDigraphLayout#PackAll
* @constant
* @static
* @return {number}
*/
LayeredDigraphLayout['PackAll'] = LayeredDigraphLayout.PackAll = 7;


/****************************************************************************************/
//Network, Vertex, and Edge

/**
* @ignore
* @constructor
* @extends LayoutNetwork
* @category Layout
* @class
* This class represents an abstract graph of {@link LayeredDigraphVertex}es and {@link LayeredDigraphEdge}s
* that can be constructed based on the {@link Node}s and {@link Link}s of a {@link Diagram}
* so that the {@link LayeredDigraphLayout} can operate independently of the diagram until it
* is time to commit any node positioning or link routing.
*/
function LayeredDigraphNetwork() {
  LayoutNetwork.call(this);
}

Util.publish('LayeredDigraphNetwork', LayeredDigraphNetwork);

Util.inherit(LayeredDigraphNetwork, LayoutNetwork);

/**
* @ignore
* Allocate a new instance of {@link LayeredDigraphVertex}.
* @this {LayeredDigraphNetwork}
* @return {LayoutVertex}
*/
LayeredDigraphNetwork.prototype.createVertex = function() {
  return new LayeredDigraphVertex();
};

/**
* @ignore
* Allocate a new instance of {@link LayeredDigraphEdge}.
* @this {LayeredDigraphNetwork}
* @return {LayoutEdge}
*/
LayeredDigraphNetwork.prototype.createEdge = function() {
  return new LayeredDigraphEdge();
};


/**
* @constructor
* @extends LayoutVertex
* @category Layout
* @class
* This holds {@link LayeredDigraphLayout}-specific information about {@link Node}s.
*/
function LayeredDigraphVertex() {
  LayoutVertex.call(this);

  // layered-specific properties:

  /**
  * The layer to which the node is assigned.
  * The default value is -1.
  * @name LayeredDigraphVertex#layer
  * @function.
  * @return {number}
  */
  /** @expose @type {number} */
  this.layer = -1;

  /**
  * The column to which the node is assigned.
  * The default value is -1.
  * @name LayeredDigraphVertex#column
  * @function.
  * @return {number}
  */
  /** @expose @type {number} */
  this.column = -1;

  /**
  * The index to which the node is assigned.
  * The default value is -1.
  * @name LayeredDigraphVertex#index
  * @function.
  * @return {number}
  */
  /** @expose @type {number} */
  this.index = -1;

  /**
  * The connected component to which the node is assigned.
  * The default value is NaN.
  * @name LayeredDigraphVertex#component
  * @function.
  * @return {number}
  */
  /** @expose @type {number} */
  this.component = NaN;

  /**
  * Another LayeredDigraphVertex in the same layer that this node should be near.
  * The default value is null.
  * @name LayeredDigraphVertex#near
  * @function.
  * @return {LayeredDigraphVertex}
  */
  /** @expose @type {LayeredDigraphVertex} */
  this.near = null;

  // internal state
  /** @ignore @type {boolean} */
  this.valid = false;
  /** @ignore @type {number} */
  this.discover = NaN;
  /** @ignore @type {number} */
  this.finish = NaN;

  /** @ignore @type {number} */
  this.artificialType = 0;
  /** @ignore @type {number} */
  this.nodeMinColumnSpaceTopLeft = undefined;
  /** @ignore @type {number} */
  this.nodeMinColumnSpaceBottomRight = undefined;
}
Util.publish('LayeredDigraphVertex', LayeredDigraphVertex);

Util.inherit(LayeredDigraphVertex, LayoutVertex);


/**
* @constructor
* @extends LayoutEdge
* @category Layout
* @class
* This holds {@link LayeredDigraphLayout}-specific information about {@link Link}s.
*/
function LayeredDigraphEdge() {
  LayoutEdge.call(this);

  // layered-specific properties:

  /**
  * True if the link is part of the proper digraph.
  * The default value is false.
  * @name LayeredDigraphEdge#valid
  * @function.
  * @return {boolean}
  */
  /** @expose @type {boolean} */
  this.valid = false;

  /**
  * True if the link was reversed during cycle removal.
  * The default value is false.
  * @name LayeredDigraphEdge#rev
  * @function.
  * @return {boolean}
  */
  /** @expose @type {boolean} */
  this.rev = false;

  /**
  * True if the link is part of the depth first forest.
  * The default value is false.
  * @name LayeredDigraphEdge#forest
  * @function.
  * @return {boolean}
  */
  /** @expose @type {boolean} */
  this.forest = false;

  /**
  * Location of the port at the from node of the link.
  * Allows the crossing matrix to correctly calculate the crossings for nodes with multiple ports.
  * The default value is NaN.
  * @name LayeredDigraphEdge#portFromPos
  * @function.
  * @return {number}
  */
  /** @expose @type {number} */
  this.portFromPos = NaN;

  /**
  * Location of the port at the to node of the link.
  * Allows the crossing matrix to correctly calculate the crossings for nodes with multiple ports.
  * The default value is NaN.
  * @name LayeredDigraphEdge#portToPos
  * @function.
  * @return {number}
  */
  /** @expose @type {number} */
  this.portToPos = NaN;

  /**
  * Approximate column offset of the from port of the link from the from node column used in straightening.
  * The default value is 0.
  * @name LayeredDigraphEdge#portFromColOffset
  * @function.
  * @return {number}
  */
  /** @expose @type {number} */
  this.portFromColOffset = 0;

  /**
  * Approximate column offset of the to port of the link from the to node column used in straightening.
  * The default value is 0.
  * @name LayeredDigraphEdge#portToColOffset
  * @function.
  * @return {number}
  */
  /** @expose @type {number} */
  this.portToColOffset = 0;
}
Util.publish('LayeredDigraphEdge', LayeredDigraphEdge);

Util.inherit(LayeredDigraphEdge, LayoutEdge);

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
TreeLayout
TreeNetwork
TreeVertex
TreeEdge
*/

/***********************************TreeLayout********************************/
/*****************************************************************************/

/**
 * Constructs a {@link TreeLayout} with no {@link Layout#network}
 * and with no owning {@link Layout#diagram}.
 * @constructor
 * @extends Layout
 * @category Layout
 * @class
 * This layout positions nodes in a tree-like arrangement.
 * <p/>
 * This layout makes use of a {@link LayoutNetwork} of
 * {@link TreeVertex}es and {@link TreeEdge}s that normally
 * correspond to the {@link Node}s and {@link Link}s of the {@link Diagram}.
 */
function TreeLayout() {
  if (arguments.length > 0) {
    Util.throwError('TreeLayout constructor cannot take any arguments.');
  }
  Layout.call(this);
  /** @type {Set} */
  this._roots = new Set(Object);
  /** @type {EnumValue} */
  this._path = TreeLayout.PathDefault;
  /** @type {EnumValue} */
  this._effectivePath = TreeLayout.PathDestination;
  /** @type {EnumValue} */
  this._treeStyle = TreeLayout.StyleLayered;
  /** @type {EnumValue} */
  this._arrangement = TreeLayout.ArrangementVertical;
  /** @type {Size} */
  this._arrangementSpacing = new Size(10, 10).freeze();
  /** @type {TreeVertex} */
  this._rootDefaults = new TreeVertex();
  /** @type {TreeVertex} */
  this._alternateDefaults = new TreeVertex();
}

Util.publish('TreeLayout', TreeLayout);

Util.inherit(TreeLayout, Layout);

/**
* @ignore
* Copies properties to a cloned Layout.
* @this {TreeLayout}
* @param {Layout} copy
* @override
*/
TreeLayout.prototype.cloneProtected = function(copy) {
  Layout.prototype.cloneProtected.call(this, copy);
  // _roots gets new empty List
  copy._path = this._path;
  copy._treeStyle = this._treeStyle;
  copy._arrangement = this._arrangement;
  copy._arrangementSpacing.assign(this._arrangementSpacing);
  copy._rootDefaults.copyInheritedPropertiesFrom(this._rootDefaults);
  copy._alternateDefaults.copyInheritedPropertiesFrom(this._alternateDefaults);
};

/**
* Create a new {@link LayoutNetwork} of {@link TreeVertex}es and {@link TreeEdge}s.
* @this {TreeLayout}
* @return {LayoutNetwork} a new {@link LayoutNetwork}.
*/
TreeLayout.prototype.createNetwork = function() {
  var net = new TreeNetwork();
  net.setLayout(this);
  return net;
};

/**
* Create and initialize a {@link TreeNetwork} with the given nodes and links.
* <p/>
* This does not include any nodes of category "Comment".
* Comment nodes are added by the {@link #addComments} method.
* @this {TreeLayout}
* @param {Diagram|Group|Iterable} coll A {@link Diagram} or a {@link Group} or a collection of {@link Part}s.
* @return {LayoutNetwork}
*/
TreeLayout.prototype.makeNetwork = function(coll) {
  var net = this.createNetwork();
  if (coll instanceof Diagram) {
    this.makeNetwork1(net, coll.nodes, true);
    this.makeNetwork1(net, coll.links, true);
  } else if (coll instanceof Group) {
    this.makeNetwork1(net, coll.memberParts, false);
  } else {
    this.makeNetwork1(net, coll.iterator, false);
  }
  return net;
};

/**
* @ignore
* @this {TreeLayout}
*/
TreeLayout.prototype.makeNetwork1 = function(net, parts, toplevelonly) {
  var pit = parts.iterator;
  while (pit.next()) {
    var p = pit.value;
    if (!(p instanceof Node)) continue;
    if (!p.canLayout()) continue;
    if (p.category === 'Comment') continue;
    if (toplevelonly && !p.isTopLevel) continue;
    if (p.isLinkLabel) continue;
    if (p instanceof Group && p.layout === null) {
      this.makeNetwork1(net, p.memberParts, false);
    } else {
      net.addNode(p);
    }
  }
  pit.reset();
  while (pit.next()) {
    var p = pit.value;
    if (!(p instanceof Link)) continue;
    if (!p.canLayout()) continue;
    if (p.category === 'Comment') continue;
    if (toplevelonly && !p.isTopLevel) continue;
    var fromNode = p.fromNode;
    var toNode = p.toNode;
    if (fromNode === null || toNode === null || fromNode === toNode) continue;
    if (fromNode.category !== 'Comment' && toNode.category !== 'Comment') {
      var fromVertex = net.findGroupVertex(fromNode);
      var toVertex = net.findGroupVertex(toNode);
      if (fromVertex !== null && toVertex !== null) {
        net.linkVertexes(fromVertex, toVertex, p);
      }
    }
  }
};


/**
* Assign the positions of the vertexes in the network.
* @this {TreeLayout}
* @param {Diagram|Group|Iterable} coll A {@link Diagram} or a {@link Group} or a collection of {@link Part}s.
*/
TreeLayout.prototype.doLayout = function(coll) {
  if (!coll) Util.throwError('Layout.doLayout(collection) argument must not be null but a Diagram, a Group, or an Iterable of Parts');
  if (this.network === null) {
    this.network = this.makeNetwork(coll);
  }

  if (this.arrangement !== TreeLayout.ArrangementFixedRoots) {
    this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin);
  }

  var diagram = this.diagram;
  if (diagram === null && coll instanceof Diagram) diagram = coll;
  if (this.path === TreeLayout.PathDefault && diagram !== null) {
    this._effectivePath = (diagram.isTreePathToChildren ? TreeLayout.PathDestination : TreeLayout.PathSource);
  } else {
    this._effectivePath = (this.path === TreeLayout.PathDefault ? TreeLayout.PathDestination : this.path);
  }

  if (this.network.vertexes.count > 0) {
    this.createTrees();  // calls recursive walkTree
    this.initializeAll();  // calls non-recursive initializeTreeVertexValues
    this.assignAll();  // calls non-recursive assignTreeVertexValues
    this.sortAll();  // calls non-recursive sortTreeVertexChildren
    this.annotateAll();  // calls non-recursive addComments
    this.layoutAllTrees();  // calls recursive layoutTree
    this.arrangeTrees();

    // Update the "physical" positions of the nodes and links.
    this.updateParts();
  }

  // restore in case of future re-use
  this.network = null;
  this._roots = new Set(Object);

  this.isValidLayout = true;
};

/**
* @ignore
* This method is responsible for initializing all of the {@link TreeVertex}es,
* setting {@link TreeVertex#initialized}, {@link TreeVertex#level},
* {@link TreeVertex#parent}, and {@link TreeVertex#children}, and making sure roots
* has at least one suitable {@link TreeVertex} in it.
* <p/>
* This will call findRoots if roots is empty.
* Then it will iterate over the roots, calling walkTree on each one.
* @this {TreeLayout}
*/
TreeLayout.prototype.createTrees = function() {
  //??? support incremental layouts
  this.network.deleteSelfEdges();
  var vit = this.network.vertexes.iterator;
  while (vit.next()) {
    var v = vit.value;
    v.initialized = false;
    v.level = 0;
    v.parent = null;
    v.children = [];
  }
  // for compatibility, substitute TreeVertexes for all Nodes in _roots collection
  if (this._roots.count > 0) {
    var rit = this._roots.iterator;
    this._roots = new Set(TreeVertex);
    while (rit.next()) {
      var r = rit.value;
      if (r instanceof Node) {
        var v = this.network.findVertex(r);
        if (v !== null) {
          this._roots.add(v);
        }
      } else if (r instanceof TreeVertex) {
        this._roots.add(r);
      }
    }
  }
  if (this._roots.count === 0) {
    this.findRoots();
  }
  rit = this._roots.iterator;
  while (rit.next()) {
    var v = rit.value;
    if (!v.initialized) {
      // walkTree will remove objects in the roots collection that are child nodes
      v.initialized = true;
      this.walkTree(v);
    }
  }
};

/**
* @ignore
* This method is responsible for finding all of the root nodes.
* <p/>
* When you have not already added the roots to the roots collection,
* this will choose a root node.
* The choice may not be what you want, so we recommend that you specify the roots.
* @this {TreeLayout}
*/
TreeLayout.prototype.findRoots = function() {
  var vit = this.network.vertexes.iterator;
  while (vit.next()) {
    var v = vit.value;
    switch (this._effectivePath) {
      case TreeLayout.PathDestination:
        if (v.sourceEdges.count === 0) this._roots.add(v);
        break;
      case TreeLayout.PathSource:
        if (v.destinationEdges.count === 0) this._roots.add(v);
        break;
      default:
        Util.throwError('Unhandled path value ' + this._effectivePath.toString());
        break;
    }
  }
  if (this._roots.count === 0) {
    this.chooseRoot();
  }
};

/**
* @ignore
* This method is responsible for picking a root node if none were found.
* @this {TreeLayout}
*/
TreeLayout.prototype.chooseRoot = function() {
  var mincount = 999999;
  var bestroot = null;
  var vit = this.network.vertexes.iterator;
  while (vit.next()) {
    var v = vit.value;
    switch (this._effectivePath) {
      case TreeLayout.PathDestination:
        if (v.sourceEdges.count < mincount) { mincount = v.sourceEdges.count; bestroot = v; }
        break;
      case TreeLayout.PathSource:
        if (v.destinationEdges.count < mincount) { mincount = v.destinationEdges.count; bestroot = v; }
        break;
      default:
        Util.throwError('Unhandled path value ' + this._effectivePath.toString());
        break;
    }
  }
  if (bestroot !== null)
    this._roots.add(bestroot);
};

/**
* @ignore
* Traverse the {@link Network} and assign the {@link TreeVertex#parent},
* {@link TreeVertex#level}, and {@link TreeVertex#children} properties.
* <p/>
* This method should walk the tree recursively.
* The standard implementation gracefully handles shared nodes, including cyclical references.
* However, there can only be one {@link TreeVertex#parent} per node.
* If a node is declared to be the child of multiple nodes, it is not guaranteed which
* node wins as the parent node.
* If any of the children of this node are in the roots collection,
* they are removed from that collection.
* @this {TreeLayout}
* @param {LayoutVertex} v
*/
TreeLayout.prototype.walkTree = function(v) {  //?? this could be optimized
  if (Debug) Util.checkClass(v, TreeVertex, TreeLayout, 'walkTree:v');
  if (v === null) return;
  // handle DAGs gracefully, and ignore cycles
  switch (this._effectivePath) {
    case TreeLayout.PathDestination:
      if (v.destinationEdges.count > 0) {
        var list = new List(TreeVertex);
        var vit = v.destinationVertexes;
        while (vit.next()) {
          var c = vit.value;
          if (this.walkOK(v, c)) list.add(c);
        }
        if (list.count > 0) v.children = list.toArray();
      }
      break;
    case TreeLayout.PathSource:
      if (v.sourceEdges.count > 0) {
        var list = new List(TreeVertex);
        var vit = v.sourceVertexes;
        while (vit.next()) {
          var c = vit.value;
          if (this.walkOK(v, c)) list.add(c);
        }
        if (list.count > 0) v.children = list.toArray();
      }
      break;
    default:
      Util.throwError('Unhandled path value' + this._effectivePath.toString());
  }
  var children = v.children;
  var childrenLength = children.length;
  // set Initialized before calling WalkTree
  for (var i = 0; i < childrenLength; i++) {
    var c = children[i];
    c.initialized = true;
    c.level = v.level + 1;
    c.parent = v;
    this._roots.remove(c);
  }
  for (var i = 0; i < childrenLength; i++) {
    var c = children[i];
    this.walkTree(c);
  }
};

/**
* @ignore
* @this {TreeLayout}
* @param {LayoutVertex} v
* @param {LayoutVertex} c
* @return {boolean}
*/
TreeLayout.prototype.walkOK = function(v, c) {
	if (Debug) Util.checkClass(v, TreeVertex, TreeLayout, 'walkOK:v');
	if (Debug) Util.checkClass(c, TreeVertex, TreeLayout, 'walkOK:c');
	if (c.initialized) {
		if (this.isAncestor(c, v)) return false;
		if (c.level > v.level) return false;
		this.removeChild(c.parent, c);
		// new level will be assigned just before calling walkTree on c
		return true;
	} else {
		return true;
	}
};

/**
* @ignore
* Determines if vertex a is an ancestor of vertex b.
* @this {TreeLayout}
* @param {LayoutVertex} a
* @param {LayoutVertex} b
* @return {boolean}
*/
TreeLayout.prototype.isAncestor = function(a, b) {
	if (Debug) Util.checkClass(a, TreeVertex, TreeLayout, 'isAncestor:a');
	if (Debug) Util.checkClass(b, TreeVertex, TreeLayout, 'isAncestor:b');
	if (b === null) return false;
	var x = b.parent;
	while (x !== null && x !== a) x = x.parent;
	return (x === a);
};

/**
* @ignore
* @this {TreeLayout}
* @param {LayoutVertex} p
* @param {LayoutVertex} c
*/
TreeLayout.prototype.removeChild = function(p, c) {
  if (Debug) Util.checkClass(p, TreeVertex, TreeLayout, 'removeChild:p');
  if (Debug) Util.checkClass(c, TreeVertex, TreeLayout, 'removeChild:c');
  if (p === null) return;
  if (c === null) return;
  var v = p.children;
  var num = 0;
  for (var i = 0; i < v.length; i++) if (v[i] === c) num++;
  if (num > 0) {
    var r = new Array(v.length - num);
    var j = 0;
    for (i = 0; i < v.length; i++) if (v[i] !== c) r[j++] = v[i];
    p.children = r;
  }
};

/**
* @ignore
* @this {TreeLayout}
*/
TreeLayout.prototype.initializeAll = function() {
  var rit = this._roots.iterator;
  while (rit.next()) {
    var v = rit.value;
    this.initializeTree(v);
  }
};

/**
* @ignore
* @this {TreeLayout}
* @param {LayoutVertex} v
*/
TreeLayout.prototype.initializeTree = function(v) {
  if (Debug) Util.checkClass(v, TreeVertex, TreeLayout, 'initializeTree:v');
  if (v === null) return;
  this.initializeTreeVertexValues(v); // inherit property values
  if (v.alignment === TreeLayout.AlignmentBusBranching)
    this.sortTreeVertexChildren(v); // maybe modify order of v.children
  var count = 0;
  var maxchildren = v.childrenCount;
  var maxgeneration = 0;
  var children = v.children;
  var childrenLength = children.length;
  for (var i = 0; i < childrenLength; i++) {
    var c = children[i];
    this.initializeTree(c);
    count += c.descendantCount + 1;
    maxchildren = Math.max(maxchildren, c.maxChildrenCount);
    maxgeneration = Math.max(maxgeneration, c.maxGenerationCount);
  }
  v.descendantCount = count;
  v.maxChildrenCount = maxchildren;
  v.maxGenerationCount = (maxchildren > 0 ? maxgeneration + 1 : 0);
};

/**
* @ignore
* @this {TreeLayout}
* @param {LayoutVertex} v
* @return {LayoutVertex}
*/
TreeLayout.prototype.mom = function(v) {
  if (Debug) Util.checkClass(v, TreeVertex, TreeLayout, 'mom:v');
  switch (this._treeStyle) {
    default:
    case TreeLayout.StyleLayered:
      if (v.parent !== null) return v.parent;
      return this._rootDefaults;
    case TreeLayout.StyleRootOnly:
      if (v.parent === null) return this._rootDefaults;
      if (v.parent.parent === null) return this._alternateDefaults;
      return v.parent;
    case TreeLayout.StyleAlternating:
      if (v.parent !== null) {
        if (v.parent.parent !== null) return v.parent.parent;
        return this._alternateDefaults;
      }  // ?? return this._rootDefaults
    case TreeLayout.StyleLastParents:
      {
        var lastparent = true;
        if (v.childrenCount === 0) {
          lastparent = false;
        } else {
          var children = v.children;
          var childrenLength = children.length;
          for (var i = 0; i < childrenLength; i++) {
            var c = children[i];
            if (c.childrenCount > 0) {
              lastparent = false;
              break;
            }
          }
        }
        if (lastparent && v.parent !== null) return this._alternateDefaults;
        if (v.parent !== null) return v.parent;
        return this._rootDefaults;
      }
  }
};

/**
* Assign initial property values for a {@link TreeVertex}.
* <p/>
* The values may be inherited, so this method is called while
* propagating values from the root nodes.
* This method should not walk the tree, since it is called for each
* {@link TreeVertex} in a depth-first manner starting at a root.
* <p/>
* You probably do not need to override this method,
* but if you do you should call first either the base method
* or {@link TreeVertex#copyInheritedPropertiesFrom}, since they
* assign most of the {@link TreeVertex} property values
* used to influence the layout.
* Informational properties such as {@link TreeVertex#descendantCount}
* and {@link TreeVertex#maxGenerationCount} will not yet have been initialized
* by the time this method is called.
* It is more common to override {@link #assignTreeVertexValues} in order to
* modify a property or two to customize the layout at that node.
* <p/>
* When the {@link TreeVertex#alignment} is {@link TreeLayout#AlignmentBusBranching},
* this will modify the {@link TreeVertex#angle} appropriately depending on which
* side of the bus the vertex is on.
* @expose
* @this {TreeLayout}
* @param {LayoutVertex} v
* @since 1.2
*/
TreeLayout.prototype.initializeTreeVertexValues = function(v) {
  if (Debug) Util.checkClass(v, TreeVertex, TreeLayout, 'initializeTreeVertexValues:v');
  var mom = this.mom(v);
  v.copyInheritedPropertiesFrom(mom);

  // caution: this depends on the parent having been sorted first
  if (v.parent !== null && v.parent.alignment === TreeLayout.AlignmentBusBranching) {
    var a = v.angle;
    var pchildren = v.parent.children;
    var i = 0;
    while (i < pchildren.length) {
      if (v === pchildren[i]) break;
      i++;
    }
    if (i % 2 === 0) {  // even child: turn
      // but last child keeps going in same direction, the rest turn
      if (i !== pchildren.length - 1) {
        if (a === 90) a = 180;
        else if (a === 180) a = 270;
        else if (a === 270) a = 180;
        else a = 270;
      }
    } else {  // odd child: turn the other way
      if (a === 90) a = 0;
      else if (a === 180) a = 90;
      else if (a === 270) a = 0;
      else a = 90;
    }
    v.angle = a;
  }

  v.initialized = true;  // should already be true, but make sure
};

/**
* @ignore
* @this {TreeLayout}
*/
TreeLayout.prototype.assignAll = function() {
	var rit = this._roots.iterator;
	while (rit.next()) {
		var v = rit.value;
		this.assignTree(v);
	}
};

/**
* @ignore
* @this {TreeLayout}
*/
TreeLayout.prototype.assignTree = function(v) {
  if (Debug) Util.checkClass(v, TreeVertex, TreeLayout, 'assignTree:v');
  if (v === null) return;
  this.assignTreeVertexValues(v);
  var children = v.children;
  var childrenLength = children.length;
  for (var i = 0; i < childrenLength; i++) {
    var c = children[i];
    this.assignTree(c);
  }
};

/**
* Assign final property values for a {@link TreeVertex}.
* <p/>
* This method is commonly overridden in order to provide
* tree layout properties for particular nodes.
* This method is called after values have been inherited from other
* {@link TreeVertex}es, so you can examine and modify the
* values of related tree nodes.
* <p/>
* However, when {@link TreeVertex#alignment} is {@link TreeLayout#AlignmentBusBranching},
* changing the {@link TreeVertex#sorting} or
* {@link TreeVertex#comparer} properties in this method will have no effect.
* <p/>
* This method should not walk the tree, since it is called for each
* {@link TreeVertex} in a depth-first manner starting at a root.
* @expose
* @this {TreeLayout}
* @param {LayoutVertex} v
* @since 1.1
*/
TreeLayout.prototype.assignTreeVertexValues = function(v) {
	//if (Debug) Util.checkClass(v, TreeVertex, TreeLayout, 'assignTreeVertexValues:v');
};

/**
* @ignore
* @this {TreeLayout}
*/
TreeLayout.prototype.sortAll = function() {
  var rit = this._roots.iterator;
  while (rit.next()) {
    var v = rit.value;
    this.sortTree(v);
  }
};

/**
* @ignore
* @this {TreeLayout}
* @param {LayoutVertex} v
*/
TreeLayout.prototype.sortTree = function(v) {
  if (Debug) Util.checkClass(v, TreeVertex, TreeLayout, 'sortTree:v');
  if (v === null) return;
  if (v.alignment !== TreeLayout.AlignmentBusBranching)
    this.sortTreeVertexChildren(v);
  var children = v.children;
  var childrenLength = children.length;
  for (var i = 0; i < childrenLength; i++) {
    var c = children[i];
    this.sortTree(c);
  }
};

/**
* @ignore
* Sort the {@link TreeVertex#children} of a node.
* The default behavior depends on the value of {@link TreeVertex#sorting}.
* <p/>
* This method should not walk the tree, since it is called for each
* {@link TreeVertex} in a depth-first manner starting at a root.
* Normally this is called after all of the vertexes have had their values
* set by {@link #assignTreeVertexValues}.
* <p/>
* However, if {@link TreeVertex#alignment} is {@link TreeLayout#AlignmentBusBranching},
* this will be called before {@link #assignTreeVertexValues}.
* The "BusBranching" alignment depends on inheriting the {@link TreeVertex#angle},
* which in turn depends on the sort order, hence sorting must be performed first.
* The difference is that when "BusBranching" the initialization pass has not yet finished,
* so informational properties have not yet been computed when this method is called.
* @expose
* @this {TreeLayout}
* @param {LayoutVertex} v
*/
TreeLayout.prototype.sortTreeVertexChildren = function(v) {
  if (Debug) Util.checkClass(v, TreeVertex, TreeLayout, 'sortTreeVertexChildren:v');
  switch (v.sorting) {
    case TreeLayout.SortingForwards:  // nothing needed
      break;
    case TreeLayout.SortingReverse:  // just reverse the array
      v.children.reverse();
      break;
    case TreeLayout.SortingAscending:  // sort using comparer
      v.children.sort(v.comparer);
      break;
    case TreeLayout.SortingDescending:  // sort, then reverse
      v.children.sort(v.comparer);
      v.children.reverse();
      break;
    default:
      Util.throwError('Unhandled sorting value ' + v.sorting.toString());
  }
};

/**
* @ignore
* @this {TreeLayout}
*/
TreeLayout.prototype.annotateAll = function() {
  var vit = this.network.vertexes.iterator;
  while (vit.next()) {
    var v = vit.value;
    this.addComments(v);
  }
};

/**
* Find associated objects to be positioned along with the {@link TreeVertex}.
* <p/>
* This looks for visible {@link Node}'s whose category is "Comment" and
* that refer to the tree vertex's {@link Node}.
* You may want to override this method in order to customize how
* any associated objects are found and how the node's {@link LayoutVertex#bounds}
* are set to reserve space for those associated objects.
* This method should not walk the tree, since it is called for each
* {@link TreeVertex} in an indeterminate order.
* @expose
* @this {TreeLayout}
* @param {LayoutVertex} v
* @since 1.2
*/
TreeLayout.prototype.addComments = function(v) {
  if (Debug) Util.checkClass(v, TreeVertex, TreeLayout, 'addComments:v');
  var a = v.angle;
  var parent = v.parent;
  var pa = 0;
  var align = v.alignment;
  var palign = TreeLayout.AlignmentCenterChildren;
  var inbus = false;
  if (parent !== null) {
    pa = parent.angle;
    palign = parent.alignment;
    inbus = this.isBusAlignment(palign);
  }
  var vertical = (a === 90 || a === 270);
  var pvertical = (pa === 90 || pa === 270);
  var leaf = (v.childrenCount === 0);
  var extraWidth = 0;
  var extraHeight = 0;
  var spacing = 0;
  var commentSpacing = v.commentSpacing;
  if (v.node !== null) {
    var nit = v.node.findNodesConnected();
    while (nit.next()) {
      var comment = nit.value;
      if (comment.category !== 'Comment') continue;
      if (!comment.isVisible()) continue;
      if (v.comments === null) v.comments = [];
      v.comments.push(comment);
      comment.ensureBounds();
      var cb = comment.measuredBounds;
      if ((vertical && !leaf) || (!inbus && !pvertical && leaf) || (inbus && pvertical && leaf)) {
        // if vertical tree, leave room for comments on the side, unless it's a leaf
        extraWidth = Math.max(extraWidth, cb.width);
        extraHeight += cb.height + Math.abs(spacing);
      } else {
        extraWidth += cb.width + Math.abs(spacing);
        extraHeight = Math.max(extraHeight, cb.height);
      }
      spacing = commentSpacing;
    }
  }
  if (v.comments !== null) {
    if ((vertical && !leaf) || (!inbus && !pvertical && leaf) || (inbus && pvertical && leaf)) {
      extraWidth += Math.abs(v.commentMargin);
      extraHeight = Math.max(0, extraHeight - v.height);
    } else {
      extraHeight += Math.abs(v.commentMargin);
      extraWidth = Math.max(0, extraWidth - v.width);
    }
    var crect = Util.tempRectAt(0, 0, v._bounds.width + extraWidth, v._bounds.height + extraHeight);
    v.bounds = crect;
    Util.freeRect(crect);
  }
};

/**
* @ignore
* @this {TreeLayout}
* @param {EnumValue} a
* @return {boolean}
*/
TreeLayout.prototype.isBusAlignment = function(a) {
  return a === TreeLayout.AlignmentBus || a === TreeLayout.AlignmentBusBranching ||
         a === TreeLayout.AlignmentTopLeftBus || a === TreeLayout.AlignmentBottomRightBus;
};

/**
* @ignore
* @this {TreeLayout}
* @param {EnumValue} a
* @return {boolean}
*/
TreeLayout.prototype.isBusTwoSided = function(a) {
  return a === TreeLayout.AlignmentBus || a === TreeLayout.AlignmentBusBranching;
};

/**
* @ignore
* @this {TreeLayout}
* @param {LayoutVertex} v
* @return {boolean}
*/
TreeLayout.prototype.isLeftSideBus = function(v) {
  if (Debug) Util.checkClass(v, TreeVertex, TreeLayout, 'isLeftSideBus:v');
  var parent = v.parent;
  if (parent !== null) {
    var palign = parent.alignment;
    if (this.isBusAlignment(palign)) {
      if (this.isBusTwoSided(palign)) {
        var children = parent.children;
        var i = 0;
        while (i < children.length) {
          if (v === children[i]) break;
          i++;
        }
        return (i % 2 === 0);
      } else if (palign === TreeLayout.AlignmentTopLeftBus) {
        return true;
      } else {
        return false;
      }
    }
  }
  return false;
};

/**
* Position and {@link TreeVertex#comments} around the vertex.
* <p/>
* This method should not walk the tree, since it is called for each
* {@link TreeVertex} in an indeterminate order.
* @expose
* @this {TreeLayout}
* @param {LayoutVertex} v
* @since 1.2
*/
TreeLayout.prototype.layoutComments = function(v) {
  if (Debug) Util.checkClass(v, TreeVertex, TreeLayout, 'layoutComments:v');
  if (v.comments !== null) {
    var node = v.node;
    var nodebounds = node.measuredBounds;
    var parent = v.parent;
    var a = v.angle;
    var pa = 0;
    var align = v.alignment;
    var palign = TreeLayout.AlignmentCenterChildren;
    var inbus = false;
    if (parent !== null) {
      pa = parent.angle;
      palign = parent.alignment;
      inbus = this.isBusAlignment(palign);
    }
    var vertical = (a === 90 || a === 270);
    var pvertical = (pa === 90 || pa === 270);
    var leaf = (v.childrenCount === 0);
    var left = this.isLeftSideBus(v);
    var f = 0;
    var comments = v.comments;
    var commentsLength = comments.length;
    var cloc = Util.tempPoint();
    for (var i = 0; i < commentsLength; i++) {
      var c = comments[i];
      var cbounds = c.measuredBounds;
      if ((vertical && !leaf) || (!inbus && !pvertical && leaf) || (inbus && pvertical && leaf)) {
        if ((pa > 135 && !inbus) || (pvertical && left)) {
          if (v.commentMargin >= 0) {
            cloc._set(v._bounds.x - v.commentMargin - cbounds.width, v._bounds.y + f); //??? assumes LocationSpot is TopLeft for each comment
            c.location = cloc;
            var lit = c.findLinksInto();
            while (lit.next()) {
              var link = lit.value;
              link.fromSpot = Spot.MiddleLeft;
              link.toSpot = Spot.MiddleRight;
            }
          } else {
            cloc._set(v._bounds.x + v._focus.x * 2 - v.commentMargin, v._bounds.y + f);
            c.location = cloc;
            var lit = c.findLinksInto();
            while (lit.next()) {
              var link = lit.value;
              link.fromSpot = Spot.MiddleRight;
              link.toSpot = Spot.MiddleLeft;
            }
          }
        } else {
          if (v.commentMargin >= 0) {
            cloc._set(v._bounds.x + v._focus.x * 2 + v.commentMargin, v._bounds.y + f);
            c.location = cloc;
            var lit = c.findLinksInto();
            while (lit.next()) {
              var link = lit.value;
              link.fromSpot = Spot.MiddleRight;
              link.toSpot = Spot.MiddleLeft;
            }
          } else {
            cloc._set(v._bounds.x + v.commentMargin - cbounds.width, v._bounds.y + f);
            c.location = cloc;
            var lit = c.findLinksInto();
            while (lit.next()) {
              var link = lit.value;
              link.fromSpot = Spot.MiddleLeft;
              link.toSpot = Spot.MiddleRight;
            }
          }
        }
        if (v.commentSpacing >= 0)
          f += cbounds.height + v.commentSpacing;
        else
          f += v.commentSpacing - cbounds.height;
      } else {
        if ((pa > 135 && !inbus) || (!pvertical && left)) {
          if (v.commentMargin >= 0) {
            cloc._set(v._bounds.x + f, v._bounds.y - v.commentMargin - cbounds.height);
            c.location = cloc;
            var lit = c.findLinksInto();
            while (lit.next()) {
              var link = lit.value;
              link.fromSpot = Spot.MiddleTop;
              link.toSpot = Spot.MiddleBottom;
            }
          } else {
            cloc._set(v._bounds.x + f, v._bounds.y + v._focus.y * 2 - v.commentMargin);
            c.location = cloc;
            var lit = c.findLinksInto();
            while (lit.next()) {
              var link = lit.value;
              link.fromSpot = Spot.MiddleBottom;
              link.toSpot = Spot.MiddleTop;
            }
          }
        } else {
          if (v.commentMargin >= 0) {
            cloc._set(v._bounds.x + f, v._bounds.y + v._focus.y * 2 + v.commentMargin);
            c.location = cloc;
            var lit = c.findLinksInto();
            while (lit.next()) {
              var link = lit.value;
              link.fromSpot = Spot.MiddleBottom;
              link.toSpot = Spot.MiddleTop;
            }
          } else {
            cloc._set(v._bounds.x + f, v._bounds.y + v.commentMargin - cbounds.height);
            c.location = cloc;
            var lit = c.findLinksInto();
            while (lit.next()) {
              var link = lit.value;
              link.fromSpot = Spot.MiddleTop;
              link.toSpot = Spot.MiddleBottom;
            }
          }
        }
        if (v.commentSpacing >= 0)
          f += cbounds.width + v.commentSpacing;
        else
          f += v.commentSpacing - cbounds.width;
      }
    }
    Util.freePoint(cloc);
    // if the comments stick down beyound the bottom of the node,
    // make sure the child links avoid the comments
    var diff = f - v.commentSpacing - (vertical ? nodebounds.height : nodebounds.width);
    if (this._effectivePath === TreeLayout.PathDestination) {
      var destEdges = v.destinationEdges;
      while (destEdges.next()) {
        var edge = destEdges.value;
        var link = edge.link;
        if (link && link.routing !== Link.AvoidsNodes)
          link.fromEndSegmentLength = (diff > 0 ? diff : NaN);
      }
    } else { // the path is TreeLayout.PathSource
      var sourceEdges = v.sourceEdges;
      while (sourceEdges.next()) {
        var edge = sourceEdges.value;
        var link = edge.link;
        if (link && link.routing !== Link.AvoidsNodes)
          link.toEndSegmentLength = (diff > 0 ? diff : NaN);
      }
    }
  }
};

/**
* @ignore
* @this {TreeLayout}
*/
TreeLayout.prototype.layoutAllTrees = function() {
  var rit = this._roots.iterator;
  while (rit.next()) {
    var v = rit.value;
    this.layoutTree(v);
  }
};

/**
* @ignore
* Recursively lay out a subtree starting with the given parent node.
* <p/>
* This method should walk the tree recursively.
* @this {TreeLayout}
* @param {LayoutVertex} v
*/
TreeLayout.prototype.layoutTree = function(v) {
  if (Debug) Util.checkClass(v, TreeVertex, TreeLayout, 'layoutTree:v');
  if (v === null) return;
  var children = v.children;
  var childrenLength = children.length;
  for (var i = 0; i < childrenLength; i++) {
    var child = children[i];
    this.layoutTree(child);
  }
  switch (v.compaction) {
    case TreeLayout.CompactionNone:
      this.layoutTreeNone(v);
      break;
    case TreeLayout.CompactionBlock:
      if (v.alignment === TreeLayout.AlignmentBusBranching) {
        this.layoutTreeNone(v); // simpler, faster, and less buggy
      } else {
        this.layoutTreeBlock(v);
      }
      break;
    default:
      Util.throwError('Unhandled compaction value ' + v.compaction.toString());
  }
};

/**
* @ignore
* @this {TreeLayout}
* @param {LayoutVertex} v
*/
TreeLayout.prototype.layoutTreeNone = function(v) {
  if (Debug) Util.checkClass(v, TreeVertex, TreeLayout, 'layoutTreeNone:v');
  if (v.childrenCount === 0) {
    var inbus = false;
    var pa = 0;
    var palign = TreeLayout.AlignmentCenterChildren;
    if (v.parent !== null) {
      pa = v.parent.angle;
      palign = v.parent.alignment;
      inbus = this.isBusAlignment(palign);
    }
    var left = this.isLeftSideBus(v);
    v._relativePosition._set(0, 0);
    v._subtreeSize._set(v.width, v.height);
    //if a comment goes in a negative direction, offset the node to account for the extra space needed for the subwidth/subheight
    if (v.parent !== null && v.comments !== null && (((pa === 180 || pa === 270) && !inbus) || left)) {
      if ((pa === 180 && !inbus) || ((pa === 90 || pa === 270) && left))
        v._subtreeOffset._set(v.width - v._focus.x * 2, 0);
      else
        v._subtreeOffset._set(0, v.height - v._focus.y * 2);
    } else {
      v._subtreeOffset._set(0, 0);
    }
    return;
  }
  var angle = this.orthoAngle(v);
  var vertical = (angle === 90 || angle === 270);
  var maxsubbreadth = 0;
  var children = v.children;
  var childrenLength = children.length;
  for (var i = 0; i < childrenLength; i++) {
    var child = children[i];
    maxsubbreadth = Math.max(maxsubbreadth, (vertical ? child._subtreeSize.width : child._subtreeSize.height));
  }
  var align = v.alignment;
  var alignstart = (align === TreeLayout.AlignmentStart);
  var alignend = (align === TreeLayout.AlignmentEnd);
  var alignbus = this.isBusAlignment(align);
  var limit = Math.max(0, v.breadthLimit);
  var layerspacing = this.computeLayerSpacing(v);  // limit layerspacing to be no more negative than the depth of the node
  var nodespacing = v.nodeSpacing;
  var nodeindent = this.computeNodeIndent(v);
  var initialspacing = ((alignstart || alignend) ? 0 : nodeindent / 2);
  var rowspacing = v.rowSpacing;
  var rowindent = 0;
  if (alignstart || alignend || v.routeAroundCentered || (v.routeAroundLastParent && v.maxGenerationCount === 1)) {
    rowindent = Math.max(0, v.rowIndent);
  }
  var vWidth = v.width;
  var vHeight = v.height;
  var subwidth = 0;
  var subheight = 0;
  var olddepth = 0;
  var x = 0;
  var y = 0;
  var row = 0;
  var col = 0;
  var firstidx = 0;
  var maxsubhalf = 0;
  var maxsubhalf2 = 0;
  if (alignbus && !this.isBusTwoSided(align))
    if (angle > 135) children.reverse();
  if (this.isBusTwoSided(align)) {
    if (childrenLength > 1) {
      for (var i = 0; i < childrenLength; i++) {
        var child = children[i];
        var childSubSize = child._subtreeSize;
        if (i % 2 === 0 && i !== childrenLength - 1)
        // for a bus, remember the subwidth of one half so we know where to offset the parent
        // we don't include the last odd child because it will be in the middle
          maxsubhalf = Math.max(maxsubhalf,
                                (vertical ? childSubSize.width : childSubSize.height)
                                + this.computeBusNodeSpacing(child) - nodespacing);
        else if (i % 2 !== 0)
          maxsubhalf2 = Math.max(maxsubhalf2,
                                 (vertical ? childSubSize.width : childSubSize.height)
                                 + this.computeBusNodeSpacing(child) - nodespacing);
      }
    } else if (childrenLength === 1) {
      maxsubhalf = (vertical ? children[0]._subtreeSize.width : children[0]._subtreeSize.height);
    }
  }
  // lay out nodes in a bus
  if (alignbus) {
    switch (align) {
      case TreeLayout.AlignmentBus:
      case TreeLayout.AlignmentBusBranching:
        var rvalues;  // fake passing by reference by returning an array
        if (angle < 135) rvalues = this.layoutBusChildrenPosDir(v, children, maxsubhalf, maxsubhalf2, subwidth, subheight);
        else rvalues = this.layoutBusChildrenNegDir(v, children, maxsubhalf, maxsubhalf2, subwidth, subheight);
        maxsubhalf = rvalues[0];
        subwidth = rvalues[1];
        subheight = rvalues[2];
        //Util.freeArray(rvalues);
        break;
      case TreeLayout.AlignmentTopLeftBus:
        for (var i = 0; i < childrenLength; i++) {
          var child = children[i];
          var childSubSize = child._subtreeSize;
          var rspace = (col === 0 ? 0 : rowspacing);
          if (vertical) {
            // align the right edges of the vertexes so the distance to the parent's center is constant
            child._relativePosition._set(maxsubbreadth - childSubSize.width, y + rspace);
            subwidth = Math.max(subwidth, childSubSize.width);
            subheight = Math.max(subheight, y + rspace + childSubSize.height);
            y += rspace + childSubSize.height;
          } else {
            // align the bottom edges of the vertexes so the distance to the parent's center is constant
            child._relativePosition._set(x + rspace, maxsubbreadth - childSubSize.height);
            subwidth = Math.max(subwidth, x + rspace + childSubSize.width);
            subheight = Math.max(subheight, childSubSize.height);
            x += rspace + childSubSize.width;
          }
          col++;
        }
        break;
      case TreeLayout.AlignmentBottomRightBus:
        for (var l = 0; l < childrenLength; l++) {
          var child = children[l];
          var childSubSize = child._subtreeSize;
          var rspace = (col === 0 ? 0 : rowspacing);
          if (vertical) {
            // set the child's RelativePosition offset from the parent, because we don't want a negative offset later
            child._relativePosition._set(nodespacing / 2 + v._focus.x, y + rspace);
            subwidth = Math.max(subwidth, childSubSize.width);
            subheight = Math.max(subheight, y + rspace + childSubSize.height);
            y += rspace + childSubSize.height;
          } else {
            child._relativePosition._set(x + rspace, nodespacing / 2 + v._focus.y);
            subwidth = Math.max(subwidth, x + rspace + childSubSize.width);
            subheight = Math.max(subheight, childSubSize.height);
            x += rspace + childSubSize.width;
          }
          col++;
        }
        break;
    }
  } else {  //children not in a bus
    for (var idx = 0; idx < childrenLength; idx++) {
      var child = children[idx];
      var childSubSize = child._subtreeSize;
      if (vertical) {
        if (limit > 0 && col > 0 && x + nodespacing + childSubSize.width > limit) {  // need new row
          if (x < maxsubbreadth) {  // align the previous row
            this.shiftRelPosAlign(v, align, maxsubbreadth - x, 0, firstidx, idx - 1);
          }
          row++;
          col = 0;  // start new row
          firstidx = idx;  // remember index of first child in this row
          olddepth = subheight;  // remember current depth for this row
          x = 0;
          y = (angle > 135 ? -subheight - rowspacing : subheight + rowspacing);
        }
        var nspace = (col === 0 ? initialspacing : nodespacing);
        this.recordMidPoints(child, 0, y);  // for links being routed around rows
        child._relativePosition._set(x + nspace, y);
        subwidth = Math.max(subwidth, x + nspace + childSubSize.width);
        subheight = Math.max(subheight, olddepth + (row === 0 ? 0 : rowspacing) + childSubSize.height);
        x += nspace + childSubSize.width;
      } else {  // horizontal growth direction
        if (limit > 0 && col > 0 && y + nodespacing + childSubSize.height > limit) {  // need new row
          if (y < maxsubbreadth) {  // align the previous row
            this.shiftRelPosAlign(v, align, 0, maxsubbreadth - y, firstidx, idx - 1);
          }
          row++;
          col = 0;  // start new row
          firstidx = idx;
          olddepth = subwidth;  // remember current depth for this row
          y = 0;
          x = (angle > 135 ? -subwidth - rowspacing : subwidth + rowspacing);
        }
        var nspace = (col === 0 ? initialspacing : nodespacing);
        this.recordMidPoints(child, x, 0);
        child._relativePosition._set(x, y + nspace);
        subheight = Math.max(subheight, y + nspace + childSubSize.height);
        subwidth = Math.max(subwidth, olddepth + (row === 0 ? 0 : rowspacing) + childSubSize.width);
        y += nspace + childSubSize.height;
      }
      col++;
    }
  }
  if (row > 0) { // if there were multiple rows
    if (vertical) {
      subheight += Math.max(0, layerspacing);  // leave extra room past last row
      if (x < subwidth) {  // align the last row
        this.shiftRelPosAlign(v, align, subwidth - x, 0, firstidx, childrenLength - 1);
      }
      if (rowindent > 0) {
        if (!alignend) this.shiftRelPos(v, rowindent, 0, 0, childrenLength - 1);
        subwidth += rowindent;
      }
    } else {
      subwidth += Math.max(0, layerspacing);  // leave extra room past last row
      if (y < subheight) {  // align the last row
        this.shiftRelPosAlign(v, align, 0, subheight - y, firstidx, childrenLength - 1);
      }
      if (rowindent > 0) {
        if (!alignend) this.shiftRelPos(v, 0, rowindent, 0, childrenLength - 1);
        subheight += rowindent;
      }
    }
  }
  // align this parent node relative to all of its children/descendents
  var offsetx = 0;
  var offsety = 0;
  switch (align) {
    case TreeLayout.AlignmentCenterSubtrees:
      if (vertical) {
        offsetx += subwidth / 2 - v._focus.x - nodeindent / 2;
      } else {
        offsety += subheight / 2 - v._focus.y - nodeindent / 2;
      }
      break;
    case TreeLayout.AlignmentCenterChildren:
      if (row > 0) {  // same as CenterSubtrees when there's multiple rows
        if (vertical) {
          offsetx += subwidth / 2 - v._focus.x - nodeindent / 2;
        } else {
          offsety += subheight / 2 - v._focus.y - nodeindent / 2;
        }
      } else {
        var num = childrenLength;
        if (vertical) {
          var first = children[0]._relativePosition.x + children[0]._subtreeOffset.x;
          var last = children[num - 1]._relativePosition.x + children[num - 1]._subtreeOffset.x + children[num - 1]._focus.x * 2;
          offsetx += first + (last - first) / 2 - v._focus.x - nodeindent / 2;
        } else {
          var first = children[0]._relativePosition.y + children[0]._subtreeOffset.y;
          var last = children[num - 1]._relativePosition.y + children[num - 1]._subtreeOffset.y + children[num - 1]._focus.y * 2;
          offsety += first + (last - first) / 2 - v._focus.y - nodeindent / 2;
        }
      }
      break;
    case TreeLayout.AlignmentStart:
      if (vertical) {
        offsetx -= nodeindent;
        subwidth += nodeindent;
      } else {
        offsety -= nodeindent;
        subheight += nodeindent;
      }
      break;
    case TreeLayout.AlignmentEnd:
      if (vertical) {
        offsetx += (subwidth - v.width) + nodeindent;
        subwidth += nodeindent;
      } else {
        offsety += (subheight - v.height) + nodeindent;
        subheight += nodeindent;
      }
      break;
    case TreeLayout.AlignmentBus:
    case TreeLayout.AlignmentBusBranching:
      if (vertical) {
        if (childrenLength > 1) {
          offsetx += maxsubhalf + nodespacing / 2 - v._focus.x;
        } else { // with only one child, offset just like CenterChildren
          offsetx += children[0]._focus.x - v._focus.x + children[0]._subtreeOffset.x;
        }
      } else {
        if (childrenLength > 1) {
          offsety += maxsubhalf + nodespacing / 2 - v._focus.y;
        } else {
          offsety += children[0]._focus.y - v._focus.y + children[0]._subtreeOffset.y;
        }
      }
      break;
    case TreeLayout.AlignmentTopLeftBus:
      if (vertical) {
        offsetx += subwidth + nodespacing / 2 - v._focus.x;
      } else {
        offsety += subheight + nodespacing / 2 - v._focus.y;
      }
      break;
    case TreeLayout.AlignmentBottomRightBus:
      break;
    default:
      Util.throwError('Unhandled alignment value ' + align.toString());
  }
  // fix up all children's RelativePositions relative to the desired position of this parent node
  for (var i = 0; i < childrenLength; i++) {
    var child = children[i];
    if (vertical) {
      child._relativePosition._set(
        child._relativePosition.x + child._subtreeOffset.x - offsetx,
        child._relativePosition.y + ((angle > 135) ?
          ((alignbus ? -subheight : -child._subtreeSize.height) + child._subtreeOffset.y - layerspacing) :
          (vHeight + layerspacing + child._subtreeOffset.y)));
    } else {
      child._relativePosition._set(
        child._relativePosition.x + ((angle > 135) ?
          ((alignbus ? -subwidth : -child._subtreeSize.width) + child._subtreeOffset.x - layerspacing) :
          (vWidth + layerspacing + child._subtreeOffset.x)),
        child._relativePosition.y + child._subtreeOffset.y - offsety);
    }
  }
  // include the NODE itself in the subtree size, and adjust the offset if it is negative
  if (vertical) {
    subwidth = this.calculateSubwidth(v, subwidth, offsetx);
    // maybe the alignment caused the parent node to stick out
    if (offsetx < 0) offsetx = 0; // subwidth has already been compensated
    if (angle > 135) offsety += subheight + layerspacing;
    subheight += vHeight + layerspacing;
  } else {
    if (angle > 135) offsetx += subwidth + layerspacing;
    subwidth += vWidth + layerspacing;
    subheight = this.calculateSubheight(v, subheight, offsety);
    // maybe the alignment caused the parent node to stick out
    if (offsety < 0) offsety = 0; // subheight has already been compensated
  }
  // save results
  v._subtreeOffset._set(offsetx, offsety);
  v._subtreeSize._set(subwidth, subheight);
};

/**
* @ignore
* For a positive direction, we will set up the first half of the children,
* then the second half, and finally the last odd child, if there is one.
* @this {TreeLayout}
* @param {LayoutVertex} v
* @param {Array.<LayoutVertex>} children
* @param {number} maxsubhalf
* @param {number} maxsubhalf2
* @param {number} subwidth
* @param {number} subheight
* @return {Array.<number>}
*/
TreeLayout.prototype.layoutBusChildrenPosDir = function(v, children, maxsubhalf, maxsubhalf2, subwidth, subheight) {
  if (Debug) Util.checkClass(v, TreeVertex, TreeLayout, 'layoutBusChildrenPosDir:v');
  var childrenLength = children.length;
  if (childrenLength === 0) {
    var result = [];  //Util.tempArray(3);
    result[0] = maxsubhalf;
    result[1] = subwidth;
    result[2] = subheight;
    return result;
  }
  if (childrenLength === 1) {
    var child = children[0];
    subwidth = child._subtreeSize.width;
    subheight = child._subtreeSize.height;
    var result = [];  //Util.tempArray(3);
    result[0] = maxsubhalf;
    result[1] = subwidth;
    result[2] = subheight;
    return result;
  }
  var nodespacing = v.nodeSpacing;
  var rowspacing = v.rowSpacing;
  var angle = this.orthoAngle(v);
  var vertical = (angle === 90);
  var col = 0;
  var x = 0;
  var y = 0;
  // keep track of the area taken by the first half of the children so we know where
  // to place the last odd child later
  // o-|-o
  // | |-o
  // o |
  // o-|
  // for instance, above, ysave would be a number greater than y after setting up the
  // second half of the children, so we will use it when positioning the last odd child
  // set RelativePositions for the first half of the children
  for (var i = 0; i < childrenLength; i++) {
    // if odd number of children, set up the last one later
    if (i % 2 !== 0 || (childrenLength > 1 && i === childrenLength - 1)) continue;
    var child = children[i];
    var childSubSize = child._subtreeSize;
    var rspace = (col === 0 ? 0 : rowspacing);
    if (vertical) {
      // align the right edges of the vertexes so the distances between the two sides of the bus are constant
      var dx = this.computeBusNodeSpacing(child) - nodespacing;
      child._relativePosition._set(maxsubhalf - (childSubSize.width + dx), y + rspace);
      subwidth = Math.max(subwidth, childSubSize.width + dx);
      subheight = Math.max(subheight, y + rspace + childSubSize.height);
      y += rspace + childSubSize.height;
    } else {
      // align the bottom edges of the vertexes so the distances between the two sides of the bus are constant
      var dy = this.computeBusNodeSpacing(child) - nodespacing;
      child._relativePosition._set(x + rspace, maxsubhalf - (childSubSize.height + dy));
      subheight = Math.max(subheight, childSubSize.height + dy);
      subwidth = Math.max(subwidth, x + rspace + childSubSize.width);
      x += rspace + childSubSize.width;
    }
    col++;
  }
  // now adjust x and y for the second half of the children
  col = 0;
  var xsave = x;  // save x and y for placing the last odd child
  var ysave = y;
  if (vertical) {
    x = maxsubhalf + nodespacing;
    y = 0;
  } else {
    x = 0;
    y = maxsubhalf + nodespacing;
  }
  for (var i = 0; i < childrenLength; i++) {
    if (i % 2 === 0) continue;
    var child = children[i];
    var childSubSize = child._subtreeSize;
    var rspace = (col === 0 ? 0 : rowspacing);
    if (vertical) {
      var dx = this.computeBusNodeSpacing(child) - nodespacing;
      child._relativePosition._set(x + dx, y + rspace);
      subwidth = Math.max(subwidth, x + childSubSize.width + dx);
      subheight = Math.max(subheight, y + rspace + childSubSize.height);
      y += rspace + childSubSize.height;
    } else {
      var dy = this.computeBusNodeSpacing(child) - nodespacing;
      child._relativePosition._set(x + rspace, y + dy);
      subwidth = Math.max(subwidth, x + rspace + childSubSize.width);
      subheight = Math.max(subheight, y + childSubSize.height + dy);
      x += rspace + childSubSize.width;
    }
    col++;
  }
  // set up the last odd child
  if (childrenLength > 1 && childrenLength % 2 === 1) {
    var child = children[childrenLength - 1];
    var childSubSize = child._subtreeSize;
    var rowsp = this.computeBusLastRowSpacing(child, vertical ? Math.max(Math.abs(ysave), Math.abs(y)) : Math.max(Math.abs(xsave), Math.abs(x)));
    // newmsh is used when we have a last odd child that extends beyond maxsubhalf
    //  o-|-o
    // o--o
    // in this case, maxsubhalf is not correct because it only takes into account the first half of the children
    // and doesn't include the last odd child
    if (vertical) {
      child._relativePosition._set(maxsubhalf + nodespacing / 2 - child._focus.x - child._subtreeOffset.x, subheight + rowsp);
      var min = maxsubhalf + nodespacing / 2 - child._focus.x - child._subtreeOffset.x;
      subwidth = Math.max(subwidth, min + childSubSize.width);
      if (min < 0) subwidth -= min;
      subheight = Math.max(subheight, Math.max(ysave, y) + rowsp + childSubSize.height);
      // if the child wants a negative RelativePosition, move all children and make it 0
      if (child._relativePosition.x < 0) maxsubhalf = this.fixRelativePositions(v, child._relativePosition.x, false, maxsubhalf, nodespacing);
    } else {
      child._relativePosition._set(subwidth + rowsp, maxsubhalf + nodespacing / 2 - child._focus.y - child._subtreeOffset.y);
      subwidth = Math.max(subwidth, Math.max(xsave, x) + rowsp + childSubSize.width);
      var min = maxsubhalf + nodespacing / 2 - child._focus.y - child._subtreeOffset.y;
      subheight = Math.max(subheight, min + childSubSize.height);
      if (min < 0) subheight -= min;
      // if the child wants a negative RelativePosition, move all the children and make it 0
      if (child._relativePosition.y < 0) maxsubhalf = this.fixRelativePositions(v, child._relativePosition.y, true, maxsubhalf, nodespacing);
    }
  }
  var result = [];  //Util.tempArray(3);
  result[0] = maxsubhalf;
  result[1] = subwidth;
  result[2] = subheight;
  return result;
};

/**
* @ignore
* For a negative direction, we will set up the first half of the children,
* then the second half, and finally the last odd child, if there is one.
* @this {TreeLayout}
* @param {LayoutVertex} v
* @param {Array.<LayoutVertex>} children
* @param {number} maxsubhalf
* @param {number} maxsubhalf2
* @param {number} subwidth
* @param {number} subheight
* @return {Array.<number>}
*/
TreeLayout.prototype.layoutBusChildrenNegDir = function(v, children, maxsubhalf, maxsubhalf2, subwidth, subheight) {
  if (Debug) Util.checkClass(v, TreeVertex, TreeLayout, 'layoutBusChildrenNegDir:v');
  var childrenLength = children.length;
  if (childrenLength === 0) {
    var result = [];  //Util.tempArray(3);
    result[0] = maxsubhalf;
    result[1] = subwidth;
    result[2] = subheight;
    return result;
  }
  if (childrenLength === 1) {
    var child = children[0];
    subwidth = child._subtreeSize.width;
    subheight = child._subtreeSize.height;
    var result = [];  //Util.tempArray(3);
    result[0] = maxsubhalf;
    result[1] = subwidth;
    result[2] = subheight;
    return result;
  }
  var nodespacing = v.nodeSpacing;
  var rowspacing = v.rowSpacing;
  var angle = this.orthoAngle(v);
  var vertical = (angle === 270);
  var col = 0;
  var x = 0;
  var y = 0;
  // keep track of the area taken by the first half of the children so we know where
  // to place the last odd child later
  // o-|-o
  // | |-o
  // o |
  // o-|
  // for instance, above, ysave would be a number greater than y after setting up the
  // second half of the children, so we will use it when positioning the last odd child
  // set RelativePositions for the first half of the children
  for (var i = 0; i < childrenLength; i++) {
    // if odd number of children, set up the last one later
    if (i % 2 !== 0 || (childrenLength > 1 && i === childrenLength - 1)) continue;
    var child = children[i];
    var childSubSize = child._subtreeSize;
    var rspace = (col === 0 ? 0 : rowspacing);
    if (vertical) {
      // align the right edges of the vertexes so the distances between two sides of the bus are constant
      var dx = this.computeBusNodeSpacing(child) - nodespacing;
      y -= rspace + childSubSize.height;
      child._relativePosition._set(maxsubhalf - (childSubSize.width + dx), y);
      subwidth = Math.max(subwidth, childSubSize.width + dx);
      subheight = Math.max(subheight, Math.abs(y));
    } else {
      // align the bottom edges of the vertexes so the distance between the two sides of the bus are constant
      var dy = this.computeBusNodeSpacing(child) - nodespacing;
      x -= rspace + childSubSize.width;
      child._relativePosition._set(x, maxsubhalf - (childSubSize.height + dy));
      subheight = Math.max(subheight, childSubSize.height + dy);
      subwidth = Math.max(subwidth, Math.abs(x));
    }
    col++;
  }
  // now adjust x and y for the second half of the children
  col = 0;
  var xsave = x;  // save x and y for placing the last odd childe
  var ysave = y;
  if (vertical) {
    x = maxsubhalf + nodespacing;
    y = 0;
  } else {
    x = 0;
    y = maxsubhalf + nodespacing;
  }
  for (var i = 0; i < childrenLength; i++) {
    if (i % 2 === 0) continue;
    var child = children[i];
    var childSubSize = child._subtreeSize;
    var rspace = (col === 0 ? 0 : rowspacing);
    if (vertical) {
      var dx = this.computeBusNodeSpacing(child) - nodespacing;
      y -= rspace + childSubSize.height;
      child._relativePosition._set(x + dx, y);
      subwidth = Math.max(subwidth, x + childSubSize.width + dx);
      subheight = Math.max(subheight, Math.abs(y));
    } else {
      var dy = this.computeBusNodeSpacing(child) - nodespacing;
      x -= rspace + childSubSize.width;
      child._relativePosition._set(x, y + dy);
      subheight = Math.max(subheight, y + childSubSize.height + dy);
      subwidth = Math.max(subwidth, Math.abs(x));
    }
    col++;
  }
  // set up the last odd child
  if (childrenLength > 1 && childrenLength % 2 === 1) {
    var child = children[childrenLength - 1];
    var childSubSize = child._subtreeSize;
    var rowsp = this.computeBusLastRowSpacing(child, vertical ? Math.max(Math.abs(ysave), Math.abs(y)) : Math.max(Math.abs(xsave), Math.abs(x)));
    // newmsh is used when we have a last odd child that extends beyond maxsubhalf
    //  o-|-o
    // o--o
    // in this case, maxsubhalf is not correct because it only takes into account the first half of the children
    // and doesn't include the last odd child
    if (vertical) {
      child._relativePosition._set(maxsubhalf + nodespacing / 2 - child._focus.x - child._subtreeOffset.x, -subheight - childSubSize.height - rowsp);
      var min = maxsubhalf + nodespacing / 2 - child._focus.x - child._subtreeOffset.x;
      subwidth = Math.max(subwidth, min + childSubSize.width);
      if (min < 0) subwidth -= min;
      subheight = Math.max(subheight, Math.abs(Math.min(ysave, y)) + rowsp + childSubSize.height);
      // if the child wants a negative RelativePosition, move all the children to make it 0
      if (child._relativePosition.x < 0) maxsubhalf = this.fixRelativePositions(v, child._relativePosition.x, false, maxsubhalf, nodespacing);
    } else {
      child._relativePosition._set(-subwidth - childSubSize.width - rowsp, maxsubhalf + nodespacing / 2 - child._focus.y - child._subtreeOffset.y);
      subwidth = Math.max(subwidth, Math.abs(Math.min(xsave, x)) + rowsp + childSubSize.width);
      var min = maxsubhalf + nodespacing / 2 - child._focus.y - child._subtreeOffset.y;
      subheight = Math.max(subheight, min + childSubSize.height);
      if (min < 0) subheight -= min;
      // if the child wants a negative RelativePosition, move all the children to make it 0
      if (child._relativePosition.y < 0) maxsubhalf = this.fixRelativePositions(v, child._relativePosition.y, true, maxsubhalf, nodespacing);
    }
  }
  // now normalize all RelativePositions to be non-negative
  for (var i = 0; i < childrenLength; i++) {
    var child = children[i];
    if (vertical) {
      child._relativePosition._set(child._relativePosition.x, child._relativePosition.y + subheight);
    } else {
      child._relativePosition._set(child._relativePosition.x + subwidth, child._relativePosition.y);
    }
  }
  var result = [];  //Util.tempArray(3);
  result[0] = maxsubhalf;
  result[1] = subwidth;
  result[2] = subheight;
  return result;
};

/**
* @ignore
* Get the amount of space to insert between a child vertex and its parent spine
* when the parent's {@link TreeVertex#alignment} is Bus or BusBranching.
* <p/>
* This function is called on each child vertex to determine the initial distance of a child
* from the spine that connects to its parent vertex.
* This function is not called on the last odd child
* because that vertex is placed at the end of the spine rather than to either side.
* @this {TreeLayout}
* @param {LayoutVertex} child
* @return {number} By default this returns the parent's {@link TreeVertex#nodeSpacing};
* a small value may result in unpleasant routing of links,
* a negative value may cause the node overlaps.
*/
TreeLayout.prototype.computeBusNodeSpacing = function(child) {
  if (Debug) Util.checkClass(child, TreeVertex, TreeLayout, 'fixRelativePostions:child');
  if (child.parent === null) return 0;
  return child.parent.nodeSpacing;
};

/**
* @ignore
* Get the amound of space to leave between the sibling child vertexes and this last odd vertex
* when the parent's {@link TreeVertex#alignment} is Bus or BusBranching.
* <p/>
* This function is called only when there is an odd number of child vertexes.
* This function is not called when the parent vertex only has one child.
* In that case there is no spine separating the two columns of child vertexes.
* @this {TreeLayout}
* @param {LayoutVertex} lastchild
* @param {number} dist the length of the central line (spine) separating the two sides,
* so far excluding the initial {@link TreeVertex#nodeSpacing}
* that extends form the parent's spine.
* @return {number} By default this returns the parent's {@link TreeVertex#rowSpacing};
* a negative value may cause node overlaps.
*/
TreeLayout.prototype.computeBusLastRowSpacing = function(lastchild, dist) {
  if (Debug) Util.checkClass(lastchild, TreeVertex, TreeLayout, 'fixRelativePostions:lastchild');
  if (lastchild.parent === null) return 0;
  return lastchild.parent.rowSpacing;
};

/**
* @ignore
* @this {TreeLayout}
* @param {LayoutVertex} v
* @param {number} offset
* @param {boolean} vertical
* @param {number} maxsubhalf
* @param {number} nodespacing
* @return {number}
*/
TreeLayout.prototype.fixRelativePositions = function(v, offset, vertical, maxsubhalf, nodespacing) {
  if (Debug) Util.checkClass(v, TreeVertex, TreeLayout, 'fixRelativePostions:v');
  var children = v.children;
  var childrenLength = children.length;
  // move all children by the offset so none have negative RelativePosition values
  for (var i = 0; i < childrenLength; i++) {
    if (vertical)
      children[i]._relativePosition._set(children[i]._relativePosition.x, children[i]._relativePosition.y - offset);
    else
      children[i]._relativePosition._set(children[i]._relativePosition.x - offset, children[i]._relativePosition.y);
  }
  var lastchild = children[childrenLength - 1];
  return Math.max(maxsubhalf, (vertical ? lastchild._subtreeOffset.y + lastchild._focus.y - nodespacing / 2 :
                                          lastchild._subtreeOffset.x + lastchild._focus.x - nodespacing / 2));
};

/**
* @ignore
* @this {TreeLayout}
* @param {LayoutVertex} v
* @param {number} subwidth
* @param {number} offset
* @return {number}
*/
TreeLayout.prototype.calculateSubwidth = function(v, subwidth, offset) {
  if (Debug) Util.checkClass(v, TreeVertex, TreeLayout, 'calculateSubwidth:v');
  // when comments are involved, make sure they are accounted for in subwidth if they extend beyond the edges of the subtree
  switch (v.alignment) {
    case TreeLayout.AlignmentCenterChildren:
    case TreeLayout.AlignmentCenterSubtrees:
      var w = subwidth;
      if (offset + v.width > w) w = offset + v.width;
      if (offset < 0) w -= offset; // increases w
      return w;
    case TreeLayout.AlignmentStart:
      if (v.width > subwidth) return v.width;
      return subwidth;
    case TreeLayout.AlignmentEnd:
      if (v._focus.x * 2 > subwidth) return v.width;
      return subwidth + v.width - v._focus.x * 2;
    case TreeLayout.AlignmentBus:
    case TreeLayout.AlignmentBusBranching:
      var min = Math.min(0, offset);
      var max = Math.max(subwidth, offset + v.width);
      return Math.max(v.width, max - min);
    case TreeLayout.AlignmentTopLeftBus:
      return v.width - v._focus.x + v.nodeSpacing / 2 + subwidth;
    case TreeLayout.AlignmentBottomRightBus:
      return Math.max(v.width, v._focus.x + v.nodeSpacing / 2 + subwidth);
    default:
      return subwidth;
  }
};

/**
* @ignore
* @this {TreeLayout}
* @param {LayoutVertex} v
* @param {number} subheight
* @param {number} offset
* @return {number}
*/
TreeLayout.prototype.calculateSubheight = function(v, subheight, offset) {
  if (Debug) Util.checkClass(v, TreeVertex, TreeLayout, 'calculateSubheight:v');
  // when comments are involved, make sure they are accounted for in subheight if they extend beyond the edges of the subtree
  switch (v.alignment) {
    case TreeLayout.AlignmentCenterChildren:
    case TreeLayout.AlignmentCenterSubtrees:
      var h = subheight;
      if (offset + v.height > h) h = offset + v.height;
      if (offset < 0) h -= offset; // increases h
      return h;
    case TreeLayout.AlignmentStart:
      if (v.height > subheight) return v.height;
      return subheight;
    case TreeLayout.AlignmentEnd:
      if (v._focus.y * 2 > subheight) return v.height;
      return subheight + v.height - v._focus.y * 2;
    case TreeLayout.AlignmentBus:
    case TreeLayout.AlignmentBusBranching:
      var min = Math.min(0, offset);
      var max = Math.max(subheight, offset + v.height);
      return Math.max(v.height, max - min);
    case TreeLayout.AlignmentTopLeftBus:
      return v.height - v._focus.y + v.nodeSpacing / 2 + subheight;
    case TreeLayout.AlignmentBottomRightBus:
      return Math.max(v.height, v._focus.y + v.nodeSpacing / 2 + subheight);
    default:
      return subheight;
  }
};

/**
* @ignore
* @this {TreeLayout}
* @param {EnumValue} align
* @param {number} offwidth
* @param {number} offheight
* @return {Array.<number>}
*/
TreeLayout.prototype.alignOffset = function(align, offwidth, offheight) {
  if (Debug) Util.checkClass(align, EnumValue, TreeLayout, 'alignOffset:align');
  switch (align) {
    case TreeLayout.AlignmentCenterSubtrees: offwidth /= 2; offheight /= 2; break;
    case TreeLayout.AlignmentCenterChildren: offwidth /= 2; offheight /= 2; break;
    case TreeLayout.AlignmentStart: offwidth = 0; offheight = 0; break;
    case TreeLayout.AlignmentEnd: break;
    default: Util.throwError('Unhandled alignment value ' + align.toString());
  }
  var result = [];  //Util.tempArray(2);
  result[0] = offwidth;
  result[1] = offheight;
  return result;
};

/**
* @ignore
* @this {TreeLayout}
* @param {LayoutVertex} v
* @param {EnumValue} align
* @param {number} offwidth
* @param {number} offheight
* @param {number} first
* @param {number} last
*/
TreeLayout.prototype.shiftRelPosAlign = function(v, align, offwidth, offheight, first, last) {
  if (Debug) Util.checkClass(v, TreeVertex, TreeLayout, 'shiftRelPosAlign:v');
  if (Debug) Util.checkClass(align, EnumValue, TreeLayout, 'shiftRelPosAlign:align');
  var shift = this.alignOffset(align, offwidth, offheight); // offwidth stored in shift[0], offheight in shift[1]
  this.shiftRelPos(v, shift[0], shift[1], first, last);
  //Util.freeArray(shift);
};

/**
* @ignore
* @this {TreeLayout}
* @param {LayoutVertex} v
* @param {number} offwidth
* @param {number} offheight
* @param {number} first
* @param {number} last
*/
TreeLayout.prototype.shiftRelPos = function(v, offwidth, offheight, first, last) {
  if (Debug) Util.checkClass(v, TreeVertex, TreeLayout, 'shiftRelPos:v');
  if (offwidth === 0 && offheight === 0) return;
  var children = v.children;
  for (var i = first; i <= last; i++) {
    var c = children[i];
    var p = c._relativePosition;  // OK to clobber Point
    p.x += offwidth;
    p.y += offheight;
  }
};

/**
* @ignore
* Tell TreeEdges their parent node relative coordinates
* @this {TreeLayout}
* @param {LayoutVertex} v
* @param {number} x
* @param {number} y
*/
TreeLayout.prototype.recordMidPoints = function(v, x, y) {
  if (Debug) {
    Util.checkClass(v, TreeVertex, TreeLayout, 'recordMidPoints:v');
    Util.checkPrimitive(x, 'number', TreeLayout, 'recordMidPoints:x');
    Util.checkPrimitive(y, 'number', TreeLayout, 'recordMidPoints:y');
  }
  var parent = v.parent;
  switch (this._effectivePath) {
    case TreeLayout.PathDestination:
      var eit = v.sourceEdges;
      while (eit.next()) {
        var e = eit.value;
        if (e.fromVertex === parent) {
          e._relativePoint._set(x, y);
        }
      }
      break;
    case TreeLayout.PathSource:
      var eit = v.destinationEdges;
      while (eit.next()) {
        var e = eit.value;
        if (e.toVertex === parent) {
          e._relativePoint._set(x, y);
        }
      }
      break;
    default:
      Util.throwError('Unhandled path value ' + this._effectivePath.toString());
  }
};


/**
* @ignore
* @this {TreeLayout}
* @param {LayoutVertex} v
*/
TreeLayout.prototype.layoutTreeBlock = function(v) {
  if (Debug) Util.checkClass(v, TreeVertex, TreeLayout, 'layoutTreeBlock:v');
  if (v.childrenCount === 0) {
    var parent = v.parent;
    var inbus = false;
    var pa = 0;
    var palign = TreeLayout.AlignmentCenterChildren;
    if (parent !== null) {
      pa = parent.angle;
      palign = parent.alignment;
      inbus = this.isBusAlignment(palign);
    }
    var left = this.isLeftSideBus(v);
    v._relativePosition._set(0, 0);
    v._subtreeSize._set(v.width, v.height);
    //if a comment goes in a negative direction, offset the node to account for the extra space needed for the subwidth/subheight
    if (v.parent !== null && v.comments !== null && (((pa === 180 || pa === 270) && !inbus) || left)) {
      if ((pa === 180 && !inbus) || ((pa === 90 || pa === 270) && left))
        v._subtreeOffset._set(v.width - v._focus.x * 2, 0);
      else
        v._subtreeOffset._set(0, v.height - v._focus.y * 2);
    } else {
      v._subtreeOffset._set(0, 0);
    }
    v.leftFringe = null;
    v.rightFringe = null;
    return;
  }
  var angle = this.orthoAngle(v);
  var vertical = (angle === 90 || angle === 270);
  var maxsubbreadth = 0;
  var children = v.children;
  var childrenLength = children.length;
  for (var i = 0; i < childrenLength; i++) {
    var child = children[i];
    maxsubbreadth = Math.max(maxsubbreadth, (vertical ? child._subtreeSize.width : child._subtreeSize.height));
  }
  var align = v.alignment;
  var alignstart = (align === TreeLayout.AlignmentStart);
  var alignend = (align === TreeLayout.AlignmentEnd);
  var alignbus = this.isBusAlignment(align);
  var limit = Math.max(0, v.breadthLimit);
  var layerspacing = this.computeLayerSpacing(v);  // limit layerspacing to be no more negative than the depth of the node
  var nodespacing = v.nodeSpacing;
  var nodeindent = this.computeNodeIndent(v);
  var rowspacing = v.rowSpacing;
  var rowindent = 0;
  if (alignstart || alignend || v.routeAroundCentered || (v.routeAroundLastParent && v.maxGenerationCount === 1)) {
    rowindent = Math.max(0, v.rowIndent);
  }
  var vWidth = v.width;
  var vHeight = v.height;
  var subwidth = 0;
  var subheight = 0;
  var olddepth = 0;
  var lfringe = null;
  var rfringe = null;
  var lsizewidth = 0;
  var lsizeheight = 0;
  var x = 0;
  var y = 0;
  var row = 0;
  var col = 0;
  var firstidx = 0;
  var maxsubhalf = 0;
  var maxsubhalf2 = 0;
  if (alignbus && !this.isBusTwoSided(align))
    if (angle > 135) children.reverse();
  if (this.isBusTwoSided(align)) {
    if (childrenLength > 1) {
      for (var i = 0; i < childrenLength; i++) {
        if (i % 2 === 0 && i !== childrenLength - 1)
        // for a bus, remember the subwidth of one half so we know where to offset the parent
        // we don't include the last odd child because it will be in the middle
          maxsubhalf = Math.max(maxsubhalf, (vertical ? children[i]._subtreeSize.width : children[i]._subtreeSize.height));
        else if (i % 2 !== 0)
          maxsubhalf2 = Math.max(maxsubhalf2, (vertical ? children[i]._subtreeSize.width : children[i]._subtreeSize.height));
      }
    } else if (childrenLength === 1) {
      maxsubhalf = (vertical ? children[0]._subtreeSize.width : children[0]._subtreeSize.height);
    }
  }
  // lay out nodes in a bus
  if (alignbus) {
    switch (align) {
      case TreeLayout.AlignmentBus:
        var rvalues;  // fake passing by reference by returning an array
        if (angle < 135) rvalues = this.layoutBusChildrenPosDir(v, children, maxsubhalf, maxsubhalf2, subwidth, subheight);
        else rvalues = this.layoutBusChildrenNegDir(v, children, maxsubhalf, maxsubhalf2, subwidth, subheight);
        maxsubhalf = rvalues[0];
        subwidth = rvalues[1];
        subheight = rvalues[2];
        //Util.freeArray(rvalues);
        break;
      case TreeLayout.AlignmentTopLeftBus:
        for (var i = 0; i < childrenLength; i++) {
          var child = children[i];
          var childSubSize = child._subtreeSize;
          var rspace = (col === 0 ? 0 : rowspacing);
          if (vertical) {
            // align the right edges of the vertexes so the distance to the parent's center is constant
            child._relativePosition._set(maxsubbreadth - childSubSize.width, y + rspace);
            subwidth = Math.max(subwidth, childSubSize.width);
            subheight = Math.max(subheight, y + rspace + childSubSize.height);
            y += rspace + childSubSize.height;
          } else {
            // align the bottom edges of the vertexes so the distance to the parent's center is constant
            child._relativePosition._set(x + rspace, maxsubbreadth - childSubSize.height);
            subwidth = Math.max(subwidth, x + rspace + childSubSize.width);
            subheight = Math.max(subheight, childSubSize.height);
            x += rspace + childSubSize.width;
          }
          col++;
        }
        break;
      case TreeLayout.AlignmentBottomRightBus:
        for (var i = 0; i < childrenLength; i++) {
          var child = children[i];
          var childSubSize = child._subtreeSize;
          var rspace = (col === 0 ? 0 : rowspacing);
          if (vertical) {
            // set the child's RelativePosition offset from the parent, because we don't want a negative offset later
            child._relativePosition._set(nodespacing / 2 + v._focus.x, y + rspace);
            subwidth = Math.max(subwidth, childSubSize.width);
            subheight = Math.max(subheight, y + rspace + childSubSize.height);
            y += rspace + childSubSize.height;
          } else {
            child._relativePosition._set(x + rspace, nodespacing / 2 + v._focus.y);
            subwidth = Math.max(subwidth, x + rspace + childSubSize.width);
            subheight = Math.max(subheight, childSubSize.height);
            x += rspace + childSubSize.width;
          }
          col++;
        }
        break;
    }
    // set up fringes for the bus
    lfringe = this.allocTempPointArray(2);
    rfringe = this.allocTempPointArray(2);
    if (vertical) {
      lfringe[0]._set(0, 0);
      lfringe[1]._set(0, subheight);
      rfringe[0]._set(subwidth, 0);
      rfringe[1]._set(subwidth, subheight);
    } else {
      lfringe[0]._set(0, 0);
      lfringe[1]._set(subwidth, 0);
      rfringe[0]._set(0, subheight);
      rfringe[1]._set(subwidth, subheight);
    }
  } else {  //children not in a bus
    for (var idx = 0; idx < childrenLength; idx++) {
      var child = children[idx];
      var childSubSize = child._subtreeSize;
      if (vertical) {
        if (limit > 0 && col > 0 && x + nodespacing + childSubSize.width > limit) {  // need new row
          if (x < maxsubbreadth) {  // align the previous row
            this.shiftRelPosAlign(v, align, maxsubbreadth - x, 0, firstidx, idx - 1);
          }
          row++;  // start new row
          col = 0;  // number of nodes in this row
          firstidx = idx;  // remember index of first child in this row
          olddepth = subheight;  // remember current depth for this row
          x = 0;  // total width so far, excluding any indents
          y = (angle > 135 ? -subheight - rowspacing : subheight + rowspacing);
        }
        this.recordMidPoints(child, 0, y);  // for links being routed around rows
        var cpos = 0;
        if (col === 0) {  // get or create first set of fringes for these children
          lfringe = child.leftFringe;
          rfringe = child.rightFringe;
          lsizewidth = childSubSize.width;
          lsizeheight = childSubSize.height;
          // if CHILD doesn't have fringes, or we can't use them, create them
          if (lfringe === null || rfringe === null || angle !== this.orthoAngle(child)) {
            lfringe = this.allocTempPointArray(2);
            rfringe = this.allocTempPointArray(2);
            lfringe[0]._set(0, 0);
            lfringe[1]._set(0, lsizeheight);
            rfringe[0]._set(lsizewidth, 0);
            rfringe[1]._set(lsizewidth, lsizeheight);
          }
        } else {
          var rvalues = this.mergeFringes(v, child, lfringe, rfringe, lsizewidth, lsizeheight);
          cpos = rvalues[0];
          lfringe = rvalues[1];
          rfringe = rvalues[2];
          lsizewidth = rvalues[3];
          lsizeheight = rvalues[4];
          //Util.freeArray(rvalues);
          // if CHILD's subtree after merge extends "left" beyond original fringe,
          // we need to adjust all of the previous children's RelativePositions (starting at FIRSTIDX)
          // and normalize the fringes
          if (x < childSubSize.width && cpos < 0) {
            this.shiftRelPos(v, -cpos, 0, firstidx, idx - 1);
            this.shiftFringe(lfringe, -cpos, 0);
            this.shiftFringe(rfringe, -cpos, 0);
            cpos = 0;
          }
        }
        child._relativePosition._set(cpos, y);
        subwidth = Math.max(subwidth, lsizewidth);
        subheight = Math.max(subheight, olddepth + (row === 0 ? 0 : rowspacing) + childSubSize.height);
        x = lsizewidth;
      } else {  // horizontal growth direction
        if (limit > 0 && col > 0 && y + nodespacing + childSubSize.height > limit) {  // need new row
          if (y < maxsubbreadth) {  // align the previous row
            this.shiftRelPosAlign(v, align, 0, maxsubbreadth - y, firstidx, idx - 1);
          }
          row++;  // start new row
          col = 0;  // number of nodes in this row
          firstidx = idx;  // remember index of first child in this row
          olddepth = subwidth;  // remember current depth for this row
          y = 0;  // total height so far, excluding any indents
          x = (angle > 135 ? -subwidth - rowspacing : subwidth + rowspacing);
        }
        this.recordMidPoints(child, x, 0);  // for links being routed around rows
        var cpos = 0;
        if (col === 0) {  // get or create first set of fringes for these children
          lfringe = child.leftFringe;
          rfringe = child.rightFringe;
          lsizewidth = childSubSize.width;
          lsizeheight = childSubSize.height;
          // if CHILD doesn't have fringes, or we can't use them, create them
          if (lfringe === null || rfringe === null || angle !== this.orthoAngle(child)) {
            lfringe = this.allocTempPointArray(2);
            rfringe = this.allocTempPointArray(2);
            lfringe[0]._set(0, 0);
            lfringe[1]._set(lsizewidth, 0);
            rfringe[0]._set(0, lsizeheight);
            rfringe[1]._set(lsizewidth, lsizeheight);
          }
        } else {
          var rvalues = this.mergeFringes(v, child, lfringe, rfringe, lsizewidth, lsizeheight);
          cpos = rvalues[0];
          lfringe = rvalues[1];
          rfringe = rvalues[2];
          lsizewidth = rvalues[3];
          lsizeheight = rvalues[4];
          //Util.freeArray(rvalues);
          // if CHILD's subtree after merge extends "above" beyond original fringe,
          // we need to adjust all of the previous children's RelativePositions (starting at FIRSTIDX)
          // and normalize the fringes
          if (y < childSubSize.height && cpos < 0) {
            this.shiftRelPos(v, 0, -cpos, firstidx, idx - 1);
            this.shiftFringe(lfringe, 0, -cpos);
            this.shiftFringe(rfringe, 0, -cpos);
            cpos = 0;
          }
        }
        child._relativePosition._set(x, cpos);
        subheight = Math.max(subheight, lsizeheight);
        subwidth = Math.max(subwidth, olddepth + (row === 0 ? 0 : rowspacing) + childSubSize.width);
        y = lsizeheight;
      }
      col++;
    }
  }
  if (row > 0) { // if there were multiple rows...
    if (vertical) {
      subheight += Math.max(0, layerspacing);  // leave extra room past last row
      if (x < subwidth) {  // align the last row
        this.shiftRelPosAlign(v, align, subwidth - x, 0, firstidx, childrenLength - 1);
      }
      if (rowindent > 0) {
        if (!alignend) this.shiftRelPos(v, rowindent, 0, 0, childrenLength - 1);
        subwidth += rowindent;
      }
    } else {
      subwidth += Math.max(0, layerspacing);  // leave extra room past last row
      if (y < subheight) {  // align the last row
        this.shiftRelPosAlign(v, align, 0, subheight - y, firstidx, childrenLength - 1);
      }
      if (rowindent > 0) {
        if (!alignend) this.shiftRelPos(v, 0, rowindent, 0, childrenLength - 1);
        subheight += rowindent;
      }
    }
  }
  // align this parent node relative to all of its children/descendents
  var offsetx = 0;
  var offsety = 0;
  switch (align) {
    case TreeLayout.AlignmentCenterSubtrees:
      if (vertical) {
        offsetx += subwidth / 2 - v._focus.x - nodeindent / 2;
      } else {
        offsety += subheight / 2 - v._focus.y - nodeindent / 2;
      }
      break;
    case TreeLayout.AlignmentCenterChildren:
      if (row > 0) {  // same as CenterSubtrees when there's multiple rows
        if (vertical) {
          offsetx += subwidth / 2 - v._focus.x - nodeindent / 2;
        } else {
          offsety += subheight / 2 - v._focus.y - nodeindent / 2;
        }
      } else {
        var num = childrenLength;
        if (vertical) {
          var first = children[0]._relativePosition.x + children[0]._subtreeOffset.x;
          var last = children[num - 1]._relativePosition.x + children[num - 1]._subtreeOffset.x + children[num - 1]._focus.x * 2;
          offsetx += first + (last - first) / 2 - v._focus.x - nodeindent / 2;
        } else {
          var first = children[0]._relativePosition.y + children[0]._subtreeOffset.y;
          var last = children[num - 1]._relativePosition.y + children[num - 1]._subtreeOffset.y + children[num - 1]._focus.y * 2;
          offsety += first + (last - first) / 2 - v._focus.y - nodeindent / 2;
        }
      }
      break;
    case TreeLayout.AlignmentStart:
      if (vertical) {
        offsetx -= nodeindent;
        subwidth += nodeindent;
      } else {
        offsety -= nodeindent;
        subheight += nodeindent;
      }
      break;
    case TreeLayout.AlignmentEnd:
      if (vertical) {
        offsetx += (subwidth - v.width) + nodeindent;
        subwidth += nodeindent;
      } else {
        offsety += (subheight - v.height) + nodeindent;
        subheight += nodeindent;
      }
      break;
    case TreeLayout.AlignmentBus:
      if (vertical) {
        if (childrenLength > 1) {
          offsetx += maxsubhalf + nodespacing / 2 - v._focus.x;
        } else { // with only one child, offset just like CenterChildren
          offsetx += children[0]._focus.x - v._focus.x + children[0]._subtreeOffset.x;
        }
      } else {
        if (childrenLength > 1) {
          offsety += maxsubhalf + nodespacing / 2 - v._focus.y;
        } else { // with only one child, offset just like CenterChildren
          offsety += children[0]._focus.y - v._focus.y + children[0]._subtreeOffset.y;
        }
      }
      break;
    case TreeLayout.AlignmentTopLeftBus:
      if (vertical) {
        offsetx += subwidth + nodespacing / 2 - v._focus.x;
      } else {
        offsety += subheight + nodespacing / 2 - v._focus.y;
      }
      break;
    case TreeLayout.AlignmentBottomRightBus:
      break;
    default:
      Util.throwError('Unhandled alignment value ' + align.toString());
  }
  // fix up all children's RelativePositions relative to the desired position of this parent node
  for (var i = 0; i < childrenLength; i++) {
    var child = children[i];
    if (vertical) {
      child._relativePosition._set(
        child._relativePosition.x + child._subtreeOffset.x - offsetx,
        child._relativePosition.y + ((angle > 135) ?
          ((alignbus ? -subheight : -child._subtreeSize.height) + child._subtreeOffset.y - layerspacing) :
          (vHeight + layerspacing + child._subtreeOffset.y)));
    } else {
      child._relativePosition._set(
        child._relativePosition.x + ((angle > 135) ?
          ((alignbus ? -subwidth : -child._subtreeSize.width) + child._subtreeOffset.x - layerspacing) :
          (vWidth + layerspacing + child._subtreeOffset.x)),
        child._relativePosition.y + child._subtreeOffset.y - offsety);
    }
  }
  // include the NODE itself in the subtree size, and adjust the offset if the direction is negative
  var fringeoffwidth = 0;
  var fringeoffheight = 0;
  if (alignbus) {
    if (vertical) {
      subwidth = this.calculateSubwidth(v, subwidth, offsetx);
      // maybe the alignment caused the parent node to stick out
      if (offsetx < 0) offsetx = 0;  // subwidth has already been compensated
      if (angle > 135) offsety += subheight + layerspacing;
      subheight += vHeight + layerspacing;
      if (align === TreeLayout.AlignmentBottomRightBus) fringeoffwidth += nodespacing / 2 + v._focus.x;
      fringeoffheight += vHeight + layerspacing;
    } else {
      if (angle > 135) offsetx += subwidth + layerspacing;
      subwidth += vWidth + layerspacing;
      subheight = this.calculateSubheight(v, subheight, offsety);
      // maybe the alignment caused the parent node to stick out
      if (offsety < 0) offsety = 0; // subheight has already been compensated
      if (align === TreeLayout.AlignmentBottomRightBus) fringeoffheight += nodespacing / 2 + v._focus.y;
      fringeoffwidth += vWidth + layerspacing;
    }
  } else {
    if (vertical) {
      if (v.comments === null) {
        if (vWidth > subwidth) {
          var fringeoffarr = this.alignOffset(align, vWidth - subwidth, 0);
          fringeoffwidth = fringeoffarr[0];
          fringeoffheight = fringeoffarr[1];
          //Util.freeArray(fringeoffarr);
          subwidth = vWidth;
          offsetx = 0;
        }
      } else {
        subwidth = this.calculateSubwidth(v, subwidth, offsetx);
      }
      if (offsetx < 0) {
        fringeoffwidth -= offsetx;  // increase fringe offset
        offsetx = 0;
      }
      if (angle > 135) offsety += subheight + layerspacing;
      subheight = Math.max(Math.max(subheight, vHeight), subheight + vHeight + layerspacing);
      fringeoffheight += vHeight + layerspacing;
    } else {
      if (angle > 135) offsetx += subwidth + layerspacing;
      subwidth = Math.max(Math.max(subwidth, vWidth), subwidth + vWidth + layerspacing);
      if (v.comments === null) {
        if (vHeight > subheight) {
          var fringeoffarr = this.alignOffset(align, 0, vHeight - subheight);
          fringeoffwidth = fringeoffarr[0];
          fringeoffheight = fringeoffarr[1];
          //Util.freeArray(fringeoffarr);
          subheight = vHeight;
          offsety = 0;
        }
      } else {
        subheight = this.calculateSubheight(v, subheight, offsety);
      }
      if (offsety < 0) {
        fringeoffheight -= offsety;  // increase fringe offset
        offsety = 0;
      }
      fringeoffwidth += vWidth + layerspacing;
    }
  }
  // create new fringes for the whole subtree
  var newleft;
  var newright;
  if (row > 0) {  // when there are multiple rows, just assume everything's a big block
    newleft = this.allocTempPointArray(4);
    newright = this.allocTempPointArray(4);
    if (vertical) {
      newleft[2]._set(0, vHeight + layerspacing);
      newleft[3]._set(newleft[2].x, subheight);
      newright[2]._set(subwidth, newleft[2].y);
      newright[3]._set(newright[2].x, newleft[3].y);
    } else {
      newleft[2]._set(vWidth + layerspacing, 0);
      newleft[3]._set(subwidth, newleft[2].y);
      newright[2]._set(newleft[2].x, subheight);
      newright[3]._set(newleft[3].x, newright[2].y);
    }
  } else {
    newleft = this.allocTempPointArray(lfringe.length + 2);
    newright = this.allocTempPointArray(rfringe.length + 2);
    var p;
    for (var i = 0; i < lfringe.length; i++) {
      p = lfringe[i];
      newleft[i + 2]._set(p.x + fringeoffwidth, p.y + fringeoffheight);
    }
    for (var i = 0; i < rfringe.length; i++) {
      p = rfringe[i];
      newright[i + 2]._set(p.x + fringeoffwidth, p.y + fringeoffheight);
    }
  }
  // add the parent node to the fringe
  if (vertical) {
    newleft[0]._set(offsetx, 0);
    newleft[1]._set(newleft[0].x, vHeight);
    // handle negative LayerSpacing causing overlap in breadth
    if (newleft[2].y < newleft[1].y) {
      if (newleft[2].x > newleft[0].x)
        newleft[2].assign(newleft[1]);  // inside parent node: use parent corner
      else
        newleft[1].assign(newleft[2]);  // outside parent node: extend exterior
    }
    if (newleft[3].y < newleft[2].y) {
      if (newleft[3].x > newleft[0].x)
        newleft[3].assign(newleft[2]);
      else
        newleft[2].assign(newleft[3]);
    }
    newright[0]._set(offsetx + vWidth, 0);
    newright[1]._set(newright[0].x, vHeight);
    // handle negative LayerSpacing causing overlap in breadth
    if (newright[2].y < newright[1].y) {
      if (newright[2].x < newright[0].x)
        newright[2].assign(newright[1]);  // inside parent node: use parent corner
      else
        newright[1].assign(newright[2]);  // outside parent node: extend exterior
    }
    if (newright[3].y < newright[2].y) {
      if (newright[3].x < newright[0].x)
        newright[3].assign(newright[2]);
      else
        newright[2].assign(newright[3]);
    }
    // extend the fringe vertically so that orthogonal links don't extend outside
    newleft[2].y -= layerspacing / 2;
    newright[2].y -= layerspacing / 2;
  } else {
    newleft[0]._set(0, offsety);
    newleft[1]._set(vWidth, newleft[0].y);
    // handle negative LayerSpacing causing overlap in breadth
    if (newleft[2].x < newleft[1].x) {
      if (newleft[2].y > newleft[0].y)
        newleft[2].assign(newleft[1]);  // inside parent node: use parent corner
      else
        newleft[1].assign(newleft[2]);  // outside parent node: extend exterior
    }
    if (newleft[3].x < newleft[2].x) {
      if (newleft[3].y > newleft[0].y)
        newleft[3].assign(newleft[2]);
      else
        newleft[2].assign(newleft[3]);
    }
    newright[0]._set(0, offsety + vHeight);
    newright[1]._set(vWidth, newright[0].y);
    // handle negative LayerSpacing causing overlap in breadth
    if (newright[2].x < newright[1].x) {
      if (newright[2].y < newright[0].y)
        newright[2].assign(newright[1]);  // inside parent node: use parent corner
      else
        newright[1].assign(newright[2]);  // outside parent node: extend exterior
    }
    if (newright[3].x < newright[2].x) {
      if (newright[3].y < newright[0].y)
        newright[3].assign(newright[2]);
      else
        newright[2].assign(newright[3]);
    }
    // extend the fringe horizontally so that orthogonal links don't extend outside
    newleft[2].x -= layerspacing / 2;
    newright[2].x -= layerspacing / 2;
  }
  this.freeTempPointArray(lfringe);
  this.freeTempPointArray(rfringe);
  // save results
  v.leftFringe = newleft;
  v.rightFringe = newright;
  v._subtreeOffset._set(offsetx, offsety);
  v._subtreeSize._set(subwidth, subheight);
};

/**
* @ignore
* @this {TreeLayout}
* @param {Array.<Point>} fringe
* @param {number} offsetwidth
* @param {number} offsetheight
*/
TreeLayout.prototype.shiftFringe = function(fringe, offsetwidth, offsetheight) {
  for (var i = 0; i < fringe.length; i++) {
    var p = fringe[i];  // OK to clobber?
    p.x += offsetwidth;
    p.y += offsetheight;
  }
};

/**
* @ignore
* @this {TreeLayout}
* @param {LayoutVertex} parent
* @param {LayoutVertex} child
* @param {Array.<Point>} lfringe
* @param {Array.<Point>} rfringe
* @param {number} lsizewidth
* @param {number} lsizeheight
* @return {Array}
*/
TreeLayout.prototype.mergeFringes = function(parent, child, lfringe, rfringe, lsizewidth, lsizeheight) {
  if (Debug) Util.checkClass(parent, TreeVertex, TreeLayout, 'mergeFringes:parent');
  if (Debug) Util.checkClass(child, TreeVertex, TreeLayout, 'mergeFringes:child');
  var angle = this.orthoAngle(parent);
  var vertical = (angle === 90 || angle === 270);
  var nodespacing = parent.nodeSpacing;
  var al = lfringe;
  var ar = rfringe;
  var aszwidth = lsizewidth;
  var aszheight = lsizeheight;
  var bl = child.leftFringe;
  var br = child.rightFringe;
  var bsz = child._subtreeSize;
  var d = (vertical ? Math.max(aszheight, bsz.height) : Math.max(aszwidth, bsz.width));
  if (bl === null || angle !== this.orthoAngle(child)) {
    bl = this.allocTempPointArray(2);
    br = this.allocTempPointArray(2);
    if (vertical) {
      bl[0]._set(0, 0);
      bl[1]._set(0, bsz.height);
      br[0]._set(bsz.width, 0);
      br[1]._set(br[0].x, bl[1].y);
    } else {
      bl[0]._set(0, 0);
      bl[1]._set(bsz.width, 0);
      br[0]._set(0, bsz.height);
      br[1]._set(bl[1].x, br[0].y);
    }
  }
  // handle general case
  if (vertical) {
    var abreadth = aszwidth;
    var m = abreadth - this.fringeDistanceX(ar, bl, abreadth);
    m += nodespacing;
    lfringe = this.fringeUnionLeftX(al, bl, m);
    rfringe = this.fringeUnionRightX(ar, br, m);
    lsizewidth = Math.max(0, m) + bsz.width;
    lsizeheight = d;
    this.freeTempPointArray(al);
    this.freeTempPointArray(bl);
    this.freeTempPointArray(ar);
    this.freeTempPointArray(br);
    var result = [];  //Util.tempArray(5);
    result[0] = m;
    result[1] = lfringe;
    result[2] = rfringe;
    result[3] = lsizewidth;
    result[4] = lsizeheight;
    return result;
  } else {
    var abreadth = aszheight;
    var m = abreadth - this.fringeDistanceY(ar, bl, abreadth);
    m += nodespacing;
    lfringe = this.fringeUnionLeftY(al, bl, m);
    rfringe = this.fringeUnionRightY(ar, br, m);
    lsizewidth = d;
    lsizeheight = Math.max(0, m) + bsz.height;
    this.freeTempPointArray(al);
    this.freeTempPointArray(bl);
    this.freeTempPointArray(ar);
    this.freeTempPointArray(br);
    var result = [];  //Util.tempArray(5);
    result[0] = m;
    result[1] = lfringe;
    result[2] = rfringe;
    result[3] = lsizewidth;
    result[4] = lsizeheight;
    return result;
  }
};

/**
* @ignore
* @this {TreeLayout}
* @param {Array.<Point>} av
* @param {Array.<Point>} bv
* @param {number} offset
* @return {Array.<Point>}
*/
TreeLayout.prototype.fringeUnionLeftY = function(av, bv, offset) {
  if (av === null || av.length < 2 || bv === null || bv.length < 2) return null;  // not enough points!
  var cv = this.allocTempPointArray(av.length + bv.length);
  var i = 0;
  var j = 0;
  var k = 0;
  var c;
  // copy any leading points of BV, shifted by OFFSET
  while (j < bv.length && bv[j].x < av[0].x) {
    c = bv[j++]
    cv[k++]._set(c.x, c.y+offset);
  }
  // copy all of AV
  while (i < av.length) {
    c = av[i++];
    cv[k++]._set(c.x, c.y);
  }
  // skip the part of BV that is covered by AV
  var lastX = av[av.length - 1].x;
  while (j < bv.length && bv[j].x <= lastX) {
    j++;
  }
  // copy the trailing points of BV, shifted by OFFSET
  while (j < bv.length && bv[j].x > lastX) {
    c = bv[j++];
    cv[k++]._set(c.x, c.y+offset);
  }
  // minimize size of result array
  var r = this.allocTempPointArray(k);
  for (i = 0; i < k; i++) r[i].assign(cv[i]);
  this.freeTempPointArray(cv);
  return r;
};

/**
* @ignore
* @this {TreeLayout}
* @param {Array.<Point>} av
* @param {Array.<Point>} bv
* @param {number} offset
* @return {Array.<Point>}
*/
TreeLayout.prototype.fringeUnionLeftX = function(av, bv, offset) {
  if (av === null || av.length < 2 || bv === null || bv.length < 2) return null;  // not enough points!
  var cv = this.allocTempPointArray(av.length + bv.length);
  var i = 0;
  var j = 0;
  var k = 0;
  var c;
  // copy any leading points of BV, shifted by OFFSET
  while (j < bv.length && bv[j].y < av[0].y) {
    c = bv[j++];
    cv[k++]._set(c.x+offset, c.y);
  }
  // copy all of AV
  while (i < av.length) {
    c = av[i++];
    cv[k++]._set(c.x, c.y);
  }
  // skip the part of BV that is covered by AV
  var lastY = av[av.length - 1].y;
  while (j < bv.length && bv[j].y <= lastY) {
    j++;
  }
  // copy the trailing points of BV, shifted by OFFSET
  while (j < bv.length && bv[j].y > lastY) {
    c = bv[j++];
    cv[k++]._set(c.x + offset, c.y);
  }
  // minimize size of result array
  var r = this.allocTempPointArray(k);
  for (i = 0; i < k; i++) r[i].assign(cv[i]);
  this.freeTempPointArray(cv);
  return r;
};

/**
* @ignore
* @this {TreeLayout}
* @param {Array.<Point>} av
* @param {Array.<Point>} bv
* @param {number} offset
* @return {Array.<Point>}
*/
TreeLayout.prototype.fringeUnionRightY = function(av, bv, offset) {
  if (av === null || av.length < 2 || bv === null || bv.length < 2) return null;  // not enough points!
  var cv = this.allocTempPointArray(av.length + bv.length);
  var i = 0;
  var j = 0;
  var k = 0;
  var c;
  // copy any leading points of AV
  while (i < av.length && av[i].x < bv[0].x) {
    c = av[i++];
    cv[k++]._set(c.x, c.y);
  }
  // copy all of BV, shifted by OFFSET
  while (j < bv.length) {
    c = bv[j++];
    cv[k++]._set(c.x, c.y+offset);
  }
  // skip the part of AV that is covered by BV
  var lastX = bv[bv.length - 1].x;
  while (i < av.length && av[i].x <= lastX) {
    i++;
  }
  // copy the trailing points of AV
  while (i < av.length && av[i].x > lastX) {
    c = av[i++];
    cv[k++]._set(c.x, c.y);
  }
  // minimize size of result array
  var r = this.allocTempPointArray(k);
  for (i = 0; i < k; i++) r[i].assign(cv[i]);
  this.freeTempPointArray(cv);
  return r;
};

/**
* @ignore
* @this {TreeLayout}
* @param {Array.<Point>} av
* @param {Array.<Point>} bv
* @param {number} offset
* @return {Array.<Point>}
*/
TreeLayout.prototype.fringeUnionRightX = function(av, bv, offset) {
  if (av === null || av.length < 2 || bv === null || bv.length < 2) return null;  // not enough points!
  var cv = this.allocTempPointArray(av.length + bv.length);
  var i = 0;
  var j = 0;
  var k = 0;
  var c;
  // copy any leading points of AV
  while (i < av.length && av[i].y < bv[0].y) {
    c = av[i++];
    cv[k++]._set(c.x, c.y);
  }
  // copy all of BV, shifted by OFFSET
  while (j < bv.length) {
    c = bv[j++];
    cv[k++]._set(c.x+offset, c.y);
  }
  // skip the part of AV that is covered by BV
  var lastY = bv[bv.length - 1].y;
  while (i < av.length && av[i].y <= lastY) {
    i++;
  }
  // copy the trailing points of AV
  while (i < av.length && av[i].y > lastY) {
    c = av[i++];
    cv[k++]._set(c.x, c.y);
  }
  // minimize size of result array
  var r = this.allocTempPointArray(k);
  for (i = 0; i < k; i++) r[i].assign(cv[i]);
  this.freeTempPointArray(cv);
  return r;
};

/**
* @ignore
* @this {TreeLayout}
* @param {Array.<Point>} av
* @param {Array.<Point>} bv
* @param {number} offset
* @return {number}
*/
TreeLayout.prototype.fringeDistanceY = function(av, bv, offset) {
  var min = 9999999;
  if (av === null || av.length < 2 || bv === null || bv.length < 2) return min;  // not enough points!
  var i = 0;
  var j = 0;
  while (i < av.length && j < bv.length) {
    var ai = av[i];
    var bj = bv[j]; var bjx = bj.x; var bjy = bj.y;
    bjy += offset;
    var an = ai;
    if (i + 1 < av.length) {
      an = av[i + 1];
    }
    var bn = bj; var bnx = bn.x; var bny = bn.y;
    if (j + 1 < bv.length) {
      bn = bv[j + 1]; bnx = bn.x; bny = bn.y;
      bny += offset;
    }
    var diff = min;
    if (ai.x === bjx) {  // same X's, so just compare Y's
      diff = bjy - ai.y;
    } else if (ai.x > bjx && ai.x < bnx) {  // ai is between bj and bn
      diff = (bjy + ((ai.x - bjx) / (bnx - bjx)) * (bny - bjy)) - ai.y;
    } else if (bjx > ai.x && bjx < an.x) {  // bj is between ai and an
      diff = bjy - (ai.y + ((bjx - ai.x) / (an.x - ai.x)) * (an.y - ai.y));
    }
    //    Maybe use the below if copy() is too expensive??
    //    bjy -= offset;
    //    if (j + 1 < bv.length) {
    //      bny -= offset;  // set bnx (or bv[j+1].x) back to its original value for the next pass
    //    }
    if (diff < min) {
      min = diff;
    }
    // pick next point
    if (an.x <= ai.x) {
      i++;
    } else if (bnx <= bjx) {
      j++;
    } else {
      // both indices increment if both next points have the same X
      if (an.x <= bnx) i++;
      if (bnx <= an.x) j++;
    }
  }
  return min;
};

/**
* @ignore
* @this {TreeLayout}
* @param {Array.<Point>} av
* @param {Array.<Point>} bv
* @param {number} offset
* @return {number}
*/
TreeLayout.prototype.fringeDistanceX = function(av, bv, offset) {
  var min = 9999999;
  if (av === null || av.length < 2 || bv === null || bv.length < 2) return min;  // not enough points!
  var i = 0;
  var j = 0;
  while (i < av.length && j < bv.length) {
    var ai = av[i];
    var bj = bv[j]; var bjx = bj.x; var bjy = bj.y;
    bjx += offset;
    var an = ai;
    if (i + 1 < av.length) {
      an = av[i + 1];
    }
    var bn = bj; var bnx = bn.x; var bny = bn.y;
    if (j + 1 < bv.length) {
      bn = bv[j + 1]; bnx = bn.x; bny = bn.y;
      bnx += offset;
    }
    var diff = min;
    if (ai.y === bjy) {  // same Y's, so just compare X's
      diff = bjx - ai.x;
    } else if (ai.y > bjy && ai.y < bny) {  // ai is between bj and bn
      diff = (bjx + ((ai.y - bjy) / (bny - bjy)) * (bnx - bjx)) - ai.x;
    } else if (bjy > ai.y && bjy < an.y) {  // bj is between ai and an
      diff = bjx - (ai.x + ((bjy - ai.y) / (an.y - ai.y)) * (an.x - ai.x));
    }
    //    Maybe use the below if copy() is too expensive??
    //    bjx -= offset;
    //    if (j + 1 < bv.length) {
    //      bnx -= offset;  // set bnx (or bv[j+1].x) back to its original value for the next pass
    //    }
    if (diff < min) {
      min = diff;
    }
    // pick next point
    if (an.y <= ai.y) {
      i++;
    } else if (bny <= bjy) {
      j++;
    } else {
      // both indices increment if both next points have the same Y
      if (an.y <= bny) i++;
      if (bny <= an.y) j++;
    }
  }
  return min;
};

/**
* @ignore
* Arrays of tree fringe points are now pre-allocated with Points, so that they can be re-used too.
* @this {TreeLayout}
* @param {number} len
* @return {Array} of uninitialized Points
*/
TreeLayout.prototype.allocTempPointArray = function(len) {
  // make sure there's a collection of caches of Arrays
  if (!this._tempArrays) this._tempArrays = [];
  // see if there's a cache (actually an Array) of Arrays of the requested length
  var cache = this._tempArrays[len];
  if (cache !== undefined) {
    // see if there's any Array in the cache
    var oldarr = cache.pop();
    if (oldarr !== undefined) return oldarr;
  }
  // allocate a new Array holding that number of Points
  var newarr = [];
  for (var i = 0; i < len; i++) newarr[i] = new Point();
  return newarr;
};

/**
* @ignore
* @this {TreeLayout}
* @param {Array} a
*/
TreeLayout.prototype.freeTempPointArray = function(a) {
  if (!this._tempArrays) return;
  var len = a.length;
  var cache = this._tempArrays[len];
  if (cache === undefined) {
    cache = [];
    this._tempArrays[len] = cache;
  }
  cache.push(a);
};

/**
* Position each separate tree.
* <p/>
* This is called after each tree has been laid out and thus each subtree
* bounds are known.
* The {@link #arrangement} and {@link #arrangementSpacing} and {@link Layout#arrangementOrigin}
* properties affect this method's behavior.
* @expose
* @this {TreeLayout}
* @since 1.2
*/
TreeLayout.prototype.arrangeTrees = function() {
  if (this._arrangement === TreeLayout.ArrangementFixedRoots) {
    var rit = this._roots.iterator;
    while (rit.next()) {
      var root = rit.value;
      var r = root.node;
      if (r === null) continue;
      var pos = r.position;
      var posx = pos.x;
      var posy = pos.y;
      if (!isFinite(posx)) posx = 0;
      if (!isFinite(posy)) posy = 0;
      this.assignAbsolutePositions(root, posx, posy);
    }
  } else {
    var p = this.arrangementOrigin;
    var px = p.x;
    var py = p.y;
    var rit = this._roots.iterator;
    while (rit.next()) {
      var root = rit.value;
      this.assignAbsolutePositions(root, px + root._subtreeOffset.x, py + root._subtreeOffset.y);
      switch (this._arrangement) {
        case TreeLayout.ArrangementVertical:
          py += root._subtreeSize.height + this._arrangementSpacing.height;
          break;
        case TreeLayout.ArrangementHorizontal:
          px += root._subtreeSize.width + this._arrangementSpacing.width;
          break;
        default:
          Util.throwError('Unhandled arrangement value ' + this._arrangement.toString());
      }
    }
  }
};

/**
* @ignore
* @this {TreeLayout}
* @param {LayoutVertex} v
* @param {number} px
* @param {number} py
*/
TreeLayout.prototype.assignAbsolutePositions = function(v, px, py) {
  if (v === null) return;
  if (Debug) Util.checkClass(v, TreeVertex, TreeLayout, 'assignAbsolutePositions:v');
  v.x = px;
  v.y = py;
  var children = v.children;
  var childrenLength = children.length;
  for (var i = 0; i < childrenLength; i++) {
    var c = children[i];
    this.assignAbsolutePositions(c, px + c._relativePosition.x, py + c._relativePosition.y);
  }
};

/**
* Set the fromSpot and toSpot for each Vertex, position each {@link Node} according
* to the Vertex position, and then position the {@link Link}s.
* <p/>
* You should not call this method -- it is a "protected virtual" method.
* @this {TreeLayout}
*/
TreeLayout.prototype.commitLayout = function() {
  this.setPortSpotsAll();
  this.commitNodes();
  if (this.isRouting) this.commitLinks();
};

/**
* Commit the position of all vertex nodes.
* @expose
* @this {TreeLayout}
*/
TreeLayout.prototype.commitNodes = function() {
  var vit = this.network.vertexes.iterator;
  var v;
  while (vit.next()) {
    v = vit.value;
    v.commit();
  }
  vit.reset();
  while (vit.next()) {
    v = vit.value;
    this.layoutComments(v);
  }
};

/**
* Commit the position and routing of all edge links.
* This is called by {@link #commitLayout}.
* This is only called if {@link Layout#isRouting} is true.
* @expose
* @this {TreeLayout}
*/
TreeLayout.prototype.commitLinks = function() {
  var eit = this.network.edges.iterator;
  while (eit.next()) {
    var e = eit.value;
    e.commit();
  }
};

/**
* @ignore
* @this {TreeLayout}
*/
TreeLayout.prototype.setPortSpotsAll = function() {
  var rit = this._roots.iterator;
  while (rit.next()) {
    var v = rit.value;
    this.setPortSpotsTree(v);
  }
};

/**
* @ignore
* @this {TreeLayout}
* @param {LayoutVertex} v
*/
TreeLayout.prototype.setPortSpotsTree = function(v) {
  if (v === null) return;
  if (Debug) Util.checkClass(v, TreeVertex, TreeLayout, 'setPortSpotsTree:v');
  this.setPortSpots(v);
  var children = v.children;
  var childrenLength = children.length;
  for (var i = 0; i < childrenLength; i++) {
    var c = children[i];
    this.setPortSpotsTree(c);
  }
};

/**
* @ignore
* Assign port spots for single-port nodes, if {@link TreeVertex#setsPortSpot} or
* {@link TreeVertex#setsChildPortSpot} is true, according to the value of {@link #portSpot}
* or {@link #childPortSpot}.
* <p/>
* This iterates over all of the {@link TreeEdge}s in the network,
* and assigns their fromSpot and/or toSpot property if the
* {@link TreeVertex#setsPortSpot} and/or {@link TreeVertex#setsChildPortSpot} properties
* are true, and if the port's node only has a single port.
* <p/>
* The spot values are given by {@link #portSpot}
* and {@link #childPortSpot} respectively, unless the value is Spot.Default.
* In the latter case the actual spot is determined by the {@link TreeVertex#angle}
* of the parent node (the fromVertex).
* For example, when the angle is zero, the tree grows deeper toward the right.
* So the fromSpot will be set to Spot.MiddleRight, and the
* toSpot will be set to Spot.MiddleLeft.
* @expose
* @this {TreeLayout}
* @param {LayoutVertex} v
*/
TreeLayout.prototype.setPortSpots = function(v) {
  if (Debug) Util.checkClass(v, TreeVertex, TreeLayout, 'setPortSpots:v');
  var align = v.alignment;
  if (this.isBusAlignment(align)) {
    this.setPortSpotsBus(v, align);
  } else {
    var angle = this.orthoAngle(v);
    if (this._effectivePath === TreeLayout.PathDestination) {
      var eit = v.destinationEdges;
      while (eit.next()) {
        var edge = eit.value;
        var link = edge.link;
        if (link !== null) {
          if (v.setsPortSpot) {
            if (v.portSpot.isDefault()) {
              switch (angle) {
                case 0: link.fromSpot = Spot.MiddleRight; break;
                case 90: link.fromSpot = Spot.MiddleBottom; break;
                case 180: link.fromSpot = Spot.MiddleLeft; break;
                default: link.fromSpot = Spot.MiddleTop; break;
              }
            } else {
              link.fromSpot = v.portSpot;
            }
          }
          if (v.setsChildPortSpot) {
            if (v.childPortSpot.isDefault()) {
              switch (angle) {
                case 0: link.toSpot = Spot.MiddleLeft; break;
                case 90: link.toSpot = Spot.MiddleTop; break;
                case 180: link.toSpot = Spot.MiddleRight; break;
                default: link.toSpot = Spot.MiddleBottom; break;
              }
            } else {
              link.toSpot = v.childPortSpot;
            }
          }
        }
      }
    } else {  // tree path === source
      var eit = v.sourceEdges;
      while (eit.next()) {
        var edge = eit.value;
        var link = edge.link;
        if (link !== null) {
          if (v.setsPortSpot) {
            if (v.portSpot.isDefault()) {
              switch (angle) {
                case 0: link.toSpot = Spot.MiddleRight; break;
                case 90: link.toSpot = Spot.MiddleBottom; break;
                case 180: link.toSpot = Spot.MiddleLeft; break;
                default: link.toSpot = Spot.MiddleTop; break;
              }
            } else {
              link.toSpot = v.portSpot;
            }
          }
          if (v.setsChildPortSpot) {
            if (v.childPortSpot.isDefault()) {
              switch (angle) {
                case 0: link.fromSpot = Spot.MiddleLeft; break;
                case 90: link.fromSpot = Spot.MiddleTop; break;
                case 180: link.fromSpot = Spot.MiddleRight; break;
                default: link.fromSpot = Spot.MiddleBottom; break;
              }
            } else {
              link.fromSpot = v.childPortSpot;
            }
          }
        }
      }
    }
  }
};

/**
* @ignore
* Sets the PortSpots for vertexes with Bus alignments
* @this {TreeLayout}
* @param {LayoutVertex} v
* @param {EnumValue} align
*/
TreeLayout.prototype.setPortSpotsBus = function(v, align) {
  if (Debug) Util.checkClass(v, TreeVertex, TreeLayout, 'setPortSpotsBus:v');
  if (Debug) Util.checkClass(align, EnumValue, TreeLayout, 'setPortSpots:align');
  var dest = (this._effectivePath === TreeLayout.PathDestination);
  var angle = this.orthoAngle(v);
  var parentspot;
  switch (angle) {
    case 0: parentspot = Spot.MiddleRight; break;
    case 90: parentspot = Spot.MiddleBottom; break;
    case 180: parentspot = Spot.MiddleLeft; break;
    default: parentspot = Spot.MiddleTop; break;
  }
  var children = v.children;
  var childrenLength = children.length;
  switch (align) {
    case TreeLayout.AlignmentBus:
    case TreeLayout.AlignmentBusBranching:
      {
        for (var i = 0; i < childrenLength; i++) {
          var c = children[i];
          var eit = (dest ? c.sourceEdges : c.destinationEdges);
          if (!eit.next()) continue;
          var edge = eit.value;
          var l = edge.link;
          if (l !== null) {
            var childspot = (angle === 90 || angle === 270 ? Spot.MiddleLeft : Spot.MiddleTop);
            if (childrenLength === 1 || (i === childrenLength - 1 && childrenLength % 2 === 1)) {
              switch (angle) {
                case 0: childspot = Spot.MiddleLeft; break;
                case 90: childspot = Spot.MiddleTop; break;
                case 180: childspot = Spot.MiddleRight; break;
                default: childspot = Spot.MiddleBottom; break;
              }
            } else {
              if (i % 2 === 0) {
                childspot = (angle === 90 || angle === 270 ? Spot.MiddleRight : Spot.MiddleBottom);
              }
            }
            if (dest) {
              if (v.setsPortSpot) l.fromSpot = parentspot;
              if (v.setsChildPortSpot) l.toSpot = childspot;
            } else {
              if (v.setsPortSpot) l.fromSpot = childspot;
              if (v.setsChildPortSpot) l.toSpot = parentspot;
            }
          }
        }
        break;
      }
    case TreeLayout.AlignmentTopLeftBus:
      {
        var childspot = (angle === 90 || angle === 270 ? Spot.MiddleRight : Spot.MiddleBottom);
        var eit = (dest ? v.destinationEdges : v.sourceEdges);
        while (eit.next()) {
          var edge = eit.value;
          var l = edge.link;
          if (l !== null) {
            if (dest) {
              if (v.setsPortSpot) l.fromSpot = parentspot;
              if (v.setsChildPortSpot) l.toSpot = childspot;
            } else {
              if (v.setsPortSpot) l.fromSpot = childspot;
              if (v.setsChildPortSpot) l.toSpot = parentspot;
            }
          }
        }
        break;
      }
    case TreeLayout.AlignmentBottomRightBus:
      {
        var childspot = (angle === 90 || angle === 270 ? Spot.MiddleLeft : Spot.MiddleTop);
        var eit = (dest ? v.destinationEdges : v.sourceEdges);
        while (eit.next()) {
          var edge = eit.value;
          var l = edge.link;
          if (l !== null) {
            if (dest) {
              if (v.setsPortSpot) l.fromSpot = parentspot;
              if (v.setsChildPortSpot) l.toSpot = childspot;
            } else {
              if (v.setsPortSpot) l.fromSpot = childspot;
              if (v.setsChildPortSpot) l.toSpot = parentspot;
            }
          }
        }
        break;
      }
  }
};

/**
* @ignore
* @this {TreeLayout}
* @param {LayoutVertex} v
* @return {number}
*/
TreeLayout.prototype.orthoAngle = function(v) {
  var angle = v.angle;
  if (angle <= 45)
    return 0;
  else if (angle <= 135)
    return 90;
  else if (angle <= 225)
    return 180;
  else if (angle <= 315)
    return 270;
  else
    return 0;
};

/**
* @ignore
* @this {TreeLayout}
* @param {LayoutVertex} v
* @return {number}
*/
TreeLayout.prototype.computeLayerSpacing = function(v) {
  if (Debug) Util.checkClass(v, TreeVertex, TreeLayout, 'computeLayerSpacing:v');
  var angle = this.orthoAngle(v);
  var vertical = (angle === 90 || angle === 270);
  var layerspacing = v.layerSpacing;  // limit layerspacing to be no more negative than the depth of the node
  if (v.layerSpacingParentOverlap > 0) {
    var overlap = Math.min(1, v.layerSpacingParentOverlap);
    layerspacing -= (vertical ? v.height * overlap : v.width * overlap);
  }
  if (layerspacing < (vertical ? -v.height : -v.width))
    layerspacing = (vertical ? -v.height : -v.width);
  return layerspacing;
};

/**
* @ignore
* @this {TreeLayout}
* @param {LayoutVertex} v
* @return {number}
*/
TreeLayout.prototype.computeNodeIndent = function(v) {
  if (Debug) Util.checkClass(v, TreeVertex, TreeLayout, 'computeNodeIndent:v');
  var angle = this.orthoAngle(v);
  var vertical = (angle === 90 || angle === 270);
  var nodeindent = v.nodeIndent;
  if (v.nodeIndentPastParent > 0) {
    var ind = Math.min(1, v.nodeIndentPastParent);
    nodeindent += (vertical ? v.width * ind : v.height * ind);
  }
  nodeindent = Math.max(0, nodeindent);
  return nodeindent;
};

/***********************************Properties********************************/

/**
* Gets or sets the collection of root vertexes.
* <p/>
* Initially this will be an empty {@link Set}.
* <p/>
* If the {@link #path} is either {@link PathDestination} or
* {@link PathSource}, this layout can easily
* determine all of the tree roots by searching the whole network.
* Otherwise, you should explicitly initialize this collection
* with one or more {@link TreeVertex}es.
* @name TreeLayout#roots
* @function.
* @return {Set}
*/
/** @type {Set} */
TreeLayout.prototype.roots;
Util.exportProperty(TreeLayout, 'roots', TreeLayout.prototype.roots);
Util.defineProperty(TreeLayout, { roots: 'roots' },
	/** @this {TreeLayout} */
	function() { return this._roots; },
	/** @this {TreeLayout} */
	function(val) {
	  if (this._roots !== val) {
	    Util.checkClass(val, Set, TreeLayout, 'roots');
			this._roots = val;
			this.invalidateLayout();
		}
	}
);

/**
* Gets or sets how the tree should be constructed from the
* {@link TreeEdge}s connecting {@link TreeVertex}es.
* Must be {@link TreeLayout#PathDestination} or {@link TreeLayout#PathSource} or {@link TreeLayout#PathDefault}.
* <p/>
* The default value is {@link TreeLayout#PathDefault},
* where the value of {@link Diagram#isTreePathToChildren} determines the effective value of this property.
* @name TreeLayout#path
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
TreeLayout.prototype.path;
Util.exportProperty(TreeLayout, 'path', TreeLayout.prototype.path);
Util.defineProperty(TreeLayout, { path: 'path' },
  /** @this {TreeLayout} */
  function() { return this._path; },
  /** @this {TreeLayout} */
  function(val) {
    if (this._path !== val) {
      Util.checkClass(val, EnumValue, TreeLayout, 'path');
      this._path = val;
      this.invalidateLayout();
    }
  }
);

/**
* Gets or sets the Style for the resulting trees.
* Must be {@link TreeLayout#StyleLayered}, {@link TreeLayout#StyleAlternating},
* {@link TreeLayout#StyleLastParents}, or {@link TreeLayout#StyleRootOnly}.
* <p/>
* The default value is {@link TreeLayout#StyleLayered}.
* @name TreeLayout#treeStyle
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
TreeLayout.prototype.treeStyle;
Util.exportProperty(TreeLayout, 'treeStyle', TreeLayout.prototype.treeStyle);
Util.defineProperty(TreeLayout, { treeStyle: 'treeStyle' },
  /** @this {TreeLayout} */
  function() { return this._treeStyle; },
  /** @this {TreeLayout} */
  function(val) {
    if (this._arrangement !== val) {
      if (Debug) Util.checkClass(val, EnumValue, TreeLayout, 'treeStyle');
      if (val === TreeLayout.StyleLayered || val === TreeLayout.StyleAlternating ||
			    val === TreeLayout.StyleLastParents || val === TreeLayout.StyleRootOnly) {
        this._treeStyle = val;
        this.invalidateLayout();
      }
    }
  }
);

/**
* Gets or sets how {@link #arrangeTrees} should lay out the separate trees.
* Must be {@link TreeLayout#ArrangementVertical}, {@link TreeLayout#ArrangementHorizontal},
* or {@link TreeLayout#ArrangementFixedRoots}.
* <p/>
* The default value is {@link TreeLayout#ArrangementVertical}
* @name TreeLayout#arrangement
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
TreeLayout.prototype.arrangement;
Util.exportProperty(TreeLayout, 'arrangement', TreeLayout.prototype.arrangement);
Util.defineProperty(TreeLayout, { arrangement: 'arrangement' },
  /** @this {TreeLayout} */
  function() { return this._arrangement; },
  /** @this {TreeLayout} */
  function(val) {
    if (this._arrangement !== val) {
      if (Debug) Util.checkClass(val, EnumValue, TreeLayout, 'arrangement');
      if (val === TreeLayout.ArrangementVertical || val === TreeLayout.ArrangementHorizontal || val === TreeLayout.ArrangementFixedRoots) {
        this._arrangement = val;
        this.invalidateLayout();
      }
    }
  }
);

/**
* Gets or sets the space between which {@link #arrangeTrees} will position the trees.
* <p/>
* This defaults to the Size(10, 10).
* <p/>
* This property is ignored if {@link #arrangement} is {@link TreeLayout#ArrangementFixedRoots}.
* @name TreeLayout#arrangementSpacing
* @function.
* @return {Size}
*/
/** @type {Size} */
TreeLayout.prototype.arrangementSpacing;
Util.exportProperty(TreeLayout, 'arrangementSpacing', TreeLayout.prototype.arrangementSpacing);
Util.defineProperty(TreeLayout, { arrangementSpacing: 'arrangementSpacing' },
  /** @this {TreeLayout} */
  function() { return this._arrangementSpacing; },
  /** @this {TreeLayout} */
  function(val) {
    var old = this._arrangementSpacing;
    if (!old.equals(val)) {
      this._arrangementSpacing.assign(val);
      this.invalidateLayout();
    }
  }
);

/**
* Gets or sets the object holding the default values for root {@link TreeVertex}es.
* <p/>
* The values for the following inheritable properties are actually stored in this object:
* {@link #sorting}, {@link #comparer}, {@link #angle},
* {@link #alignment}, {@link #nodeIndent}, {@link #nodeIndentPastParent},
* {@link #nodeSpacing}, {@link #layerSpacing}, {@link #layerSpacingParentOverlap},
* {@link #compaction}, {@link #breadthLimit}, {@link #rowSpacing}, {@link #rowIndent},
* {@link #commentSpacing}, {@link #commentMargin},
* {@link #setsPortSpot}, {@link #portSpot}, {@link #setsChildPortSpot}, {@link #childPortSpot}.
* The other properties of this {@link TreeVertex} are ignored.
* @name TreeLayout#rootDefaults
* @function.
* @return {TreeVertex}
*/
/** @type {TreeVertex} */
TreeLayout.prototype.rootDefaults;
Util.exportProperty(TreeLayout, 'rootDefaults', TreeLayout.prototype.rootDefaults);
Util.defineProperty(TreeLayout, { rootDefaults: 'rootDefaults' },
  /** @this {TreeLayout} */
  function() { return this._rootDefaults; },
  /** @this {TreeLayout} */
  function(val) {
    if (this._rootDefaults !== val) {
      if (Debug) Util.checkClass(val, TreeVertex, TreeLayout, 'rootDefaults');
      this._rootDefaults = val;
      this.invalidateLayout();
    }
  }
);

/**
* Gets or sets the object holding the default values for alternate layer {@link TreeVertex}es,
* used when the {@link #treeStyle} is {@link #StyleAlternating} or {@link #StyleLastParents}.
* <p/>
* See the list of inheritable properties in the documentation for {@link #rootDefaults}.
* The other properties of this {@link TreeVertex} are ignored.
* @name TreeLayout#alternateDefaults
* @function.
* @return {TreeVertex}
*/
/** @type {TreeVertex} */
TreeLayout.prototype.alternateDefaults;
Util.exportProperty(TreeLayout, 'alternateDefaults', TreeLayout.prototype.alternateDefaults);
Util.defineProperty(TreeLayout, { alternateDefaults: 'alternateDefaults' },
  /** @this {TreeLayout} */
  function() { return this._alternateDefaults; },
  /** @this {TreeLayout} */
  function(val) {
    if (this._alternateDefaults !== val) {
      if (Debug) Util.checkClass(val, TreeVertex, TreeLayout, 'alternateDefaults');
      this._alternateDefaults = val;
      this.invalidateLayout();
    }
  }
);

/**
* Gets or sets the default Sorting policy.
* Must be {@link TreeLayout#SortingForwards}, {@link TreeLayout#SortingReverse},
* {@link TreeLayout#SortingAscending}, or {@link TreeLayout#SortingDescending}.
* <p/>
* The default value is {@link TreeLayout#SortingForwards}.
* <p/>
* This sets the {@link #rootDefaults}' property of the same name.
* @name TreeLayout#sorting
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
TreeLayout.prototype.sorting;
Util.exportProperty(TreeLayout, 'sorting', TreeLayout.prototype.sorting);
Util.defineProperty(TreeLayout, { sorting: 'sorting' },
	/** @this {TreeLayout} */
	function() { return this._rootDefaults.sorting; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._rootDefaults.sorting !== val) {
			if (Debug) Util.checkClass(val, EnumValue, TreeLayout, 'sorting');
      if (val === TreeLayout.SortingForwards || val === TreeLayout.SortingReverse ||
			val === TreeLayout.SortingAscending || TreeLayout.SortingDescending) {
				this._rootDefaults.sorting = val;
        this.invalidateLayout();
      }
    }
  }
);

/**
* Gets or sets the default comparison function used for sorting.
* <p/>
* The default comparer compares the {@link LayoutVertex#node} Text values.
* <p/>
* This sets the {@link #rootDefaults}' property of the same name.
* @name TreeLayout#comparer
* @function.
* @return {function(TreeVertex, TreeVertex):number}
*/
/** @type {function(TreeVertex, TreeVertex):number} */
TreeLayout.prototype.comparer;
Util.exportProperty(TreeLayout, 'comparer', TreeLayout.prototype.comparer);
Util.defineProperty(TreeLayout, { comparer: 'comparer' },
	/** @this {TreeLayout} */
	function() { return this._rootDefaults.comparer; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._rootDefaults.comparer !== val) {
			if (Debug) Util.checkPrimitive(val, 'function', TreeLayout, 'comparer');
			this._rootDefaults.comparer = val;
			this.invalidateLayout();
		}
	}
);

/**
* Gets or sets the default direction for tree growth.
* <p/>
* The default value is 0; the value must be one of: 0, 90, 180, 270.
* <p/>
* These values are in degrees, where 0 is along the positive X axis,
* and where 90 is along the positive Y axis.
* This sets the {@link #rootDefaults}' property of the same name.
* @name TreeLayout#angle
* @function.
* @return {number}
*/
/** @type {number} */
TreeLayout.prototype.angle;
Util.exportProperty(TreeLayout, 'angle', TreeLayout.prototype.angle);
Util.defineProperty(TreeLayout, { angle: 'angle' },
	/** @this {TreeLayout} */
	function() { return this._rootDefaults.angle; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._rootDefaults.angle !== val) {
			if (val === 0 || val === 90 || val === 180 || val === 270) {
				this._rootDefaults.angle = val;
				this.invalidateLayout();
			}
		}
	}
);

/**
* Gets or sets the default alignment of parents relative to their children.
* Must be a static constant of {@link TreeLayout} whose name starts with "Alignment".
* <p/>
* The default value is {@link TreeLayout#AlignmentCenterChildren}.
* <p/>
* This sets the {@link #rootDefaults}' property of the same name.
* @name TreeLayout#alignment
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
TreeLayout.prototype.alignment;
Util.exportProperty(TreeLayout, 'alignment', TreeLayout.prototype.alignment);
Util.defineProperty(TreeLayout, { alignment: 'alignment' },
	/** @this {TreeLayout} */
	function() { return this._rootDefaults.alignment; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._rootDefaults.alignment !== val) {
			if (Debug) Util.checkEnumValue(val, TreeLayout, TreeLayout, 'alignment');
      this._rootDefaults.alignment = val;
      this.invalidateLayout();
		}
	}
);

/**
* Gets or sets the default indentation of the first child.
* <p/>
* The default value is zero.  The value should be non-negative.
* <p/>
* This property is only sensible when the {@link #alignment}
* is {@link #AlignmentStart} or {@link #AlignmentEnd}.
* Having a positive value is useful if you want to reserve space
* at the start of the row of children for some reason.
* For example, if you want to pretend the parent node is infinitely deep,
* you can set this to be the breadth of the parent node.
* This sets the {@link #rootDefaults}' property of the same name.
* @name TreeLayout#nodeIndent
* @function.
* @return {number}
*/
/** @type {number} */
TreeLayout.prototype.nodeIndent;
Util.exportProperty(TreeLayout, 'nodeIndent', TreeLayout.prototype.nodeIndent);
Util.defineProperty(TreeLayout, { nodeIndent: 'nodeIndent' },
	/** @this {TreeLayout} */
	function() { return this._rootDefaults.nodeIndent; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._rootDefaults.nodeIndent !== val && val >= 0) {
			this._rootDefaults.nodeIndent = val;
			this.invalidateLayout();
		}
	}
);

/**
* Gets or sets the fraction of this node's breadth is added to {@link #nodeIndent}
* to determine any spacing at the start of the children.
* <p/>
* The default value is 0.0 -- the only indentation is specified by {@link #nodeIndent}.
* When the value is 1.0, the children will be indented past the breadth of the parent node.
* <p/>
* This property is only sensible when the {@link #alignment}
* is {@link #AlignmentStart} or {@link #AlignmentEnd}.
* This sets the {@link #rootDefaults}' property of the same name.
* @name TreeLayout#nodeIndentPastParent
* @function.
* @return {number}
*/
/** @type {number} */
TreeLayout.prototype.nodeIndentPastParent;
Util.exportProperty(TreeLayout, 'nodeIndentPastParent', TreeLayout.prototype.nodeIndentPastParent);
Util.defineProperty(TreeLayout, { nodeIndentPastParent: 'nodeIndentPastParent' },
	/** @this {TreeLayout} */
	function() { return this._rootDefaults.nodeIndentPastParent; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._rootDefaults.nodeIndentPastParent !== val && val >= 0 && val <= 1) {
			this._rootDefaults.nodeIndentPastParent = val;
			this.invalidateLayout();
		}
	}
);

/**
* Gets or sets the distance between child nodes.
* <p/>
* The default value is 20.
* <p/>
* A negative value causes sibling nodes to overlap.
* This sets the {@link #rootDefaults}' property of the same name.
* @name TreeLayout#nodeSpacing
* @function.
* @return {number}
*/
/** @type {number} */
TreeLayout.prototype.nodeSpacing;
Util.exportProperty(TreeLayout, 'nodeSpacing', TreeLayout.prototype.nodeSpacing);
Util.defineProperty(TreeLayout, { nodeSpacing: 'nodeSpacing' },
	/** @this {TreeLayout} */
	function() { return this._rootDefaults.nodeSpacing; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._rootDefaults.nodeSpacing !== val) {
			this._rootDefaults.nodeSpacing = val;
			this.invalidateLayout();
		}
	}
);

/**
* Gets or sets the distance between a parent node and its children.
* <p/>
* The default value is 50.
* <p/>
* This is the distance between a parent node and its first row
* of children, in case there are multiple rows of its children.
* The {@link #rowSpacing} property determines the distance
* between rows of children.
* Negative values may cause children to overlap with the parent.
* This sets the {@link #rootDefaults}' property of the same name.
* @name TreeLayout#layerSpacing
* @function.
* @return {number}
*/
/** @type {number} */
TreeLayout.prototype.layerSpacing;
Util.exportProperty(TreeLayout, 'layerSpacing', TreeLayout.prototype.layerSpacing);
Util.defineProperty(TreeLayout, { layerSpacing: 'layerSpacing' },
	/** @this {TreeLayout} */
	function() { return this._rootDefaults.layerSpacing; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._rootDefaults.layerSpacing !== val) {
			this._rootDefaults.layerSpacing = val;
			this.invalidateLayout();
		}
	}
);

/**
* Gets or sets the fraction of the node's depth for which the children's layer starts overlapped with the parent's layer.
* <p/>
* The default value is 0.0 -- there is overlap between layers only if {@link #layerSpacing} is negative.
* A value of 1.0 and a zero {@link #layerSpacing} will cause child nodes to completely overlap the parent.
* <p/>
* A value greater than zero may still cause overlap between layers,
* unless the value of {@link #layerSpacing} is large enough.
* A value of zero might still allow overlap between layers,
* if {@link #layerSpacing} is negative.
* This sets the {@link #rootDefaults}' property of the same name.
* @name TreeLayout#layerSpacingParentOverlap
* @function.
* @return {number}
*/
/** @type {number} */
TreeLayout.prototype.layerSpacingParentOverlap;
Util.exportProperty(TreeLayout, 'layerSpacingParentOverlap', TreeLayout.prototype.layerSpacingParentOverlap);
Util.defineProperty(TreeLayout, { layerSpacingParentOverlap: 'layerSpacingParentOverlap' },
	/** @this {TreeLayout} */
	function() { return this._rootDefaults.layerSpacingParentOverlap; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._rootDefaults.layerSpacingParentOverlap !== val && val >= 0 && val <= 1) {
			this._rootDefaults.layerSpacingParentOverlap = val;
			this.invalidateLayout();
		}
	}
);

/**
* Gets or sets how closely to pack the child nodes of a subtree.
* Must be either {@link TreeLayout#CompactionBlock} or {@link TreeLayout#CompactionNone}.
* <p/>
* The default value is {@link #CompactionBlock}.
* <p/>
* This sets the {@link #rootDefaults}' property of the same name.
* @name TreeLayout#compaction
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
TreeLayout.prototype.compaction;
Util.exportProperty(TreeLayout, 'compaction', TreeLayout.prototype.compaction);
Util.defineProperty(TreeLayout, { compaction: 'compaction' },
	/** @this {TreeLayout} */
	function() { return this._rootDefaults.compaction; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._rootDefaults.compaction !== val) {
			if (Debug) Util.checkClass(val, EnumValue, TreeLayout, 'compaction');
      if (val === TreeLayout.CompactionNone || val === TreeLayout.CompactionBlock) {
				this._rootDefaults.compaction = val;
				this.invalidateLayout();
			}
		}
	}
);

/**
* Gets or sets a limit on how broad a tree should be.
* <p/>
* A value of zero (the default) means there is no limit;
* a positive value specifies a limit.
* The default value is zero.
* <p/>
* This property is just a suggested constraint on how
* broadly the tree will be laid out.
* When there isn't enough breadth for all of the children of a node,
*  the children are placed in as many rows as needed to try to stay
* within the given breadth limit.
* If the value is too small, since this layout algorithm
* does not modify the size or shape of any node, the nodes will
* just be laid out in a line, one per row, and the breadth is
* determined by the broadest node.
* The distance between rows is specified by {@link #rowSpacing}.
* To make room for the links that go around earlier rows to get to
* later rows, when the alignment is not a "center" alignment, the
* {@link #rowIndent} property specifies that space at the
* start of each row.
* This sets the {@link #rootDefaults}' property of the same name.
* @name TreeLayout#breadthLimit
* @function.
* @return {number}
*/
/** @type {number} */
TreeLayout.prototype.breadthLimit;
Util.exportProperty(TreeLayout, 'breadthLimit', TreeLayout.prototype.breadthLimit);
Util.defineProperty(TreeLayout, { breadthLimit: 'breadthLimit' },
	/** @this {TreeLayout} */
	function() { return this._rootDefaults.breadthLimit; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._rootDefaults.breadthLimit !== val && val >= 0) {
			this._rootDefaults.breadthLimit = val;
			this.invalidateLayout();
		}
	}
);

/**
* Gets or sets the distance between rows of children.
* <p/>
* The default value is 25.
* <p/>
* This property is only used when there is more than one
* row of children for a given parent node.
* {@link #layerSpacing} determines the distance between
* the parent node and its first row of child nodes.
* This sets the {@link #rootDefaults}' property of the same name.
* @name TreeLayout#rowSpacing
* @function.
* @return {number}
*/
/** @type {number} */
TreeLayout.prototype.rowSpacing;
Util.exportProperty(TreeLayout, 'rowSpacing', TreeLayout.prototype.rowSpacing);
Util.defineProperty(TreeLayout, { rowSpacing: 'rowSpacing' },
	/** @this {TreeLayout} */
	function() { return this._rootDefaults.rowSpacing; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._rootDefaults.rowSpacing !== val) {
			this._rootDefaults.rowSpacing = val;
			this.invalidateLayout();
		}
	}
);

/**
* Gets or sets the default indentation of the first child of each row,
* if the {@link #alignment} is not a "Center" alignment.
* <p/>
* The default value is 10.  The value should be non-negative.
* <p/>
* This is used to leave room for the links that connect a parent node
* with the child nodes that are in additional rows.
* This sets the {@link #rootDefaults}' property of the same name.
* @name TreeLayout#rowIndent
* @function.
* @return {number}
*/
/** @type {number} */
TreeLayout.prototype.rowIndent;
Util.exportProperty(TreeLayout, 'rowIndent', TreeLayout.prototype.rowIndent);
Util.defineProperty(TreeLayout, { rowIndent: 'rowIndent' },
	/** @this {TreeLayout} */
	function() { return this._rootDefaults.rowIndent; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._rootDefaults.rowIndent !== val && val >= 0) {
			this._rootDefaults.rowIndent = val;
			this.invalidateLayout();
		}
	}
);

/**
* Gets or sets the distance between comments.
* <p/>
* The default value is 10.
* <p/>
* This is used by {@link #addComments} and {@link #layoutComments}.
* This sets the {@link #rootDefaults}' property of the same name.
* @name TreeLayout#commentSpacing
* @function.
* @return {number}
*/
/** @type {number} */
TreeLayout.prototype.commentSpacing;
Util.exportProperty(TreeLayout, 'commentSpacing', TreeLayout.prototype.commentSpacing);
Util.defineProperty(TreeLayout, { commentSpacing: 'commentSpacing' },
	/** @this {TreeLayout} */
	function() { return this._rootDefaults.commentSpacing; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._rootDefaults.commentSpacing !== val) {
			this._rootDefaults.commentSpacing = val;
			this.invalidateLayout();
		}
	}
);

/**
* Gets or sets the distance between a node and its comments.
* <p/>
* The default value is 20.
* <p/>
* This is used by {@link #addComments} and {@link #layoutComments}.
* This sets the {@link #rootDefaults}' property of the same name.
* @name TreeLayout#commentMargin
* @function.
* @return {number}
*/
/** @type {number} */
TreeLayout.prototype.commentMargin;
Util.exportProperty(TreeLayout, 'commentMargin', TreeLayout.prototype.commentMargin);
Util.defineProperty(TreeLayout, { commentMargin: 'commentMargin' },
	/** @this {TreeLayout} */
	function() { return this._rootDefaults.commentMargin; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._rootDefaults.commentMargin !== val) {
			this._rootDefaults.commentMargin = val;
			this.invalidateLayout();
		}
	}
);

/**
* Gets or sets whether the TreeLayout should set the
* FromSpot for this parent node port.
* <p/>
* The default value is true -- this may modify the spot of the port of this node, the parent,
* if the node has only a single port.
* <p/>
* The spot used depends on the value of {@link #portSpot}.
* This sets the {@link #rootDefaults}' property of the same name.
* @name TreeLayout#setsPortSpot
* @function.
* @return {boolean}
*/
/** @type {boolean} */
TreeLayout.prototype.setsPortSpot;
Util.exportProperty(TreeLayout, 'setsPortSpot', TreeLayout.prototype.setsPortSpot);
Util.defineProperty(TreeLayout, { setsPortSpot: 'setsPortSpot' },
	/** @this {TreeLayout} */
	function() { return this._rootDefaults.setsPortSpot; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._rootDefaults.setsPortSpot !== val) {
			this._rootDefaults.setsPortSpot = val;
			this.invalidateLayout();
		}
	}
);

/**
* Gets or sets the spot that this node's port gets as its FromSpot.
* <p/>
* The default value is {@link Spot#Default}.
* <p/>
* A value of Spot.Default will cause the TreeLayout
* to assign a FromSpot based on the parent node's {@link TreeVertex#angle}.
* If the value is other than NoSpot, it is just assigned.
* When {@link #path} is {@link #PathSource},
* the port's ToSpot is set instead of the FromSpot.
* This sets the {@link #rootDefaults}' property of the same name.
* @name TreeLayout#portSpot
* @this {TreeLayout}
* @function.
* @return {Spot}
*/
/** @type {Spot} */
TreeLayout.prototype.portSpot;
Util.exportProperty(TreeLayout, 'portSpot', TreeLayout.prototype.portSpot);
Util.defineProperty(TreeLayout, { portSpot: 'portSpot' },
  /** @this {TreeLayout} */
	function() { return this._rootDefaults.portSpot; },
  /** @this {TreeLayout} */
	function(val) {
	  if (!this._rootDefaults.portSpot.equals(val)) {
	    this._rootDefaults.portSpot = val;
	    this.invalidateLayout();
	  }
	}
);

/**
* Gets or sets whether the TreeLayout should set the
* ToSpot for each child node port.
* <p/>
* The default value is true -- this may modify the spot of the ports of the children nodes,
* if the node has only a single port.
* <p/>
* The spot used depends on the value of {@link #childPortSpot}.
* This sets the {@link #rootDefaults}' property of the same name.
* @name TreeLayout#setsChildPortSpot
* @function.
* @return {boolean}
*/
/** @type {boolean} */
TreeLayout.prototype.setsChildPortSpot;
Util.exportProperty(TreeLayout, 'setsChildPortSpot', TreeLayout.prototype.setsChildPortSpot);
Util.defineProperty(TreeLayout, { setsChildPortSpot: 'setsChildPortSpot' },
	/** @this {TreeLayout} */
	function() { return this._rootDefaults.setsChildPortSpot; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._rootDefaults.setsChildPortSpot !== val) {
			this._rootDefaults.setsChildPortSpot = val;
			this.invalidateLayout();
		}
	}
);

/**
* Gets or sets the spot that children nodes' ports get as their ToSpot.
* <p/>
* The default value is {@link Spot#Default}.
* <p/>
* A value of Spot.Default will cause the TreeLayout
* to assign a ToSpot based on the parent node's {@link TreeVertex#angle}.
* If the value is other than NoSpot, it is just assigned.
* When {@link #path} is {@link #PathSource},
* the port's FromSpot is set instead of the ToSpot.
* This sets the {@link #rootDefaults}' property of the same name.
* @name TreeLayout#childPortSpot
* @this {TreeLayout}
* @function.
* @return {Spot}
*/
/** @type {Spot} */
TreeLayout.prototype.childPortSpot;
Util.exportProperty(TreeLayout, 'childPortSpot', TreeLayout.prototype.childPortSpot);
Util.defineProperty(TreeLayout, { childPortSpot: 'childPortSpot' },
  /** @this {TreeLayout} */
	function() { return this._rootDefaults.childPortSpot; },
  /** @this {TreeLayout} */
	function(val) {
	  if (!this._rootDefaults.childPortSpot.equals(val)) {
	    this._rootDefaults.childPortSpot = val;
	    this.invalidateLayout();
	  }
	}
);

/**
* Gets or sets the default Sorting policy.
* Must be {@link TreeLayout#SortingForwards}, {@link TreeLayout#SortingReverse},
* {@link TreeLayout#SortingAscending}, or {@link TreeLayout#SortingDescending}.
* <p/>
* The default value is {@link #SortingForwards}.
* <p/>
* This sets the {@link #alternateDefaults}' property of the same name.
* @name TreeLayout#alternateSorting
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
TreeLayout.prototype.alternateSorting;
Util.exportProperty(TreeLayout, 'alternateSorting', TreeLayout.prototype.alternateSorting);
Util.defineProperty(TreeLayout, { alternateSorting: 'alternateSorting' },
	/** @this {TreeLayout} */
	function() { return this._alternateDefaults.sorting; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._alternateDefaults.sorting !== val) {
			if (Debug) Util.checkClass(val, EnumValue, TreeLayout, 'alternateSorting');
      if (val === TreeLayout.SortingForwards || val === TreeLayout.SortingReverse ||
			val === TreeLayout.SortingAscending || TreeLayout.SortingDescending) {
				this._alternateDefaults.sorting = val;
        this.invalidateLayout();
      }
    }
  }
);

/**
* Gets or sets the default comparison function used for sorting.
* <p/>
* The default comparer compares the {@link LayoutVertex#node} Text values.
* <p/>
* This sets the {@link #alternateDefaults}' property of the same name.
* @name TreeLayout#alternateComparer
* @function.
* @return {function(TreeVertex, TreeVertex):number}
*/
/** @type {function(TreeVertex, TreeVertex):number} */
TreeLayout.prototype.alternateComparer;
Util.exportProperty(TreeLayout, 'alternateComparer', TreeLayout.prototype.alternateComparer);
Util.defineProperty(TreeLayout, { alternateComparer: 'alternateComparer' },
	/** @this {TreeLayout} */
	function() { return this._alternateDefaults.comparer; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._alternateDefaults.comparer !== val) {
			if (Debug) Util.checkPrimitive(val, 'function', TreeLayout, 'alternateComparer');
			this._alternateDefaults.comparer = val;
			this.invalidateLayout();
		}
	}
);

/**
* Gets or sets the default direction for tree growth.
* <p/>
* The default value is 0; the value must be one of: 0, 90, 180, 270.
* <p/>
* These values are in degrees, where 0 is along the positive X axis,
* and where 90 is along the positive Y axis.
* This sets the {@link #alternateDefaults}' property of the same name.
* @name TreeLayout#alternateAngle
* @function.
* @return {number}
*/
/** @type {number} */
TreeLayout.prototype.alternateAngle;
Util.exportProperty(TreeLayout, 'alternateAngle', TreeLayout.prototype.alternateAngle);
Util.defineProperty(TreeLayout, { alternateAngle: 'alternateAngle' },
	/** @this {TreeLayout} */
	function() { return this._alternateDefaults.angle; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._alternateDefaults.angle !== val) {
			if (val === 0 || val === 90 || val === 180 || val === 270) {
				this._alternateDefaults.angle = val;
				this.invalidateLayout();
			}
		}
	}
);

/**
* Gets or sets the default alignment of parents relative to their children.
* Must be a static constant of {@link TreeLayout} whose name starts with "Alignment".
* <p/>
* The default value is {@link TreeLayout#AlignmentCenterChildren}.
* <p/>
* This sets the {@link #alternateDefaults}' property of the same name.
* @name TreeLayout#alternateAlignment
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
TreeLayout.prototype.alternateAlignment;
Util.exportProperty(TreeLayout, 'alternateAlignment', TreeLayout.prototype.alternateAlignment);
Util.defineProperty(TreeLayout, { alternateAlignment: 'alternateAlignment' },
	/** @this {TreeLayout} */
	function() { return this._alternateDefaults.alignment; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._alternateDefaults.alignment !== val) {
			if (Debug) Util.checkEnumValue(val, TreeLayout, TreeLayout, 'alternateAlignment');
      this._alternateDefaults.alignment = val;
      this.invalidateLayout();
		}
	}
);

/**
* Gets or sets the default indentation of the first child.
* <p/>
* The default value is zero.  The value should be non-negative.
* <p/>
* This property is only sensible when the {@link #alignment}
* is {@link #AlignmentStart} or {@link #AlignmentEnd}.
* Having a positive value is useful if you want to reserve space
* at the start of the row of children for some reason.
* For example, if you want to pretend the parent node is infinitely deep,
* you can set this to be the breadth of the parent node.
* This sets the {@link #alternateDefaults}' property of the same name.
* @name TreeLayout#alternateNodeIndent
* @function.
* @return {number}
*/
/** @type {number} */
TreeLayout.prototype.alternateNodeIndent;
Util.exportProperty(TreeLayout, 'alternateNodeIndent', TreeLayout.prototype.alternateNodeIndent);
Util.defineProperty(TreeLayout, { alternateNodeIndent: 'alternateNodeIndent' },
	/** @this {TreeLayout} */
	function() { return this._alternateDefaults.nodeIndent; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._alternateDefaults.nodeIndent !== val && val >= 0) {
			this._alternateDefaults.nodeIndent = val;
			this.invalidateLayout();
		}
	}
);

/**
* Gets or sets the fraction of this node's breadth is added to {@link #nodeIndent}
* to determine any spacing at the start of the children.
* <p/>
* The default value is 0.0 -- the only indentation is specified by {@link #nodeIndent}.
* When the value is 1.0, the children will be indented past the breadth of the parent node.
* <p/>
* This property is only sensible when the {@link #alignment}
* is {@link #AlignmentStart} or {@link #AlignmentEnd}.
* This sets the {@link #alternateDefaults}' property of the same name.
* @name TreeLayout#alternateNodeIndentPastParent
* @function.
* @return {number}
*/
/** @type {number} */
TreeLayout.prototype.alternateNodeIndentPastParent;
Util.exportProperty(TreeLayout, 'alternateNodeIndentPastParent', TreeLayout.prototype.alternateNodeIndentPastParent);
Util.defineProperty(TreeLayout, { alternateNodeIndentPastParent: 'alternateNodeIndentPastParent' },
	/** @this {TreeLayout} */
	function() { return this._alternateDefaults.nodeIndentPastParent; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._alternateDefaults.nodeIndentPastParent !== val && val >= 0 && val <= 1) {
			this._alternateDefaults.nodeIndentPastParent = val;
			this.invalidateLayout();
		}
	}
);

/**
* Gets or sets the distance between child nodes.
* <p/>
* The default value is 20.
* <p/>
* A negative value causes sibling nodes to overlap.
* This sets the {@link #alternateDefaults}' property of the same name.
* @name TreeLayout#alternateNodeSpacing
* @function.
* @return {number}
*/
/** @type {number} */
TreeLayout.prototype.alternateNodeSpacing;
Util.exportProperty(TreeLayout, 'alternateNodeSpacing', TreeLayout.prototype.alternateNodeSpacing);
Util.defineProperty(TreeLayout, { alternateNodeSpacing: 'alternateNodeSpacing' },
	/** @this {TreeLayout} */
	function() { return this._alternateDefaults.nodeSpacing; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._alternateDefaults.nodeSpacing !== val) {
			this._alternateDefaults.nodeSpacing = val;
			this.invalidateLayout();
		}
	}
);

/**
* Gets or sets the distance between a parent node and its children.
* <p/>
* The default value is 50.
* <p/>
* This is the distance between a parent node and its first row
* of children, in case there are multiple rows of its children.
* The {@link #rowSpacing} property determines the distance
* between rows of children.
* Negative values may cause children to overlap with the parent.
* This sets the {@link #alternateDefaults}' property of the same name.
* @name TreeLayout#alternateLayerSpacing
* @function.
* @return {number}
*/
/** @type {number} */
TreeLayout.prototype.alternateLayerSpacing;
Util.exportProperty(TreeLayout, 'alternateLayerSpacing', TreeLayout.prototype.alternateLayerSpacing);
Util.defineProperty(TreeLayout, { alternateLayerSpacing: 'alternateLayerSpacing' },
	/** @this {TreeLayout} */
	function() { return this._alternateDefaults.layerSpacing; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._alternateDefaults.layerSpacing !== val) {
			this._alternateDefaults.layerSpacing = val;
			this.invalidateLayout();
		}
	}
);

/**
* Gets or sets the fraction of the node's depth for which the children's layer starts overlapped with the parent's layer.
* <p/>
* The default value is 0.0 -- there is overlap between layers only if {@link #layerSpacing} is negative.
* A value of 1.0 and a zero {@link #layerSpacing} will cause child nodes to completely overlap the parent.
* <p/>
* A value greater than zero may still cause overlap between layers,
* unless the value of {@link #layerSpacing} is large enough.
* A value of zero might still allow overlap between layers,
* if {@link #layerSpacing} is negative.
* This sets the {@link #alternateDefaults}' property of the same name.
* @name TreeLayout#alternateLayerSpacingParentOverlap
* @function.
* @return {number}
*/
/** @type {number} */
TreeLayout.prototype.alternateLayerSpacingParentOverlap;
Util.exportProperty(TreeLayout, 'alternateLayerSpacingParentOverlap', TreeLayout.prototype.alternateLayerSpacingParentOverlap);
Util.defineProperty(TreeLayout, { alternateLayerSpacingParentOverlap: 'alternateLayerSpacingParentOverlap' },
	/** @this {TreeLayout} */
	function() { return this._alternateDefaults.layerSpacingParentOverlap; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._alternateDefaults.layerSpacingParentOverlap !== val && val >= 0 && val <= 1) {
			this._alternateDefaults.layerSpacingParentOverlap = val;
			this.invalidateLayout();
		}
	}
);

/**
* Gets or sets how closely to pack the child nodes of a subtree.
* Must be either {@link TreeLayout#CompactionBlock} or {@link TreeLayout#CompactionNone}.
* <p/>
* The default value is {@link TreeLayout#CompactionBlock}.
* <p/>
* This sets the {@link #alternateDefaults}' property of the same name.
* @name TreeLayout#alternateCompaction
* @function.
* @return {EnumValue}
*/
/** @type {EnumValue} */
TreeLayout.prototype.alternateCompaction;
Util.exportProperty(TreeLayout, 'alternateCompaction', TreeLayout.prototype.alternateCompaction);
Util.defineProperty(TreeLayout, { alternateCompaction: 'alternateCompaction' },
	/** @this {TreeLayout} */
	function() { return this._alternateDefaults.compaction; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._alternateDefaults.compaction !== val) {
			if (Debug) Util.checkClass(val, EnumValue, TreeLayout, 'alternateCompaction');
      if (val === TreeLayout.CompactionNone || val === TreeLayout.CompactionBlock) {
				this._alternateDefaults.compaction = val;
				this.invalidateLayout();
			}
		}
	}
);

/**
* Gets or sets a limit on how broad a tree should be.
* <p/>
* A value of zero (the default) means there is no limit;
* a positive value specifies a limit.
* The default value is zero.
* <p/>
* This property is just a suggested constraint on how
* broadly the tree will be laid out.
* When there isn't enough breadth for all of the children of a node,
*  the children are placed in as many rows as needed to try to stay
* within the given breadth limit.
* If the value is too small, since this layout algorithm
* does not modify the size or shape of any node, the nodes will
* just be laid out in a line, one per row, and the breadth is
* determined by the broadest node.
* The distance between rows is specified by {@link #rowSpacing}.
* To make room for the links that go around earlier rows to get to
* later rows, when the alignment is not a "center" alignment, the
* {@link #rowIndent} property specifies that space at the
* start of each row.
* This sets the {@link #alternateDefaults}' property of the same name.
* @name TreeLayout#alternateBreadthLimit
* @function.
* @return {number}
*/
/** @type {number} */
TreeLayout.prototype.alternateBreadthLimit;
Util.exportProperty(TreeLayout, 'alternateBreadthLimit', TreeLayout.prototype.alternateBreadthLimit);
Util.defineProperty(TreeLayout, { alternateBreadthLimit: 'alternateBreadthLimit' },
	/** @this {TreeLayout} */
	function() { return this._alternateDefaults.breadthLimit; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._alternateDefaults.breadthLimit !== val && val >= 0) {
			this._alternateDefaults.breadthLimit = val;
			this.invalidateLayout();
		}
	}
);

/**
* Gets or sets the distance between rows of children.
* <p/>
* The default value is 25.
* <p/>
* This property is only used when there is more than one
* row of children for a given parent node.
* {@link #layerSpacing} determines the distance between
* the parent node and its first row of child nodes.
* This sets the {@link #alternateDefaults}' property of the same name.
* @name TreeLayout#alternateRowSpacing
* @function.
* @return {number}
*/
/** @type {number} */
TreeLayout.prototype.alternateRowSpacing;
Util.exportProperty(TreeLayout, 'alternateRowSpacing', TreeLayout.prototype.alternateRowSpacing);
Util.defineProperty(TreeLayout, { alternateRowSpacing: 'alternateRowSpacing' },
	/** @this {TreeLayout} */
	function() { return this._alternateDefaults.rowSpacing; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._alternateDefaults.rowSpacing !== val) {
			this._alternateDefaults.rowSpacing = val;
			this.invalidateLayout();
		}
	}
);

/**
* Gets or sets the default indentation of the first child of each row,
* if the {@link #alignment} is not a "Center" alignment.
* <p/>
* The default value is 10.  The value should be non-negative.
* <p/>
* This is used to leave room for the links that connect a parent node
* with the child nodes that are in additional rows.
* This sets the {@link #alternateDefaults}' property of the same name.
* @name TreeLayout#alternateRowIndent
* @function.
* @return {number}
*/
/** @type {number} */
TreeLayout.prototype.alternateRowIndent;
Util.exportProperty(TreeLayout, 'alternateRowIndent', TreeLayout.prototype.alternateRowIndent);
Util.defineProperty(TreeLayout, { alternateRowIndent: 'alternateRowIndent' },
	/** @this {TreeLayout} */
	function() { return this._alternateDefaults.rowIndent; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._alternateDefaults.rowIndent !== val && val >= 0) {
			this._alternateDefaults.rowIndent = val;
			this.invalidateLayout();
		}
	}
);

/**
* Gets or sets the distance between comments.
* <p/>
* The default value is 10.
* <p/>
* This is used by {@link #addComments} and {@link #layoutComments}.
* This sets the {@link #alternateDefaults}' property of the same name.
* @name TreeLayout#alternateCommentSpacing
* @function.
* @return {number}
*/
/** @type {number} */
TreeLayout.prototype.alternateCommentSpacing;
Util.exportProperty(TreeLayout, 'alternateCommentSpacing', TreeLayout.prototype.alternateCommentSpacing);
Util.defineProperty(TreeLayout, { alternateCommentSpacing: 'alternateCommentSpacing' },
	/** @this {TreeLayout} */
	function() { return this._alternateDefaults.commentSpacing; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._alternateDefaults.commentSpacing !== val) {
			this._alternateDefaults.commentSpacing = val;
			this.invalidateLayout();
		}
	}
);

/**
* Gets or sets the distance between a node and its comments.
* <p/>
* The default value is 20.
* <p/>
* This is used by {@link #addComments} and {@link #layoutComments}.
* This sets the {@link #alternateDefaults}' property of the same name.
* @name TreeLayout#alternateCommentMargin
* @function.
* @return {number}
*/
/** @type {number} */
TreeLayout.prototype.alternateCommentMargin;
Util.exportProperty(TreeLayout, 'alternateCommentMargin', TreeLayout.prototype.alternateCommentMargin);
Util.defineProperty(TreeLayout, { alternateCommentMargin: 'alternateCommentMargin' },
	/** @this {TreeLayout} */
	function() { return this._alternateDefaults.commentMargin; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._alternateDefaults.commentMargin !== val) {
			this._alternateDefaults.commentMargin = val;
			this.invalidateLayout();
		}
	}
);

/**
* Gets or sets whether the TreeLayout should set the
* FromSpot for this parent node port.
* <p/>
* The default value is true -- this may modify the spot of the port of this node, the parent,
* if the node has only a single port.
* <p/>
* The spot used depends on the value of {@link #portSpot}.
* This sets the {@link #alternateDefaults}' property of the same name.
* @name TreeLayout#alternateSetsPortSpot
* @function.
* @return {boolean}
*/
/** @type {boolean} */
TreeLayout.prototype.alternateSetsPortSpot;
Util.exportProperty(TreeLayout, 'alternateSetsPortSpot', TreeLayout.prototype.alternateSetsPortSpot);
Util.defineProperty(TreeLayout, { alternateSetsPortSpot: 'alternateSetsPortSpot' },
	/** @this {TreeLayout} */
	function() { return this._alternateDefaults.setsPortSpot; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._alternateDefaults.setsPortSpot !== val) {
			this._alternateDefaults.setsPortSpot = val;
			this.invalidateLayout();
		}
	}
);

/**
* Gets or sets the spot that this node's port gets as its FromSpot.
* <p/>
* The default value is {@link Spot#Default}.
* <p/>
* A value of {@link Spot#Default} will cause the TreeLayout
* to assign a FromSpot based on the parent node's {@link TreeVertex#angle}.
* If the value is other than NoSpot, it is just assigned.
* When {@link #path} is {@link #PathSource},
* the port's ToSpot is set instead of the FromSpot.
* This sets the {@link #alternateDefaults}' property of the same name.
* @name TreeLayout#alternatePortSpot
* @this {TreeLayout}
* @function.
* @return {Spot}
*/
/** @type {Spot} */
TreeLayout.prototype.alternatePortSpot;
Util.exportProperty(TreeLayout, 'alternatePortSpot', TreeLayout.prototype.alternatePortSpot);
Util.defineProperty(TreeLayout, { alternatePortSpot: 'alternatePortSpot' },
  /** @this {TreeLayout} */
	function() { return this._alternateDefaults.portSpot; },
  /** @this {TreeLayout} */
	function(val) {
	  if (!this._alternateDefaults.portSpot.equals(val)) {
	    this._alternateDefaults.portSpot = val;
	    this.invalidateLayout();
	  }
	}
);

/**
* Gets or sets whether the TreeLayout should set the
* ToSpot for each child node port.
* <p/>
* The default value is true -- this may modify the spot of the ports of the children nodes,
* if the node has only a single port.
* <p/>
* The spot used depends on the value of {@link #childPortSpot}.
* This sets the {@link #alternateDefaults}' property of the same name.
* @name TreeLayout#alternateSetsChildPortSpot
* @function.
* @return {boolean}
*/
/** @type {boolean} */
TreeLayout.prototype.alternateSetsChildPortSpot;
Util.exportProperty(TreeLayout, 'alternateSetsChildPortSpot', TreeLayout.prototype.alternateSetsChildPortSpot);
Util.defineProperty(TreeLayout, { alternateSetsChildPortSpot: 'alternateSetsChildPortSpot' },
	/** @this {TreeLayout} */
	function() { return this._alternateDefaults.setsChildPortSpot; },
	/** @this {TreeLayout} */
	function(val) {
		if (this._alternateDefaults.setsChildPortSpot !== val) {
			this._alternateDefaults.setsChildPortSpot = val;
			this.invalidateLayout();
		}
	}
);

/**
* Gets or sets the spot that children nodes' ports get as their ToSpot
* The default value is {@link Spot#Default}.
* <p/>
* A value of Spot.Default will cause the TreeLayout
* to assign a ToSpot based on the parent node's {@link TreeVertex#angle}.
* <p/>
* If the value is other than NoSpot, it is just assigned.
* When {@link #path} is {@link #PathSource},
* the port's FromSpot is set instead of the ToSpot.
* This sets the {@link #alternateDefaults}' property of the same name.
* @name TreeLayout#alternateChildPortSpot
* @this {TreeLayout}
* @function.
* @return {Spot}
*/
/** @type {Spot} */
TreeLayout.prototype.alternateChildPortSpot;
Util.exportProperty(TreeLayout, 'alternateChildPortSpot', TreeLayout.prototype.alternateChildPortSpot);
Util.defineProperty(TreeLayout, { alternateChildPortSpot: 'alternateChildPortSpot' },
  /** @this {TreeLayout} */
	function() { return this._alternateDefaults.childPortSpot; },
  /** @this {TreeLayout} */
	function(val) {
	  if (!this._alternateDefaults.childPortSpot.equals(val)) {
	    this._alternateDefaults.childPortSpot = val;
	    this.invalidateLayout();
	  }
	}
);

/***********************************Enums*************************************/

// These values specify how to build a tree from the TreeNetwork
/**
* This value for {@link TreeLayout#path} causes the value of {@link Diagram#isTreePathToChildren}
* to effectively choose either {@link TreeLayout#PathDestination} (if true) or {@link TreeLayout#PathSource} (if false).
* @name TreeLayout#PathDefault
* @constant
* @static
* @return {EnumValue}
*/
TreeLayout['PathDefault'] = TreeLayout.PathDefault = Util.defineEnumValue(TreeLayout, 'PathDefault', -1);

/**
* The children of a {@link TreeVertex} are its {@link LayoutVertex#destinationVertexes},
* the collection of connected {@link LayoutEdge#toVertex}es;
* This value is used for {@link TreeLayout#path}.
* The tree roots are those {@link TreeVertex}es that have a zero {@link LayoutVertex#sourceEdgesCount}.
* @name TreeLayout#PathDestination
* @constant
* @static
* @return {EnumValue}
*/
TreeLayout['PathDestination'] = TreeLayout.PathDestination = Util.defineEnumValue(TreeLayout, 'PathDestination', 0);

/**
* The children of a {@link TreeVertex} are its {@link LayoutVertex#sourceVertexes},
* the collection of connected {@link LayoutEdge#fromVertex}es;
* This value is used for {@link TreeLayout#path}.
* The tree roots are those {@link TreeVertex}es that have a zero {@link LayoutVertex#destinationEdgesCount}.
* @name TreeLayout#PathSource
* @constant
* @static
* @return {EnumValue}
*/
TreeLayout['PathSource'] = TreeLayout.PathSource = Util.defineEnumValue(TreeLayout, 'PathSource', 1);

// These values specify whether to sort the children of a node,
// and in what order to position them.
/**
* Lay out each child in the order in which they were found;
* This value is used for {@link TreeLayout#sorting} or {@link TreeLayout#alternateSorting}.
* @name TreeLayout#SortingForwards
* @constant
* @static
* @return {EnumValue}
*/
TreeLayout['SortingForwards'] = TreeLayout.SortingForwards = Util.defineEnumValue(TreeLayout, 'SortingForwards', 10);

/**
* Lay out each child in reverse order from which they were found;
* This value is used for {@link TreeLayout#sorting} or {@link TreeLayout#alternateSorting}.
* @name TreeLayout#SortingReverse
* @constant
* @static
* @return {EnumValue}
*/
TreeLayout['SortingReverse'] = TreeLayout.SortingReverse = Util.defineEnumValue(TreeLayout, 'SortingReverse', 11);

/**
* Lay out each child according to the sort order given by {@link TreeVertex#comparer};
* This value is used for {@link TreeLayout#sorting} or {@link TreeLayout#alternateSorting}.
* @name TreeLayout#SortingAscending
* @constant
* @static
* @return {EnumValue}
*/
TreeLayout['SortingAscending'] = TreeLayout.SortingAscending = Util.defineEnumValue(TreeLayout, 'SortingAscending', 12);

/**
* Lay out each child in reverse sort order given by {@link TreeVertex#comparer};
* This value is used for {@link TreeLayout#sorting} or {@link TreeLayout#alternateSorting}.
* @name TreeLayout#SortingDescending
* @constant
* @static
* @return {EnumValue}
*/
TreeLayout['SortingDescending'] = TreeLayout.SortingDescending = Util.defineEnumValue(TreeLayout, 'SortingDescending', 13);

// These values specify how to position a parent {@link TreeVertex}
// relative to its children, or how to align children in a bus.
/**
* The parent is centered at the middle of the range of its child subtrees;
* This value is used for {@link TreeLayout#alignment} or {@link TreeLayout#alternateAlignment}.
* When there is a breadth limit that causes there to be multiple rows,
* the links that extend from the parent to those children in rows past
* the first one may cross over the nodes that are in earlier rows.
* @name TreeLayout#AlignmentCenterSubtrees
* @constant
* @static
* @return {EnumValue}
*/
TreeLayout['AlignmentCenterSubtrees'] = TreeLayout.AlignmentCenterSubtrees = Util.defineEnumValue(TreeLayout, 'AlignmentCenterSubtrees', 20);

/**
* The parent is centered at the middle of the range of its immediate child nodes;
* This value is used for {@link TreeLayout#alignment} or {@link TreeLayout#alternateAlignment}.
* When there is a breadth limit that causes there to be multiple rows,
* the links that extend from the parent to those children in rows past
* the first one may cross over the nodes that are in earlier rows.
* @name TreeLayout#AlignmentCenterChildren
* @constant
* @static
* @return {EnumValue}
*/
TreeLayout['AlignmentCenterChildren'] = TreeLayout.AlignmentCenterChildren = Util.defineEnumValue(TreeLayout, 'AlignmentCenterChildren', 21);

/**
* The parent is positioned near the first of its children;
* This value is used for {@link TreeLayout#alignment} or {@link TreeLayout#alternateAlignment}.
* @name TreeLayout#AlignmentStart
* @constant
* @static
* @return {EnumValue}
*/
TreeLayout['AlignmentStart'] = TreeLayout.AlignmentStart = Util.defineEnumValue(TreeLayout, 'AlignmentStart', 22);

/**
* The parent is positioned near the last of its children;
* This value is used for {@link TreeLayout#alignment} or {@link TreeLayout#alternateAlignment}.
* @name TreeLayout#AlignmentEnd
* @constant
* @static
* @return {EnumValue}
*/
TreeLayout['AlignmentEnd'] = TreeLayout.AlignmentEnd = Util.defineEnumValue(TreeLayout, 'AlignmentEnd', 23);

/**
* The children are positioned in a bus on both sides of an "aisle" where the links to them go,
* with the last odd child (if any) placed at the end of the aisle in the middle.
* The children, if they are themselves parents, continue at the same inherited angle;
* use {@link TreeLayout#AlignmentBusBranching} if you want grandchildren to proceed growing in
* the different angle as determined by the side.
* This value is used for {@link TreeLayout#alignment} or {@link TreeLayout#alternateAlignment}.
* A bus does not take {@link TreeVertex#breadthLimit} into account.
* @name TreeLayout#AlignmentBus
* @constant
* @static
* @return {EnumValue}
*/
TreeLayout['AlignmentBus'] = TreeLayout.AlignmentBus = Util.defineEnumValue(TreeLayout, 'AlignmentBus', 24);

/**
* Like {@link TreeLayout#AlignmentBus} with the children arranged on both sides of an "aisle"
* with any last odd child placed at the end of the aisle,
* but the children get an {@link TreeVertex#angle} that depends on which side of the aisle
* they were placed.
* This only works well when the {@link TreeLayout#treeStyle} is {@link TreeLayout#StyleLayered}.
* This value is used for {@link TreeLayout#alignment} or {@link TreeLayout#alternateAlignment}.
* A bus does not take {@link TreeVertex#breadthLimit} into account.
* @name TreeLayout#AlignmentBusBranching
* @constant
* @static
* @return {EnumValue}
*/
TreeLayout['AlignmentBusBranching'] = TreeLayout.AlignmentBusBranching = Util.defineEnumValue(TreeLayout, 'AlignmentBusBranching', 25);

/**
* The children are positioned in a bus, only on the top or left side of the parent;
* This value is used for {@link TreeLayout#alignment} or {@link TreeLayout#alternateAlignment}.
* A bus does not take {@link TreeVertex#breadthLimit} into account.
* @name TreeLayout#AlignmentTopLeftBus
* @constant
* @static
* @return {EnumValue}
*/
TreeLayout['AlignmentTopLeftBus'] = TreeLayout.AlignmentTopLeftBus = Util.defineEnumValue(TreeLayout, 'AlignmentTopLeftBus', 26);

/**
* The children are positioned in a bus, only on the bottom or right side of the parent;
* This value is used for {@link TreeLayout#alignment} or {@link TreeLayout#alternateAlignment}.
* A bus does not take {@link TreeVertex#breadthLimit} into account.
* @name TreeLayout#AlignmentBottomRightBus
* @constant
* @static
* @return {EnumValue}
*/
TreeLayout['AlignmentBottomRightBus'] = TreeLayout.AlignmentBottomRightBus = Util.defineEnumValue(TreeLayout, 'AlignmentBottomRightBus', 27);

// These values specify how closely packed the children of a node should be.
/**
* Only simple placement of children next to each other, as determined by their subtree breadth;
* This value is used for {@link TreeLayout#compaction} or {@link TreeLayout#alternateCompaction}.
* For any node, there will not be another node at any depth occupying the same breadth position,
* unless there are multiple rows.  In other words, if there is no breadth limit resulting in
* multiple rows, with this compaction mode it is as if every node were infinitely deep.
* @name TreeLayout#CompactionNone
* @constant
* @static
* @return {EnumValue}
*/
TreeLayout['CompactionNone'] = TreeLayout.CompactionNone = Util.defineEnumValue(TreeLayout, 'CompactionNone', 30);

/**
* A simple fitting of subtrees;
* This value is used for {@link TreeLayout#compaction} or {@link TreeLayout#alternateCompaction}.
* This mode produces more compact trees -- often nicer looking too.
* Nodes will not overlap each other, unless you have negative values
* for some of the spacing properties.
* However it is possible when the links are orthogonally styled that
* occasionally the subtrees will be placed so close together that some
* links may overlap the links or even the nodes of other subtrees.
* @name TreeLayout#CompactionBlock
* @constant
* @static
* @return {EnumValue}
*/
TreeLayout['CompactionBlock'] = TreeLayout.CompactionBlock = Util.defineEnumValue(TreeLayout, 'CompactionBlock', 31);

// These values specify the general style in which the nodes are laid out.
/**
* The normal tree style, where all of the children of each {@link TreeVertex} are lined up
* horizontally or vertically;
* This value is used for {@link TreeLayout#treeStyle}.
* Each {@link TreeVertex} gets its properties from its parent node.
* {@link TreeLayout#rootDefaults} is used for all default {@link TreeVertex} property values;
* {@link TreeLayout#alternateDefaults} is ignored.
* @name TreeLayout#StyleLayered
* @constant
* @static
* @return {EnumValue}
*/
TreeLayout['StyleLayered'] = TreeLayout.StyleLayered = Util.defineEnumValue(TreeLayout, 'StyleLayered', 40);

/**
* Just like the standard layered tree style, except that the nodes with children but no grandchildren
* have alternate properties;
* This value is used for {@link TreeLayout#treeStyle}.
* Each {@link TreeVertex} gets its properties from its parent node.
* However, for those nodes whose {@link TreeVertex#maxGenerationCount} is 1,
* in other words when it has children but no grandchildren,
* the properties are copied from {@link TreeLayout#alternateDefaults}.
* If the tree only has two levels, the root node gets the {@link TreeLayout#rootDefaults}.
* @name TreeLayout#StyleLastParents
* @constant
* @static
* @return {EnumValue}
*/
TreeLayout['StyleLastParents'] = TreeLayout.StyleLastParents = Util.defineEnumValue(TreeLayout, 'StyleLastParents', 41);

/**
* Alternate layers of the tree have different properties, typically including the angle;
* This value is used for {@link TreeLayout#treeStyle}.
* Each {@link TreeVertex} gets its properties from its grandparent node.
* The root nodes get their defaults from {@link TreeLayout#rootDefaults};
* the immediate children of root nodes get their defaults from {@link TreeLayout#alternateDefaults}.
* Depending on the properties used, it is possible for some link routes to cross over nodes.
* @name TreeLayout#StyleAlternating
* @constant
* @static
* @return {EnumValue}
*/
TreeLayout['StyleAlternating'] = TreeLayout.StyleAlternating = Util.defineEnumValue(TreeLayout, 'StyleAlternating', 42);

/**
* All of the nodes get the alternate properties, except the root node gets the default properties;
* This value is used for {@link TreeLayout#treeStyle}.
* The root node gets the {@link TreeLayout#rootDefaults} properties,
* the root node's children get the {@link TreeLayout#alternateDefaults} properties,
* and all the rest of the {@link TreeVertex}es get their properties from their parent node.
* @name TreeLayout#StyleRootOnly
* @constant
* @static
* @return {EnumValue}
*/
TreeLayout['StyleRootOnly'] = TreeLayout.StyleRootOnly = Util.defineEnumValue(TreeLayout, 'StyleRootOnly', 43);

// These values specify how to position the resulting trees in the document.
/**
* Position each tree in a non-overlapping fashion by increasing Y coordinates,
* starting at the {@link Layout#arrangementOrigin};
* This value is used for {@link TreeLayout#arrangement}.
* @name TreeLayout#ArrangementVertical
* @constant
* @static
* @return {EnumValue}
*/
TreeLayout['ArrangementVertical'] = TreeLayout.ArrangementVertical = Util.defineEnumValue(TreeLayout, 'ArrangementVertical', 50);

/**
* Position each tree in a non-overlapping fashion by increasing X coordinates,
* starting at the {@link Layout#arrangementOrigin};
* This value is used for {@link TreeLayout#arrangement}.
* @name TreeLayout#ArrangementHorizontal
* @constant
* @static
* @return {EnumValue}
*/
TreeLayout['ArrangementHorizontal'] = TreeLayout.ArrangementHorizontal = Util.defineEnumValue(TreeLayout, 'ArrangementHorizontal', 51);

/**
* Do not move each root node, but position all of their descendants relative to their root;
* This value is used for {@link TreeLayout#arrangement}.
* @name TreeLayout#ArrangementFixedRoots
* @constant
* @static
* @return {EnumValue}
*/
TreeLayout['ArrangementFixedRoots'] = TreeLayout.ArrangementFixedRoots = Util.defineEnumValue(TreeLayout, 'ArrangementFixedRoots', 52);


/***********************************TreeNetwork*******************************/
/*****************************************************************************/

/**
* @ignore
* @constructor
* @extends LayoutNetwork
* @category Layout
* @class
* This class represents an abstract graph of {@link TreeVertex}es and {@link TreeEdge}s
* that can be constructed based on the {@link Node}s and {@link Link}s of a {@link Diagram}
* so that the {@link TreeLayout} can operate independently of the diagram until it
* is time to commit any node positioning or link routing.
*/
function TreeNetwork() {
  LayoutNetwork.call(this);
}

Util.publish('TreeNetwork', TreeNetwork);

Util.inherit(TreeNetwork, LayoutNetwork);

/**
* @ignore
* Allocate a new instance of {@link TreeVertex}.
* @this {TreeNetwork}
* @return {LayoutVertex}
*/
TreeNetwork.prototype.createVertex = function() {
  return new TreeVertex();
};

/**
* @ignore
* Allocate a new instance of {@link TreeEdge}.
* @this {TreeNetwork}
* @return {LayoutEdge}
*/
TreeNetwork.prototype.createEdge = function() {
  return new TreeEdge();
};

/***********************************TreeVertex********************************/
/*****************************************************************************/

/**
* @constructor
* @extends LayoutVertex
* @category Layout
* @class
* This holds {@link TreeLayout}-specific information about {@link Node}s.
*/
function TreeVertex() {
  LayoutVertex.call(this);

  // tree specific properties:

  /**
  * Gets or sets whether this node has been initialized as part of {@link TreeLayout#doLayout} when building the tree structures.
  * <p/>
  * The default value is false.
  * @name TreeVertex#initialized
  * @function.
  * @return {boolean}
  */
  /** @expose @type {boolean} */
  this.initialized = false;

  /**
  * Gets or sets the logical parent for this node.
  * <p/>
  * The default value is null.
  * <p/>
  * This structural property is computed in {@link TreeLayout#doLayout} when building the tree structures.
  * You should probably not be setting this property.
  * @name TreeVertex#parent
  * @function.
  * @return {TreeVertex}
  */
  /** @expose @type {TreeVertex} */
  this.parent = null;

  /**
  * Gets or sets the logical children for this node.
  * <p/>
  * The default value is an empty array.
  * <p/>
  * This structural property is computed in {@link TreeLayout#doLayout} when building the tree structures.
  * You should probably not be setting this property.
  * @name TreeVertex#children
  * @function.
  * @return {Array.<TreeVertex>}
  */
  /** @expose @type {Array.<TreeVertex>} */
  this.children = [];

  /**
  * Gets or sets the number of single-parent ancestors this node has.
  * <p/>
  * This could also be interpreted as which layer this node is in.
  * A root node will have a value of zero.
  * <p/>
  * This informational property is computed in {@link TreeLayout#doLayout} when building the tree structures.
  * You should probably not be setting this property.
  * @name TreeVertex#level
  * @function.
  * @return {number}
  */
  /** @expose @type {number} */
  this.level = 0;

  /**
  * Gets or sets the number of descendants this node has.
  * <p/>
  * For a leaf node, this will be zero.
  * <p/>
  * This informational property is computed as part of the {@link TreeLayout#initializeTreeVertexValues} pass.
  * You should probably not be setting this property.
  * @name TreeVertex#descendantCount
  * @function.
  * @return {number}
  */
  /** @expose @type {number} */
  this.descendantCount = 0;

  /**
  * Gets or sets the maximum number of children of any descendant of this node.
  * <p/>
  * For a leaf node, this will be zero.
  * <p/>
  * This informational property is computed as part of the {@link TreeLayout#initializeTreeVertexValues} pass.
  * You should probably not be setting this property.
  * @name TreeVertex#maxChildrenCount
  * @function.
  * @return {number}
  */
  /** @expose @type {number} */
  this.maxChildrenCount = 0;

  /**
  * Gets or sets the maximum depth of the subtrees below this node.
  * <p/>
  * For a leaf node, this will be zero.
  * <p/>
  * This informational property is computed as part of the {@link TreeLayout#initializeTreeVertexValues} pass.
  * You should probably not be setting this value.
  * @name TreeVertex#maxGenerationCount
  * @function.
  * @return {number}
  */
  /** @expose @type {number} */
  this.maxGenerationCount = 0;

  /**
  * Gets or sets an array of {@link Node}s that will be positioned near this node.
  * <p/>
  * The default value is null.
  * <p/>
  * These objects should not have their own {@link TreeVertex}es to be laid out.
  * Typically these will be {@link Node}s whose Category is "Comment".
  * This array should be allocated and initialized in {@link TreeLayout#addComments}.
  * @name TreeVertex#comments
  * @function.
  * @return {Array.<Node>}
  */
  /** @expose @type {Array.<Node>} */
  this.comments = null;

  // these three Point or Size objects get clobbered a lot, and we don't bother freezing them
  // they are not exposed because the property setters displace the values
  /** @ignore @type {Point} */
  this._relativePosition = new Point(0, 0);
  /** @ignore @type {Size} */
  this._subtreeSize = new Size(0, 0);
  /** @ignore @type {Point} */
  this._subtreeOffset = new Point(0, 0);

  // unexposed properties
  /** @ignore @type {boolean} */
  this.routeFirstRow = false;
  /** @ignore @type {boolean} */
  this.routeAroundCentered = false;
  /** @ignore @type {boolean} */
  this.routeAroundLastParent = false;

  // internal state
  /** @ignore @type {Array.<Point>} */
  this.leftFringe = null;
  /** @ignore @type {Array.<Point>} */
  this.rightFringe = null;

  // inherited properties:

  /**
  * Gets or sets whether and in what order the children should be sorted.
  * <p/>
  * The default value is {@link TreeLayout#SortingForwards}.
  * <p/>
  * This inherited property is initialized in the {@link TreeLayout#initializeTreeVertexValues} pass.
  * @name TreeVertex#sorting
  * @function.
  * @return {EnumValue}
  */
  /** @expose @type {EnumValue} */
  this.sorting = TreeLayout.SortingForwards;

  /**
  * Gets or sets how the children should be sorted.
  * <p/>
  * This inherited property is initialized in the {@link TreeLayout#initializeTreeVertexValues} pass.
  * @name TreeVertex#comparer
  * @function.
  * @return {function(TreeVertex, TreeVertex):number}
  */
  /** @expose @type {function(TreeVertex, TreeVertex):number} */
  this.comparer = LayoutVertex.standardComparer;

  /**
  * Gets or sets the actual absolute angle at which this node should grow.
  * <p/>
  * The default value is zero, meaning that general tree growth should proceed rightwards along the X axis.
  * <p/>
  * This inherited property is initialized in the {@link TreeLayout#initializeTreeVertexValues} pass.
  * By default this is the same as the Angle of the parent {@link TreeVertex}.
  * However, after the initial propagation of property values, perhaps in
  * an override of {@link TreeLayout#assignTreeVertexValues},
  * you could just set this property to specify the angle at which this node grows its subtrees.
  * @name TreeVertex#angle
  * @function.
  * @return {number}
  */
  /** @expose @type {number} */
  this.angle = 0;

  /**
  * Gets or sets how this parent node should be aligned relative to its children.
  * <p/>
  * The default value is {@link TreeLayout#AlignmentCenterChildren}.
  * <p/>
  * This inherited property is initialized in the {@link TreeLayout#initializeTreeVertexValues} pass.
  * @name TreeVertex#alignment
  * @function.
  * @return {EnumValue}
  */
  /** @expose @type {EnumValue} */
  this.alignment = TreeLayout.AlignmentCenterChildren;

  /**
  * Gets or sets the distance the first child should be indented.
  * <p/>
  * The default value is zero. The value should be non-negative.
  * <p/>
  * This inherited property is initialized in the {@link TreeLayout#initializeTreeVertexValues} pass.
  * This property is only sensible when the {@link #alignment} is
  * {@link TreeLayout#AlignmentStart} or {@link TreeLayout#AlignmentEnd}.
  * @name TreeVertex#nodeIndent
  * @function.
  * @return {number}
  */
  /** @expose @type {number} */
  this.nodeIndent = 0;

  /**
  * Gets or sets whether the first child should be indented past the parent node's breadth.
  * <p/>
  * The default value is 0.0 -- the only start or end spacing is provided by {@link #nodeIndent}.
  * Values must range from 0.0 to 1.0, where 1.0 means the full breadth of this node.
  * <p/>
  * This inherited property is initialized in the {@link TreeLayout#initializeTreeVertexValues} pass.
  * This property is only sensible when the {@link #alignment} is
  * {@link TreeLayout#AlignmentStart} or {@link TreeLayout#AlignmentEnd}.
  * @name TreeVertex#nodeIndentPastParent
  * @function.
  * @return {number}
  */
  /** @expose @type {number} */
  this.nodeIndentPastParent = 0;

  /**
  * Gets or sets the distance between child nodes.
  * <p/>
  * The default value is 20.
  * <p/>
  * A negative value will cause sibling nodes to overlap.
  * This inherited property is initialized in the {@link TreeLayout#initializeTreeVertexValues} pass.
  * @name TreeVertex#nodeSpacing
  * @function.
  * @return {number}
  */
  /** @expose @type {number} */
  this.nodeSpacing = 20;

  /**
  * Gets or sets the distance between this node and its children.
  * <p/>
  * The default value is 50.
  * <p/>
  * Negative values may cause children to overlap with the parent.
  * This inherited property is initialized in the {@link TreeLayout#initializeTreeVertexValues} pass.
  * @name TreeVertex#layerSpacing
  * @function.
  * @return {number}
  */
  /** @expose @type {number} */
  this.layerSpacing = 50;

  /**
  * Gets or sets the fraction of this node's depth that may overlap with the children's layer.
  * <p/>
  * The default value is 0.0 -- there is overlap only if {@link #layerSpacing} is negative.
  * Values must range from 0.0 to 1.0, where 1.0 means the full depth of this node.
  * <p/>
  * When this value is greater than 0.0, there might not be overlap if {@link #layerSpacing}
  * is larger than the depth of this node times this fraction.
  * Even when this value is 0.0, there may be overlap when {@link #layerSpacing} is negative.
  * This inherited property is initialized in the {@link TreeLayout#initializeTreeVertexValues} pass.
  * @name TreeVertex#layerSpacingParentOverlap
  * @function.
  * @return {number}
  */
  /** @expose @type {number} */
  this.layerSpacingParentOverlap = 0;

  /**
  * Gets or sets how the children of this node should be packed together.
  * <p/>
  * The default value is {@link TreeLayout#CompactionBlock}.
  * <p/>
  * This inherited property is initialized in the {@link TreeLayout#initializeTreeVertexValues} pass.
  * @name TreeVertex#compaction
  * @function.
  * @return {EnumValue}
  */
  /** @expose @type {EnumValue} */
  this.compaction = TreeLayout.CompactionBlock;

  /**
  * Gets or sets how broad a node and its descendants should be.
  * <p/>
  * By default this is zero.  A value of zero imposes no limit;
  * a positive value will specify a limit for the total width of this subtree.
  * <p/>
  * This inherited property is initialized in the {@link TreeLayout#initializeTreeVertexValues} pass.
  * @name TreeVertex#breadthLimit
  * @function.
  * @return {number}
  */
  /** @expose @type {number} */
  this.breadthLimit = 0;

  /**
  * Gets or sets the distance between rows within one layer, all sharing the same parent.
  * <p/>
  * The default value is 25.
  * <p/>
  * Negative values may cause nodes to overlap.
  * This inherited property is initialized in the {@link TreeLayout#initializeTreeVertexValues} pass.
  * @name TreeVertex#rowSpacing
  * @function.
  * @return {number}
  */
  /** @expose @type {number} */
  this.rowSpacing = 25;

  /**
  * Gets or sets the distance the first child of each row should be indented.
  * <p/>
  * The default value is 10.  The value should be non-negative.
  * <p/>
  * This inherited property is initialized in the {@link TreeLayout#initializeTreeVertexValues} pass.
  * This property is only used when the {@link #breadthLimit} is positive,
  * and some initial space needs to be reserved in each row of nodes for the links
  * that are routed around those rows.
  * @name TreeVertex#rowIndent
  * @function.
  * @return {number}
  */
  /** @expose @type {number} */
  this.rowIndent = 10;

  /**
  * Gets or sets the space to leave between consecutive comments.
  * <p/>
  * The default value is 10.
  * <p/>
  * Negative values may cause comments to overlap.
  * This inherited property is initialized in the {@link TreeLayout#initializeTreeVertexValues} pass.
  * @name TreeVertex#commentSpacing
  * @function.
  * @return {number}
  */
  /** @expose @type {number} */
  this.commentSpacing = 10;

  /**
  * Gets or sets the space to leave between the node and the comments.
  * <p/>
  * The default value is 20.
  * <p/>
  * Negative values may cause comments to overlap with the node.
  * This inherited property is initialized in the {@link TreeLayout#initializeTreeVertexValues} pass.
  * @name TreeVertex#commentMargin
  * @function.
  * @return {number}
  */
  /** @expose @type {number} */
  this.commentMargin = 20;

  /**
  * Gets or sets whether the TreeLayout should set the FromSpot for this parent node port.
  * <p/>
  * The default value is true -- this may modify the spot of the port of this node, the parent,
  * if the node has only a single port.
  * <p/>
  * This inherited property is initialized in the {@link TreeLayout#initializeTreeVertexValues} pass.
  * The spot used depends on the value of {@link #portSpot}.
  * @name TreeVertex#setsPortSpot
  * @function.
  * @return {boolean}
  */
  /** @expose @type {boolean} */
  this.setsPortSpot = true;

  /**
  * Gets or sets the spot that this node's port gets as its FromSpot,
  * if {@link #setsPortSpot} is true and the node has only a single port.
  * <p/>
  * The default value is {@link Spot#Default}.
  * <p/>
  * This inherited property is initialized in the {@link TreeLayout#initializeTreeVertexValues} pass.
  * A value of {@link Spot#Default} will cause the TreeLayout
  * to assign a FromSpot based on the parent node's {@link TreeVertex#angle}.
  * If the value is other than NoSpot, it is just assigned.
  * When {@link TreeLayout#path} is {@link TreeLayout#PathSource}, the port's ToSpot is set instead of the FromSpot.
  * @name TreeVertex#portSpot
  * @function.
  * @return {Spot}
  */
  /** @expose @type {Spot} */
  this.portSpot = Spot.Default;

  /**
  * Gets or sets whether the TreeLayout should set the ToSpot for each child node port.
  * <p/>
  * The default value is true -- this may modify the spots of the ports of the children nodes,
  * if the node has only a single port.
  * <p/>
  * This inherited property is initialized in the {@link TreeLayout#initializeTreeVertexValues} pass.
  * The spot used depends on the value of {@link #childPortSpot}.
  * @name TreeVertex#setsChildPortSpot
  * @function.
  * @return {boolean}
  */
  /** @expose @type {boolean} */
  this.setsChildPortSpot = true;

  /**
  * Gets or sets the spot that children nodes' ports get as their ToSpot,
  * if {@link #setsChildPortSpot} is true and the node has only a single port.
  * <p/>
  * The default value is {@link Spot#Default}.
  * <p/>
  * This inherited property is initialized in the {@link TreeLayout#initializeTreeVertexValues} pass.
  * A value of {@link Spot#Default} will cause the TreeLayout
  * to assign a ToSpot based on the parent node's {@link TreeVertex#angle}.
  * If the value is other than NoSpot, it is just assigned.
  * When {@link TreeLayout#path} is {@link TreeLayout#PathSource}, the port's FromSpot is set instead of the ToSpot.
  * @name TreeVertex#childPortSpot
  * @function.
  * @return {Spot}
  */
  /** @expose @type {Spot} */
  this.childPortSpot = Spot.Default;
}

Util.publish('TreeVertex', TreeVertex);

Util.inherit(TreeVertex, LayoutVertex);

/**
* Copy inherited properties from another TreeVertex to this one.
* @expose
* @this {TreeVertex}
* @param {TreeVertex} copy
*/
TreeVertex.prototype.copyInheritedPropertiesFrom = function(copy) {
  if (copy === null) return;
  this.sorting = copy.sorting;
  this.comparer = copy.comparer;
  this.angle = copy.angle;
  this.alignment = copy.alignment;
  this.nodeIndent = copy.nodeIndent;
  this.nodeIndentPastParent = copy.nodeIndentPastParent;
  this.nodeSpacing = copy.nodeSpacing;
  this.layerSpacing = copy.layerSpacing;
  this.layerSpacingParentOverlap = copy.layerSpacingParentOverlap;
  this.compaction = copy.compaction;
  this.breadthLimit = copy.breadthLimit;
  this.rowSpacing = copy.rowSpacing;
  this.rowIndent = copy.rowIndent;
  this.commentSpacing = copy.commentSpacing;
  this.commentMargin = copy.commentMargin;
  this.setsPortSpot = copy.setsPortSpot;
  this.portSpot = copy.portSpot;
  this.setsChildPortSpot = copy.setsChildPortSpot;
  this.childPortSpot = copy.childPortSpot;
};

/***********************************Properties********************************/

/**
* Gets the number of immediate children this node has.
* <p/>
* The default value is zero.
* @name TreeVertex#childrenCount
* @function.
* @return {number}
*/
/** @type {number} */
TreeVertex.prototype.childrenCount;
Util.defineReadOnlyProperty(TreeVertex, { childrenCount: 'childrenCount' },
  /** @this {TreeVertex} */
  function() { return this.children.length; }
);

/**
* Gets or sets the position of this node relative to its parent node.
* <p/>
* This informational property is computed during {@link TreeLayout#doLayout}.
* You should probably not be setting this property.
* @name TreeVertex#relativePosition
* @function.
* @return {Point}
*/
/** @type {Point} */
TreeVertex.prototype.relativePosition;
Util.exportProperty(TreeVertex, 'relativePosition', TreeVertex.prototype.relativePosition);
Util.defineProperty(TreeVertex, { relativePosition: 'relativePosition' },
  /** @this {TreeVertex} */
  function() { return this._relativePosition; },
  /** @this {TreeVertex} */
  function(val) {
    Util.checkClass(val, Point, TreeVertex, 'relativePosition');
    this._relativePosition.set(val);
  }
);

/**
* Gets or sets the size of the subtree (including all descendants) parented by this node.
* <p/>
* This informational property is computed during {@link TreeLayout#doLayout}.
* Of course if there are no children, this is just the same as Size.
* You should probably not be setting this property.
* @name TreeVertex#subtreeSize
* @function.
* @return {Size}
*/
/** @type {Size} */
TreeVertex.prototype.subtreeSize;
Util.exportProperty(TreeVertex, 'subtreeSize', TreeVertex.prototype.subtreeSize);
Util.defineProperty(TreeVertex, { subtreeSize: 'subtreeSize' },
  /** @this {TreeVertex} */
  function() { return this._subtreeSize; },
  /** @this {TreeVertex} */
  function(val) {
    Util.checkClass(val, Size, TreeVertex, 'subtreeSize');
    this._subtreeSize.set(val);
  }
);

/**
* Gets or sets the offset of this parent node relative to its whole subtree.
* <p/>
* This informational property is computed during {@link TreeLayout#doLayout}.
* Of course if there are no children, this is just (0, 0).
* You should probably not be setting this property.
* @name TreeVertex#subtreeOffset
* @function.
* @return {Point}
*/
/** @type {Point} */
TreeVertex.prototype.subtreeOffset;
Util.exportProperty(TreeVertex, 'subtreeOffset', TreeVertex.prototype.subtreeOffset);
Util.defineProperty(TreeVertex, { subtreeOffset: 'subtreeOffset' },
  /** @this {TreeVertex} */
  function() { return this._subtreeOffset; },
  /** @this {TreeVertex} */
  function(val) {
    Util.checkClass(val, Point, TreeVertex, 'subtreeOffset');
    this._subtreeOffset.set(val);
  }
);


/***********************************TreeEdge**********************************/
/*****************************************************************************/

/**
* @constructor
* @extends LayoutEdge
* @category Layout
* @class
* This holds {@link TreeLayout}-specific information about {@link Link}s.
*/
function TreeEdge() {
  LayoutEdge.call(this);

  // tree specific properties:

  // this gets clobbered, but we don't bother to freeze it
  // this is not exposed because the property setter displaces the X,Y values
  /** @ignore @type {Point} */
  this._relativePoint = new Point(0, 0);
}

Util.publish('TreeEdge', TreeEdge);

Util.inherit(TreeEdge, LayoutEdge);

/**
* Commits the position of the Link and routes it.
* @this {TreeEdge}
*/
TreeEdge.prototype.commit = function() {
  var link = this.link;
  if (link === null) return;
  if (link.routing === Link.AvoidsNodes) return;

  var layout = this.network.layout;
  var parent = null;
  var child = null;
  switch (layout._effectivePath) {
    case TreeLayout.PathDestination: parent = this.fromVertex; child = this.toVertex; break;
    case TreeLayout.PathSource: parent = this.toVertex; child = this.fromVertex; break;
    default: Util.throwError('Unhandled path value ' + layout._effectivePath.toString());
  }
  if (parent === null || child === null) return;

  var p = this._relativePoint;
  if (p.x === 0 && p.y === 0 && !parent.routeFirstRow) { // no rows
    this.adjustRouteForAngleChange(parent, child);
    return;
  }
  var vertexbounds = parent.bounds;
  var angle = layout.orthoAngle(parent);
  var layerspacing = layout.computeLayerSpacing(parent);
  var rowspacing = parent.rowSpacing;
  link.updateRoute();
  var bezier = (link.curve === Link.Bezier);
  var ortho = link.isOrthogonal;
  var idx;
  var prev;
  var next;
  var last;
  link.startRoute();
  if (ortho || bezier) {
    idx = 2;
    while (link.pointsCount > 4) link.removePoint(2);
    prev = link.getPoint(1);
    next = link.getPoint(2);
  } else {
    idx = 1;
    while (link.pointsCount > 3) link.removePoint(1);
    prev = link.getPoint(0);
    next = link.getPoint(link.pointsCount - 1);
  }
  last = link.getPoint(link.pointsCount - 1);
  var c;
  if (angle === 0) {
    if (parent.alignment === TreeLayout.AlignmentEnd) {
      // route around at Y coordinate relative to the bottom of the parent node
      c = vertexbounds.bottom + p.y;
      // try to keep the links straight from the parent node -- consider room from RowIndent and NodeIndent
      if (p.y === 0 && prev.y > last.y + parent.rowIndent) {
        c = Math.min(c, Math.max(prev.y, c - layout.computeNodeIndent(parent)));
      }
    } else if (parent.alignment === TreeLayout.AlignmentStart) {
      // route around at Y coordinate relative to the top of the parent node
      c = vertexbounds.top + p.y;
      // try to keep the links straight from the parent node -- consider room from RowIndent and NodeIndent
      if (p.y === 0 && prev.y < last.y - parent.rowIndent) {
        c = Math.max(c, Math.min(prev.y, c + layout.computeNodeIndent(parent)));
      }
    } else if (parent.routeAroundCentered || (parent.routeAroundLastParent && parent.maxGenerationCount === 1)) {
      c = vertexbounds.top - parent._subtreeOffset.y + p.y;
    } else {
      c = vertexbounds.y + vertexbounds.height / 2 + p.y;
    }
    if (bezier) {  // curved segments
      // add a straight curve at Y-coord C
      link.insertPointAt(idx, prev.x, c); idx++;
      link.insertPointAt(idx, vertexbounds.right + layerspacing, c); idx++;
      link.insertPointAt(idx, vertexbounds.right + layerspacing + (p.x - rowspacing) / 3, c); idx++;
      link.insertPointAt(idx, vertexbounds.right + layerspacing + (p.x - rowspacing) * 2 / 3, c); idx++;
      link.insertPointAt(idx, vertexbounds.right + layerspacing + (p.x - rowspacing), c); idx++;
      link.insertPointAt(idx, next.x, c); idx++;
    } else {  // straight line segments
      if (ortho) { link.insertPointAt(idx, vertexbounds.right + layerspacing / 2, prev.y); idx++; }
      link.insertPointAt(idx, vertexbounds.right + layerspacing / 2, c); idx++;
      link.insertPointAt(idx, vertexbounds.right + layerspacing + p.x - (ortho ? rowspacing / 2 : rowspacing), c); idx++;
      if (ortho) { link.insertPointAt(idx, link.getPoint(idx - 1).x, next.y); idx++; }
    }
  } else if (angle === 90) {
    if (parent.alignment === TreeLayout.AlignmentEnd) {
      c = vertexbounds.right + p.x;
      if (p.x === 0 && prev.x > last.x + parent.rowIndent) {
        c = Math.min(c, Math.max(prev.x, c - layout.computeNodeIndent(parent)));
      }
    } else if (parent.alignment === TreeLayout.AlignmentStart) {
      c = vertexbounds.left + p.x;
      if (p.x === 0 && prev.x < last.x - parent.rowIndent) {
        c = Math.max(c, Math.min(prev.x, c + layout.computeNodeIndent(parent)));
      }
    } else if (parent.routeAroundCentered || (parent.routeAroundLastParent && parent.maxGenerationCount === 1)) {
      c = vertexbounds.left - parent._subtreeOffset.x + p.x;
    } else {
      c = vertexbounds.x + vertexbounds.width / 2 + p.x;
    }
    if (bezier) {
      link.insertPointAt(idx, c, prev.y); idx++;
      link.insertPointAt(idx, c, vertexbounds.bottom + layerspacing); idx++;
      link.insertPointAt(idx, c, vertexbounds.bottom + layerspacing + (p.y - rowspacing) / 3); idx++;
      link.insertPointAt(idx, c, vertexbounds.bottom + layerspacing + (p.y - rowspacing) * 2 / 3); idx++;
      link.insertPointAt(idx, c, vertexbounds.bottom + layerspacing + (p.y - rowspacing)); idx++;
      link.insertPointAt(idx, c, next.y); idx++;
    } else {
      if (ortho) { link.insertPointAt(idx, prev.x, vertexbounds.bottom + layerspacing / 2); idx++; }
      link.insertPointAt(idx, c, vertexbounds.bottom + layerspacing / 2); idx++;
      link.insertPointAt(idx, c, vertexbounds.bottom + layerspacing + p.y - (ortho ? rowspacing / 2 : rowspacing)); idx++;
      if (ortho) { link.insertPointAt(idx, next.x, link.getPoint(idx - 1).y); idx++; }
    }
  } else if (angle === 180) {
    if (parent.alignment === TreeLayout.AlignmentEnd) {
      c = vertexbounds.bottom + p.y;
      if (p.y === 0 && prev.y > last.y + parent.rowIndent) {
        c = Math.min(c, Math.max(prev.y, c - layout.computeNodeIndent(parent)));
      }
    } else if (parent.alignment === TreeLayout.AlignmentStart) {
      c = vertexbounds.top + p.y;
      if (p.y === 0 && prev.y < last.y - parent.rowIndent) {
        c = Math.max(c, Math.min(prev.y, c + layout.computeNodeIndent(parent)));
      }
    } else if (parent.routeAroundCentered || (parent.routeAroundLastParent && parent.maxGenerationCount === 1)) {
      c = vertexbounds.top - parent._subtreeOffset.y + p.y;
    } else {
      c = vertexbounds.y + vertexbounds.height / 2 + p.y;
    }
    if (bezier) {
      link.insertPointAt(idx, prev.x, c); idx++;
      link.insertPointAt(idx, vertexbounds.left - layerspacing, c); idx++;
      link.insertPointAt(idx, vertexbounds.left - layerspacing + (p.x + rowspacing) / 3, c); idx++;
      link.insertPointAt(idx, vertexbounds.left - layerspacing + (p.x + rowspacing) * 2 / 3, c); idx++;
      link.insertPointAt(idx, vertexbounds.left - layerspacing + (p.x + rowspacing), c); idx++;
      link.insertPointAt(idx, next.x, c); idx++;
    } else {
      if (ortho) { link.insertPointAt(idx, vertexbounds.left - layerspacing / 2, prev.y); idx++; }
      link.insertPointAt(idx, vertexbounds.left - layerspacing / 2, c); idx++;
      link.insertPointAt(idx, vertexbounds.left - layerspacing + p.x + (ortho ? rowspacing / 2 : rowspacing), c); idx++;
      if (ortho) { link.insertPointAt(idx, link.getPoint(idx - 1).x, next.y); idx++; }
    }
  } else if (angle === 270) {
    if (parent.alignment === TreeLayout.AlignmentEnd) {
      c = vertexbounds.right + p.x;
      if (p.x === 0 && prev.x > last.x + parent.rowIndent) {
        c = Math.min(c, Math.max(prev.x, c - layout.computeNodeIndent(parent)));
      }
    } else if (parent.alignment === TreeLayout.AlignmentStart) {
      c = vertexbounds.left + p.x;
      if (p.x === 0 && prev.x < last.x - parent.rowIndent) {
        c = Math.max(c, Math.min(prev.x, c + layout.computeNodeIndent(parent)));
      }
    } else if (parent.routeAroundCentered || (parent.routeAroundLastParent && parent.maxGenerationCount === 1)) {
      c = vertexbounds.left - parent._subtreeOffset.x + p.x;
    } else {
      c = vertexbounds.x + vertexbounds.width / 2 + p.x;
    }
    if (bezier) {
      link.insertPointAt(idx, c, prev.y); idx++;
      link.insertPointAt(idx, c, vertexbounds.top - layerspacing); idx++;
      link.insertPointAt(idx, c, vertexbounds.top - layerspacing + (p.y + rowspacing) / 3); idx++;
      link.insertPointAt(idx, c, vertexbounds.top - layerspacing + (p.y + rowspacing) * 2 / 3); idx++;
      link.insertPointAt(idx, c, vertexbounds.top - layerspacing + (p.y + rowspacing)); idx++;
      link.insertPointAt(idx, c, next.y); idx++;
    } else {
      if (ortho) { link.insertPointAt(idx, prev.x, vertexbounds.top - layerspacing / 2); idx++; }
      link.insertPointAt(idx, c, vertexbounds.top - layerspacing / 2); idx++;
      link.insertPointAt(idx, c, vertexbounds.top - layerspacing + p.y + (ortho ? rowspacing / 2 : rowspacing)); idx++;
      if (ortho) { link.insertPointAt(idx, next.x, link.getPoint(idx - 1).y); idx++; }
    }
  } else {
    Util.throwError('Invalid angle ' + angle);
  }
  link.commitRoute();
};

/**
* @ignore
* @this {TreeEdge}
* @param {LayoutVertex} parent
* @param {LayoutVertex} child
*/
TreeEdge.prototype.adjustRouteForAngleChange = function(parent, child) {
  if (Debug) Util.checkClass(parent, TreeVertex, TreeEdge, 'adjustRouteForAngleChange:parent');
  if (Debug) Util.checkClass(child, TreeVertex, TreeEdge, 'adjustRouteForAngleChange:child');
  var link = this.link;
  var layout = this.network.layout;
  var angle = layout.orthoAngle(parent);
  var childangle = layout.orthoAngle(child);
  if (angle === childangle) return;
  var layerspacing = layout.computeLayerSpacing(parent);
  var pb = parent.bounds;
  var cb = child.bounds;
  // but maybe an Angle change causes the child node not to be adjacent to the layer
  // separating it with the parent node; only need to do anything if that's the case
  if ((angle === 0 && cb.left - pb.right < layerspacing + 1) ||
      (angle === 90 && cb.top - pb.bottom < layerspacing + 1) ||
      (angle === 180 && pb.left - cb.right < layerspacing + 1) ||
      (angle === 270 && pb.top - cb.bottom < layerspacing + 1)) {
    return;
  }
  link.updateRoute();
  var bezier = (link.curve === Link.Bezier);
  var ortho = link.isOrthogonal;
  var alignbus = layout.isBusAlignment(this.fromVertex.alignment);
  link.startRoute();
  var x;
  var y;
  if (angle === 0) {
    x = pb.right + layerspacing / 2;
    if (bezier) {  // curved segments
      if (link.pointsCount === 4) {
        y = link.getPoint(3).y;
        link.setPointAt(1, x - 20, link.getPoint(1).y);
        link.insertPointAt(2, x - 20, y);
        link.insertPointAt(3, x, y);
        link.insertPointAt(4, x + 20, y);
        link.setPointAt(5, link.getPoint(5).x, y);
      }
    } else if (ortho) {
      if (alignbus) {
        link.setPointAt(3, link.getPoint(2).x, link.getPoint(4).y);
      } else if (link.pointsCount === 6) {
        link.setPointAt(2, x, link.getPoint(2).y);
        link.setPointAt(3, x, link.getPoint(3).y);
      }
    } else {
      if (link.pointsCount === 4) {
        link.insertPointAt(2, x, link.getPoint(2).y);
      } else if (link.pointsCount === 3) {
        link.setPointAt(1, x, link.getPoint(2).y);
      } else if (link.pointsCount === 2) {
        link.insertPointAt(1, x, link.getPoint(1).y);
      }
    }
  } else if (angle === 90) {
    y = pb.bottom + layerspacing / 2;
    if (bezier) {  // curved segments
      if (link.pointsCount === 4) {
        x = link.getPoint(3).x;
        link.setPointAt(1, link.getPoint(1).x, y - 20);
        link.insertPointAt(2, x, y - 20);
        link.insertPointAt(3, x, y);
        link.insertPointAt(4, x, y + 20);
        link.setPointAt(5, x, link.getPoint(5).y);
      }
    } else if (ortho) {
      if (alignbus) {
        link.setPointAt(3, link.getPoint(2).x, link.getPoint(4).y);
      } else if (link.pointsCount === 6) {
        link.setPointAt(2, link.getPoint(2).x, y);
        link.setPointAt(3, link.getPoint(3).x, y);
      }
    } else {
      if (link.pointsCount === 4) {
        link.insertPointAt(2, link.getPoint(2).x, y);
      } else if (link.pointsCount === 3) {
        link.setPointAt(1, link.getPoint(2).x, y);
      } else if (link.pointsCount === 2) {
        link.insertPointAt(1, link.getPoint(1).x, y);
      }
    }
  } else if (angle === 180) {
    x = pb.left - layerspacing / 2;
    if (bezier) {  // curved segments
      if (link.pointsCount === 4) {
        y = link.getPoint(3).y;
        link.setPointAt(1, x + 20, link.getPoint(1).y);
        link.insertPointAt(2, x + 20, y);
        link.insertPointAt(3, x, y);
        link.insertPointAt(4, x - 20, y);
        link.setPointAt(5, link.getPoint(5).x, y);
      }
    } else if (ortho) {
      if (alignbus) {
        link.setPointAt(3, link.getPoint(2).x, link.getPoint(4).y);
      } else if (link.pointsCount === 6) {
        link.setPointAt(2, x, link.getPoint(2).y);
        link.setPointAt(3, x, link.getPoint(3).y);
      }
    } else {
      if (link.pointsCount === 4) {
        link.insertPointAt(2, x, link.getPoint(2).y);
      } else if (link.pointsCount === 3) {
        link.setPointAt(1, x, link.getPoint(2).y);
      } else if (link.pointsCount === 2) {
        link.insertPointAt(1, x, link.getPoint(1).y);
      }
    }
  } else if (angle === 270) {
    y = pb.top - layerspacing / 2;
    if (bezier) {  // curved segments
      if (link.pointsCount === 4) {
        x = link.getPoint(3).x;
        link.setPointAt(1, link.getPoint(1).x, y + 20);
        link.insertPointAt(2, x, y + 20);
        link.insertPointAt(3, x, y);
        link.insertPointAt(4, x, y - 20);
        link.setPointAt(5, x, link.getPoint(5).y);
      }
    } else if (ortho) {
      if (alignbus) {
        link.setPointAt(3, link.getPoint(2).x, link.getPoint(4).y);
      } else if (link.pointsCount === 6) {
        link.setPointAt(2, link.getPoint(2).x, y);
        link.setPointAt(3, link.getPoint(3).x, y);
      }
    } else {
      if (link.pointsCount === 4) {
        link.insertPointAt(2, link.getPoint(2).x, y);
      } else if (link.pointsCount === 3) {
        link.setPointAt(1, link.getPoint(2).x, y);
      } else if (link.pointsCount === 2) {
        link.insertPointAt(1, link.getPoint(1).x, y);
      }
    }
  }
  link.commitRoute();
};

/***********************************Properties********************************/

/**
* Gets or sets a Point, relative to the parent node,
* that may be useful in routing this link.
* @name TreeEdge#relativePoint
* @function.
* @return {Point}
*/
/** @type {Point} */
TreeEdge.prototype.relativePoint;
Util.exportProperty(TreeEdge, 'relativePoint', TreeEdge.prototype.relativePoint);
Util.defineProperty(TreeEdge, { relativePoint: 'relativePoint' },
  /** @this {TreeEdge} */
  function() { return this._relativePoint; },
  /** @this {TreeEdge} */
  function(val) { this._relativePoint.set(val); }
);

/*
*  Copyright (C) 1998-2013 by Northwoods Software Corporation. All Rights Reserved.
*
*  Restricted Rights: Use, duplication, or disclosure by the U.S.
*  Government is subject to restrictions as set forth in subparagraph
*  (c) (1) (ii) of DFARS 252.227-7013, or in FAR 52.227-19, or in FAR
*  52.227-14 Alt. III, as applicable.
*
*  This software is proprietary to and embodies the confidential
*  technology of Northwoods Software Corporation. Possession, use, or
*  copying of this software and media is authorized only pursuant to a
*  valid written license from Northwoods or an authorized sublicensor.
*/

/*
Svg
*/

// see ???? for current issues

/**
* @ignore
* @constructor
* @class
* This class is used for parsing and generating SVG.
*/
function Svg() {
  // be sure that all data properties are named starting with an underscore
  //an array containing all the GraphObjects generated for the SVG
  this._graphObjectArray = [];

  //for shape names in testing
  //this._count = 0;
}

/**
* @ignore
* Create a {@link GraphObject} from some SVG.
* @this {Svg}
* @param {string|Document} svg either an XML DOM Node or a string that is parsed into XML DOM.
* @return {GraphObject}
*/
Svg.prototype.fromSvg = function(svg) {
  var xmlDoc;
  //if svg is an XML DOM Node it is cloned to avoid modifying the referenced document
  if (typeof svg === 'string') xmlDoc = new DOMParser().parseFromString(svg, 'text/xml');
  else if (svg instanceof Document) {
    xmlDoc = svg.implementation.createDocument('http://www.w3.org/2000/svg', 'svg', null);
    xmlDoc.appendChild(xmlDoc.importNode(svg.documentElement, true));
  } else return null;

  var svgElts = xmlDoc.getElementsByTagName('svg'); // there could be multiple SVG elements?
  if (svgElts.length === 0) return null;
  var svgElt = svgElts[0];

  //create and save brushes created for each gradient element
  //patterns?
  var linGrads = xmlDoc.getElementsByTagName('linearGradient');
  var radGrads = xmlDoc.getElementsByTagName('radialGradient');
  for (var i = 0; i < linGrads.length; i++) {
    var grad = linGrads[i];
    // ???? Why are the start and end assumed to be Left-Right?
    var brush = GraphObject.make(Brush, Brush.Linear, { start: Spot.Left, end: Spot.Right });
    //add color stops
    var stops = grad.childNodes;
    for (var j = 0; j < stops.length; j++) {
      if (stops[j].tagName === 'stop') {
        var color = stops[j].getAttribute('stop-color');
        var ofst = stops[j].getAttribute('offset');
        if (ofst.indexOf('%') !== -1) brush.addColorStop(.01 * parseFloat(ofst), color);
        else brush.addColorStop(parseFloat(ofst), color);
      }
    }
    var id = grad.getAttribute('id');
    if (typeof id === 'string') this['_brush' + id] = brush;
  }
  for (var i = 0; i < radGrads.length; i++) {
    var grad = radGrads[i];
    // ???? Why are the start and end assumed to be Center-Center?
    var brush = GraphObject.make(Brush, Brush.Radial, { start: Spot.Center, end: Spot.Center });
    //add color stops
    var stops = grad.childNodes;
    for (var j = 0; j < stops.length; j++) {
      if (stops[j].tagName === 'stop') {
        var color = stops[j].getAttribute('stop-color');
        var ofst = stops[j].getAttribute('offset');
        if (ofst.indexOf('%') !== -1) brush.addColorStop(.01 * parseFloat(ofst), color);
        else brush.addColorStop(parseFloat(ofst), color);
      }
    }
    var id = grad.getAttribute('id');
    if (typeof id === 'string') this['_brush' + id] = brush;
  }

  //append referenced nodes to <use> nodes, the <use> will then be treated as <g>
  //--------------if <use> references a <symbol> or <svg> it is treated differently
  var usesIncomplete = true;
  while (usesIncomplete) {
    usesIncomplete = false;
    var uses = xmlDoc.getElementsByTagName('use');
    for (var i = 0; i < uses.length; i++) {
      var use = uses[i]; // SVGUseElement
      if (use.childNodes.length !== 0) continue;
      var href = use.href;
      if (href === undefined) continue; // needed? or does (refElt === null) catch all?
      var ref = href.baseVal.substring(1);
      var refElt = xmlDoc.getElementById(ref);
      if (refElt === null) continue;
      var newElt = refElt.cloneNode(true);
      newElt.removeAttribute('id');
      var x = parseFloat(use.getAttribute('x'));
      var y = parseFloat(use.getAttribute('y'));
      if (isNaN(x)) x = 0;
      if (isNaN(y)) y = 0;
      var trans = use.getAttribute('transform');
      if (trans === null) trans = '';
      use.setAttribute('transform', trans + ' translate(' + x + ',' + y + ')');
      use.appendChild(newElt);
      if (newElt.tagName === 'use') usesIncomplete = true;
    }
  }

  this._createShapes(svgElt, null);

  if (this._graphObjectArray.length === 0) return null;
  else if (this._graphObjectArray.length === 1) return this._graphObjectArray[0];
  var imagePanel = new Panel();
  for (var i = 0; i < this._graphObjectArray.length; i++) imagePanel.add(this._graphObjectArray[i]);
  return imagePanel;
};

//go through the <svg> and add all shapes to this._graphObjectArray
//add a Panel for a group with transforms
//brush patterns?
//svgElt is the element currently being added, panel is the panel, representing a group, that its shapes should be added to
//if panel is null they will be added to this._graphObjectArray
//this is called originally by fromSvg(svg) with an entire <svg> element as svgElt and panel = null
/**
* @ignore
* @param {SVGElement} svgElt
* @param {Panel} panel
* @this {Svg}
*/
Svg.prototype._createShapes = function(svgElt, panel) {
  var tag = svgElt.tagName;
  if (tag !== 'g' && tag !== 'svg' && tag !== 'use' && tag !== 'symbol') return;

  var elts = svgElt.childNodes;
  for (var i = 0; i < elts.length; i++) {
    //will we need a case "svg"? also "text" should be handled
    var elt = elts[i];
    var gojsObj = null;
    if (elt.getAttribute === undefined) continue;
    var trans = elt.getAttribute('transform');
    switch (elt.tagName) {
      case 'g':
        if (trans === null) this._createShapes(elt, null);
        else {
          gojsObj = new Panel();
          this._createShapes(elt, gojsObj);
        }
        break;
      case 'use':
        if (trans === null) this._createShapes(elt, null);
        else {
          gojsObj = new Panel();
          this._createShapes(elt, gojsObj);
        }
        break;
      case 'symbol':
        //symbols will currently not act differently than groups
        //getSymbolScale is not yet functional and will need to take into account viewBox and preserveAspectRatio values for the <symbol>
        //as well as the height and width provided by the containing <use>
        if (svgElt.tagName !== 'use') break;
        gojsObj = new Panel();
        this._createShapes(elt, gojsObj);
        gojsObj.scale = this._getSymbolScale(elt, svgElt);
        break;
      case 'path':
        gojsObj = this._handlePath(elt);
        break;
      case 'line':
        gojsObj = this._handleLine(elt);
        break;
      case 'circle':
        gojsObj = this._handleCircle(elt);
        break;
      case 'ellipse':
        gojsObj = this._handleEllipse(elt);
        break;
      case 'rect':
        gojsObj = this._handleRect(elt);
        break;
      case 'polygon':
        gojsObj = this._handlePolyline(elt);
        break;
      case 'polyline':
        gojsObj = this._handlePolyline(elt);
    }

    if (gojsObj === null) continue;

    //stroke and fill properties
    if (gojsObj instanceof Shape) {
      var strokeWidth = parseFloat(this._findXMLProperty(elt, 'stroke-width'));
      if (!isNaN(strokeWidth)) gojsObj.strokeWidth = strokeWidth;
      var strokeCap = this._findXMLProperty(elt, 'stroke-linecap');
      if (strokeCap !== null) gojsObj.strokeCap = strokeCap;
      var fill = this._findXMLProperty(elt, 'fill');
      if (fill !== null && fill.indexOf('url') !== -1) {
        var refId = fill.substring(fill.indexOf('#') + 1, fill.length - 1); //make sure this always works
        var brush = this['_brush' + refId];
        if (brush instanceof Brush) gojsObj.fill = brush;
        else gojsObj.fill = 'black';
      }
      else if (fill === null) gojsObj.fill = 'black';
      else if (fill === 'none') gojsObj.fill = null;
      else gojsObj.fill = fill;
      var stroke = this._findXMLProperty(elt, 'stroke');
      if (stroke !== null && stroke.indexOf('url') !== -1) {
        var refId = stroke.substring(stroke.indexOf('#') + 1, stroke.length - 1); //make sure this always works
        var brush = this['_brush' + refId];
        if (brush instanceof Brush) gojsObj.stroke = brush;
        else gojsObj.stroke = 'black';
      }
      else if (stroke === 'none') gojsObj.stroke = null;
      else gojsObj.stroke = stroke;

      gojsObj.isGeometryPositioned = true;

      //for testing purposes
      /*gojsObj.name = "s" + this._count;
      this._count++;*/
    }

    //transforms

    //handle panels?
    if (trans !== null) {

      //separate the transform property string into separate transforms by splitting them
      // at the parentheses closing their parameters

      //transform commands are executed from right to left

      var transforms = trans.split(')');
      //if the parameters for any transform on an object contain errors,
      // perform no transforms on the object
      var validParams = true;
      for (var j = 0; j < transforms.length; j++) {
        if (/\(.*[^0-9\.,\s-]/.test(transforms[j])) validParams = false;
        if (/\(.*[0-9]-[0-9]/.test(transforms[j])) validParams = false;
      }
      if (validParams) {
        for (var j = transforms.length - 1; j >= 0; j--) {
          var transString = transforms[j];
          if (transString === '') continue;
          var parenInd = transString.indexOf('(');
          var transCommand = transString.substring(0, parenInd).replace(/\s*/, '');
          var paramString = transString.substring(parenInd + 1);
          var transParams = paramString.split(/\s*[\s,]\s*/);
          switch (transCommand) {
            case 'rotate':
              this._transformRotate(gojsObj, transParams);
              break;
            case 'translate':
              this._transformTranslate(gojsObj, transParams);
              break;
            case 'scale':
              this._transformScale(gojsObj, transParams);
              break;
            case 'skewX':
              this._transformSkewX(gojsObj, parseFloat(transParams[0]) * Math.PI / 180);
              break;
            case 'skewY':
              this._transformSkewY(gojsObj, parseFloat(transParams[0]) * Math.PI / 180);
              break;
            case 'matrix':
              this._transformMatrix(gojsObj, transParams);
              break;
          }
        }
      }
    }

    if (gojsObj instanceof Panel) {
      var panElts = gojsObj.elements.iterator;
      var xmin = 0;
      var ymin = 0;
      var pPos = gojsObj.position.copy();
      if (isNaN(pPos.x)) pPos.x = 0;
      if (isNaN(pPos.y)) pPos.y = 0;
      while (panElts.next()) {
        var ePos = panElts.value.position.copy();
        if (isNaN(ePos.x)) ePos.x = 0;
        if (isNaN(ePos.y)) ePos.y = 0;
        if (ePos.x < xmin) xmin = ePos.x;
        if (ePos.y < ymin) ymin = ePos.y;
      }
      pPos.x += xmin;
      pPos.y += ymin;
      gojsObj.position = pPos;
    }

    if (panel === null) this._graphObjectArray.push(gojsObj);
    else panel.add(gojsObj);

  }

  //also need to handle <symbol>s
  //<use> treated as group, <svg> also (?)
};

//gojsObj is a shape or panel
//matrixParams is an array containing the 6 number parameters for a matrix transformation as strings
//change the geometry and position of the GraphObject according to the parameters
/**
* @ignore
* @param {Shape|Panel} gojsObj
* @param {Array} matrixParams
* @this {Svg}
*/
Svg.prototype._transformMatrix = function(gojsObj, matrixParams) {
  var a = parseFloat(matrixParams[0]);
  var b = parseFloat(matrixParams[1]);
  var c = parseFloat(matrixParams[2]);
  var d = parseFloat(matrixParams[3]);
  var e = parseFloat(matrixParams[4]);
  var f = parseFloat(matrixParams[5]);
  //do not transform if parameters are missing
  if (isNaN(a + b + c + d + e + f)) return;

  var pos = gojsObj.position.copy();
  if (isNaN(pos.x)) pos.x = 0;
  if (isNaN(pos.y)) pos.y = 0;

  if (gojsObj instanceof Shape) {
    var geo = gojsObj.geometry.copy();

    if (geo.type === Geometry.Rectangle) {
      geo = this._turnRectangleIntoPath(geo);
    } else if (geo.type === Geometry.Ellipse) {
      geo = this._turnEllipseIntoPath(geo);
    } else if (geo.type === Geometry.Line) {
      geo.type = Geometry.Path;
      var fig = new PathFigure(geo.startX, geo.startY);
      var seg = new PathSegment(PathSegment.Line, geo.endX, geo.endY);
      fig.segments.add(seg);
      geo.figures.add(fig);
    }

    //will need to offset geometry first and after

    geo.offset(pos.x, pos.y);
    geo.transform(a, b, c, d, e - pos.x, f - pos.y);

    //what about strokeWidth?

    var p = geo.normalize();
    gojsObj.geometry = geo;
    pos.x -= p.x;
    pos.y -= p.y;
    gojsObj.position = pos;
  } else {
    //gojsObj is a Panel

    //increase all elements' positions by the panel's position, then decrease them by that amount after tranforming them
    var pElts = gojsObj.elements.iterator;
    while (pElts.next()) {
      var ePos = pElts.value.position.copy();
      ePos.x += pos.x;
      ePos.y += pos.y;
      pElts.value.position = ePos;
    }
    pElts.reset();
    while (pElts.next()) this._transformMatrix(pElts.value, matrixParams);
    pElts.reset();
    while (pElts.next()) {
      var ePos = pElts.value.position.copy();
      ePos.x -= pos.x;
      ePos.y -= pos.y;
      pElts.value.position = ePos;
    }
  }
};

/**
* @ignore
* @param {Shape|Panel} gojsObj
* @param {Array} rotateParams
* @this {Svg}
*/
Svg.prototype._transformRotate = function(gojsObj, rotateParams) {
  var angle = parseFloat(rotateParams[0]);
  var cx = parseFloat(rotateParams[1]);
  var cy = parseFloat(rotateParams[2]);
  if (isNaN(cx)) cx = 0;
  if (isNaN(cy)) cy = 0;
  if (!isNaN(angle)) {
    var radAngle = angle * Math.PI / 180;

    var pos = gojsObj.position.copy();
    if (isNaN(pos.x)) pos.x = 0;
    if (isNaN(pos.y)) pos.y = 0;

    if (gojsObj instanceof Shape) {
      var geo = gojsObj.geometry.copy();

      if (geo.type === Geometry.Ellipse) geo = this._turnEllipseIntoPath(geo);
      else if (geo.type === Geometry.Rectangle) geo = this._turnRectangleIntoPath(geo);

      if (geo.type === Geometry.Path) {
        geo.rotate(angle, cx - pos.x, cy - pos.y);

        var p = geo.normalize();
        gojsObj.geometry = geo;
        pos.x -= p.x;
        pos.y -= p.y;
        gojsObj.position = pos;
      } else {
        //line geometry
        var relStartX = geo.startX - cx + pos.x;
        var relStartY = geo.startY - cy + pos.y;
        var relEndX = geo.endX - cx + pos.x;
        var relEndY = geo.endY - cy + pos.y;
        var newStartX = relStartX * Math.cos(radAngle) - relStartY * Math.sin(radAngle) + cx - pos.x;
        var newStartY = relStartY * Math.cos(radAngle) + relStartX * Math.sin(radAngle) + cy - pos.y;
        var newEndX = relEndX * Math.cos(radAngle) - relEndY * Math.sin(radAngle) + cx - pos.x;
        var newEndY = relEndY * Math.cos(radAngle) + relEndX * Math.sin(radAngle) + cy - pos.y;
        var minX = Math.min(newStartX, newEndX);
        var minY = Math.min(newStartY, newEndY);
        geo.startX = newStartX - minX;
        geo.startY = newStartY - minY;
        geo.endX = newEndX - minX;
        geo.endY = newEndY - minY;
        pos.x += minX;
        pos.y += minY;
        gojsObj.position = pos;
        gojsObj.geometry = geo;
      }
      if (gojsObj.fill instanceof Brush) {
        var newBrush = gojsObj.fill.copy();
        var oldAngle = Math.atan((.5 - newBrush.start.y) / (.5 - newBrush.start.x));
        var brushAngle = oldAngle + radAngle;
        newBrush.start = new Spot((1 - Math.cos(brushAngle)) / 2, (1 - Math.sin(brushAngle)) / 2);
        newBrush.end = new Spot((1 + Math.cos(brushAngle)) / 2, (1 + Math.sin(brushAngle)) / 2);
        gojsObj.fill = newBrush;
      }
      if (gojsObj.stroke instanceof Brush) {
        var newBrush = gojsObj.stroke.copy();
        var oldAngle = Math.atan((.5 - newBrush.start.y) / (.5 - newBrush.start.x));
        var brushAngle = oldAngle + radAngle;
        newBrush.start = new Spot((1 - Math.cos(brushAngle)) / 2, (1 - Math.sin(brushAngle)) / 2);
        newBrush.end = new Spot((1 + Math.cos(brushAngle)) / 2, (1 + Math.sin(brushAngle)) / 2);
        gojsObj.stroke = newBrush;
      }
    } else {
      //gojsObj is a panel
      var pElts = gojsObj.elements.iterator;
      while (pElts.next()) {
        var ePos = pElts.value.position.copy();
        ePos.x += pos.x;
        ePos.y += pos.y;
        pElts.value.position = ePos;
      }
      pElts.reset();
      while (pElts.next()) this._transformRotate(pElts.value, rotateParams);
      pElts.reset();
      while (pElts.next()) {
        var ePos = pElts.value.position.copy();
        ePos.x -= pos.x;
        ePos.y -= pos.y;
        pElts.value.position = ePos;
      }
    }
  }
};

/**
* @ignore
* @param {Shape|Panel} gojsObj
* @param {Array} transParams
* @this {Svg}
*/
Svg.prototype._transformTranslate = function(gojsObj, transParams) {  //should only position be used?
  //will use parseFloat to read these, though might be expressions -- SVG will treat as an incorrect value if not a number, not just take the part that is one
  var dx = parseFloat(transParams[0]);
  var dy = parseFloat(transParams[1]);
  if (!isNaN(dx) || !isNaN(dy)) {
    var pos = gojsObj.position.copy();
    if (isNaN(pos.x)) pos.x = 0;
    if (isNaN(pos.y)) pos.y = 0;
    gojsObj.position = new Point(dx + pos.x, dy + pos.y);
  }
};

/**
* @ignore
* @param {Shape|Panel} gojsObj
* @param {Array} scaleParams
* @this {Svg}
*/
Svg.prototype._transformScale = function(gojsObj, scaleParams) {
  var xScale = parseFloat(scaleParams[0]);
  var yScale = parseFloat(scaleParams[1]);
  if (isNaN(xScale)) return;
  if (isNaN(yScale)) yScale = xScale;

  var pos = gojsObj.position.copy();
  if (isNaN(pos.x)) pos.x = 0;
  if (isNaN(pos.y)) pos.y = 0;

  if (gojsObj instanceof Shape) {
    var geo = gojsObj.geometry.copy();
    pos.x *= xScale;
    pos.y *= yScale;
    gojsObj.position = pos;
    geo.scale(xScale, yScale);
    //what about strokeWidth?
    gojsObj.geometry = geo;
  } else {
    //gojsObj is a panel
    var pElts = gojsObj.elements.iterator;
    while (pElts.next()) {
      var ePos = pElts.value.position.copy();
      ePos.x += pos.x;
      ePos.y += pos.y;
      pElts.value.position = ePos;
    }
    pElts.reset();
    while (pElts.next()) this._transformScale(pElts.value, scaleParams);
    pElts.reset();
    while (pElts.next()) {
      var ePos = pElts.value.position.copy();
      ePos.x -= pos.x;
      ePos.y -= pos.y;
      pElts.value.position = ePos;
    }
  }
};

/**
* @ignore
* @param {Shape|Panel} gojsObj
* @param {number} angle
* @this {Svg}
*/
Svg.prototype._transformSkewX = function(gojsObj, angle) {
  if (isNaN(angle)) return;

  var pos = gojsObj.position.copy();
  if (isNaN(pos.x)) pos.x = 0;
  if (isNaN(pos.y)) pos.y = 0;

  if (gojsObj instanceof Shape) {

    var geo = gojsObj.geometry.copy();

    if (geo.type === Geometry.Rectangle) {
      geo = this._turnRectangleIntoPath(geo);
    } else if (geo.type === Geometry.Ellipse) {
      geo = this._turnEllipseIntoPath(geo);
    } else if (geo.type === Geometry.Line) {
      geo.type = Geometry.Path;
      var fig = new PathFigure(geo.startX, geo.startY);
      var seg = new PathSegment(PathSegment.Line, geo.endX, geo.endY);
      fig.segments.add(seg);
      geo.figures.add(fig);
    }

    geo.offset(pos.x, pos.y);
    geo.transform(1, 0, Math.tan(angle), 1, -pos.x, -pos.y);
    //what about strokeWidth?

    var p = geo.normalize();
    gojsObj.geometry = geo;
    pos.x -= p.x;
    pos.y -= p.y;
    gojsObj.position = pos;
  } else {
    //panel
    var pElts = gojsObj.elements.iterator;
    while (pElts.next()) {
      var ePos = pElts.value.position.copy();
      ePos.x += pos.x;
      ePos.y += pos.y;
      pElts.value.position = ePos;
    }
    pElts.reset();
    while (pElts.next()) this._transformSkewX(pElts.value, angle);
    pElts.reset();
    while (pElts.next()) {
      var ePos = pElts.value.position.copy();
      ePos.x -= pos.x;
      ePos.y -= pos.y;
      pElts.value.position = ePos;
    }
  }
};

/**
* @ignore
* @param {Shape|Panel} gojsObj
* @param {number} angle
* @this {Svg}
*/
Svg.prototype._transformSkewY = function(gojsObj, angle) {
  if (isNaN(angle)) return;

  var pos = gojsObj.position.copy();
  if (isNaN(pos.x)) pos.x = 0;
  if (isNaN(pos.y)) pos.y = 0;

  if (gojsObj instanceof Shape) {

    var geo = gojsObj.geometry.copy();

    if (geo.type === Geometry.Rectangle) {
      geo = this._turnRectangleIntoPath(geo);
    } else if (geo.type === Geometry.Ellipse) {
      geo = this._turnEllipseIntoPath(geo);
    } else if (geo.type === Geometry.Line) {
      geo.type = Geometry.Path;
      var fig = new PathFigure(geo.startX, geo.startY);
      var seg = new PathSegment(PathSegment.Line, geo.endX, geo.endY);
      fig.segments.add(seg);
      geo.figures.add(fig);
    }

    geo.offset(pos.x, pos.y);
    geo.transform(1, Math.tan(angle), 0, 1, -pos.x, -pos.y);

    //what about strokeWidth?

    var p = geo.normalize();
    gojsObj.geometry = geo;
    pos.x -= p.x;
    pos.y -= p.y;
    gojsObj.position = pos;
  } else {
    //panel
    var pElts = gojsObj.elements.iterator;
    while (pElts.next()) {
      var ePos = pElts.value.position.copy();
      ePos.x += pos.x;
      ePos.y += pos.y;
      pElts.value.position = ePos;
    }
    pElts.reset();
    while (pElts.next()) this._transformSkewY(pElts.value, angle);
    pElts.reset();
    while (pElts.next()) {
      var ePos = pElts.value.position.copy();
      ePos.x -= pos.x;
      ePos.y -= pos.y;
      pElts.value.position = ePos;
    }
  }
};

/**
* @ignore
* @param {SVGRectElement} xmlElt
* @this {Svg}
*/
Svg.prototype._handleRect = function(xmlElt) {
  var shape = new Shape();
  var height = parseFloat(xmlElt.getAttribute('height'));
  var width = parseFloat(xmlElt.getAttribute('width'));
  var x = parseFloat(xmlElt.getAttribute('x'));
  var y = parseFloat(xmlElt.getAttribute('y'));
  if (isNaN(height) || isNaN(width)) return null;
  if (isNaN(x)) x = 0;
  if (isNaN(y)) y = 0;
  var geo = new Geometry(Geometry.Rectangle);
  geo.startX = 0;
  geo.startY = 0;
  geo.endX = width;
  geo.endY = height;
  shape.position = new Point(x, y);
  shape.geometry = geo;

  return shape;
};

/**
* @ignore
* @param {SVGPathElement} xmlElt
* @this {Svg}
*/
Svg.prototype._handlePath = function(xmlElt) {
  var shape = new Shape();
  var data = xmlElt.getAttribute('d');
  var geo;
  if (typeof data === 'string') shape.geometryString = Geometry.fillPath(data);
  return shape;
};

/**
* @ignore
* @param {SVGLineElement} xmlElt
* @this {Svg}
*/
Svg.prototype._handleLine = function(xmlElt) {  //change to position rather than startx & y?
  var shape = new Shape();
  var x1 = parseFloat(xmlElt.getAttribute('x1'));
  var y1 = parseFloat(xmlElt.getAttribute('y1'));
  var x2 = parseFloat(xmlElt.getAttribute('x2'));
  var y2 = parseFloat(xmlElt.getAttribute('y2'));
  if (isNaN(x1)) x1 = 0;
  if (isNaN(y1)) y1 = 0;
  if (isNaN(x2)) x2 = 0;
  if (isNaN(y2)) y2 = 0;
  var geo = new Geometry(Geometry.Line);
  shape.position = new Point(Math.min(x1, x2), Math.min(y1, y2));  //use minimum point, do this for other shapes
  if ((x2 - x1) / (y2 - y1) > 0) {
    geo.startX = 0;
    geo.startY = 0;
    geo.endX = Math.abs(x2 - x1);
    geo.endY = Math.abs(y2 - y1);
  } else {
    geo.startX = 0;
    geo.startY = Math.abs(y2 - y1);
    geo.endX = Math.abs(x2 - x1);
    geo.endY = 0;
  }
  shape.geometry = geo;

  return shape;
};

/**
* @ignore
* @param {SVGCircleElement} xmlElt
* @this {Svg}
*/
Svg.prototype._handleCircle = function(xmlElt) {
  var shape = new Shape();
  var r = parseFloat(xmlElt.getAttribute('r'));
  var cx = parseFloat(xmlElt.getAttribute('cx'));
  var cy = parseFloat(xmlElt.getAttribute('cy'));
  if (isNaN(r)) return null;
  if (isNaN(cx)) cx = 0;
  if (isNaN(cy)) cy = 0;
  var geo = new Geometry(Geometry.Ellipse);
  geo.startX = 0;
  geo.startY = 0;
  geo.endX = 2 * r;
  geo.endY = 2 * r;
  shape.position = new Point(cx - r, cy - r);
  shape.geometry = geo;

  return shape;
};

/**
* @ignore
* @param {SVGEllipseElement} xmlElt
* @this {Svg}
*/
Svg.prototype._handleEllipse = function(xmlElt) {
  var shape = new Shape();
  var rx = parseFloat(xmlElt.getAttribute('rx'));
  var ry = parseFloat(xmlElt.getAttribute('ry'));
  var cx = parseFloat(xmlElt.getAttribute('cx'));
  var cy = parseFloat(xmlElt.getAttribute('cy'));
  if (isNaN(cx)) cx = 0;
  if (isNaN(cy)) cy = 0;
  if (isNaN(rx) || isNaN(ry)) return null;
  var geo = new Geometry(Geometry.Ellipse);
  geo.startX = 0;
  geo.startY = 0;
  geo.endX = 2 * rx;
  geo.endY = 2 * ry;
  shape.position = new Point(cx - rx, cy - ry);
  shape.geometry = geo;

  return shape;
};

/**
* @ignore
* @param {SVGPolygonElement|SVGPolylineElement} xmlElt
* @this {Svg}
*/
Svg.prototype._handlePolyline = function(xmlElt) { //should this change to include a position?
  var close = false;
  if (xmlElt.tagName === 'polygon') close = true;
  else if (xmlElt.tagName !== 'polyline') return null;
  var shape = new Shape();

  var points = xmlElt.getAttribute('points');
  var geom = new Geometry;
  var figureList = new List(PathFigure);
  var pointValues = points.split(/\s*[\s,]\s*/);
  if (pointValues.length < 4) return null;
  var figure;
  var segs = new List(PathSegment);
  var xVal, yVal;
  for (var i = 1; i < pointValues.length; i += 2) {
    xVal = eval(pointValues[i - 1]);
    yVal = eval(pointValues[i]);
    if (typeof xVal !== 'number' || isNaN(xVal) || typeof yVal !== 'number' || isNaN(yVal)) return null;
    if (i === 1) figure = new PathFigure(xVal, yVal);
    else segs.add(new PathSegment(PathSegment.Line, xVal, yVal));
  }
  if (close) {
    var endSeg = new PathSegment(PathSegment.Line, figure.startX, figure.startY);
    endSeg.close();
    segs.add(endSeg);
  }
  figure.segments = segs;
  figureList.add(figure);
  geom.figures = figureList;
  var p = geom.normalize();
  shape.position = new Point(-p.x, -p.y);
  shape.geometry = geom;

  return shape;
};

/**
* @ignore
* @param {*} xmlElt can't type-check, should be of type "Node" but we modified the externs.
* @param {string} property
* @this {Svg}
*/
Svg.prototype._findXMLProperty = function(xmlElt, property) {
  var eltProp = xmlElt.getAttribute(property);
  if (typeof eltProp !== 'string') eltProp = xmlElt.style[property];
  if (typeof eltProp !== 'string' || eltProp === '') {
    var par = xmlElt.parentNode;
    if (par.tagName === 'g' || par.tagName === 'use') return this._findXMLProperty(par, property);
    else return null;
  }
  return eltProp;
};

Svg.prototype._getSymbolScale = function(symbol, parent) { //doesn't do anything yet
  var PAR = symbol.getAttribute('preserveAspectRatio');
  var viewBox = symbol.getAttribute('viewBox');
  var vbPoints = [];
  if (typeof viewBox === 'string') vbPoints = viewBox.split(/\s*[\s,]\s*/);
  if (vbPoints.length < 4) return 1; // ???? but it returns 1 anyway
  return 1;
};

/**
* @ignore
* @param {Geometry} geom
* @this {Svg}
*/
Svg.prototype._turnEllipseIntoPath = function(geom) {
  var x1 = geom.startX;
  var y1 = geom.startY;
  var x2 = geom.endX;
  var y2 = geom.endY;

  var rx = Math.abs(x2 - x1) / 2;
  var ry = Math.abs(y2 - y1) / 2;
  var cx = Math.min(x1, x2) + rx;
  var cy = Math.min(y1, y2) + ry;

  var temp = new Point();

  var f = new PathFigure(cx, cy - ry);

  var p1 = new PathSegment(PathSegment.Bezier);
  p1.point1X = cx + (Geo.KAPPA * rx);
  p1.point1Y = cy - ry;
  p1.point2X = cx + rx;
  p1.point2Y = cy - (Geo.KAPPA * ry);
  p1.endX = cx + rx;
  p1.endY = cy;
  f.segments.add(p1);

  var p2 = new PathSegment(PathSegment.Bezier);
  p2.point1X = cx + rx;
  p2.point1Y = cy + (Geo.KAPPA * ry);
  p2.point2X = cx + (Geo.KAPPA * rx);
  p2.point2Y = cy + ry;
  p2.endX = cx;
  p2.endY = cy + ry;
  f.segments.add(p2);

  var p3 = new PathSegment(PathSegment.Bezier);
  p3.point1X = cx - (Geo.KAPPA * rx);
  p3.point1Y = cy + ry;
  p3.point2X = cx - rx;
  p3.point2Y = cy + (Geo.KAPPA * ry);
  p3.endX = cx - rx;
  p3.endY = cy;
  f.segments.add(p3);

  var p4 = new PathSegment(PathSegment.Bezier);
  p4.point1X = cx - rx;
  p4.point1Y = cy - (Geo.KAPPA * ry);
  p4.point2X = cx - (Geo.KAPPA * rx);
  p4.point2Y = cy - ry;
  p4.endX = cx;
  p4.endY = cy - ry;
  f.segments.add(p4);

  geom.type = Geometry.Path;
  geom.figures.add(f);
  return geom;
};

/**
* @ignore
* @param {Geometry} geom
* @this {Svg}
*/
Svg.prototype._turnRectangleIntoPath = function(geom) {
  var x1 = geom.startX;
  var y1 = geom.startY;
  var x2 = geom.endX;
  var y2 = geom.endY;

  var x = Math.min(x1, x2);
  var y = Math.min(y1, y2);
  var w = Math.abs(x2 - x1);
  var h = Math.abs(y2 - y1);

  var fig = new PathFigure(x, y);

  fig.segments.add(new PathSegment(PathSegment.Line, x + w, y));
  fig.segments.add(new PathSegment(PathSegment.Line, x + w, y + h));
  fig.segments.add(new PathSegment(PathSegment.Line, x, y + h).close());

  geom.type = Geometry.Path;
  geom.figures.add(fig);
  return geom;
};

// be sure that all methods are named starting with an underscore


// publish the 'go' object as a namespace
window['go'] = go;

/**
* @ignore
*/
go['version'] = '1.2.4';